RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
5766
RFC 5766-NATのリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）
URL : https://tools.ietf.org/html/rfc5766
タイトル : RFC 5766 - Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)
翻訳編集 : 自動生成
Internet Engineering Task Force（IETF）R. Mahy
コメントの要求：5766非関連
カテゴリー：Standards Track P. Matthews
ISSN：2070-1721アルカテルルーセント
                                                            J.ローゼンバーグ
                                                             jdrosen.net
                                                              2010年4月
        
NATのリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）

概要

ホストがNATの背後にある場合、特定の状況では、そのホストが他のホスト（ピア）と直接通信できない場合があります. これらの状況では、ホストが通信リレーとして機能する中間ノードのサービスを使用する必要があります. この仕様は、ホストがリレーの動作を制御し、リレーを使用してピアとパケットを交換できるようにするTURN（NATの周りにリレーを使用するトラバーサル）と呼ばれるプロトコルを定義します. TURNは、クライアントが単一のリレーアドレスを使用して複数のピアと通信できるようにするという点で、他のいくつかのリレー制御プロトコルとは異なります. 

TURNプロトコルは、NATトラバーサルへのICE（Interactive Connectivity Establishment）アプローチの一部として使用するように設計されていますが、ICEなしでも使用できます. 

このメモのステータス

これはInternet Standards Trackドキュメントです. 

このドキュメントは、IETF（Internet Engineering Task Force）の製品です. これは、IETFコミュニティのコンセンサスを表しています. 公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました. インターネット標準の詳細については、RFC 5741のセクション2を参照してください. 

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc5766で入手できます. 

著作権表示

Copyright（c）2010 IETF Trustおよびドキュメントの作成者として識別された人物. 全著作権所有. 

この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます. 

目次

   1.はじめに. . . . . . . . . . . . . . . . . . . . . . . . . 4
   2.運用の概要. . . . . . . . . . . . . . . . . . . . 5
     2.1. 輸送. . . . . . . . . . . . . . . . . . . . . . . . 8
     2.2. 割り当て. . . . . . . . . . . . . . . . . . . . . . . 9
     2.3. 権限. . . . . . . . . . . . . . . . . . . . . . . 11
     2.4. 送信メカニズム. . . . . . . . . . . . . . . . . . . . . . 12
     2.5. Channel . . . . . . . . . . . . . . . . . . . . . . . . 13
     2.6. 非特権TURNサーバー. . . . . . . . . . . . . . . . 15
     2.7. IPフラグメンテーションの回避. . . . . . . . . . . . . . . . 16
     2.8. RTPサポート. . . . . . . . . . . . . . . . . . . . . . . 17
     2.9. サーバーのエニーキャスト発見. . . . . . . . . . . . . . . 17
   3.用語. . . . . . . . . . . . . . . . . . . . . . . . . 18
   4.一般的な行動. . . . . . . . . . . . . . . . . . . . . . . 19
   5.割り当て. . . . . . . . . . . . . . . . . . . . . . . . . 22
   6.割り当ての作成. . . . . . . . . . . . . . . . . . . . 23
     6.1. 割り当てリクエストの送信. . . . . . . . . . . . . . . 23
     6.2. 割り当てリクエストの受信. . . . . . . . . . . . . . 24
     6.3. 割り当て成功応答の受信. . . . . . . . . . 28
     6.4. 割り当てエラー応答の受信. . . . . . . . . . . 29日
   7.割り当ての更新. . . . . . . . . . . . . . . . . . . 31
     7.1. 更新リクエストの送信. . . . . . . . . . . . . . . . 31
     7.2. 更新リクエストの受信. . . . . . . . . . . . . . . 31
     7.3. 更新応答の受信. . . . . . . . . . . . . . . 32
   8.権限. . . . . . . . . . . . . . . . . . . . . . . . . 32
   9. CreatePermission. . . . . . . . . . . . . . . . . . . . . . . 34
     9.1. CreatePermissionリクエストの作成 . . . . . . . . . . . 34
     9.2. CreatePermissionリクエストを受け取ります. . . . . . . . . . . 34
     9.3. CreatePermission応答を受け取ります. . . . . . . . . . 35
   10.送信およびデータメソッド. . . . . . . . . . . . . . . . . . . . 35
     10.1 送信表示の形成. . . . . . . . . . . . . . . . 35
     10.2 送信表示の受信. . . . . . . . . . . . . . . 35
        
     10.3 UDPデータグラムの受信. . . . . . . . . . . . . . . . . 36
     10.4. データ表示の受信. . . . . . . . . . . . . . . 37
   11.Channel. . . . . . . . . . . . . . . . . . . . . . . . . . . 37
     11.1 ChannelBindリクエストを送信します. . . . . . . . . . . . . . 39
     11.2 ChannelBindリクエストを受信します. . . . . . . . . . . . . 39
     11.3. ChannelBind応答の受信. . . . . . . . . . . . . 40
     11.4. ChannelDataメッセージ. . . . . . . . . . . . . . . . . 41
     11.5. ChannelDataメッセージの送信. . . . . . . . . . . . . . 41
     11.6. ChannelDataメッセージの受信. . . . . . . . . . . . . 42
     11.7. ピアからのデータの中継 . . . . . . . . . . . . . . 43
   12. IPヘッダーフィールド. . . . . . . . . . . . . . . . . . . . . . . 43
   13.新しいSTUNメソッド. . . . . . . . . . . . . . . . . . . . . . . 45
   14.新しいSTUN属性. . . . . . . . . . . . . . . . . . . . . 45
     14.1. チャネル番号. . . . . . . . . . . . . . . . . . . . . . 45
     14.2. LIFETIME . . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.3. XOR-PEER-ADDRESS. . . . . . . . . . . . . . . . . . . . . 46
     14.4. データ. . . . . . . . . . . . . . . . . . . . . . . . . . . 46
     14.5 XOR-RELAYED-ADDRESS. . . . . . . . . . . . . . . . . . . 46
     14.6 EVEN-PORT. . . . . . . . . . . . . . . . . . . . . . . . 46
     14.7. 要求されたトランスポート. . . . . . . . . . . . . . . . . . . 47
     14.8. 断片化しない. . . . . . . . . . . . . . . . . . . . . . 47
     14.9. 予約トークン. . . . . . . . . . . . . . . . . . . . 48
   15.新しいSTUNエラー応答コード. . . . . . . . . . . . . . . . 48
   16.詳細な例. . . . . . . . . . . . . . . . . . . . . . . 48
   17.セキュリティに関する考慮事項. . . . . . . . . . . . . . . . . . . 55
     17.1. 部外者攻撃. . . . . . . . . . . . . . . . . . . . . 55
       17.1.1. 不正な割り当ての取得. . . . . . . . . 55
       17.1.2. オフライン辞書攻撃. . . . . . . . . . . . . 56
       17.1.3. 偽の更新と権限. . . . . . . . . . . 56
       17.1.4. 偽データ. . . . . . . . . . . . . . . . . . . . . . 56
       17.1.5. サーバーの偽装. . . . . . . . . . . . . . . 57
       17.1.6. 盗聴トラフィック. . . . . . . . . . . . . . . . 58
       17.1.7. ターンループアタック. . . . . . . . . . . . . . . . . . 58
     17.2. ファイアウォールの考察. . . . . . . . . . . . . . . . . 59
       17.2.1. 偽の権限. . . . . . . . . . . . . . . . . . 59
       17.2.2. ブラックリストIPアドレス. . . . . . . . . . . . . . 60
       17.2.3. 既知のポートでのサーバーの実行 . . . . . . . . 60
     17.3. インサイダー攻撃. . . . . . . . . . . . . . . . . . . . . 60
       17.3.1. TURN Serverに対するDoS. . . . . . . . . . . . . . . 60
       17.3.2. 悪意のあるトラフィックの匿名中継. . . . . . . 61
       17.3.3. その他の割り当ての操作. . . . . . . . . . . 61
     17.4. その他の考慮事項. . . . . . . . . . . . . . . . . . . 61
   18. IANAの考慮事項. . . . . . . . . . . . . . . . . . . . . 61
   19. IABに関する考慮事項. . . . . . . . . . . . . . . . . . . . . . 62
   20.謝辞. . . . . . . . . . . . . . . . . . . . . . . 63
   21.参考文献. . . . . . . . . . . . . . . . . . . . . . . . . . 64
     21.1. 規範的参照. . . . . . . . . . . . . . . . . . . 64
     21.2. 有益な参照. . . . . . . . . . . . . . . . . . 64
        
1.はじめに
NATの背後にあるホストは、他のホストとパケットを交換したい場合があります. その一部はNATの背後にある場合もあります. これを行うために、関係するホストは、直接の通信パスを発見しようとして「ホールパンチング」技術（[RFC5128]を参照）を使用できます. つまり、あるホストから別のホストへ、NATやルーターを経由して通過するが、リレーを経由しない通信パスです. 

[RFC5128]と[RFC4787]で説明されているように、両方のホストが正常に動作しないNATの背後にある場合、ホールパンチテクニックは失敗します. たとえば、両方のホストが「アドレス依存マッピング」または「アドレスおよびポート依存マッピング」のマッピング動作を持つNATの背後にある場合、通常、ホールパンチテクニックは失敗します. 

直接通信経路が見つからない場合は、パケットの中継となる中間ホストのサービスを利用する必要があります. このリレーは通常、パブリックインターネットにあり、NATの背後にある2つのホスト間でパケットをリレーします. 

この仕様は、NATの背後にあるホスト（TURNクライアントと呼ばれる）が別のホスト（TURNサーバーと呼ばれる）がリレーとして機能することを要求できるようにする、TURNと呼ばれるプロトコルを定義します. クライアントは、サーバーが他の特定のホスト（ピアと呼ばれる）との間でパケットをリレーするように調整し、リレーの実行方法を制御できます. クライアントは、リレーされたトランスポートアドレスと呼ばれるサーバー上のIPアドレスとポートを取得することでこれを行います. ピアが中継されたトランスポートアドレスにパケットを送信すると、サーバーはパケットをクライアントに中継します. クライアントがデータパケットをサーバーに送信すると、サーバーは、中継されたトランスポートアドレスをソースとして使用して、適切なピアにデータパケットを中継します. 

TURNを使用するクライアントは、リレーされたトランスポートアドレスをピアに伝達し、各ピアのIPアドレスとポートを学習する何らかの方法が必要です（より正確には、各ピアのServer-Reflexive Transport Address、セクション2を参照）. これがどのように行われるかは、TURNプロトコルの範囲外です. これを行う方法の1つは、クライアントとピアが電子メールメッセージを交換することです. 別の方法は、クライアントとそのピアが特別な目的の「導入」または「ランデブー」プロトコルを使用することです（詳細については、[RFC5128]を参照してください）. 

TURNがICE [RFC5245]で使用される場合、中継されたトランスポートアドレスおよびピアのIPアドレスとポートは、ランデブープロトコルが伝達する必要のあるICE候補情報に含まれます. たとえば、SIP [RFC3261]を使用するマルチメディアソリューションの一部としてTURNおよびICEが使用されている場合、SIPはランデブープロトコルの役割を果たし、ICE候補情報をSIPメッセージの本文内で伝達します. TURNおよびICEが他のランデブープロトコルで使用される場合、[MMUSIC-ICE-NONSIP]はランデブープロトコルが実行する必要のあるサービスに関するガイダンスを提供します. 

NATの背後にある2つのホスト間の通信を可能にするTURNサーバーの使用は機能する可能性が非常に高いですが、サーバーは通常インターネットへの高帯域幅接続を必要とするため、TURNサーバーのプロバイダーにとって高コストになります. その結果、直接通信パスが見つからない場合にのみ、TURNサーバーを使用することをお勧めします. クライアントとピアがICEを使用して通信パスを決定する場合、ICEはホールパンチテクニックを使用して直接パスを最初に検索し、直接パスが見つからない場合にのみTURNサーバーを使用します. 

TURNは当初、SIPを使用してシグナリングされるマルチメディアセッションをサポートするために発明されました. SIPはフォーキングをサポートしているため、TURNはリレーされたトランスポートアドレスごとに複数のピアをサポートします. 他のアプローチ（例えば、SOCKS [RFC1928]）でサポートされていない機能. ただし、TURNが他のタイプのアプリケーションに適していることを確認するように注意が払われています. 

TURNは、NATトラバーサルへのより大きなICEアプローチの一部として設計されました. TURNの実装者は、ICEを調査し、アプリケーションへの使用を真剣に検討することをお勧めします. ただし、ICEなしでTURNを使用することは可能です. 

TURNは、STUN（NATのセッショントラバーサルユーティリティ）プロトコル[RFC5389]の拡張機能です. すべてではありませんが、ほとんどのTURNメッセージはSTUN形式のメッセージです. このドキュメントの読者は、STUNに精通している必要があります. 

2.運用の概要
このセクションでは、TURNの操作の概要について説明します. それは非規範的です. 

一般的な構成では、TURNクライアントはプライベートネットワーク[RFC1918]に接続され、1つ以上のNATを介してパブリックインターネットに接続されます. 公共のインターネットにはTURNサーバーがあります. インターネットの他の場所には、TURNクライアントが通信することを希望する1つ以上のピアがあります. これらのピアは、1つ以上のNATの背後にある場合とそうでない場合があります. クライアントはサーバーをリレーとして使用して、これらのピアにパケットを送信し、これらのピアからパケットを受信します. 

                                        Peer A
                                        Server-Reflexive    +---------+
                                        Transport Address   |         |
                                        192.0.2.150:32102   |         |
                                            |              /|         |
                          TURN              |            / ^|  Peer A |
    Client's              Server            |           /  ||         |
    Host Transport        Transport         |         //   ||         |
    Address               Address           |       //     |+---------+
   10.1.1.2:49721       192.0.2.15:3478     |+-+  //     Peer A
            |               |               ||N| /       Host Transport
            |   +-+         |               ||A|/        Address
            |   | |         |               v|T|     192.168.100.2:49582
            |   | |         |               /+-+
 +---------+|   | |         |+---------+   /              +---------+
 |         ||   |N|         ||         | //               |         |
 | TURN    |v   | |         v| TURN    |/                 |         |
 | Client  |----|A|----------| Server  |------------------|  Peer B |
 |         |    | |^         |         |^                ^|         |
 |         |    |T||         |         ||                ||         |
 +---------+    | ||         +---------+|                |+---------+
                | ||                    |                |
                | ||                    |                |
                +-+|                    |                |
                   |                    |                |
                   |                    |                |
             Client's                   |            Peer B
             Server-Reflexive    Relayed             Transport
             Transport Address   Transport Address   Address
             192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191
        
図1

図1は、一般的な配置を示しています. この図では、TURNクライアントとTURNサーバーはNATによって分離されており、クライアントはプライベート側にあり、サーバーはNATのパブリック側にあります. このNATは「悪い」NATであると想定されています. たとえば、「アドレスとポートに依存するマッピング」のマッピングプロパティがある場合があります（[RFC4787]を参照）. 

クライアントは、クライアントのHOST TRANSPORT ADDRESSと呼ばれる（IPアドレス、ポート）の組み合わせからサーバーと通信します. （IPアドレスとポートの組み合わせはTRANSPORT ADDRESSと呼ばれます. ）

クライアントは、そのホストトランスポートアドレスからTURN SERVER TRANSPORT ADDRESSと呼ばれるTURNサーバー上のトランスポートアドレスにTURNメッセージを送信します. クライアントは、不特定の手段（構成など）を介してTURNサーバーのトランスポートアドレスを学習します. このアドレスは通常、多くのクライアントによって同時に使用されます. 

クライアントはNATの背後にあるため、サーバーはクライアントからのパケットを、NAT自体のトランスポートアドレスから送信されたものと見なします. このアドレスは、クライアントのSERVER-REFLEXIVEトランスポートアドレスと呼ばれます. サーバーからクライアントのServer-Reflexive Transport Addressに送信されたパケットは、NATによってクライアントのホストトランスポートアドレスに転送されます. 

クライアントはTURNコマンドを使用して、サーバー上でALLOCATIONを作成および操作します. 割り当ては、サーバー上のデータ構造です. このデータ構造には、とりわけ、割り当て用のリレー転送アドレスが含まれます. リレーされたトランスポートアドレスは、ピアがサーバーにデータをクライアントにリレーさせるために使用できるサーバー上のトランスポートアドレスです. 割り当ては、中継されたトランスポートアドレスによって一意に識別されます. 

割り当てが作成されると、クライアントはアプリケーションデータをサーバーに送信し、どのピアにデータを送信するかを示し、サーバーはこのデータを適切なピアに中継します. クライアントはTURNメッセージ内でアプリケーションデータをサーバーに送信します. サーバーでは、TURNメッセージからデータが抽出され、UDPデータグラムでピアに送信されます. 逆方向では、ピアは、アプリケーションデータをUDPデータグラムで、割り当てのために中継されたトランスポートアドレスに送信できます. 次に、サーバーはこのデータをTURNメッセージ内にカプセル化し、どのピアがデータを送信したかを示すとともにクライアントに送信します. TURNメッセージには常にクライアントが通信しているピアの指示が含まれているため、クライアントは単一の割り当てを使用して複数のピアと通信できます. 

ピアがNATの背後にある場合、クライアントは、ホストトランスポートアドレスではなくServer-Reflexive Transport Addressを使用してピアを識別する必要があります. たとえば、上記の例でアプリケーションデータをピアAに送信するには、クライアントは192.168.100.2：49582（ピアAのホストトランスポートアドレス）ではなく、192.0.2.150：32102（ピアAのServer-Reflexive Transport Address）を指定する必要があります. 

サーバー上の各割り当ては単一のクライアントに属し、その割り当てでのみ使用されるrelayed transport addressが1つだけあります. したがって、パケットがサーバー上の中継されたトランスポートアドレスに到着すると、サーバーはデータの対象となるクライアントを認識します. 

クライアントは、サーバー上で同時に複数の割り当てを持つ場合があります. 

2.1. 交通手段
この仕様で定義されているTURNは、サーバーとピアの間で常にUDPを使用します. ただし、この仕様では、UDP、TCP、またはTCPを介したトランスポート層セキュリティ（TLS）のいずれかを使用して、クライアントとサーバーの間でTURNメッセージを伝送できます. 

           +----------------------------+---------------------+
           | TURN client to TURN server | TURN server to peer |
           +----------------------------+---------------------+
           |             UDP            |         UDP         |
           |             TCP            |         UDP         |
           |        TLS over TCP        |         UDP         |
           +----------------------------+---------------------+
        
クライアントとサーバーの間でTCPまたはTLS-over-TCPが使用されている場合、サーバーは、ピアとの間でデータを中継するときに、これらのトランスポートとUDPトランスポートの間で変換します. 

このバージョンのTURNはサーバーとピアの間のUDPのみをサポートしているため、ほとんどのクライアントはクライアントとサーバーの間でもUDPを使用することを好むと予想されます. そのため、一部の読者は疑問に思うかもしれません：なぜTCPとTLS-over-TCPもサポートするのですか？

一部のファイアウォールはUDPを完全にブロックするように構成されているため、TURNはクライアントとサーバー間のTCPトランスポートをサポートします. これらのファイアウォールはUDPをブロックしますが、TCPはブロックしません. これは、TCPには、ファイアウォールによって保護されているノードの意図をファイアウォールにわかりやすくするプロパティがあるためです. たとえば、TCPには3ウェイハンドシェイクがあり、保護されたノードが特定の接続の確立を本当に望んでいることが明確になりますが、UDPの場合、ファイアウォールが実行できる最善の方法は、フィルタリングルールを使用してどのフローが望ましいかを推測することです. また、TCPには明示的な接続ティアダウンがあります. 一方、UDPの場合、ファイアウォールはタイマーを使用してフローがいつ終了するかを推測する必要があります. 

TLSはTURNのデフォルトのダイジェスト認証では提供されない追加のセキュリティプロパティを提供するため、TURNはクライアントとサーバー間のTLS-over-TCPトランスポートをサポートします. 一部のクライアントが利用したいプロパティ. 特に、TLSは、クライアントが正しいサーバーと通信していることを確認する方法を提供し、TURN制御メッセージの機密性を提供します. TLSを使用するオーバーヘッドは、ダイジェスト認証のオーバーヘッドよりも高いため、TURNはTLSを必要としません. たとえば、TLSを使用すると、ほとんどのアプリケーションデータが二重に暗号化されます（TLSによって1回、UDPデータグラムで暗号化されていることを確認するために1回）. 

サーバーとピアの間のTCPのサポートを追加するために、TURNの拡張が計画されています[TURN-TCP]. このため、サーバーとピア間でUDPを使用する割り当てはUDP割り当てと呼ばれ、サーバーとピア間でTCPを使用する割り当てはTCP割り当てと呼ばれます. この仕様では、UDP割り当てについてのみ説明しています. 

この仕様で定義されているTURNは、IPv4のみをサポートしています. この仕様のすべてのIPアドレスはIPv4アドレスでなければなりません. IPv6のサポートを追加し、IPv4とIPv6の間のリレーをサポートするTURNの拡張が計画されています[TURN-IPv6]. 

TURNの一部のアプリケーションでは、クライアントは、サーバーとの通信に使用するホストトランスポートアドレスでTURNパケット以外のパケットを送受信する場合があります. これは、ICEでTURNを使用する場合などに発生します. このような場合、クライアントは、到着するパケットの送信元アドレスを調べることにより、TURNパケットを他のパケットと区別できます. TURNサーバーから到着するパケットは、TURNパケットになります. 

2.2. 割り当て
サーバーで割り当てを作成するために、クライアントはAllocateトランザクションを使用します. クライアントはサーバーに割り当て要求を送信し、サーバーは割り当てられたrelayed transport addressを含む割り当て成功応答で応答します. クライアントは、必要な割り当てのタイプ（たとえば、割り当ての有効期間）を記述する属性をAllocateリクエストに含めることができます. データの中継にはセキュリティの影響があるため、サーバーは、クライアントがサーバーの使用を許可されていることを示すために、通常はSTUNの長期資格情報メカニズムを使用してクライアント自体を認証する必要があります. 

リレーされたトランスポートアドレスが割り当てられると、クライアントは割り当てを有効に保つ必要があります. これを行うために、クライアントは定期的にサーバーに更新要求を送信します. TURNは、リフレッシュのために意図的に別のメソッド（AllocateではなくRefresh）を使用して、何らかの理由で割り当てが消えた場合にクライアントに通知されるようにします. 

更新トランザクションの頻度は、割り当ての有効期間によって決まります. 割り当てのデフォルトの有効期間は10分です. この値は、クライアントが予期せずにタイムリーに終了した割り当てを期限切れにする一方で、更新が通常クライアントに負担にならないように十分に長くなるように選択されました. ただし、クライアントはAllocateリクエストでより長いライフタイムをリクエストでき、Refreshリクエストでそのリクエストを変更でき、サーバーは常にレスポンスで実際のライフタイムを示します. クライアントは、前の割り当てまたはリフレッシュトランザクションの「ライフタイム」秒以内に新しいリフレッシュトランザクションを発行する必要があります. クライアントが割り当てを使用したくない場合は、リクエストされたライフタイムが0のリフレッシュ要求を使用して割り当てを削除する必要があります. 

サーバーとクライアントの両方が、5-TUPLEと呼ばれる値を追跡します. クライアントでは、5タプルはクライアントのホストトランスポートアドレス、サーバートランスポートアドレス、およびサーバーと通信するためにクライアントが使用するトランスポートプロトコルで構成されます. サーバーでは、5タプル値は同じですが、クライアントのホストトランスポートアドレスがクライアントのサーバー再帰アドレスに置き換えられます. これは、サーバーから見たクライアントのアドレスであるためです. 

クライアントとサーバーの両方が、割り当て要求で使用された5タプルを記憶しています. クライアントとサーバー間の後続のメッセージは、同じ5タプルを使用します. このようにして、クライアントとサーバーは、どの割り当てが参照されているかを認識します. クライアントが2番目のrelayed transport addressを割り当てる場合は、別の5タプルを使用して（たとえば、別のクライアントホストアドレスまたはポートを使用して）2番目の割り当てを作成する必要があります. 

注：このドキュメントで使用されている用語は5タプルを指しますが、TURNサーバーは、同じ結果が得られる任意の識別子を格納できます. 具体的には、実装は5タプルの代わりにファイル記述子を使用してTCP接続を表すことができます. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |-- Allocate request --------------->|             |             |
    |                                    |             |             |
    |<--------------- Allocate failure --|             |             |
    |                 (401 Unauthorized) |             |             |
    |                                    |             |             |
    |-- Allocate request --------------->|             |             |
    |                                    |             |             |
    |<---------- Allocate success resp --|             |             |
    |            (192.0.2.15:50000)      |             |             |
    //                                   //            //            //
    |                                    |             |             |
    |-- Refresh request ---------------->|             |             |
    |                                    |             |             |
    |<----------- Refresh success resp --|             |             |
    |                                    |             |             |
        
図2

図2では、クライアントは資格情報なしでサーバーに割り当て要求を送信します. サーバーはすべての要求がSTUNの長期資格情報メカニズムを使用して認証されることを要求するため、サーバーは401（無許可）エラーコードで要求を拒否します. 次にクライアントは再試行しますが、今回は資格情報（図には示されていません）が含まれます. 今回は、サーバーが割り当て要求を受け入れ、割り当てに割り当てられたrelayed transport addressを（とりわけ）含む割り当て成功応答を返します. しばらくすると、クライアントは割り当てを更新することを決定し、更新要求をサーバーに送信します. 更新が受け入れられ、サーバーは更新成功応答を返します. 

2.3. 許可
TURNを使用して企業のファイアウォールセキュリティを回避できるという企業のIT管理者の間の懸念を軽減するために、TURNには権限の概念が含まれています. TURNアクセス許可は、[RFC4787]に準拠するNATのアドレス制限されたフィルタリングメカニズムを模倣します. 

割り当てには0個以上のアクセス許可を設定できます. 各権限は、IPアドレスとライフタイムで構成されます. サーバーは、割り当てのrelayed transport addressでUDPデータグラムを受信すると、最初にアクセス許可のリストを確認します. データグラムの送信元IPアドレスが許可と一致する場合、アプリケーションデータはクライアントにリレーされます. それ以外の場合、UDPデータグラムは通知なく破棄されます. 

更新されない場合、権限は5分後に期限切れになり、権限を明示的に削除する方法はありません. この動作は、[RFC4787]に準拠するNATの動作と一致するように選択されました. 

クライアントは、CreatePermissionリクエストまたはChannelBindリクエストを使用して、権限をインストールまたは更新できます. CreatePermissionリクエストを使用すると、1つのリクエストで複数の権限をインストールまたは更新できます. これは、ICEを使用するアプリケーションにとって重要です. セキュリティ上の理由から、アクセス許可は、認証可能なトランザクションによってのみインストールまたは更新できます. したがって、送信表示とChannelDataメッセージ（ピアにデータを送信するために使用される）は、権限をインストールまたは更新しません. 

権限は割り当てのコンテキスト内にあるため、1つの割り当てで権限を追加または期限切れにしても、他の割り当てには影響しません. 

2.4. 送信メカニズム

クライアントとピアがTURNサーバを使用してアプリケーション・データを交換するには、2つのメカニズムがあります。 最初のメカニズムはSend and Dataメソッドを使用し、2つ目の方法はチャンネルを使用します。 両方の方法に共通しているのは、クライアントが単一の割り当てられた中継されたトランスポート・アドレスを使用して複数のピアと通信する能力です。したがって、両方の方法には、クライアントがどのピアがデータを受信すべきかをサーバに示し、サーバがどのピアがデータを送信したかをクライアントに示すための手段が含まれています。

送信メカニズムでは、送信表示とデータ表示を使用します。 送信表示はクライアントからサーバにアプリケーションデータを送信するために使用され、データ表示はサーバからクライアントにアプリケーションデータを送信するために使用されます。

Sendメカニズムを使用する場合，クライアントは，(a)ピアの（サーバ反射的な）トランスポートアドレスを指定するXOR-PEER-ADDRESS属性と，(b)アプリケーションデータを保持するDATA属性を含むSend指示をTURNサーバに送信する． TURNサーバは，Send指示を受けると，DATA属性からアプリケーションデータを抽出し，割り当てられた中継アドレスを送信元アドレスとして，UDPデータグラムで相手に送信する． 中継されたトランスポート・アドレスは、Send指示に使用される5タプルによって暗示されるので、指定する必要はないことに注意してください。

逆方向では、TURNサーバー上のリレーされたトランスポートアドレスに到着するUDPデータグラムがデータ表示に変換され、クライアントに送信されます. ピアのServer-Reflexive Transport AddressがXOR-PEER-ADDRESS属性とデータに含まれていますそれ自体はDATA属性にあります. リレーされたトランスポートアドレスは割り当てを一意に識別したため、サーバーはどのクライアントがデータを受信する必要があるかを認識しています. 

STUNの長期資格情報メカニズムは認証表示をサポートしていないため、送信およびデータ表示は認証できません. クライアントからサーバーへのレッグはピアへの合計パスの半分にすぎないため、これは最初に現れるほど大きな問題ではありません. 適切なセキュリティを必要とするアプリケーションは、クライアントとピアの間で送信されるデータを暗号化する必要があります. 

送信表示は認証されないため、攻撃者が偽の送信表示をサーバーに送信し、サーバーがこれらをピアに中継する可能性があります. この攻撃を部分的に緩和するために、TURNでは、クライアントが送信指示を使用してピアにデータを送信する前に、ピアに対する許可をインストールする必要があります. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |-- CreatePermission req (Peer A) -->|             |             |
    |<-- CreatePermission success resp --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)-------------->|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<-------------- Data ind (Peer A) --|             |             |
    |                                    |             |             |
    |                                    |             |             |
    |--- Send ind (Peer B)-------------->|             |             |
    |                                    | dropped     |             |
    |                                    |             |             |
    |                                    |<== data ==================|
    |                            dropped |             |             |
    |                                    |             |             |
        
図3

図3では、クライアントはすでにアロケーションを作成しており、今度はピアにデータを送信したいと考えています。 クライアントはまず、XOR-PEER-ADDRESS属性にピアAの(サーバ-reflexive)IPアドレスを指定したCreatePermissionリクエストをサーバに送信してパーミッションを作成します。 クライアントは、Send指示を使用してピアAにデータを送信する。サーバでは、アプリケーションデータが抽出され、中継されたトランスポートアドレスをソーストランスポートアドレスとして使用して、UDPデータグラムでピアAに転送される。 中継されたトランスポートアドレスでピアAからのUDPデータグラムを受信すると、その内容はData指示に置かれ、クライアントに転送される。 その後、クライアントはピアBとデータ交換を試みるが、ピアBにはパーミッションがインストールされていないため、クライアントからのSend指示とピアからのUDPデータグラムの両方がサーバによってドロップされる。

2.5. Channel
一部のアプリケーション（Voi​​ce over IPなど）では、送信表示またはデータ表示がアプリケーションデータに追加する36バイトのオーバーヘッドにより、クライアントとサーバーの間に必要な帯域幅が大幅に増加する可能性があります. これを解決するために、TURNは、クライアントとサーバーがデータを特定のピアに関連付けるための2番目の方法を提供します. 

この2番目の方法は、ChannelDataメッセージと呼ばれる代替パケット形式を使用します. ChannelDataメッセージは、他のTURNメッセージで使用されるSTUNヘッダーを使用しませんが、チャネル番号と呼ばれる番号を含む4バイトのヘッダーを持っています. 使用中の各チャネル番号は特定のピアにバインドされているため、ピアのホストトランスポートアドレスの省略形として機能します. 

チャネルをピアにバインドするために、クライアントはChannelBind要求をサーバーに送信し、バインドされていないチャネル番号とピアのトランスポートアドレスを含めます. チャネルがバインドされると、クライアントはChannelDataメッセージを使用して、ピア宛のサーバーデータを送信できます. 同様に、サーバーはChannelDataメッセージを使用して、そのピアからクライアントに向けてデータを中継できます. 

更新されない限り、チャネルバインディングは10分間持続します. この存続期間は、アクセス許可の存続期間よりも長くなるように選択されています. チャネルバインディングは、チャネルに再バインドする別のChannelBind要求をピアに送信することによって更新されます. アクセス許可と同様（ただし、割り当てとは異なります）、チャネルバインディングを明示的に削除する方法はありません. クライアントは単にタイムアウトするまで待つ必要があります. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |-- ChannelBind req ---------------->|             |             |
    | (Peer A to 0x4001)                 |             |             |
    |                                    |             |             |
    |<---------- ChannelBind succ resp --|             |             |
    |                                    |             |             |
    |-- [0x4001] data ------------------>|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<------------------ [0x4001] data --|             |             |
    |                                    |             |             |
    |--- Send ind (Peer A)-------------->|             |             |
    |                                    |=== data ===>|             |
    |                                    |             |             |
    |                                    |<== data ====|             |
    |<------------------ [0x4001] data --|             |             |
    |                                    |             |             |
        
図4

図4は、使用中のチャネルメカニズムを示しています. クライアントは既に割り当てを作成しており、チャネルをピアAにバインドしようとしています. これを行うために、クライアントはチャネルバインド要求をサーバーに送信し、ピアAのトランスポートアドレスとチャネル番号（0x4001）を指定します. その後、クライアントはChannelDataメッセージ内にカプセル化されたアプリケーションデータをピアAに送信できます. これは次のように表示されます. 

"[0x4001] data"ここで、0x4001はチャネル番号です. ChannelDataメッセージがサーバーに到着すると、サーバーはデータをUDPデータグラムに転送し、ピアA（チャネル番号0x4001にバインドされているピア）に送信します. 

逆方向では、ピアAがUDPデータグラムをrelayed transport addressに送信すると、このUDPデータグラムは、割り当てに割り当てられたrelayed transport addressでサーバーに到着します. チャネル番号が割り当てられているピアAからUDPデータグラムを受信したため、サーバーはデータをクライアントに送信するときに、データをChannelDataメッセージにカプセル化します. 

チャネルがバインドされると、クライアントは自由にChannelDataメッセージを混合し、表示を送信できます. 図では、クライアントは後でChannelDataメッセージではなく送信指示を使用してピアAに追加のデータを送信することを決定します. たとえば、クライアントはこれを行うことを決定し、DONT-FRAGMENT属性を使用できるようにします（次を参照）. セクション）. ただし、チャネルがバインドされると、呼び出しフローに示されているように、サーバーは常にChannelDataメッセージを使用します. 

ChannelDataメッセージは、クライアントがチャネルをバインドしたピアにのみ使用できることに注意してください. 上記の例では、ピアAはチャネルにバインドされていますが、ピアBはバインドされていないため、ピアBとの間のアプリケーションデータは送信メカニズムを使用します. 

2.6. 非特権TURNサーバー
このバージョンのTURNは、サーバーを、特別に特権を必要とせずに、一般的に利用可能なオペレーティングシステムのユーザースペースで実行されるアプリケーションとして実装できるように設計されています. この設計上の決定は、TURNサーバーのデプロイを容易にするために行われました. たとえば、1つのピアがNATトラバーサルサービスを別のピアに提供できるように、TURNサーバーをピアツーピアアプリケーションに統合できるようにします. 

この設計上の決定は、TURNサーバーによって中継されるデータに次の影響を与えます. 

o Diffservフィールドの値はサーバー全体で保持されない場合があります. 

o Time to Live（TTL）フィールドは、サーバー全体で減少するのではなく、リセットされる場合があります. 

o明示的輻輳通知（ECN）フィールドはサーバーによってリセットされる場合があります. 

o ICMPメッセージはサーバーによってリレーされません. 

oパケットはサーバーで再構成されるため、エンドツーエンドの断片化はありません. 

今後の作業では、これらの制限に対処する代替TURNセマンティクスを指定する可能性があります. 

2.7. IPフラグメンテーションの回避
[Frag-Harmful]で説明されている理由により、アプリケーション、特に大量のデータを送信するアプリケーションは、パケットの断片化を回避するために努力する必要があります. TCPを使用するアプリケーションは、フラグメンテーション回避がTCPの標準的な部分になっているため、多かれ少なかれこの問題を無視できますが、UDPを使用するアプリケーション（したがって、このバージョンのTURNを使用するアプリケーション）は、フラグメンテーション回避を自分で処理する必要があります. 

クライアントとピアで実行されているアプリケーションは、IPフラグメンテーションを回避するために2つのアプローチのいずれかをとることができます. 

最初のアプローチは、クライアントとピア間で交換されるTURNメッセージ/ UDPデータグラムで大量のアプリケーションデータを送信しないようにすることです. これは、ほとんどのVoIP（Voice-over-IP）アプリケーションで採用されているアプローチです. このアプローチでは、アプリケーションはIP仕様[RFC0791]で、最大576バイトのIPパケットをフラグメント化する必要がないことを指定しているという事実を利用しています. 

断片化を回避しながら含めることができるアプリケーションデータの正確な量は、クライアントとサーバー間のTURNセッションの詳細（UDP、TCP、またはTLSトランスポートが使用されるかどうか、ChannelDataメッセージまたは送信/データ表示が使用されるかどうか）に依存します. 追加の属性（DONT-FRAGMENT属性など）が含まれているかどうか. 判断が難しいもう1つの要素は、IP-in-IPトンネリングの使用など、他の理由でMTUがパスのどこかで削減されているかどうかです. 

ガイドラインとして、1つのTURNメッセージで最大500バイトのアプリケーションデータ（クライアントからサーバーへのレッグのクライアントによる）またはUDPデータグラム（ピアからサーバーへのレッグのピアによる）を送信すると、通常、 IPフラグメンテーションを回避します. 断片化の可能性をさらに減らすために、ChannelDataメッセージのオーバーヘッドは送信およびデータ表示よりも小さいため、大量のデータを転送するときはクライアントがChannelDataメッセージを使用することをお勧めします. 

クライアントとピアが断片化を回避するために使用できる2番目のアプローチは、パスMTU検出アルゴリズムを使用して、断片化なしで送信できるアプリケーションデータの最大量を決定することです. 

残念ながら、このバージョンのTURNを実装するサーバーはICMPメッセージをリレーしないため、[RFC1191]で定義されている従来のパスMTU検出アルゴリズムは、クライアントとピア間の伝送パスのMTUを検出できません. （ICMPメッセージがリレーされた場合でも、ICMPメッセージはNAT /ファイアウォールデバイスの組み合わせによってフィルタリングされることが多いため、アルゴリズムは常に機能するとは限りません）. 

したがって、クライアントとサーバーは、ICMPメッセージを必要としないパスMTU発見アルゴリズムを使用する必要があります. [RFC4821]で定義されているPacketized Path MTU Discoveryアルゴリズムは、そのようなアルゴリズムの1つです. 

[RFC4821]のアルゴリズムをTURNで使用する方法の詳細は、まだ調査中です. ただし、この目標へのステップとして、このバージョンのTURNはDONT-FRAGMENT属性をサポートしています. クライアントがこの属性を送信表示に含めると、ピアに送信する結果のUDPデータグラムにDFビットを設定するようサーバーに指示します. 一部のサーバーはDFビットを設定できない場合があるため、クライアントは割り当て属性にこの属性を含める必要があります. DONT-FRAGMENT属性をサポートしていないサーバーは、割り当て要求を拒否することでこれを示します. 

2.8. RTPサポート
TURNの想定される用途の1つは、RTPを使用してリアルタイムデータ（音声やビデオなど）を交換したいクライアントやピアのリレーとして使用することです. この目的でのTURNの使用を容易にするために、TURNには、古いバージョンのRTPに対する特別なサポートが含まれています. 

古いバージョンのRTP [RFC3550]では、RTPストリームが偶数のポート番号にあり、関連するRTP制御プロトコル（RTCP）ストリームが存在する場合は、次に高いポートにある必要がありました. これを必要とするピアとクライアントが連携できるようにするために、TURNは、クライアントがサーバーにリレーされたトランスポートアドレスを偶数のポート番号で割り当てることを要求し、オプションでサーバーに後続の割り当てのために次に大きいポート番号を予約することを要求できます. 

2.9. サーバーのエニーキャスト検出
このバージョンのTURNは、UDPを介してTURNサーバーのエニーキャスト検出を行う方法の将来の仕様を許可するように設計されています. 

具体的には、TURNサーバーは、クライアントが代替サーバーを試すことを示唆するAllocate要求を拒否できます. 特定の種類の攻撃を回避するために、クライアントは、代替サーバーでも初期サーバーと同じ資格情報を使用する必要があります. 

3.用語
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます. 

読者は、[RFC5389]とそこで定義されている用語に精通している必要があります. 

このドキュメントでは、次の用語が使用されています. 

TURN：TURNクライアントとTURNサーバーの間で使用されるプロトコル. これはSTUNプロトコル[RFC5389]の拡張機能です. このプロトコルにより、クライアントはリレーされたトランスポートアドレスを割り当てて使用できます. 

TURNクライアント：この仕様を実装するSTUNクライアント. 

TURNサーバー：この仕様を実装するSTUNサーバー. TURNクライアントとそのピアの間でデータを中継します. 

ピア：TURNクライアントが通信したいホスト. TURNサーバーは、TURNクライアントとそのピア間のトラフィックを中継します. ピアは、このドキュメントで定義されているプロトコルを使用してTURNサーバーと対話しません. むしろ、ピアはTURNサーバーから送信されたデータを受信し、ピアはTURNサーバーにデータを送信します. 

トランスポートアドレス：IPアドレスとポートの組み合わせ. 

ホストトランスポートアドレス：クライアントまたはピアのトランスポートアドレス. 

Server-Reflexive Transport Address：NATの「パブリックサイド」のトランスポートアドレス. このアドレスは、特定のホストトランスポートアドレスに対応するようにNATによって割り当てられます. 

リレーされたトランスポートアドレス：クライアントとピア間でパケットをリレーするために使用されるTURNサーバー上のトランスポートアドレス. ピアがTURNサーバーのこのアドレスに送信すると、パケットはクライアントに中継されます. 

TURNサーバートランスポートアドレス：TURNメッセージをサーバーに送信するために使用されるTURNサーバー上のトランスポートアドレス. これは、クライアントがサーバーとの通信に使用するトランスポートアドレスです. 

ピアトランスポートアドレス：サーバーから見たピアのトランスポートアドレス. ピアがNATの背後にある場合、これはピアのServer-Reflexive Transport Addressです. 

割り当て：割り当て要求を通じてクライアントに許可されたrelayed transport addressと、アクセス許可や有効期限タイマーなどの関連する状態. 

5タプル：クライアントとサーバー間の通信に使用される組み合わせ（クライアントIPアドレスとポート、サーバーIPアドレスとポート、およびトランスポートプロトコル（現在はUDP、TCP、またはTLSの1つ））. 5タプルは、この通信ストリームを一意に識別します. 5タプルは、サーバー上の割り当ても一意に識別します. 

チャネル：チャネル番号および関連するピアトランスポートアドレス. チャネル番号がピアのトランスポートアドレスにバインドされると、クライアントとサーバーは、より帯域幅効率の高いChannelDataメッセージを使用してデータを交換できます. 

許可：トラフィックをTURN Serverに送信し、そのトラフィックをTURNクライアントにリレーすることを許可されているピアのIPアドレスとトランスポートプロトコル（ポートは除く）. TURNサーバーは、既存の権限に一致するピアからのトラフィックのみをクライアントに転送します. 

Realm：サーバーまたはサーバー内のコンテキストを説明するために使用される文字列. Realmは、要求の認証に使用するユーザー名とパスワードの組み合わせをクライアントに通知します. 

Nonce：サーバーによってランダムに選択され、メッセージダイジェストに含まれる文字列. 返信攻撃を防ぐために、サーバーはナンスを定期的に変更する必要があります. 

4.一般的な動作
このセクションには、すべてのTURNメッセージに適用される一般的なTURN処理規則が含まれています. 

TURNはSTUNの拡張です. ChannelDataメッセージを除くすべてのTURNメッセージは、STUN形式のメッセージです. [RFC5389]で説明されているすべての基本処理ルールは、STUN形式のメッセージに適用されます. つまり、このドキュメントのすべてのメッセージ形成およびメッセージ処理の説明には、暗黙的に[RFC5389]の規則が前に付いています. 

[RFC5389]は、長期資格情報メカニズムと呼ばれる認証メカニズムを指定します. TURNサーバーとクライアントは、このメカニズムを実装する必要があります. サーバーは、クライアントからのすべてのリクエストがこのメカニズムを使用して認証されること、またはクライアント認証に同等またはより強力なメカニズムが使用されることを要求する必要があります. 

長期資格情報メカニズムはリクエストにのみ適用され、インジケーションの認証には使用できないことに注意してください. したがって、TURNの表示は認証されません. サーバーが要求の認証を要求する場合、サーバーの管理者は、クライアントが異なる管理下で複数のサーバーを使用している場合でも、クライアントが使用する必要があるユーザー名とパスワードの組み合わせを一意に識別するRealm値を選択する必要があります. サーバーの管理者は、各クライアントに一意のユーザー名を割り当てるか、同じユーザー名を複数のクライアント（たとえば、同じ部門または会社のすべてのクライアント）に割り当てるかを選択できます（MAY）. 各割り当てについて、

攻撃者がクライアントの割り当てを乗っ取るのを防ぐために、最初の割り当て後のすべての要求は、割り当ての作成に使用されたものと同じユーザー名を使用する必要があります. 具体的には、サーバーが長期資格情報メカニズムを使用する必要があり、非割り当てリクエストがこのメカニズムで認証に合格し、5タプルが既存の割り当てを識別しているが、リクエストが同じユーザー名を使用していない場合割り当てを作成するために使用される場合、要求は441（Wrong Credentials）エラーで拒否される必要があります. 

TURNメッセージがクライアントからサーバーに到着すると、サーバーはメッセージ内の5タプルを使用して、関連する割り当てを識別します. AllChannelateリクエストを除くすべてのTURNメッセージ（ChannelDataを含む）について、5タプルが既存の割り当てを識別しない場合、メッセージは437 Allocation Mismatchエラーで拒否されるか（要求の場合）、暗黙的に無視される場合（これは指示またはChannelDataメッセージです）. Allocate以外のリクエストに対する437エラー応答を受信するクライアントは、割り当てが存在しないと想定する必要があります. 

[RFC5389]は、SOFTWAREおよびFINGERPRINT属性を含む、いくつかの属性を定義しています. クライアントは、すべての割り当て要求と更新要求にソフトウェア属性を含めるべきであり（SHOULD）、他の要求または指示にそれを含めてもよい（MAY）. サーバーはすべての割り当てと更新応答（成功または失敗のいずれか）にソフトウェア属性を含めるべきで（SHOULD）、他の応答または指示にそれを含めてもよい（MAY）. クライアントとサーバーは、このドキュメントで定義されているSTUN形式のメッセージにFINGERPRINT属性を含めることができます. 

TURNは、[RFC5389]で説明されている後方互換性メカニズムを使用しません. 

この仕様で定義されているTURNは、IPv4のみをサポートしています. クライアントのIPアドレス、サーバーのIPアドレス、および中継されたトランスポートアドレスに表示されるすべてのIPアドレスは、IPv4アドレスである必要があります. 

デフォルトでは、TURNはSTUNと同じポートで実行されます. UDPおよびTCPを介したTURNの場合は3478、TLSを介したTURNの場合は5349です. ただし、TURNには独自のサービスレコード（SRV）名のセットがあります. UDPおよびTCPの場合は「turn」、TLSの場合は「turns」です. セクション6で説明したSRVプロシージャまたはALTERNATE-SERVERプロシージャのいずれかを使用して、別のポートでTURNを実行できます. 

相互運用性を確保するために、TURNサーバーはクライアントとサーバー間のUDPトランスポートの使用をサポートしなければならず（MUST）、TCPおよびTLSトランスポートの使用をサポートする必要があります（SHOULD）. 

クライアントとサーバーの間でUDPトランスポートが使用されている場合、クライアントは、一定のタイムアウト期間内に応答を受信しないと、要求を再送信します. このため、サーバーは同じ5タプルと同じトランザクションIDを持つ2つ（またはそれ以上）のリクエストを受信する場合があります. STUNは、サーバーがこのケースを認識し、要求をべき等として扱うことを要求します（[RFC5389]を参照）. 一部の実装では、受信したすべての要求と対応する応答を40秒間記憶することにより、この要件を満たすことを選択する場合があります. 他の実装では、要求の再処理を選択して、そのような再処理で基本的に同じ応答が返されるように調整できます. 後者のアプローチ（いわゆる「ステートレススタックアプローチ」）を選択する実装者を支援するために、この仕様には、これがどのように行われるかに関するいくつかの実装上の注意が含まれています. 

クライアントとサーバー間でTCPトランスポートが使用されている場合、ビットエラーによりTURNパケットの長さフィールドが破損し、受信者がTURNメッセージの着信ストリームとの同期を失う可能性があります. TCPトランスポート上で無効なTURNメッセージの長いシーケンスを検出するクライアントまたはサーバーは、対応するTCP接続を閉じて、この状況をより迅速に検出できるようにする必要があります. 

有効なユーザー名とパスワードを使用するクライアントによるサーバーに対する意図的または非意図的なサービス拒否攻撃を軽減するために、サーバーは、特定のユーザー名に対して同時にアクティブな割り当ての数とその量の両方に制限を課すことをお勧めしますそれらの割り当てが使用できる帯域幅. サーバーは、486（Allocation Quota Exceeded）で一度にアクティブにできる割り当ての上限数を超える新しい割り当てを拒否し、帯域幅の割り当てを超えるアプリケーションデータトラフィックを破棄する必要があります. 

5.割り当て
すべてのTURN操作は割り当てを中心に展開され、すべてのTURNメッセージは割り当てに関連付けられています. 割り当ては、概念的には次の状態データで構成されています. 

o中継されたトランスポートアドレス. 

o 5タプル：（クライアントのIPアドレス、クライアントのポート、サーバーのIPアドレス、サーバーのポート、トランスポートプロトコル）;

o認証情報. 

o有効期限までの時間. 

o権限のリスト. 

oチャネルからピアへのバインディングのリスト. 

リレーされたトランスポートアドレスは、ピアと通信するためにサーバーによって割り当てられたトランスポートアドレスです. 5タプルは、クライアントとサーバー間の通信パスを示します. クライアントでは、5タプルはクライアントのホストトランスポートアドレスを使用します. サーバーでは、5タプルはクライアントのServer-Reflexive Transport Addressを使用します. 

リレーされたトランスポートアドレスと5タプルはすべての割り当て全体で一意である必要があるため、どちらか一方を使用して割り当てを一意に識別できます. 

認証情報（ユーザー名、パスワード、Realm、ノンスなど）は、後続の要求の確認と応答のメッセージの整合性の計算の両方に使用されます. ユーザー名、Realm、およびnonceの値は、最初は割り当てを作成する認証済みのAllocateリクエストで使用される値ですが、サーバーは438（Stale Nonce）応答を使用して割り当ての有効期間中にnonce値を変更できます. セキュリティ上の理由から、パスワードを明示的に保存するのではなく、サーバーがユーザー名、Realm、およびパスワードのMD5ハッシュであるキー値を保存することが望ましい場合があることに注意してください（[RFC5389]を参照）. 

有効期限までの時間は、割り当てが期限切れになるまでの残り時間（秒）です. 各割り当てまたは更新トランザクションはこのタイマーを設定し、それが0に向かって下降します. デフォルトでは、各割り当てまたは更新トランザクションはこのタイマーをデフォルトのライフタイム値である600秒（10分）にリセットしますが、クライアントはリクエストを割り当てて更新します. 割り当ては、更新リクエストを使用してのみ更新できます. ピアにデータを送信しても、割り当ては更新されません. 割り当てが期限切れになると、割り当てに関連付けられている状態データを解放できます. 

権限のリストはセクション8で説明され、チャネルのリストはセクション11で説明されています. 

6.割り当ての作成
サーバー上の割り当ては、Allocateトランザクションを使用して作成されます. 

6.1. 割り当てリクエストの送信
クライアントは、次のようにAllocateリクエストを作成します. 

クライアントは最初にホストトランスポートアドレスを選択します. クライアントが現在使用されていないトランスポートアドレスを選択することをお勧めします. これは通常、基盤となるOSが現在使用されていないポートを新しいソケットに選択できるようにすることによって行われます. 

次に、クライアントは、クライアントとサーバー間で使用するトランスポートプロトコルを選択します. トランスポートプロトコルは、UDP、TCP、またはTLS-over-TCPのいずれかである必要があります. この仕様ではサーバーとピア間のUDPのみが許可されているため、別のトランスポートを使用する理由がない限り、クライアントがUDPを選択することをお勧めします. 別のトランスポートを選択する理由の1つは、クライアントが、構成または実験により、UDPを使用してTURNサーバーに接続できないと考えていることです. 詳細については、セクション2.1を参照してください. 

また、クライアントはサーバートランスポートアドレスを選択します. これは、次のように行う必要があります. クライアントは（おそらく設定を介して）TURNサーバーのドメイン名を受け取ります. 次に、クライアントは[RFC5389]で説明されているDNS手順を使用しますが、「stun」（または「stuns」）ではなく「turn」（またはTLSを介したTURNの場合は「turns」）のSRVサービス名を使用します. たとえば、example.comドメイン内のサーバーを見つけるために、クライアントは、 '_ turn._udp.example.com'、 '_ turn._tcp.example.com'、および '_turns._tcp.example.com'のルックアップを実行します. クライアントは、それぞれUDP、TCP、またはTLS-over-TCPを使用してサーバーと通信する必要があります. 

クライアントはリクエストにREQUESTED-TRANSPORT属性を含めなければなりません. この属性は、サーバーとピア間のトランスポートプロトコルを指定します（これは5タプルに表示されるトランスポートプロトコルではないことに注意してください）. この仕様では、REQUESTED-TRANSPORTタイプは常にUDPです. この属性は、将来の拡張で他のプロトコルを指定できるようにするために含まれています. 

クライアントがサーバーに割り当ての有効期限フィールドをデフォルトの有効期間以外の値に初期化することを希望する場合、希望する値を指定するLIFETIME属性を含めることができます（MAY）. これは単なる要求であり、サーバーは別の値を使用することを選択できます. サーバーは、フィールドをデフォルト値未満に初期化する要求を無視することに注意してください. 

クライアントが後でこの割り当ての1つ以上の送信指示でDONT-FRAGMENT属性を使用することを希望する場合、クライアントは、割り当てリクエストにDONT-FRAGMENT属性を含める必要があります（SHOULD）. これにより、クライアントはこの属性がサーバーでサポートされているかどうかをテストできます. 

クライアントがリレーされたトランスポートアドレスのポート番号が偶数であることを要求する場合、クライアントにはEVEN-PORT属性が含まれます. この属性が含まれていない場合、ポートは偶数または奇数になります. EVEN-PORT属性のRビットを1に設定することにより、クライアントは、サーバーが次に割り当てられる（同じIPアドレス上の）次に大きいポート番号を予約するように要求できます. Rビットが0の場合、そのような要求は行われません. 

また、クライアントはリクエストにRESERVATION-TOKEN属性を含めて、割り当て用に以前に予約されたポートを使用するようサーバーに要求してもよい（MAY）. RESERVATION-TOKEN属性が含まれている場合、クライアントはEVEN-PORT属性を省略しなければなりません（MUST）. 

構築されると、クライアントは5タプルで割り当て要求を送信します. 

6.2. 割り当てリクエストの受信
サーバーは、割り当て要求を受信すると、次のチェックを実行します. 

1.サーバーは、要求が認証されることを要求する必要があります. この認証は、クライアントとサーバーがこのドキュメントの範囲外のいくつかの手順を通じて別のメカニズムを使用することに同意しない限り、[RFC5389]の長期資格情報メカニズムを使用して行わなければなりません（MUST）. 

2.サーバーは、5タプルが既存の割り当てによって現在使用されているかどうかを確認します. はいの場合、サーバーは437（割り当て不一致）エラーで要求を拒否します. 

3.サーバーは、リクエストにREQUESTED-TRANSPORT属性が含まれているかどうかを確認します. REQUESTED-TRANSPORT属性が含まれていないか、形式が正しくない場合、サーバーは400（Bad Request）エラーで要求を拒否します. それ以外の場合、属性が含まれているがUDP以外のプロトコルを指定すると、サーバーは442（サポートされていないトランスポートプロトコル）エラーで要求を拒否します. 

4.リクエストにはDONT-FRAGMENT属性が含まれる場合があります. サポートしているが、サーバーがDFビットが1に設定されたUDPデータグラムの送信をサポートしていない場合（セクション12を参照）、サーバーは、割り当て要求のDONT-FRAGMENT属性を不明なcomprehension-required属性として扱います. 

5.サーバーは、リクエストにRESERVATION-TOKEN属性が含まれているかどうかを確認します. はいの場合、リクエストにEVEN-PORT属性も含まれていると、サーバーはリクエストを400（Bad Request）エラーで拒否します. それ以外の場合は、トークンが有効であるかどうかを確認します（つまり、トークンが範囲内にあり、有効期限が切れておらず、対応するrelayed transport addressがまだ利用可能です）. トークンが何らかの理由で有効でない場合、サーバーは508（容量不足）エラーで要求を拒否します. 

6.サーバーは、リクエストにEVEN-PORT属性が含まれているかどうかを確認します. イエスの場合、サーバーは要求を満たすことができるかどうかをチェックします（つまり、以下で説明するようにrelayed transport addressを割り当てることができます）. サーバーが要求を満たせない場合、サーバーは508（不十分な容量）エラーで要求を拒否します. 

7.クライアントがローカルに定義された割り当て割り当てを超えようとしていると感じた場合、サーバーはいつでも、486（割り当て割り当てに到達）エラーでリクエストを拒否することを選択できます（MAY）. サーバーはこの割り当て割り当てを自由に定義できますが、クライアントのトランスポートアドレスではなく、要求の認証に使用されるユーザー名に基づいて定義する必要があります（SHOULD）. 

8.また、クライアントを別のサーバーにリダイレクトしたい場合、サーバーはいつでも、300（代替試行）エラーで要求を拒否することを選択できます（MAY）. このエラーコードと属性の使用は、[RFC5389]の仕様に従います. 

すべてのチェックに合格すると、サーバーが割り当てを作成します. 5タプルはAllocateリクエストからの5タプルに設定されますが、権限のリストとチャネルのリストは最初は空です. 

サーバーは、次のように割り当て用のrelayed transport addressを選択します. 

oリクエストにRESERVATION-TOKENが含まれている場合、サーバーは、含まれているトークンに対応する以前に予約されたトランスポートアドレスを使用します（まだ使用可能な場合）. RESERVATION-TOKENを含むAllocateリクエストは、予約を行ったAllocateリクエストとは異なる5タプルを使用するため、予約はサーバー全体の予約であり、特定の割り当てに固有のものではないことに注意してください. RESERVATION-TOKEN属性を含むAllocateリクエストの5タプルは、許可されている任意の5タプルにすることができます. 異なるクライアントIPアドレスとポート、異なるトランスポートプロトコル、さらには異なるサーバーIPアドレスとポートを使用できます（もちろん、サーバーのIPアドレスとポートがサーバーがTURN要求をリッスンしている場合）. 

o要求にRビットが0に設定されたEVEN-PORT属性が含まれている場合、サーバーは中継されたトランスポートアドレスを偶数のポート番号で割り当てます. 

oリクエストにRビットが1に設定されたEVEN-PORT属性が含まれている場合、サーバーは同じIPアドレスでポート番号NとN + 1のペアを探します（Nは偶数）. ポートNは現在の割り当てで使用され、ポートN + 1の中継されたトランスポートアドレスにはトークンが割り当てられ、将来の割り当てのために予約されます. サーバーはこの予約を少なくとも30秒間保持する必要があり、長く保持することを選択できます（たとえば、ポートNでの割り当てが期限切れになるまで）. 次に、サーバーは成功応答のRESERVATION-TOKEN属性にトークンを含めます. 

それ以外の場合、サーバーは使用可能なrelayed transport addressを割り当てます. 

すべての場合において、サーバーは49152から65535の範囲（動的および/またはプライベートポート範囲[ポート番号]）からのみポートを割り当てる必要があります（ここで指定されていない何らかの手段により、他のアプリケーションが実行していることをTURNサーバーアプリケーションが認識していない場合）.  TURNサーバーアプリケーションと同じホスト上では、この範囲外のポートを割り当てることによる影響はありません. この条件は、専用マシンでTURNサーバーアプリケーションを実行するか、マシン上の他のアプリケーションがTURNサーバーアプリケーションを起動する前にポートを割り当てるように設定することで、しばしば満たすことができます. いずれの場合も、TURNサーバーは、クライアントがTURNを使用して標準サービスを実行しないようにするために、0〜1023（既知のポート範囲）のポートを割り当てないでください. 

注：IETFは現在、特定の種類の攻撃を回避するためにランダム化されたポート割り当てのトピックを調査しています（[TSVWG-PORT]を参照）. TURNの実装者がこのトピックに遅れないようにし、必要に応じて、ランダム化されたポート割り当てアルゴリズムを実装することを強くお勧めします. これは特に、基盤となるOSから多数のポートを事前に割り当て、後で割り当てに割り当てることを選択するサーバーに当てはまります. たとえば、サーバーはこの手法を選択してEVEN-PORT属性を実装できます. 

サーバーは、有効期限フィールドの初期値を次のように決定します. リクエストにLIFETIME属性が含まれている場合、サーバーはクライアントの提案されたライフタイムの最小値とサーバーの最大許容ライフタイムを計算します. この計算された値がデフォルトのライフタイムより大きい場合、サーバーは計算されたライフタイムを有効期限フィールドの初期値として使用します. それ以外の場合、サーバーはデフォルトの有効期間を使用します. サーバーは3600秒（1時間）以下の最大許容ライフタイム値を使用することをお勧めします. 割り当て割り当てを実装するか、何らかの方法で割り当てに対してユーザーに課金するサーバーは、より短い最大許容ライフタイム（おそらくデフォルトのライフタイムと同じくらい）を使用して、孤立した割り当て（つまり、対応するクライアントがクラッシュまたは終了したか、クライアント接続が何らかの理由で失われた割り当て. また、有効期限までの時間は、更新要求が成功するたびに再計算されるため、ここで計算される値は最初の更新までしか適用されないことに注意してください. 

割り当てが作成されると、サーバーは成功の応答を返します. 成功の応答には以下が含まれます. 

oリレーされたトランスポートアドレスを含むXOR-RELAYED-ADDRESS属性. 

o有効期限タイマーの現在の値を含むLIFETIME属性. 

o RESERVATION-TOKEN属性（2番目のrelayed transport addressが予約されている場合）. 

oクライアントのIPアドレスとポート（5タプルから）を含むXOR-MAPPED-ADDRESS属性. 

注：XOR-MAPPED-ADDRESS属性は、クライアントの便宜のために応答に含まれています. TURN自体はこの値を使用しませんが、ICEを実行しているクライアントはこの値を必要とする場合が多いため、学習するために一部のSTUNサーバーで余分なバインディングトランザクションを実行する必要がなくなります. 

応答（成功またはエラー）は、5タプルでクライアントに送り返されます. 

注：割り当てリクエストがUDP経由で送信される場合、[RFC5389]のセクション7.3.1では、再送信によって複数の割り当てが作成されないように、サーバーがリクエストの可能な再送信を処理する必要があります. 実装では、次のように、いわゆる「ステートレススタックアプローチ」を使用してこれを実現できます. 元のリクエストが割り当ての作成に成功したときに再送信を検出するために、サーバーはリクエストを作成したトランザクションIDと割り当てデータを保存し、それを同じ5タプルの着信Allocateリクエストと比較できます. このような要求が検出されると、サーバーは要求の解析を停止し、すぐに成功応答を生成できます. この応答を構築するとき、LIFETIME属性の値は、割り当て状態データの有効期限フィールドから取得できます. この値は、最初に返されたLIFETIME値と少し異なる場合があります. さらに、サーバーは、元の応答で返された予約トークンの指示を格納する必要がある場合があります. これにより、再送信された応答で返される可能性があります. 

元のリクエストが割り当ての作成に失敗した場合、サーバーは特別な処理を行わない場合があります. ただし、サーバーが元の要求を拒否し、再送信された要求を受け入れるというまれなケースがあることに注意してください（短時間の間に状態が変化したため）. クライアントが最初の失敗応答を受信した場合、クライアントは2番目の（成功）応答を無視し、割り当てが作成されなかったと信じます. この問題で作成された割り当ては、クライアントが更新しないため、最終的にタイムアウトになります. さらに、クライアントが後で同じ5タプルで異なるトランザクションIDを使用して再試行する場合、クライアントは437（割り当て不一致）を受け取り、別の5タプルで再試行します. 

6.3. 割り当て成功応答の受信
クライアントがAllocate成功応答を受信した場合、マッピングされたアドレスと中継されたトランスポートアドレスが、クライアントが理解し、処理する準備ができているアドレスファミリにあることを確認する必要があります. この仕様は、これら2つのアドレスがIPv4アドレスである場合のみを対象としています. これら2つのアドレスが、クライアントが処理する準備ができているアドレスファミリにない場合、クライアントは割り当てを削除し（セクション7）、不一致が修正されたと確信するまで、そのサーバーに別の割り当てを作成してはなりません（MUST NOT）. 

IETFは現在、IPv4とIPv6の間で移行するためのメカニズムを検討しています. このメカニズムにより、クライアントはIPv6を介して割り当て要求を発信しますが、要求はIPv4を介してサーバーに到着します. 

それ以外の場合、クライアントは割り当てデータ構造の独自のコピーを作成して、サーバーで何が起こっているかを追跡します. 特に、クライアントは、リクエストでサーバーに送信された値ではなく、サーバーから受信した実際の有効期間を覚えておく必要があります. 

クライアントは、リクエストに使用された5タプルと、リクエストの認証に使用されたユーザー名とパスワードを覚えて、後続のメッセージに確実に再利用する必要があります. クライアントは、サーバー上で確立するチャネルとアクセス許可も追跡する必要があります. 

クライアントはおそらく、リレーされたトランスポートアドレスをピアに送信し（ここで指定されていない方法を使用）、ピアが通信できるようにします. クライアントは、ICE処理のXOR-MAPPED-ADDRESS属性で受信したサーバー再帰アドレスを使用することもできます. 

6.4. 割り当てエラー応答の受信
クライアントがAllocateエラー応答を受信した場合、処理は返された実際のエラーコードによって異なります. 

o（リクエストがタイムアウトしました）：サーバーに問題があるか、選択したトランスポートでサーバーに到達できません. クライアントは現在のトランザクションが失敗したと見なしますが、別のトランスポート（UDPではなくTCPなど）を使用して割り当て要求を再試行することを選択できます（MAY）. 

o 300（代替を試行）：サーバーは、クライアントが代わりにALTERNATE-SERVER属性で指定されたサーバーを使用することを望んでいます. クライアントは現在のトランザクションが失敗したと見なしますが、他のサーバー（SRV手順を使用して検出された他のサーバーなど）を試す前に、代替サーバーで割り当て要求を試す必要があります（SHOULD）. 代替サーバーでAllocateリクエストを試みると、クライアントは[RFC5389]で指定されているALTERNATE-SERVERプロシージャに従います. 

o 400（不正な要求）：サーバーは、クライアントの要求が何らかの理由で不正な形式であると信じています. クライアントは、現在のトランザクションが失敗したと見なします. クライアントはユーザーまたはオペレーターに通知してもよい（MAY）、問題が修正されたと確信するまで、このサーバーで要求を再試行すべきではない（SHOULD NOT）. 

o 401（無許可）：クライアントが長期間の資格情報メカニズムの手順に従ってもこのエラーが発生する場合、サーバーはクライアントの資格情報を受け入れていません. この場合、クライアントは現在のトランザクションが失敗したと見なし、ユーザーまたはオペレーターに通知する必要があります（SHOULD）. クライアントは、問題が修正されたと確信するまで、このサーバーにそれ以上のリクエストを送信すべきではありません. 

o 403（禁止）：要求は有効ですが、サーバーはそれを実行することを拒否しています. 管理上の制限が原因である可能性があります. クライアントは、現在のトランザクションが失敗したと見なします. クライアントはユーザーまたはオペレーターに通知することができます（MAY）. 問題が修正されたと確信するまで、このサーバーで同じリクエストを再試行しないでください. 

o 420（不明な属性）：クライアントが要求にDONT-FRAGMENT属性を含め、サーバーが420エラーコードで要求を拒否し、エラー応答のUNKNOWN-ATTRIBUTES属性にDONT-FRAGMENT属性をリストした場合、これでクライアントは、サーバーがDONT-FRAGMENT属性をサポートしていないことを認識します. クライアントは現在のトランザクションが失敗したと見なしますが、DONT-FRAGMENT属性なしで割り当て要求を再試行することを選択できます（MAY）. 

o 437（割り当ての不一致）：これは、サーバーが既に使用中と見なしている5タプルをクライアントが選択したことを示します. これが発生する可能性がある1つの方法は、介在するNATが、最近クラッシュした別のクライアントによって使用されたマップされたトランスポートアドレスを割り当てた場合です. クライアントは、現在のトランザクションが失敗したと見なします. クライアントは別のクライアントトランスポートアドレスを選択して（別のトランザクションIDを使用して）割り当て要求を再試行する必要があります（SHOULD）. クライアントは、このサーバーをあきらめる前に、3つの異なるクライアントトランスポートアドレスを試す必要があります. クライアントがサーバーをあきらめたら、2分間サーバーに別の割り当てを作成しようとしないでください. 

o 438（Stale Nonce）：長期的な資格メカニズム[RFC5389]の手順を参照してください. 

o 441（間違った資格情報）：クライアントは、割り当て要求への応答としてこのエラーを受け取るべきではありません. クライアントはユーザーまたはオペレーターに通知することができます（MAY）. 問題が修正されたと確信するまで、このサーバーで同じリクエストを再試行しないでください. 

o 442（サポートされていないトランスポートアドレス）：クライアントは、UDP割り当ての要求に応答してこのエラーを受け取るべきではありません. クライアントはユーザーまたはオペレーターに通知することができます（MAY）、問題が修正されたと確信するまで、このサーバーで要求を再試行してはなりません（SHOULD NOT）. 

o 486（割り当ての割り当てに達しました）：サーバーは現在、このユーザー名でこれ以上の割り当てを作成できません. クライアントは、現在のトランザクションが失敗したと見なします. クライアントは、サーバー上でさらに割り当てを作成する前に、少なくとも1分間待機する必要があります. 

o 508（容量不足）：サーバーで使用できるrelayed transport addressがなくなったか、要求されたプロパティを持つサーバーがないか、予約されたアドレスが使用できなくなりました. クライアントは、現在の操作が失敗したと見なします. クライアントがEVEN-PORTまたはRESERVATION-TOKEN属性のいずれかを使用している場合、クライアントはこの属性を削除または変更して、すぐに再試行する場合があります. それ以外の場合、クライアントは、このサーバーでさらに割り当てを作成する前に、少なくとも1分間待機する必要があります（SHOULD）. 

不明なエラー応答は、[RFC5389]で説明されているように処理する必要があります. 

7.割り当ての更新
更新トランザクションは、（a）既存の割り当てを更新して、有効期限までの時間を更新するか、（b）既存の割り当てを削除するために使用できます. 

クライアントが割り当ての使用を継続したい場合、クライアントは期限が切れる前にそれを更新する必要があります. クライアントは、有効期限が切れる約1分前に割り当てを更新することをお勧めします. クライアントが割り当てを使用したくない場合は、割り当てを明示的に削除する必要があります. クライアントは、他の理由でいつでも割り当てを更新できます（MAY）. 

7.1. 更新リクエストの送信
クライアントが既存の割り当てをすぐに削除したい場合は、値0のLIFETIME属性が含まれます. 他のすべての形式の要求は、割り当てを更新します. 

更新トランザクションは、割り当ての有効期限タイマーを更新します. クライアントがサーバーに有効期限までのタイマーをデフォルトの有効期間以外のものに設定することを希望する場合は、要求された値を持つLIFETIME属性が含まれます. 次に、サーバーは、Allocateトランザクションの場合と同じ方法で新しい有効期限の値を計算します. ただし、要求されたライフタイムが0の場合、サーバーは割り当てをすぐに削除します. 

7.2. 更新リクエストの受信
サーバーが更新要求を受信すると、セクション4とここで説明した特定のルールに従って処理します. 

サーバーは、「望ましい存続期間」と呼ばれる値を次のように計算します. 要求にLIFETIME属性が含まれていて、属性値が0の場合、「望ましい存続期間」は0です. それ以外の場合、要求にLIFETIME属性が含まれていると、サーバーはクライアントの要求されたライフタイムの最小値とサーバーの最大許容ライフタイムを計算します. この計算された値がデフォルトのライフタイムより大きい場合、「望ましいライフタイム」は計算された値です. それ以外の場合、「目的のライフタイム」がデフォルトのライフタイムです. 

後続の処理は、「望ましいライフタイム」の値に依存します. 

o「望ましいライフタイム」が0の場合、リクエストは成功し、割り当ては削除されます. 

o「望ましい存続期間」がゼロ以外の場合、要求は成功し、割り当ての有効期限は「望ましい存続期間」に設定されます. 

リクエストが成功すると、サーバーは以下を含む成功応答を送信します. 

o有効期限タイマーの現在の値を含むLIFETIME属性. 

注：サーバーは、「ステートレススタックアプローチ」を使用してUDP経由でリフレッシュ要求のべき等性を実装するために特別なことを行う必要はありません. ゼロ以外の「望ましいライフタイム」を持つ再送信された更新リクエストは、割り当てを更新するだけです. 「望ましいライフタイム」がゼロの再送信されたリフレッシュ要求は、割り当てがすでに削除されている場合に437（割り当て不一致）応答を引き起こしますが、クライアントはこれを成功応答と同等に扱います（下記参照）. 

7.3. 更新応答の受信
クライアントがゼロ以外の存続時間でリフレッシュ要求への成功応答を受信した場合、クライアントは割り当てデータ構造のコピーを応答に含まれる有効期限までの値で更新します. 

クライアントが割り当ての削除要求に対する437（Allocation Mismatch）エラー応答を受け取った場合、割り当ては存在せず、その要求は事実上成功したと見なす必要があります. 

8.アクセス許可
割り当てごとに、サーバーは0個以上の権限のリストを保持します. 各権限は、IPアドレスとそれに関連付けられた有効期限で構成されます. 権限が存在する間、権限内のIPアドレスを使用するすべてのピアは、クライアントへのデータの送信を許可されます. 有効期限は、許可が期限切れになるまでの秒数です. 割り当てのコンテキスト内では、許可は関連するIPアドレスによって一意に識別されます. 

CreatePermission要求またはChannelBind要求のいずれかを送信することにより、クライアントはサーバーに、特定のIPアドレスのアクセス許可をインストールまたは更新させることができます. これにより、次のいずれかが発生します. 

oそのIPアドレスに対する権限が存在しない場合は、指定されたIPアドレスと、有効期限までの期間がPermission Lifetimeに等しい権限が作成されます. 

oそのIPアドレスの権限がすでに存在する場合、その権限の有効期限は、Permission Lifetimeにリセットされます. 

パーミッションの有効期間は300秒（= 5分）でなければなりません. 

各権限の有効期限は、0に達するまで毎秒1回減少します. その時点で、許可は期限切れになり、削除されます. 

CreatePermissionリクエストとChannelBindリクエストは、パーミッション上で自由に混在させることができます. 特定の権限は、最初にインストールされるか、CreatePermissionリクエストで更新されるか、後でChannelBindリクエストで更新されるか、またはその逆です. 

UDPデータグラムが割り当てのrelayed transport addressに到着すると、サーバーはIPヘッダーからソースIPアドレスを抽出します. 次に、サーバーはこのアドレスを、割り当てのアクセス許可のリストにある各アクセス許可に関連付けられているIPアドレスと比較します. 一致するものが見つからない場合、中継は許可されず、サーバーはUDPデータグラムを通知なしで破棄します. 完全に一致するものが見つかった場合、権限チェックは成功したと見なされ、サーバーは他の場所で指定されているようにUDPデータグラムの処理を続行します（セクション10.3）. アドレスのみが比較され、ポート番号は考慮されないことに注意してください. 

1つの割り当てのアクセス許可は、別の割り当てのアクセス許可とはまったく無関係です. 割り当てが期限切れになると、そのすべての権限がそれとともに期限切れになります. 

注：TURNアクセス許可は5分後に期限切れになりますが、公開時に展開された多くのNATは、UDPバインディングをかなり早く期限切れにします. したがって、TURNを使用するアプリケーションは、おそらくある種のキープアライブトラフィックをはるかに速い速度で送信したいと思うでしょう. ICEを使用するアプリケーションは、ICE [RFC5245]のキープアライブガイドラインに従う必要があります. ICEを使用しないアプリケーションは、同様のことを行うことをお勧めします. 

9. CreatePermission
TURNは、クライアントがサーバーにアクセス許可をインストールまたは更新するための2つの方法をサポートしています. このセクションでは、1つの方法、CreatePermissionリクエストについて説明します. 

CreatePermissionリクエストは、セクション10の送信メカニズムまたはセクション11のチャネルメカニズムと組み合わせて使用​​できます. 

9.1. CreatePermissionリクエストの作成
1つ以上の権限をインストールまたは更新したいクライアントは、CreatePermissionリクエストをサーバーに送信できます. 

CreatePermissionリクエストを作成する場合、クライアントは少なくとも1つのXOR-PEER-ADDRESS属性を含める必要があり、そのような属性を複数含めることができます（MAY）. 各XOR-PEER-ADDRESS属性のIPアドレス部分には、権限をインストールまたは更新する必要があるIPアドレスが含まれています. 各XOR-PEER-ADDRESS属性のポート部分は無視され、任意の値にすることができます. さまざまなXOR-PEER-ADDRESS属性を任意の順序で表示できます. 

9.2. CreatePermissionリクエストの受信
サーバーがCreatePermissionリクエストを受信すると、セクション4とここで説明した特定のルールに従って処理します. 

メッセージの有効性がチェックされます. CreatePermissionリクエストには、少なくとも1つのXOR-PEER-ADDRESS属性を含める必要があり、そのような属性を複数含めることができます（MAY）. そのような属性が存在しない場合、またはこれらの属性のいずれかが無効な場合は、400（Bad Request）エラーが返されます. リクエストは有効であるが、容量制限などが原因でサーバーがリクエストを満たせない場合は、508（不十分な容量）エラーが返されます. 

サーバーは、XOR-PEER-ADDRESS属性で許可されるIPアドレスに制限を課してもよい（MAY）-値が許可されない場合、サーバーは403（禁止）エラーで要求を拒否します. 

メッセージが有効であり、サーバーが要求を実行できる場合、サーバーは、セクション8で説明されているように、各XOR-PEER-ADDRESS属性に含まれるIPアドレスの権限をインストールまたは更新します. 各属性のポート部分は、無視され、任意の値にすることができます. 

次に、サーバーはCreatePermission成功応答で応答します. 成功の応答には必須属性はありません. 

注：サーバーは、「ステートレススタックアプローチ」を使用して、UDPを介してCreatePermissionリクエストのべき等性を実装するために特別なことを行う必要はありません. 再送信されたCreatePermissionリクエストは、権限を更新するだけです. 

9.3. CreatePermission応答の受信
クライアントが有効なCreatePermission成功応答を受信すると、クライアントはデータ構造を更新して、権限がインストールまたは更新されたことを示します. 

10.送信およびデータメソッド
TURNは、ピアとの間でデータを送受信するための2つのメカニズムをサポートしています. このセクションでは、送信メカニズムとデータメカニズムの使用について説明し、セクション11では、チャネルメカニズムの使用について説明します. 

10.1 送信表示の形成
クライアントは送信指示を使用して、ピアに中継するためにサーバーにデータを渡すことができます. チャネルがそのピアにバインドされている場合でも、クライアントは送信表示を使用できます. ただし、クライアントは、送信指示が送信されているピアのIPアドレスにインストールされている許可があることを確認する必要があります. これにより、第三者がTURNサーバーを使用してデータを任意の宛先に送信することを防ぎます. 

送信指示を形成するとき、クライアントはXOR-PEER-ADDRESS属性とDATA属性を含まなければなりません（MUST）. XOR-PEER-ADDRESS属性には、データの送信先となるピアのトランスポートアドレスが含まれ、DATA属性には、ピアに送信される実際のアプリケーションデータが含まれます. 

クライアントがサーバーにピアに送信されたUDPデータグラムにDFビットを設定することを望む場合、クライアントは送信指示にDONT-FRAGMENT属性を含めることができます. 

10.2 送信表示の受信
サーバーが送信指示を受信すると、セクション4とここで説明した特定のルールに従って処理します. 

メッセージは最初に妥当性がチェックされます. 送信表示には、XOR-PEER-ADDRESS属性とDATA属性の両方が含まれている必要があります. これらの属性の1つが欠落しているか無効である場合、メッセージは破棄されます. DATA属性には0バイトのデータを含めることができることに注意してください. 

送信指示には、DONT-FRAGMENT属性も含まれる場合があります. この属性が存在するときにサーバーが発信UDPデータグラムにDFビットを設定できない場合、サーバーは、DONT-FRAGMENT属性が不明な理解が必要な属性であるかのように動作します（したがって、送信表示は破棄されます）. 

また、サーバーは、XOR-PEER-ADDRESS属性に含まれているIPアドレスに対してインストールされている権限があることを確認します. そのような許可が存在しない場合、メッセージは破棄されます. 送信表示によって、サーバーがアクセス許可を更新することはありません. 

サーバーは、XOR-PEER-ADDRESS属性で許可されるIPアドレスとポートの値に制限を課してもよい（MAY）-値が許可されていない場合、サーバーは送信指示を通知せずに破棄します. 

すべて問題なければ、サーバーは次のようにUDPデータグラムを形成します. 

oソーストランスポートアドレスは、割り当ての中継されたトランスポートアドレスです. 割り当ては、送信指示が到着した5タプルによって決定されます. 

o宛先トランスポートアドレスはXOR-PEER-ADDRESS属性から取得されます. 

o UDPヘッダーに続くデータは、DATA属性の値フィールドの内容です. 

DONT-FRAGMENT属性（存在する場合）の処理については、セクション12で説明します. 

次に、結果のUDPデータグラムがピアに送信されます. 

10.3 UDPデータグラムの受信
サーバーは、現在割り当てられているrelayed transport addressでUDPデータグラムを受信すると、relayed transport addressに関連付けられている割り当てを検索します. 次に、サーバーは、セクション8で説明されているように、割り当てのアクセス許可のセットがUDPデータグラムの中継を許可するかどうかを確認します. 

リレーが許可されている場合、サーバーは、UDPデータグラムを送信したピアにバインドされたチャネルがあるかどうかをチェックします（セクション11を参照）. チャネルがバインドされている場合、セクション11.7で説明されているように処理が進行します. 

中継は許可されているが、チャネルがピアにバインドされていない場合、サーバーはデータ表示を形成して送信します. データ表示には、XOR-PEER-ADDRESSとDATA属性の両方が含まれている必要があります. DATA属性はデータグラムの「データオクテット」フィールドの値に設定され、XOR-PEER-ADDRESS属性は受信したUDPデータグラムのソーストランスポートアドレスに設定されます. 次に、データ表示は、割り当てに関連付けられた5タプルで送信されます. 

10.4. データ表示の受信
クライアントはデータ表示を受信すると、データ表示にXOR-PEER-ADDRESSとDATA属性の両方が含まれていることを確認し、含まれていない場合は表示を破棄します. また、クライアントは、XOR-PEER-ADDRESS属性値に、アクティブなアクセス許可があるとクライアントが信じているIPアドレスが含まれていることを確認し、それ以外の場合はデータ表示を破棄する必要があります. DATA属性には0バイトのデータを含めることができることに注意してください. 

注：後者のチェックでは、サーバーをだましてクライアントが望まないアクセス許可をインストールする攻撃者からクライアントを保護します. 

データ表示が上記のチェックに合格すると、クライアントはDATA属性内のデータオクテットを、トランスポートアドレスがXOR-PEER-ADDRESS属性で指定されているピアから受信されたという表示とともにアプリケーションに配信します. 

11.チャネル
チャネルは、クライアントとサーバーがChannelDataメッセージを使用してアプリケーションデータを送信する方法を提供します. これは、送信とデータの指示よりもオーバーヘッドが少ないです. 

ChannelDataメッセージ（セクション11.4を参照）は、チャネル番号を運ぶ2バイトのフィールドで始まります. このフィールドの値は、次のように割り当てられます. 

0x0000〜0x3FFF：これらの値をチャネル番号に使用することはできません. 

0x4000から0x7FFFまで：これらの値は、許可されるチャネル番号です（16,383の可能な値）. 

0x8000〜0xFFFF：これらの値は、将来の使用のために予約されています. 

この分割により、ChannelDataメッセージは、メッセージの最初の2ビットを調べることで、STUN形式のメッセージ（割り当て要求、送信指示など）と区別できます. 

0b00：STUN形式のメッセージ（STUN形式のメッセージの最初の2ビットは常にゼロであるため）. 

0b01：ChannelDataメッセージ（チャネル番号はChannelDataメッセージの最初のフィールドであり、チャネル番号は0x4000〜0x7FFFの範囲にあるため）. 

0b10：予約済み

0b11：予約済み

予約された値は、チャネル番号の範囲を拡張するために将来使用される可能性があります. したがって、実装は、TURNメッセージが常に0ビットで始まると想定してはなりません（MUST NOT）. 

チャネルバインディングは常にクライアントによって開始されます. クライアントは、割り当ての有効期間中いつでもチャネルをピアにバインドできます. クライアントは、データを交換する前、または（SendおよびData表示を使用して）しばらくの間データを交換した後、チャネルをピアにバインドするか、チャネルをバインドしないことを選択できます. クライアントは、チャネルを他のピアにバインドせずに、チャネルを一部のピアにバインドすることもできます. 

チャネルバインディングは割り当てに固有であるため、ある割り当てのチャネルバインディングでチャネル番号またはピアトランスポートアドレスを使用しても、別の割り当てでの使用には影響しません. 割り当てが期限切れになると、そのすべてのチャネルバインディングがそれとともに期限切れになります. 

チャネルバインディングは以下で構成されます. 

oチャネル番号. 

o（ピアの）トランスポートアドレス. そして

o有効期限までのタイマー. 

割り当てのコンテキスト内で、チャネルバインディングは、チャネル番号またはピアのトランスポートアドレスによって一意に識別されます. したがって、同じチャネルを2つの異なるトランスポートアドレスにバインドしたり、同じトランスポートアドレスを2つの異なるチャネルにバインドしたりすることはできません. 

更新されない限り、チャネルバインディングは10分間持続します. （サーバーがChannelBind要求を受信して​​同じピアにチャネルを再バインドすることにより）バインディングを更新すると、有効期限までのタイマーが10分にリセットされます. 

チャネルバインディングの有効期限が切れると、チャネルはバインド解除されます. バインドを解除すると、チャネル番号を別のトランスポートアドレスにバインドでき、トランスポートアドレスを別のチャネル番号にバインドできます. 競合状態を防止するために、クライアントは、チャネルバインディングの有効期限が切れた後、チャネル番号を別のトランスポートアドレスまたはトランスポートアドレスを別のチャネル番号にバインドする前に5分間待機する必要があります. 

チャネルをピアにバインドする場合、クライアントは、ChannelBind要求を送信するとすぐに、サーバーからチャネル上のChannelDataメッセージを受信できるように準備する必要があります. UDPでは、クライアントがChannelBind成功応答を受信する前に、サーバーからChannelDataメッセージを受信する可能性があります. 

逆方向では、クライアントはChannelBind成功応答を受信する前にChannelDataメッセージを送信することを選択できます（MAY）. ただし、そうすることは、ChannelBind要求が何らかの理由（たとえば、要求がUDP経由で送信された場合にパケットが失われるか、サーバーが要求を実行できない場合）で成功しなかった場合に、サーバーによってChannelDataメッセージがドロップされるリスクを負います.  . 安全を希望するクライアントは、チャネルバインディングが確認されるまで、データをキューに入れるか、送信表示を使用する必要があります. 

11.1 ChannelBindリクエストの送信
チャネルバインディングは、ChannelBindトランザクションを使用して作成または更新されます. ChannelBindトランザクションは、ピアに対する権限も作成または更新します（セクション8を参照）. 

ChannelBindトランザクションを開始するために、クライアントはChannelBindリクエストを形成します. バインドされるチャネルはCHANNEL-NUMBER属性で指定され、ピアのトランスポートアドレスはXOR-PEER-ADDRESS属性で指定されます. セクション11.2では、これらの属性の制限について説明します. 

既にバインドされているのと同じトランスポートアドレスにチャネルを再バインドすると、ピアにデータを送信せずにチャネルバインドと対応する権限を更新する方法が提供されます. ただし、権限はチャネルよりも頻繁に更新する必要があることに注意してください. 

11.2 ChannelBindリクエストの受信
サーバーがChannelBindリクエストを受信すると、セクション4とここで説明した特定のルールに従って処理します. 

サーバーは以下をチェックします. 

oリクエストにCHANNEL-NUMBER属性とXOR-PEER-ADDRESS属性の両方が含まれている. 

oチャネル番号の範囲は0x4000から0x7FFE（両端を含む）です. 

o現在、チャネル番号は別のトランスポートアドレスにバインドされていません（同じトランスポートアドレスで問題ありません）. 

o現在、トランスポートアドレスは別のチャネル番号にバインドされていません. 

これらのテストのいずれかが失敗すると、サーバーは400（Bad Request）エラーで応答します. 

サーバーは、XOR-PEER-ADDRESS属性で許可されるIPアドレスとポートの値に制限を課してもよい（MAY）-値が許可されない場合、サーバーは403（禁止）エラーで要求を拒否します. 

リクエストは有効であるが、サーバーが何らかの容量制限などのためにリクエストを実行できない場合、サーバーは508（不十分な容量）エラーで応答します. 

それ以外の場合、サーバーはChannelBind成功応答で応答します. 成功したChannelBind応答には必須属性はありません. 

サーバーが要求を満たすことができる場合、サーバーは、CHANNEL-NUMBER属性のチャネル番号とXOR-PEER-ADDRESS属性のトランスポートアドレスを使用して、チャネルバインディングを作成または更新します. サーバーは、セクション8で説明されているように、XOR-PEER-ADDRESS属性のIPアドレスの権限をインストールまたは更新します. 

注：サーバーは、「ステートレススタックアプローチ」を使用してUDP経由でChannelBindリクエストのべき等性を実装するために特別なことを行う必要はありません. 再送信されたChannelBindリクエストは、チャネルバインディングと対応する権限を更新するだけです. さらに、クライアントは、以前にバインドされたチャネル番号またはピアアドレスを別のチャネルにバインドする前に5分間待機する必要があるため、トランザクションが最初は失敗しても再送信は成功する可能性がなくなります. 

11.3. ChannelBind応答の受信
クライアントがChannelBind成功応答を受信すると、クライアントはデータ構造を更新して、チャネルバインディングがアクティブになったことを記録します. また、対応する権限がインストールまたは更新されたことを記録するために、データ構造を更新します. 

クライアントが、チャネル情報がクライアントとサーバー間で同期していないことを示すChannelBind失敗応答（たとえば、予期しない400 "Bad Request"応答）を受け取った場合、クライアントが直ちに割り当てを削除することをお勧めします新しい割り当てで新たに開始します. 

11.4. ChannelDataメッセージ
ChannelDataメッセージは、クライアントとサーバーの間でアプリケーションデータを運ぶために使用されます. 次の形式があります. 

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Channel Number        |            Length             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                       Application Data                        /
   /                                                               /
   |                                                               |
   |                               +-------------------------------+
   |                               |
   +-------------------------------+
        
Channel Numberフィールドは、データが移動しているチャネルの番号を指定します. したがって、データを送信している、または受信するピアのアドレスを指定します. 

Lengthフィールドは、アプリケーションデータフィールドの長さをバイト単位で指定します（つまり、ChannelDataヘッダーのサイズは含みません）. 0は有効な長さであることに注意してください. 

Application Dataフィールドには、クライアントがピアに送信しようとしているデータ、またはピアがクライアントに送信しているデータが含まれています. 

11.5. ChannelDataメッセージの送信
クライアントがチャネルをピアにバインドすると、クライアントがそのピアに送信するデータを持っている場合、ChannelDataメッセージまたは送信指示のいずれかを使用できます. つまり、クライアントはチャネルが存在する場合にチャネルを使用する義務がなく、ピアにデータを送信するときに2つのメッセージタイプを自由に混在させることができます. 一方、チャネルがピアにバインドされている場合、サーバーはChannelDataメッセージを使用する必要があります. 

ChannelDataメッセージのフィールドは、セクション11.4で説明されているように入力されます. 

TCPおよびTLS-over-TCPでは、後続のメッセージの整列を保証するために、ChannelDataメッセージを4バイトの倍数にパディングする必要があります. パディングはChannelDataメッセージの長さフィールドには反映されないため、ChannelDataメッセージの実際のサイズ（パディングを含む）は（4 +長さ）を最も近い4の倍数に切り上げたものです. UDPではパディングは必要ありませんが、含まれる場合があります. 

次に、ChannelDataメッセージが、割り当てに関連付けられた5タプルで送信されます. 

11.6. ChannelDataメッセージの受信
前述のように、ChannelDataメッセージの受信者は、最初の2ビットを使用して、STUN形式のメッセージと区別します. メッセージが予約された範囲（0x8000から0xFFFF）の値を使用する場合、メッセージは警告なしで破棄されます. 

ChannelDataメッセージがUDPデータグラムで受信され、UDPデータグラムが短すぎてChannelDataメッセージの要求された長さを含めることができない場合（つまり、UDPヘッダー長フィールド値がChannelDataヘッダー長フィールド値+ 4 + 8より小さい場合） ）の場合、メッセージは通知なく破棄されます. 

ChannelDataメッセージがTCPまたはTLS-over-TCPで受信された場合、ChannelDataメッセージの実際の長さは、セクション11.5で説明されています. 

ChannelDataメッセージがピアにバインドされていないチャネルで受信された場合、メッセージは通知なく破棄されます. 

クライアントでは、ピアに対するアクティブなアクセス許可がないとクライアントが確信している場合、クライアントがChannelDataメッセージを破棄することをお勧めします. サーバーでは、ChannelDataメッセージの受信は、チャネルバインディングまたはピアへの許可のいずれも更新してはなりません（MUST NOT）. 

サーバーでエラーが検出されない場合、サーバーは次のようにUDPデータグラムを形成することにより、アプリケーションデータをピアに中継します. 

oソーストランスポートアドレスは、割り当てのrelayed transport addressです. 割り当ては、ChannelDataメッセージが到着した5タプルによって決定されます. 

o宛先トランスポートアドレスは、チャネルがバインドされているトランスポートアドレスです. 

o UDPヘッダーに続くデータは、ChannelDataメッセージのデータフィールドの内容です. 

次に、結果のUDPデータグラムがピアに送信されます. ChannelDataメッセージのLengthフィールドが0の場合、UDPデータグラムにはデータがありませんが、UDPデータグラムは引き続き形成されて送信されます. 

11.7. ピアからのデータの中継
サーバーは、割り当てに関連付けられたrelayed transport addressでUDPデータグラムを受信すると、セクション10.3で説明されているようにそれを処理します. そのセクションがChannelDataメッセージを送信する必要があることを示す場合（UDPデータグラムに送信されたピアにバインドされたチャネルがあるため）、サーバーはセクション11.5で説明されているようにChannelDataメッセージを形成して送信します. 

12. IPヘッダーフィールド
このセクションでは、クライアントとピア間、またはその逆の中継時にサーバーがIPヘッダーにさまざまなフィールドを設定する方法について説明します. このセクションの説明は、（a）サーバーがUDPデータグラムをピアに送信する場合、または（b）サーバーがデータ表示またはChannelDataメッセージをUDPトランスポートを介してクライアントに送信する場合に適用されます. このセクションの説明は、TCPまたはTLSトランスポートを介してサーバーからクライアントに送信されるTURNメッセージには適用されません. 

以下の説明には、推奨動作と代替動作の2つの部分があります. サーバーは推奨される動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替の動作を実装する必要があります（SHOULD）. 

存続可能時間（TTL）フィールド

推奨される動作：着信値が0の場合、ドロップは着信パケットをドロップします. それ以外の場合は、発信の生存時間/ホップカウントを着信の値よりも1だけ小さい値に設定します. 

代替動作：発信パケットのデフォルトに発信値を設定します. 

DiffServコードポイント（DSCP）フィールド[RFC2474]

推奨される動作：サーバーに差別化されたサービス分類子とマーカー[RFC2474]が含まれていない限り、発信値を着信値に設定します. 

代替動作：発信値を固定値に設定します. 特に設定しない限り、デフォルトではベストエフォートです. 

どちらの場合も、サーバーが差別化されたサービスの分類子とマーカーに直接隣接している場合、DSCPは分類子の方向に任意の値に設定できます（MAY）. 

明示的輻輳通知（ECN）フィールド[RFC3168]

推奨される動作：サーバーがアクティブキュー管理を実行し、受信ECNフィールドがECT（1）（= 0b01）またはECT（0）（= 0b10）であり、サーバーが指示したい場合を除き、送信値を受信値に設定します. その輻輳が発生した場合は、発信値をCE（= 0b11）に設定します. 

代替動作：出力値をNot-ECT（= 0b00）に設定します. 

IPv4フラグメンテーションフィールド

推奨される動作：サーバーがDONT-FRAGMENT属性を含む送信表示に応答してピアにパケットを送信する場合、送信IPヘッダーのDFビットを1に設定します. アプリケーションデータを含む送信パケットを送信するその他すべての場合（たとえば、データ表示、ChannelDataメッセージ、または送信表示に含まれていないDONT-FRAGMENT属性）、アプリケーションデータが含まれていた着信パケットのDFビットからDFビットをコピーします. 

サーバーから発信されたパケットに応じて、他のフラグメンテーションフィールド（識別、その他のフラグメント、フラグメントオフセット）を設定します. 

代替動作：推奨される動作で説明したとおり. ただし、着信DFビットが0であると常に想定します. 

優先動作と代替動作の両方で、結果のパケットが発信リンクには大きすぎる可能性があります. この場合、通常の断片化規則が適用されます[RFC1122]. 

IPv4オプション

推奨される動作：発信パケットはIPv4オプションなしで送信されます. 

代替動作：優先と同じ. 

13.新しいSTUNメソッド
このセクションでは、この仕様で定義されている新しいSTUNメソッドのコードポイントを示します. これらの新しいメソッドのセマンティクスについては、このドキュメントの他の場所を参照してください. 

   0x003：割り当て（要求/応答のセマンティクスのみが定義されています）
   0x004：更新（要求/応答のセマンティクスのみが定義されています）
   0x006：送信（指示セマンティクスのみが定義されています）
   0x007：データ（定義の意味論のみ）
   0x008：CreatePermission（リクエスト/レスポンスのセマンティクスのみが定義されています
   0x009：ChannelBind（要求/応答のセマンティクスのみが定義されています）
        
14.新しいSTUN属性
このSTUN拡張は、次の新しい属性を定義します. 

     0x000C：チャネル番号
     0x000D：ライフタイム
     0x0010：予約済み（以前はBANDWIDTH）
     0x0012：XOR-PEER-ADDRESS
     0x0013：データ
     0x0016：XOR-RELAYED-ADDRESS
     0x0018：EVEN-PORT
     0x0019：要求されたトランスポート
     0x001A：DONT-FRAGMENT
     0x0021：予約済み（以前はTIMER-VAL）
     0x0022：RESERVATION-TOKEN
        
これらの属性の一部の長さは4の倍数ではありません. STUNの規則により、長さが4バイトの倍数ではない属性の直後には、次の属性（存在する場合）を確実にするために1から3のパディングバイトが続く必要があります.  4バイト境界から開始します（[RFC5389]を参照）. 

14.1. CHANNEL-NUMBER
CHANNEL-NUMBER属性には、チャネルの番号が含まれています. この属性の値の部分は4バイト長で、16ビットの符号なし整数と、それに続く2オクテットのRFFU（将来の使用のために予約）フィールドで構成されます. 送信時には0に設定し、受信時には無視する必要があります. 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |        Channel Number         |         RFFU = 0              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
14.2. LIFETIME
LIFETIME属性は、更新がない場合にサーバーが割り当てを維持する期間を表します. この属性の値の部分は4バイト長で、有効期限までの残り秒数を表す32ビットの符号なし整数値で構成されています. 

14.3. XOR-ピア-アドレス
XOR-PEER-ADDRESSは、TURNサーバーから見たピアのアドレスとポートを指定します. （たとえば、ピアがNATの背後にある場合、ピアのServer-Reflexive Transport Address）. XOR-MAPPED-ADDRESS[RFC5389]と同じ方法でエンコードされます. 

14.4. データ
DATA属性は、すべての送信およびデータ表示に存在します. この属性の値の部分は可変長であり、アプリケーションデータ（つまり、データがクライアントとピアの間で直接送信された場合、UDPヘッダーの直後に続くデータ）で構成されます. この属性の長さが4の倍数でない場合は、この属性の後にパディングを追加する必要があります. 

14.5 XORリレーアドレス
XOR-RELAYED-ADDRESSは、割り当て応答に存在します. サーバーがクライアントに割り当てたアドレスとポートを指定します. XOR-MAPPED-ADDRESS [RFC5389]と同じ方法でエンコードされます. 

14.6 EVEN-PORT
この属性により、クライアントは、中継されたトランスポートアドレスのポートが偶数になるように要求し、（オプションで）サーバーが次に大きいポート番号を予約するように要求できます. この属性の値の部分は1バイト長です. その形式は次のとおりです. 

      0
      0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+
     |R|    RFFU     |
     +-+-+-+-+-+-+-+-+
        
値には1つの1ビットフラグが含まれます. 

R：1の場合、サーバーは次の割り当てのために（同じIPアドレスで）次に大きいポート番号を予約するように要求されます. 0の場合、そのような予約は要求されません. 

属性値の他の7ビットは、送信時にはゼロに設定され、受信時には無視される必要があります. 

この属性の長さは4の倍数ではないため、パディングはこの属性の直後に続く必要があります. 

14.7. REQUESTED-TRANSPORT
   この属性は、特定のトランスポートを要求するためにクライアントによって使用されます
   割り当てられたトランスポートアドレスのプロトコル. これの価値
   属性は次の形式の4バイトです. 
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |    Protocol   |                    RFFU                       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
「プロトコル」フィールドは、目的のプロトコルを指定します. このフィールドで使用されるコードポイントは、IPv4ヘッダーのプロトコルフィールドとIPv6ヘッダーの[NextHeader]フィールドで許可されているものから取得されます[Protocol-Numbers]. この仕様では、コードポイント17（ユーザーデータグラムプロトコル）のみを使用できます. 

RFFUフィールドは、送信時にゼロに設定する必要があり、受信時には無視する必要があります. 将来の使用のために予約されています. 

14.8.  DONT-FRAGMENT
クライアントがこの属性を使用して、アプリケーションデータをピアに中継するときに、サーバーがDF（Do n't Fragment）ビットをIPヘッダーに設定することを要求します. この属性には値の部分がないため、属性の長さフィールドは0です. 

14.9.  RESERVATION-TOKEN
RESERVATION-TOKEN属性には、サーバーによって予約されているrelayed transport addressを一意に識別するトークンが含まれています. サーバーは、この属性を成功の応答に含めて、クライアントにトークンを通知します. クライアントは、この属性を後続のAllocate要求に含めて、サーバーが割り当てのrelayed transport addressを使用するように要求します. 

属性値は8バイトで、トークン値が含まれています. 

15.新しいSTUNエラー応答コード
このドキュメントでは、次の新しいエラー応答コードを定義しています. 

403（禁止）：リクエストは有効でしたが、管理上の制限または同様の制限により実行できません. 

437（Allocation Mismatch）：割り当てを設定する必要があるサーバーによって要求が受信されましたが、割り当てが存在しないか、割り当てが必要ないが割り当てが存在する要求を受信しました. 

441（間違った資格情報）：（非割り当て）要求の資格情報が、割り当ての作成に使用された資格情報と一致しません. 

442（サポートされていないトランスポートプロトコル）：割り当て要求は、サーバーと、サーバーがサポートしていないピア間でトランスポートプロトコルを使用するようにサーバーに要求しました. 注：これは、5タプルで使用されるトランスポートプロトコルを指すものではありません. 

486（割り当ての割り当てに達しました）：現在、このユーザー名を使用して割り当てを作成することはできません. 

508（容量不足）：容量制限に達したため、サーバーは要求を実行できません. Allocate応答では、サーバーがその時点でrelayed transport addressを使用できなくなっているか、要求されたプロパティが何もないか、または指定された予約トークンに対応するアドレスが使用できないことが原因である可能性があります. 

16.詳細な例
このセクションでは、TURNの使用例を示し、交換されるメッセージの内容を詳細に示します. この例では、概要（図1）に示されているネットワーク図を使用しています. 

メッセージごとに、メッセージに含まれる属性とその値が表示されます. 便宜上、値は実際のオクテットではなく、人間が読める形式で表示されます. たとえば、「XOR-RELAYED-ADDRESS = 192.0.2.15：9000」は、XOR-RELAYED-ADDRESS属性にアドレス192.0.2.15とポート9000が含まれていることを示しています. ここでは、アドレスとポートがxorの前に表示されています.  -ingが完了しました. 文字列のような値を持つ属性（例：SOFTWARE = "Example client、version 1.03"およびNONCE = "adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"）の場合、属性の値は読みやすくするために引用符で示していますが、実際の値には表示されません. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |                                    |             |             |
    |--- Allocate request -------------->|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example client, version 1.03"       |             |
    |    LIFETIME=3600 (1 hour)          |             |             |
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |                                    |             |             |
    |<-- Allocate error response --------|             |             |
    |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    ERROR-CODE=401 (Unauthorized)   |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |                                    |             |             |
    |--- Allocate request -------------->|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    LIFETIME=3600 (1 hour)          |             |             |
    |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |
    |    DONT-FRAGMENT                   |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Allocate success response ------|             |             |
    |    Transaction-Id=0xC271E932AD7446A32C234492     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    LIFETIME=1200 (20 minutes)      |             |             |
    |    XOR-RELAYED-ADDRESS=192.0.2.15:50000          |             |
    |    XOR-MAPPED-ADDRESS=192.0.2.1:7000             |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
        
クライアントは、TURNセッションで使用するホストトランスポートアドレスを選択することから始めます。この例では、クライアントは10.1.1.2.49721を選択しました。49721を選択しました（図1参照）。 次に、クライアントはサーバーのトランスポートアドレスでAllocateリクエストをサーバーに送信します。 クライアントは、このトランザクションのために、96ビットのトランザクションIDである0xA56250D3F17ABE679422DE85をランダムに選択します。このIDは、固定ヘッダのトランザクションIDフィールドにエンコードされます。 クライアントは、クライアントのソフトウェアに関する情報を示すSOFTWARE属性を含んでいる。ここでは、値として「Example client, version 1.03」となっており、Example clientと呼ばれるもののバージョン1.03であることを示している。 クライアントがLIFETIME属性を含めるのは、割り当ての有効期間をデフォルトの10分よりも長くしたいからです。この属性の値は3600秒で、1時間に相当します。 クライアントは、AllocateリクエストにREQUESTED-TRANSPORT属性を必ず含める必要があります。この仕様で許可されている値は17のみで、これはサーバーとピアの間のUDPトランスポートを示しています。 また、クライアントはDONT-FRAGMENT属性を含めるが、これはDONT-FRAGMENT属性を後のSend indicationsで使用したいためである。この属性は属性ヘッダのみで構成され、値の部分はない。 この属性は属性ヘッダのみで構成されており、値の部分はない。クライアントは最近サーバとやりとりしていないと仮定しているため、USERNAME、REALM、NONCE、MESSAGE-INTEGRITY属性を含まない。 最後に、メッセージ内の属性の順序は任意であり(MESSAGE-INTEGRITYとFINGERPRINT属性を除く)、クライアントは異なる順序を使用できたことに注意してほしい。

サーバーは、要求を認証する必要があります. したがって、サーバーは最初のAllocate要求を受信すると、要求に認証属性が含まれていないため、要求を拒否します. STUN [RFC5389]の長期資格情報メカニズムの手順に従って、サーバーは401（Unauthorized）の値を持つERROR-CODE属性、サーバーが使用する認証Realmを指定するREALM属性（この場合、サーバーのドメイン "example.com"）、およびNONCE属性のnonce値. サーバーには、サーバーのソフトウェアに関する情報を提供するソフトウェア属性も含まれています. 

クライアントは401エラーを受信すると、今回は認証属性を含めて、割り当て要求を再試行します. クライアントは新しいトランザクションIDを選択し、新しいAllocateリクエストに以前と同じ属性を設定します. クライアントにはUSERNAME属性が含まれており、サーバーから受け取ったRealm値を使用して、使用する値を決定します. ここでは、クライアントは、Realm「example.com」にユーザー名「George」を使用するように構成されています. クライアントには、401エラー応答からコピーされたREALMおよびNONCE属性も含まれています. 最後に、クライアントはメッセージの最後の属性としてMESSAGE-INTEGRITY属性を含みます. その値は、メッセージのコンテンツに対するハッシュメッセージ認証コード-セキュアハッシュアルゴリズム1（HMAC-SHA1）ハッシュです（単に ".. . 

サーバーは、認証されたAllocateリクエストを受信すると、すべてがOKであることを確認し、割り当てを作成します. サーバーはAllocate成功応答で応答します. サーバーには、割り当ての有効期間を示すLIFETIME属性が含まれています. ここでは、サーバーはクライアントの要求された1時間の存続時間を20分に短縮しました. これは、この特定のサーバーが20分を超える存続時間を許可しないためです. サーバーにはXOR-RELAYED-ADDRESS属性が含まれており、その値は割り当てのrelayed transport addressです. サーバーにはXOR-MAPPED-ADDRESS属性が含まれており、その値はクライアントのサーバー再帰アドレスです. この値は他の場合はTURNでは使用されませんが、クライアントの便宜のために返されます. サーバーにはMESSAGE-INTEGRITY属性が含まれており、応答を認証して完全性を保証します. 応答には、USERNAME、REALM、およびNONCE属性が含まれていないことに注意してください. サーバーには、SOFTWARE属性も含まれています. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- CreatePermission request ------>|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:0  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- CreatePermission success resp.--|             |             |
    |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
        
次に、クライアントは、アプリケーションデータを送信する準備として、ピアAに対する許可を作成します. これはCreatePermissionリクエストを通じて行われます. XOR-PEER-ADDRESS属性には、許可が確立されているIPアドレス（ピアAのIPアドレス）が含まれます. 属性のポート番号はCreatePermissionリクエストで使用されると無視され、ここでは0に設定されていることに注意してください. また、クライアントがピアAのサーバー再帰IPアドレスを使用し、その（プライベート）ホストアドレスを使用していないことにも注意してください. クライアントは、割り当てに関する前回のリクエストと同じユーザー名、Realm、ノンス値を使用します. 許可されていますが、クライアントはこのリクエストにソフトウェア属性を含めないことを選択しています. 

サーバーはCreatePermissionリクエストを受信し、対応する権限を作成してから、CreatePermission成功レスポンスで応答します. クライアントと同様に、サーバーは応答にSOFTWARE属性を含めないことを選択します. 繰り返しますが、成功応答にはMESSAGE-INTEGRITY属性が含まれていることに注意してください（サーバーが長期資格情報メカニズムを使用していると想定）. ただし、USERNAME、REALM、およびNONCE属性は含まれていません. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- Send indication --------------->|             |             |
    |    Transaction-Id=0x1278E9ACA2711637EF7D3328     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |
    |    DONT-FRAGMENT                   |             |             |
    |    DATA=...                        |             |             |
    |                                    |-- UDP dgm ->|             |
    |                                    |  data=...   |             |
    |                                    |             |             |
    |                                    |<- UDP dgm --|             |
    |                                    |  data=...   |             |
    |<-- Data indication ----------------|             |             |
    |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF     |             |
    |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |
    |    DATA=...                        |             |             |
        
クライアントは、送信表示を使用してアプリケーションデータをピアAに送信します. ピアAのServer-Reflexive Transport AddressはXOR-PEER-ADDRESS属性で指定され、アプリケーションデータ（ここでは単に「...」として示されています）はDATA属性で指定されています. クライアントは、アプリケーション層でパスMTU検出の形式を実行しているため、サーバーがピアに送信するUDPデータグラムのDFビットを設定する必要があることを（DONT-FRAGMENT属性を含めることによって）指定します. STUNの長期資格情報メカニズムを使用して表示を認証することはできないため、メッセージにMESSAGE-INTEGRITY属性は含まれていません. データが変更されたり偽造されたりしないことを保証するアプリケーションは、アプリケーションレベルでデータを整合性保護する必要があります. 

送信指示を受信すると、サーバーはアプリケーションデータを抽出し、UDPデータグラムでピアAに送信します. 中継されたトランスポートアドレスはデータグラムのソーストランスポートアドレスとして、DFビットは要求どおりに設定されています. クライアントが以前にピアAのサーバー再帰IPアドレスのアクセス許可を確立していなかった場合、サーバーは代わりにサイレントに送信指示を破棄することに注意してください. 

次に、ピアAは、アプリケーションデータを含む独自のUDPデータグラムで応答します. データグラムは、サーバー上の中継されたトランスポートアドレスに送信されます. これが到着すると、サーバーは、XOR-PEER-ADDRESS属性のUDPデータグラムのソースとDATA属性のUDPデータグラムからのデータを含むデータ表示を作成します. 次に、結果のデータ表示がクライアントに送信されます. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelBind request ----------->|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    CHANNEL-NUMBER=0x4000           |             |             |
    |    XOR-PEER-ADDRESS=192.0.2.210:49191            |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- ChannelBind success response ---|             |             |
    |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
        
これで、クライアントはチャネルをピアBにバインドし、CHANNEL-NUMBER属性で空きチャネル番号（0x4000）を指定し、XOR-PEER-ADDRESS属性でピアBのトランスポートアドレスを指定します. 以前と同様に、クライアントは、メッセージ内の最後の要求からのユーザー名、Realm、およびナンスを再利用します. 

要求を受信すると、サーバーはチャネル番号をピアにバインドし、ピアBのIPアドレスのアクセス許可をインストールしてから、ChannelBind成功応答を返します. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- ChannelData ------------------->|             |             |
    |    Channel-number=0x4000           |--- UDP datagram --------->|
    |    Data=...                        |    Data=...               |
    |                                    |             |             |
    |                                    |<-- UDP datagram ----------|
    |                                    |    Data=... |             |
    |<-- ChannelData --------------------|             |             |
    |    Channel-number=0x4000           |             |             |
    |    Data=...                        |             |             |
        
これで、クライアントは、ピアB宛てのデータとともにChannelDataメッセージをサーバーに送信します. ChannelDataメッセージはSTUNメッセージではないため、トランザクションIDがありません. 代わりに、チャネル番号、データ、データ長の3つのフィールドしかありません. ここで、チャネル番号フィールドは0x4000（クライアントがピアBにバインドしたばかりのチャネル）です. サーバーはChannelDataメッセージを受信すると、チャネルが現在バインドされている（バインドされている）ことを確認し、リレーされたトランスポートアドレスをソーストランスポートアドレスとして、192.0.2.210を使用して、データをピアBにUDPデータグラムで送信します. 宛先トランスポートアドレスとして49191（ChannelBind要求のXOR-PEER-ADDRESS属性の値）. 

その後、ピアBはUDPデータグラムを中継されたトランスポートアドレスに送り返します. これにより、サーバーは、UDPデータグラムからのデータを含むChannelDataメッセージをクライアントに送信します. サーバーは、UDPデータグラムが到着したrelayed transport addressが原因でChannelDataメッセージを送信するクライアントを認識し、これが192.0.2.210:49191にバインドされているチャネルであるため、チャネル0x4000を使用することを認識しています. そのアドレスにバインドされたチャネル番号がなかった場合、サーバーは代わりにデータ表示を使用したことに注意してください. 

  TURN                                 TURN           Peer          Peer
  client                               server          A             B
    |--- Refresh request --------------->|             |             |
    |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="adl7W7PeDU4hKE72jdaQvbAMcr6h39sm"      |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Refresh error response ---------|             |             |
    |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    ERROR-CODE=438 (Stale Nonce)    |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
    |                                    |             |             |
    |--- Refresh request --------------->|             |             |
    |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
    |    SOFTWARE="Example client 1.03"  |             |             |
    |    USERNAME="George"               |             |             |
    |    REALM="example.com"             |             |             |
    |    NONCE="npSw1Xw239bBwGYhjNWgz2yH47sxB2j"       |             |
    |    MESSAGE-INTEGRITY=...           |             |             |
    |                                    |             |             |
    |<-- Refresh success response -------|             |             |
    |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |
    |    SOFTWARE="Example server, version 1.17"       |             |
    |    LIFETIME=600 (10 minutes)       |             |             |
        
20分のライフタイムがアップする前のある時点で、クライアントは割り当てを更新します. これは、更新要求を使用して行われます. 以前と同様に、クライアントは最新のユーザー名、Realm、ノンス値をリクエストに含めます. クライアントにはSOFTWARE属性も含まれています. この属性は常に、割り当てメッセージと更新メッセージにこの属性を含めることをお勧めします. サーバーは更新要求を受信すると、nonce値が期限切れであることを認識し、新しいnonce値が指定されると438（Stale Nonce）エラーで応答します. 次に、クライアントはリクエストを再試行しますが、今回は新しいnonce値を使用します. この2回目の試行は受け入れられ、サーバーは成功の応答を返します. クライアントがリクエストにLIFETIME属性を含めなかったことに注意してください. 

17.セキュリティに関する考慮事項
このセクションでは、TURN展開で発生する可能性のある攻撃について考察し、プロトコルのメカニズムまたは実装の推奨プラクティスによってそれらがどのように軽減されるかについて説明します. 

TURNへの攻撃のほとんどは、リクエストの認証を要求するサーバーによって軽減されます. したがって、この仕様では認証を使用する必要があります. 必須から実装までのメカニズムは、STUNの長期的な認証メカニズムです. 同等またはより強力なセキュリティプロパティの他の認証メカニズムを使用できます. ただし、それらが相互運用可能な方法で呼び出せることを確認することが重要です. 

17.1. 部外者の攻撃
部外者による攻撃とは、攻撃者がシステムに資格情報を持たず、クライアントまたはサーバーから見たサービスを妨害しようとする攻撃です. 

17.1.1. 不正な割り当ての取得
攻撃者は、悪意のある目的のためにTURNサーバーで割り当てを取得したい場合があります. TURNサーバーは、クライアントの実際のIPアドレスを隠蔽しながらパケットを送受信するメカニズムを提供します. このため、TURNサーバーを使用して本当のIDをマスクする攻撃者にとって魅力的なターゲットになります. 

攻撃者は、TURNサーバーのサービスにお金を払うことなく、単にそれらのサービスを利用したい場合もあります. TURNサービスはプロバイダーからのリソースを必要とするため、その使用にはコストがかかることが予想されます. 

これらの攻撃は、長期の資格情報メカニズムを使用して防止されます. これにより、TURNサーバーはリクエスタのIDと、リクエスタが割り当てを取得できるかどうかを判断できます. 

17.1.2. オフライン辞書攻撃
TURNで使用される長期的な認証メカニズムは、オフラインの辞書攻撃の影響を受けます. クライアントとサーバー間のメッセージ交換を傍受できる攻撃者は、複数の候補パスワードを試し、そのうちの1つが正しいかどうかを確認することにより、パスワードを特定できます. この攻撃は、パスワードが辞書の単語など、エントロピーが低い場合に機能します. この攻撃は、エントロピーが大きい強力なパスワードを使用することで軽減できます. さらに強力な緩和が必要な状況では、クライアントとサーバー間のTLSトランスポートを使用できます. 

17.1.3. 偽の更新と権限
攻撃者は、アクティブな割り当てを削除してクライアントへのサービスを中断させるために、即時の有効期限のあるリフレッシュリクエストを送信してアクティブな割り当てを攻撃する可能性があります. これは、リフレッシュの認証によって防止されます. 同様に、望ましくない宛先へのアクセス許可を作成するためのCreatePermissionリクエストを送信しようとする攻撃者は、認証を介してこれを行うことができません. このような攻撃の動機については、17.2節で説明しています. 

17.1.4. 偽のデータ
攻撃者は、あたかもピアまたはクライアントからデータが送信されたかのように、クライアントまたはピアにデータを送信したい場合があります. そのために、攻撃者はクライアントに偽のデータ表示またはChannelDataメッセージを送信するか、TURNサーバーに偽の送信表示またはChannelDataメッセージを送信できます. 

インジケーションとChannelDataメッセージは認証されないため、この攻撃はTURNによって防止されません. ただし、この攻撃は一般にIPベースの通信に存在し、TURNによって大幅に悪化することはありません. ホストAとB間の通常のTURN以外のIPセッションを考えてみます. 攻撃者は、BのスプーフィングされたIPアドレスを使用してAにパケットを送信することにより、パケットをAから送信されたかのようにBに送信できます.  AおよびBのアドレス. TURNを使用して、データ表示を使用してクライアントにパケットを送信しようとする攻撃者は、そのIPアドレス（およびポート）、TURNサーバーのIPアドレスとポート、およびIPアドレスとポートを知る必要があります. ピア（XOR-PEER-ADDRESS属性に含めるため）. 偽のChannelDataメッセージをクライアントに送信するには、攻撃者はクライアントのIPアドレスとポートを知っている必要があります. TURNサーバーのIPアドレスとポート、およびチャネル番号. この特定の組み合わせは、TURN以外の場合よりも少し推測可能です. 

これらの攻撃は、アプリケーション層の認証技術によってより適切に軽減されます. リアルタイムトラフィックの場合、SRTP [RFC3711]を使用すると、これらの攻撃を防止できます. 

状況によっては、クライアントが直接送信できないホストに送信できるように、TURNサーバーがネットワークに配置されている場合があります. これは、たとえば、サーバーがファイアウォールの背後にあり、ファイアウォールの外側からのパケットをサーバーに配信できるが、ファイアウォールの背後にある他のホストには配信できない場合に発生する可能性があります. これらの状況では、攻撃者は、ファイアウォールの背後にある他のホストの1つのトランスポートアドレスを含むXOR-PEER-ADDRESS属性を含む送信指示をサーバーに送信する可能性があります. サーバーが任意のピアへのトラフィックの中継を許可する場合、これは攻撃者がファイアウォールの背後にある任意のホストを攻撃する方法を提供します. 

この攻撃を緩和するために、TURNでは、クライアントがホストにデータを送信する前に、ホストへの許可を確立する必要があります. したがって、攻撃者が認証されたリクエストを作成できない限り、攻撃者はクライアントがすでに通信しているホストのみを攻撃できます. さらに、サーバー管理者は、サーバーがデータを中継するIPアドレスとポートの範囲を制限するようにサーバーを構成する場合があります. さらに強力なセキュリティを提供するために、サーバー管理者は、クライアントとサーバー間のすべての通信にクライアントがTLSを使用することを要求できます. 

17.1.5. サーバーの偽装
クライアントは、TURNサーバーからリレーされたアドレスを学習すると、アプリケーションプロトコルでそのリレーされたアドレスを使用してトラフィックを受信します. したがって、そのトラフィックを傍受またはリダイレクトしようとする攻撃者は、TURNサーバーになりすまして、偽の中継アドレスをクライアントに提供しようとする可能性があります. 

この攻撃は、サーバーから送信されたものであることを確認することに加えて、応答のメッセージの整合性を提供する長期資格情報メカニズムによって防止されます. さらに、STUNヘッダーのトランザクションIDがこれを防ぐため、攻撃者は古いサーバー応答を再生できません. ナンス値を頻繁に変更することにより、リプレイ攻撃はさらに阻止されます. 

17.1.6. 盗聴トラフィック
TURNは、主に認証とメッセージの整合性に関係しています. TURN制御メッセージには特に機密性の高い情報が含まれていないため、機密性は二次的な問題にすぎません. メッセージの主要なプロトコルコンテンツは、ピアのIPアドレスです. TURN接続の盗聴者がこれを学習しないようにすることが重要な場合は、TLSを介してTURNを実行できます. 

TURN over TLSを実行してもサーバーとピア間のアプリケーションデータは保護されないため、TURNによってリレーされるアプリケーションデータの機密性は、アプリケーションプロトコル自体によって提供されるのが最適です. アプリケーションデータの機密性が重要な場合、アプリケーションはデータを暗号化するか、保護する必要があります. たとえば、リアルタイムメディアの場合、SRTPを使用して機密性を提供できます. 

17.1.7. ターンループ攻撃
攻撃者は、2つのTURNサーバー間でデータパケットを無期限にループさせる可能性があります. 攻撃は次のようになります. まず、攻撃者はサーバーBの送信元アドレスを使用してサーバーAに割り当て要求を送信します. サーバーAはその応答をサーバーBに送信します. 攻撃を成功させるためには、攻撃者はコンテンツを表示または推測できる必要があります. これにより、攻撃者は割り当てられたrelayed transport addressを知ることができます. 次に、攻撃者は、サーバーAのソースアドレスを使用して、割り当て要求をサーバーBに送信します. 攻撃者は、割り当てられたrelayed transport addressを学習できるように、応答の内容を表示または推測できる必要があります. 同じスプーフィングされたソースアドレス技術を使用して、攻撃者はサーバーAのチャネル番号をサーバーBの中継されたトランスポートアドレスにバインドします. 

結果は、サーバーAのリレーされたトランスポートアドレスからサーバーBのリレーされたトランスポートアドレスにループし、次にサーバーBのトランスポートアドレスからサーバーAのトランスポートアドレスにループし、その後再びループするデータパケットです. 

この攻撃は次のように軽減されます. サーバーは、すべてのリクエストの認証を要求したり、リレーされたトランスポートアドレスに割り当てられたポート番号をランダム化したりすることで、攻撃者にサードパーティ（この場合は他のサーバー）に送信された応答を傍受または表示させ、攻撃者は要求を認証し、中継されたトランスポートアドレスを知ることができます. これらの2つの対策のいずれかがなければ、攻撃者は応答を見る必要なく応答の内容を推測できるため、攻撃の実行がはるかに簡単になります. さらに、認証された要求を要求することにより、サーバーは攻撃者にサーバーに受け入れられる資格情報を要求します. これにより、これは部外者の攻撃から内部者の攻撃に変わり、攻撃を開始したクライアントまで追跡できます. 

他の割り当てに対するこの攻撃の影響を制限するために、そのユーザー名が所有する割り当てによってデータを中継するために使用される帯域幅にユーザー名ごとの制限を課すことにより、攻撃をさらに緩和できます. データパケットをリレーするときにTTLをデクリメントすることで、より多くの緩和策を実現で​​きます（基盤となるOSで許可されている場合）. 

17.2. ファイアウォールに関する考慮事項
TURNのセキュリティに関する重要な考慮事項は、クライアントとTURNサーバーの間に配置されたファイアウォールによって提供される保護を弱めるべきではないということです. TURNサーバーは公共のインターネット上に存在することが多く、クライアントは企業のファイアウォールを備えた企業ネットワーク内にあることが予想されます. TURNサーバーが企業に到達するための「バックドア」を提供する場合、TURNはこれらのファイアウォールによってブロックされます. 

したがって、TURNサーバーは、アドレス依存フィルタリング[RFC4787]を実装するNATデバイスの動作をエミュレートします. これは、多くのファイアウォールにも共通のプロパティです. NATまたはファイアウォールがこの動作を実装すると、内部IPアドレスとポートが最近その外部IPアドレスにパケットを送信した場合にのみ、外部IPアドレスからのパケットを内部IPアドレスとポートに送信できます. TURNサーバーでは、許可の概念が導入されています. これにより、TURNサーバーでまったく同じ動作が提供されます. クライアントが攻撃者に最初に連絡を試みない限り、攻撃者はパケットをTURNサーバーに送信して、クライアントに向けて中継されることを期待できません. 

一部のファイアウォールには、アドレス依存のフィルタリングよりもさらに制限の厳しいポリシーがあることに注意することが重要です. ファイアウォールは、アドレスとポートに依存するフィルタリングで構成することも、受信トラフィックを完全に禁止するように構成することもできます. これらの場合、クライアントがTURNサーバーへの接続を許可されていると、クライアントへの通信はファイアウォールが通常許可するものよりも制限が少なくなります. 

17.2.1. 偽の権限
ファイアウォールとNATデバイスでは、ネットワークの内部から外部のピアに向かうパケットの通過を通じて、権限が暗黙的に付与されます. したがって、ファイアウォールまたはNATの内部にあるエンティティを除いて、定義によってアクセス許可を作成することはできません. TURNを使用すると、この制限はなくなります. TURNサーバーはファイアウォールの外側にあるため、ファイアウォールの外側の攻撃者はTURNサーバーにメッセージを送信し、自分自身に権限を作成することができます. 

アクセス許可を作成するすべてのメッセージ（つまり、ChannelBindとCreatePermission）が認証されるため、この攻撃は防止されます. 

17.2.2. ブラックリストに登録されたIPアドレス
多くのファイアウォールには、ファイアウォールの背後にあるクライアントがブラックリストに登録されたIPアドレスの範囲にパケットを送信したり、IPアドレスの範囲からパケットを受信したりできないようにするブラックリストを設定できます. これは、ファイアウォールに出入りするパケットの送信元アドレスと宛先アドレスをそれぞれ検査することによって行われます. 

TURNサーバーはリレー先のピアのアドレスの範囲を任意に制限できるため、この機能はTURNにも存在します. 

17.2.3. 既知のポートでのサーバーの実行
ファイアウォールの背後にある悪意のあるクライアントがTURNサーバーに接続して、サーバーの実行に使用する割り当てを取得しようとする可能性があります. たとえば、クライアントがDNSサーバーまたはFTPサーバーを実行しようとする場合があります. 

これはTURNでは不可能です. TURNサーバーは、クライアントが権限をインストールしていないピアからのトラフィックを決して受け入れません. したがって、ピアはサービスを取得するために割り当てられたポートに接続することはできません. 

17.3. インサイダー攻撃
インサイダー攻撃では、クライアントは正当な資格情報を持っていますが、それらの資格情報に伴う信頼関係を否定します. これらの攻撃は暗号化の手段では防止できませんが、プロトコルの設計で考慮する必要があります. 

17.3.1. TURN Serverに対するDoS
他のクライアントへのサービスを中断したいクライアントは、割り当てを取得し、それをトラフィックでフラッディングして、サーバーを圧迫し、他の正当なクライアントにサービスを提供できないようにする可能性があります. これは、サーバーが特定のユーザー名に対してリレーする帯域幅の量を制限するという推奨事項によって緩和されます. これにより、クライアントが大量のトラフィックを送信するのを防ぐことはできませんが、サーバーは超過したトラフィックをすぐに破棄できます. 

各割り当てはTURNサーバーのIPアドレスのポート番号を使用するため、サーバー上の割り当ての数は有限です. 攻撃者は、大量の割り当てを要求することにより、それらすべてを消費しようとする可能性があります. これは、サーバーが特定のユーザー名に対して一度にアクティブな割り当ての数に制限を課すという推奨事項によって防止されています. 

17.3.2. 悪意のあるトラフィックの匿名中継
TURNサーバーはある程度の匿名化を提供します. クライアントは、自身のIPアドレスを明かさずにデータをピアに送信できます. したがって、TURNサーバーは、攻撃者が検出を恐れずにターゲットに対して攻撃を仕掛けるための魅力的な手段になる可能性があります. 実際、ターゲットがパケットを受信する前に任意の数のリレーを使用できるように、クライアントが複数のTURNサーバーをチェーンすることが可能です. 

この攻撃を心配している管理者は、クライアントの実際のソースIPとポート、さらにはクライアントがインストールするすべての権限をキャプチャしたログを維持できます. これにより、攻撃がTURNサーバーを介して中継されていることが発見された場合に、フォレンジックトレースで元のソースを特定できます. 

17.3.3. その他の割り当ての操作
攻撃者は、（送信元アドレスのスプーフィングによって）TURNサーバーの別のユーザーから送信されているように見えるリフレッシュ要求またはCreatePermission要求を送信することにより、TURNサーバーの他のユーザーへのサービスを妨害しようとする可能性があります. TURNは、CreatePermission、Refresh、およびChannelBindメッセージで使用される資格情報が、初期割り当ての作成に使用される資格情報と一致することを要求することで、これを防ぎます. したがって、攻撃者からの偽のリクエストは拒否されます. 

17.4. その他の考慮事項
Allocate要求によって学習されたリレーアドレスは、トランスポートモードまたはトンネルモードのIPsec認証ヘッダー（AH）[RFC4302]で正しく動作しません. ただし、トンネルモードのIPsecカプセル化セキュリティペイロード（ESP）[RFC4303]は引き続き動作するはずです. 

18. IANAに関する考慮事項
TURNはSTUN [RFC5389]の拡張であるため、この仕様で定義されているメソッド、属性、およびエラーコードは、STUNの新しいメソッド、属性、およびエラーコードです. IANAはこれらの新しいプロトコル要素をSTUNプロトコル要素のIANAレジストリに追加しました. 

この仕様で定義されている新しいSTUNメソッドのコードポイントは、セクション13にリストされています. 

この仕様で定義されている新しいSTUN属性のコードポイントは、セクション14にリストされています. 

この仕様で定義されている新しいSTUNエラーコードのコードポイントは、セクション15にリストされています. 

IANAは、UDPまたはTCPを介したTURNに「turn」というSRVサービス名を割り当て、TLSを介したTURNに「turns」というサービス名を割り当てました. 

IANAはTURNチャネル番号のレジストリを作成し、最初は次のように入力されています. 

0x0000〜0x3FFF：予約済みで、STUNヘッダーと競合するため使用できません. 

0x4000〜0x7FFF：TURN実装は、この範囲のチャネル番号を自由に使用できます. 

0x8000〜0xFFFF：未割り当て. 

このレジストリの変更は、IETF標準アクションを通じて行う必要があります. 

19. IABに関する考慮事項
IABは、クライアントが共同プロトコルリフレクションメカニズムを介してNATの反対側にある別のRealmのアドレスを決定しようとする一般的なプロセスである「片側自己アドレス修正」（UNSAF）の問題を調査しました[RFC3424 ]. TURN拡張は、このタイプの機能を実行するプロトコルの例です. IABは、この目的のために開発されたすべてのプロトコルが特定の一連の考慮事項を文書化することを義務付けています. これらの考慮事項とTURNに対する応答は、このセクションに記載されています. 

考慮事項1：UNSAF提案で解決される特定の範囲限定問題の正確な定義. 短期的な修正は、他の問題を解決するために一般化されるべきではありません. このような一般化は、想定された短期的な修正への長期的な依存と使用につながります. つまり、「短期」と呼ぶのはもはや正確ではありません. 

応答：TURNは、リレー（= TURNサーバー）とそのクライアント間の通信のためのプロトコルです. このプロトコルにより、NATの背後にあるクライアントは、リレー上のパブリックIPアドレスを取得して使用できます. クライアントの利便性として、TURNはクライアントがServer-Reflexive Transport Addressを決定することもできます. 

考慮事項2：出口戦略/移行計画の説明. 適切なテクノロジーが導入されるにつれて、より良い短期的な修正は、当然ながら使用がますます少なくなる修正です. 

応答：NATがなくなると、TURNは不要になります. 残念ながら、このドキュメントの発行日現在、NATがすぐになくなることはほとんどありません. ただし、エンドポイントに依存しないマッピング[RFC4787]のマッピングプロパティを持つNATの数が増えると、TURNの必要性も減少します. 

考慮事項3：システムをより「脆弱」にする可能性のある特定の問題についての議論. たとえば、複数のネットワークレイヤーでデータを使用するアプローチでは、依存関係が増え、デバッグの課題が増え、移行が困難になります. 

応答：TURNは、クライアントとサーバー間のNATバインディングを割り当ての存続期間中、変更せずに維持する必要があるという点で「脆弱」です. これは通常、キープアライブを使用して行われます. これを行わないと、クライアントは割り当てを失い、ピアとデータを交換できなくなります. 

考慮事項4：長期的で健全な技術ソリューションの要件を特定します. 適切な長期的な解決策を見つけるプロセスに貢献する. 

応答：NATが[RFC4787]で文書化されているNAT UDP動作の推奨事項を実装すると、TURNの必要性は減少します. アプリケーションはまた、ICE [RFC5245]を使用してピアと通信することを強くお勧めします. ICEはTURNを使用しますが、これは最後の手段としてのみ使用し、制御された方法で使用します. 

考慮事項5：展開された既存のNATと経験報告で指摘された実際的な問題の影響についての議論. 

応答：現在展開されている一部のNATは、エンドポイントに依存しないマッピング以外のマッピング動作を示します. これらのNATは、ICEなどのプロトコルがこれらのNATでServer-Reflexive Transport Addressを使用することを困難または不可能にするため、操作が困難です. このようなNATの背後にあるクライアントは、「UDPホールパンチング」技術[RFC5128]が機能しないため、TURNのようなリレープロトコルを使用せざるを得ないことがよくあります. 

20.謝辞
著者は、このドキュメントに対する多くのコメントを提供してくれたBEHAVEワーキンググループのさまざまな参加者に感謝します. Marc Petit-Huguenin、Remi Denis-Courmont、Jason Fischl、Derek MacDonald、Scott Godin、Cullen Jennings、Lars Eggert、Magnus Westerlund、Benny Prijono、およびEric Rescorlaが特に役立ち、Ericはチャネル割り当てメカニズムを提案し、Cullenは以前のバージョンのEVEN-PORTメカニズムと、問題を探すための暫定バージョンの実装に何時間も費やすMarc. Christian Huitemaはこのドキュメントの初期の寄稿者であり、最初のいくつかのバージョンの共著者でした. 最後に、作者は、テキストへの彼の貢献と、仕事が行き詰まった後にこの文書の進歩を再開するための彼の大きな助けの両方について、ダン・ウイングに感謝したいと思います. 

21.参考文献
21.1. 規範的な参考文献
[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P. 、およびD. Wing、「Session Traversal Utilities for NAT（STUN）」、RFC 5389、2008年10月. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

[RFC2474] Nichols、K.、Blake、S.、Baker、F. 、およびD. Black、「Definition of the Differentiated Services Field（DS Field）in the IPv4 and IPv6 Headers」、RFC 2474、1998年12月. 

[RFC3168]ラマクリシュナン、K. 、フロイド、S. 、およびD.ブラック、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、2001年9月. 

[RFC1122] Braden、R. 、「インターネットホストの要件-通信層」、STD 3、RFC 1122、1989年10月. 

21.2. 参考情報
[RFC1191] Mogul、J. およびS. Deering、「Path MTU discovery」、RFC 1191、1990年11月. 

[RFC0791] Postel、J. 、「インターネットプロトコル」、STD 5、RFC 791、1981年9月. 

[RFC1918] Rekhter、Y.、Moskowitz、R.、Karrenberg、D.、Groot、G. 、およびE. Lear、「プライベートインターネットのアドレス割り当て」、BCP 5、RFC 1918、1996年2月. 

[RFC3424] Daigle、L. およびIAB、「ネットワークアドレス変換を介したUNilateral Self-Address Fixing（UNSAF）に関するIABの考慮事項」、RFC 3424、2002年11月. 

[RFC4787]オーデットF.およびC.ジェニングス、「ユニキャストUDPのネットワークアドレス変換（NAT）動作要件」、BCP 127、RFC 4787、2007年1月. 

[RFC5245] Rosenberg、J. 、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal for Offer / Answer Protocols」、RFC 5245、2010年4月. 

[TURN-TCP] Perreault、S.およびJ. Rosenberg、「TCP割り当てのためのNAT（TURN）拡張に関するリレーを使用したトラバーサル」、Work in Progress、2010年3月. 

[TURN-IPv6] Perreault、S.、Camarillo、G. 、およびO. Novo、「IPv6のNAT（TURN）拡張に関するリレーを使用したトラバーサル」、Work in Progress、2010年3月. 

[TSVWG-PORT] Larsen、M.、F. Gont、「Port Randomization」、Work in Progress、2010年4月. 

[RFC5128] Srisuresh、P.、Ford、B. 、およびD. Kegel、「State of Peer-to-Peer（P2P）Communication through Network Address Translators（NATs）」、RFC 5128、2008年3月. 

[RFC1928] Leech、M.、Ganis、M.、Lee、Y.、Kuris、R.、Koblas、D. 、およびL. Jones、「SO​​CKS Protocol Version 5」、RFC 1928、1996年3月. 

[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R. 、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、2003年7月. 

[RFC3711]バウアー、M. 、マクルー、D. 、ナスルンド、M. 、カララ、E. 、およびK.ノーマン、「Secure Real-time Transport Protocol（SRTP）」、RFC 3711、2004年3月. 

[RFC4302]ケント、S. 、「IP認証ヘッダー」、RFC 4302、2005年12月. 

[RFC4303]ケント、S. 、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、2005年12月. 

[RFC4821] Mathis、M. およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、2007年3月. 

[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. 、およびE. Schooler、「SIP：Session Initiation Protocol」 、RFC 3261、2002年6月. 

[MMUSIC-ICE-NONSIP] Rosenberg、J. 、「非セッション開始プロトコル（SIP）プロトコルによるインタラクティブ接続確立（ICE）の使用に関するガイドライン」、作業中、2008年7月. 

[RFC4086] Eastlake、D.、Schiller、J. 、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月. 

[フラッグ有害]ケントとモーグル、「フラグメンテーションは有害と見なされる」. 手続き SIGCOMM '87、vol. 17、5、1987年10月

[ポート番号]「IANAポート番号レジストリ」、<http://www.iana.org>. 

[Protocol-Numbers]「IANA Protocol Numbers Registry」、2005、<http://www.iana.org>. 

著者のアドレス

Rohan Mahy無関係

メール：rohan@ekabal.com

Philip Matthews Alcatel-Lucent 600 March Roadオタワオンタリオ州カナダ

メール：philip_matthews@magma.ca

ジョナサン・ローゼンバーグjdrosen.netニュージャージー州モンマス

   メール：jdrosen@jdrosen.net
   URI:   http://www.jdrosen.net
        