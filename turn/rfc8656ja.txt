RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
8656
RFC 8656-NATのリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）
URL：https://tools.ietf.org/html/rfc8656
タイトル：RFC 8656-NATを介したリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）
翻訳編集：自動生成
Internet Engineering Task Force（IETF）T. Reddy、Ed. 
コメントの要求：8656マカフィー
廃止：5766、6156 A. Johnston、Ed. 
カテゴリー：基準はヴィラノヴァ大学を追跡する
ISSN：2070-1721 P.マシューズ
                                                          アルカテルルーセント
                                                            J.ローゼンバーグ
                                                             jdrosen.net
                                                           2020年2月
        
NATのリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）

概要

ホストがNATの背後にある場合、特定の状況では、そのホストが他のホスト（ピア）と直接通信できないことがあります. これらの状況では、ホストが通信リレーとして機能する中間ノードのサービスを使用する必要があります. この仕様では、ホストがリレーの動作を制御し、リレーを使用してピアとパケットを交換できるようにする、「NAT周りのリレーを使用したトラバーサル」（TURN）と呼ばれるプロトコルを定義しています. TURNは、クライアントが単一のリレーアドレスを使用して複数のピアと通信できるという点で、他のリレー制御プロトコルとは異なります. 

TURNプロトコルは、NATトラバーサルへのInteractive Connectivity Establishment（ICE）アプローチの一部として使用するように設計されていますが、ICEなしでも使用できます. 

このドキュメントはRFC 5766および6156を廃止します. 

このメモのステータス

これはInternet Standards Trackドキュメントです. 

このドキュメントは、IETF（Internet Engineering Task Force）の製品です. これは、IETFコミュニティのコンセンサスを表しています. 公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による公開が承認されました. インターネット標準の詳細については、RFC 7841のセクション2を参照してください. 

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8656で入手できます. 

著作権表示

著作権（c）2020 IETFトラストおよびドキュメントの作成者として識別された人物. 全著作権所有. 

この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます. 

目次

   1.  Introduction
   2.  Terminology
   3.  Overview of Operation
     3.1.  Transports
     3.2.  Allocations
     3.3.  Permissions
     3.4.  Send Mechanism
     3.5.  Channels
     3.6.  Unprivileged TURN Servers
     3.7.  Avoiding IP Fragmentation
     3.8.  RTP Support
     3.9.  Happy Eyeballs for TURN
   4.  Discovery of TURN Server
     4.1.  TURN URI Scheme Semantics
   5.  General Behavior
   6.  Allocations
   7.  Creating an Allocation
     7.1.  Sending an Allocate Request
     7.2.  Receiving an Allocate Request
     7.3.  Receiving an Allocate Success Response
     7.4.  Receiving an Allocate Error Response
   8.  Refreshing an Allocation
     8.1.  Sending a Refresh Request
     8.2.  Receiving a Refresh Request
     8.3.  Receiving a Refresh Response
   9.  Permissions
   10. CreatePermission
     10.1.  Forming a CreatePermission Request
     10.2.  Receiving a CreatePermission Request
     10.3.  Receiving a CreatePermission Response
   11. Send and Data Methods
     11.1.  Forming a Send Indication
     11.2.  Receiving a Send Indication
     11.3.  Receiving a UDP Datagram
     11.4.  Receiving a Data Indication
     11.5.  Receiving an ICMP Packet
     11.6.  Receiving a Data Indication with an ICMP Attribute
   12. Channels
     12.1.  Sending a ChannelBind Request
     12.2.  Receiving a ChannelBind Request
     12.3.  Receiving a ChannelBind Response
     12.4.  The ChannelData Message
     12.5.  Sending a ChannelData Message
     12.6.  Receiving a ChannelData Message
     12.7.  Relaying Data from the Peer
   13. Packet Translations
     13.1.  IPv4-to-IPv6 Translations
     13.2.  IPv6-to-IPv6 Translations
     13.3.  IPv6-to-IPv4 Translations
   14. UDP-to-UDP Relay
   15. TCP-to-UDP Relay
   16. UDP-to-TCP Relay
   17. STUN Methods
   18. STUN Attributes
     18.1.  CHANNEL-NUMBER
     18.2.  LIFETIME
     18.3.  XOR-PEER-ADDRESS
     18.4.  DATA
     18.5.  XOR-RELAYED-ADDRESS
     18.6.  REQUESTED-ADDRESS-FAMILY
     18.7.  EVEN-PORT
     18.8.  REQUESTED-TRANSPORT
     18.9.  DONT-FRAGMENT
     18.10. RESERVATION-TOKEN
     18.11. ADDITIONAL-ADDRESS-FAMILY
     18.12. ADDRESS-ERROR-CODE
     18.13. ICMP
   19. STUN Error Response Codes
   20. Detailed Example
   21. Security Considerations
     21.1.  Outsider Attacks
       21.1.1.  Obtaining Unauthorized Allocations
       21.1.2.  Offline Dictionary Attacks
       21.1.3.  Faked Refreshes and Permissions
       21.1.4.  Fake Data
       21.1.5.  Impersonating a Server
       21.1.6.  Eavesdropping Traffic
       21.1.7.  TURN Loop Attack
     21.2.  Firewall Considerations
       21.2.1.  Faked Permissions
       21.2.2.  Blacklisted IP Addresses
       21.2.3.  Running Servers on Well-Known Ports
     21.3.  Insider Attacks
       21.3.1.  DoS against TURN Server
       21.3.2.  Anonymous Relaying of Malicious Traffic
       21.3.3.  Manipulating Other Allocations
     21.4.  Tunnel Amplification Attack
     21.5.  Other Considerations
   22. IANA Considerations
   23. IAB Considerations
   24. Changes since RFC 5766
   25. Updates to RFC 6156
   26. References
     26.1.  Normative References
     26.2.  Informative References
   Acknowledgements
   Authors' Addresses

1.はじめに
NATの背後にあるホストは、他のホストとパケットを交換したい場合があります. その一部はNATの背後にある場合もあります. これを行うために、関与するホストは、直接の通信パスを発見するために「ホールパンチング」技術（[RFC5128]を参照）を使用できます. つまり、あるホストから別のホストへ、NATやルーターが介在して通過するが、リレーを経由しない通信パスです. 

[RFC5128]と[RFC4787]で説明されているように、両方のホストが正常に動作しないNATの背後にある場合、ホールパンチテクニックは失敗します. たとえば、両方のホストが「アドレス依存マッピング」または「アドレスおよびポート依存マッピング」（[RFC4787]のセクション4.1を参照）のマッピング動作を持つNATの背後にある場合、一般にホールパンチテクニックは失敗します. 

直接通信経路が見つからない場合は、パケットの中継となる中間ホストのサービスを利用する必要があります. このリレーは通常、パブリックインターネットにあり、NATの背後にある2つのホスト間でパケットをリレーします. 

多くの企業ネットワークでは、内部ネットワーク上のクライアントと外部IPアドレス間の直接UDP伝送は許可されていません. このような状況でメディアセッションがUDPを使用することを許可し、TCPによる強制を回避するために、エンタープライズファイアウォールを構成して、エンタープライズリレーサーバーを介してリレーされるUDPトラフィックを許可できます. WebRTCはこのシナリオのサポートを必要とします（[RFC7478]のセクション2.3.5.1を参照）. SIPまたはWebRTCの一部のユーザーは、リモートピアからのIPロケーションプライバシーを求めています. このシナリオでは、クライアントはIPロケーションプライバシーを提供するリレーサーバーを選択し、リレーされた候補のみをICE接続チェックのピアに伝達できます（[SEC-WEBRTC]のセクション4.2.4を参照）. 

この仕様は、「TURN」と呼ばれるプロトコルを定義します. これにより、NATの背後にあるホスト（「TURNクライアント」と呼ばれる）が、別のホスト（「TURNサーバー」と呼ばれる）がリレーとして機能することを要求できます. クライアントは、サーバーが他の特定のホスト（「ピア」と呼ばれる）との間でパケットをリレーするように設定でき、クライアントは、リレーの実行方法を制御できます. クライアントは、「Relayed Transport Address」と呼ばれるサーバー上のIPアドレスとポートを取得することによってこれを行います. ピアがRelayed Transport Addressにパケットを送信すると、サーバーはトランスポートプロトコルデータをパケットからクライアントにリレーします. クライアントがトランスポートプロトコルデータがサーバーによって中継されたピアを知ることを可能にするメッセージヘッダー内にカプセル化されたデータ. サーバーがICMPエラーパケットを受信した場合、サーバーは、ICMPヘッダーからクライアントに特定のレイヤー3および4ヘッダーフィールドもリレーします. クライアントがサーバーにメッセージを送信すると、サーバーはメッセージヘッダーからリモートピアを識別し、メッセージデータを目的のピアに中継します. 

TURNを使用するクライアントは、Relayed Transport Addressをピアに伝達し、各ピアのIPアドレスとポート（より正確には、各ピアのServer-Reflexive Transport Address. セクション3を参照）を学習する何らかの方法が必要です. これがどのように行われるかは、TURNプロトコルの範囲外です. これを行う方法の1つは、クライアントとピアが電子メールメッセージを交換することです. 別の方法は、クライアントとそのピアが特別な目的の「導入」または「ランデブー」プロトコルを使用することです（詳細については、[RFC5128]を参照してください）. 

TURNがICE [RFC8445]で使用される場合、中継されたトランスポートアドレスとピアのIPアドレスとポートは、ランデブープロトコルが運ぶ必要のあるICE候補情報に含まれます. たとえば、SIPを使用するマルチメディアソリューションの一部としてTURNとICEを使用する場合[RFC3261]、SIPはランデブープロトコルの役割を果たし、SIPメッセージの本体[SDP-ICE]内にICE候補情報を伝達します. TURNおよびICEが他のランデブープロトコルで使用される場合、ICEはランデブープロトコルが実行する必要のあるサービスに関するガイダンスを提供します. 

TURNサーバーを使用してNATの背後にある2つのホスト間の通信を可能にすることは非常に可能性が高いですが、サーバーは通常インターネットへの広帯域接続を必要とするため、TURNサーバーのプロバイダーにとっては高コストになります. その結果、直接通信パスが見つからない場合にのみ、TURNサーバーを使用することをお勧めします. クライアントとピアがICEを使用して通信パスを決定する場合、ICEはホールパンチテクニックを使用して直接パスを最初に検索し、直接パスが見つからない場合にのみTURNサーバーを使用します. 

TURNは当初、SIPを使用してシグナリングされるマルチメディアセッションをサポートするために発明されました. SIPはフォーキングをサポートしているため、TURNはRelayed Transport Addressごとに複数のピアをサポートします. 他のアプローチ（例えば、SOCKS [RFC1928]）でサポートされていない機能. ただし、TURNが他のタイプのアプリケーションに適していることを確認するように注意が払われています. 

TURNは、NATトラバーサルへのより大きなICEアプローチの一部として設計されました. TURNの実装者は、ICEを調査し、アプリケーションへの使用を真剣に検討することをお勧めします. ただし、ICEなしでTURNを使用することは可能です. 

TURNは、NAT（STUN）プロトコル[RFC8489]のセッショントラバーサルユーティリティの拡張機能です. すべてではありませんが、ほとんどのTURNメッセージはSTUN形式のメッセージです. このドキュメントの読者は、STUNに精通している必要があります. 

TURN仕様は、元々[RFC5766]として公開され、IPv6サポートを追加するために[RFC6156]によって更新されました. このドキュメントは、[RFC5766]と[RFC6156]の両方に取って代わり、廃止されます. 

2.用語
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます. 

読者は[RFC8489]とそこで定義されている用語に精通していることが期待されます. 

このドキュメントでは、次の用語が使用されています. 

TURN：TURNクライアントとTURNサーバーの間で使用されるプロトコル. これは、STUNプロトコル[RFC8489]の拡張機能です. このプロトコルにより、クライアントはRelayed Transport AddressをAllocationて使用できます. 

TURNクライアント：この仕様を実装するSTUNクライアント. 

TURNサーバー：この仕様を実装するSTUNサーバー. TURNクライアントとそのピアの間でデータを中継します. 

ピア：TURNクライアントが通信したいホスト. TURNサーバーは、TURNクライアントとそのピア間のトラフィックを中継します. ピアは、このドキュメントで定義されているプロトコルを使用してTURNサーバーと対話しません. むしろ、ピアはTURNサーバーから送信されたデータを受信し、ピアはTURNサーバーにデータを送信します. 

トランスポートアドレス：IPアドレスとポートの組み合わせ. 

ホストトランスポートアドレス：クライアントまたはピアのトランスポートアドレス. 

Server-Reflexive Transport Address：NATの「外部側」のトランスポートアドレス. このアドレスは、特定のホストトランスポートアドレスに対応するようにNATによってAllocationられます. 

Relayed Transport Address：クライアントとピア間でパケットをリレーするために使用されるTURNサーバー上のトランスポートアドレス. ピアがTURNサーバーのこのアドレスに送信すると、パケットはクライアントに中継されます. 

TURNサーバートランスポートアドレス：TURNメッセージをサーバーに送信するために使用されるTURNサーバー上のトランスポートアドレス. これは、クライアントがサーバーとの通信に使用するトランスポートアドレスです. 

ピアトランスポートアドレス：サーバーから見たピアのトランスポートアドレス. ピアがNATの背後にある場合、これはピアのServer-Reflexive Transport Addressです. 

Allocation：Allocation要求を通じてクライアントに許可された中継トランスポートアドレスと、アクセス許可や有効期限タイマーなどの関連する状態. 

5タプル：クライアントとサーバー間の通信に使用される組み合わせ（クライアントIPアドレスとポート、サーバーIPアドレスとポート、およびトランスポートプロトコル（現在はUDP、TCP、DTLS / UDP、またはTLS / TCPの1つ））. 5タプルは、この通信ストリームを一意に識別します. 5タプルは、サーバー上のAllocationも一意に識別します. 

トランスポートプロトコル：IP上のプロトコルで、TURNリクエスト、レスポンス、インジケーションを伝達し、5タプルを使用して識別可能なフローを提供します. この仕様では、UDPおよびTCPがトランスポートプロトコルとして定義されています. このドキュメントでは、DTLSとTLSをそれぞれ使用するセキュリティレイヤーと組み合わせたUDPとTCPの使用についても説明しています. 

チャネル：チャネル番号および関連するピアトランスポートアドレス. チャネル番号がピアのトランスポートアドレスにバインドされると、クライアントとサーバーは、より帯域幅効率の高いChannelDataメッセージを使用してデータを交換できます. 

許可：トラフィックをTURN Serverに送信し、そのトラフィックをTURNクライアントにリレーすることを許可されているピアのIPアドレスとトランスポートプロトコル（ポートは除く）. TURNサーバーは、既存の権限に一致するピアからのトラフィックのみをクライアントに転送します. 

Realm：サーバーまたはサーバー内のコンテキストを説明するために使用される文字列. Realmは、要求の認証に使用するユーザー名とパスワードの組み合わせをクライアントに通知します. 

Nonce：サーバーによってランダムに選択され、サーバーの応答に含まれる文字列. リプレイ攻撃を防ぐために、サーバーはナンスを定期的に変更する必要があります. 

（D）TLS：この用語は、トランスポート層セキュリティ[RFC8446]とデータグラムトランスポート層セキュリティ[RFC6347]の両方に適用されるステートメントに使用されます. 

3.運用の概要
このセクションでは、TURNの操作の概要について説明します. それは非規範的です. 

一般的な構成では、TURNクライアントはプライベートネットワーク[RFC1918]に接続され、1つ以上のNATを介してパブリックインターネットに接続されます. 公共のインターネットにはTURNサーバーがあります. インターネットの他の場所には、TURNクライアントが通信することを希望する1つ以上のピアがあります. これらのピアは、1つ以上のNATの背後にある場合とそうでない場合があります. クライアントはサーバーをリレーとして使用して、これらのピアにパケットを送信し、これらのピアからパケットを受信します. 

                                       Peer A
                                       Server-Reflexive    +---------+
                                       Transport Address   |         |
                                       192.0.2.150:32102   |         |
                                           |              /|         |
                         TURN              |            / ^|  Peer A |
      Client's           Server            |           /  ||         |
      Host Transport     Transport         |         //   ||         |
      Address            Address           |       //     |+---------+
   198.51.100.2:49721  192.0.2.15:3478     |+-+  //     Peer A
              |            |               ||N| /       Host Transport
              |   +-+      |               ||A|/        Address
              |   | |      |               v|T|     203.0.113.2:49582
              |   | |      |               /+-+
   +---------+|   | |      |+---------+   /              +---------+
   |         ||   |N|      ||         | //               |         |
   | TURN    |v   | |      v| TURN    |/                 |         |
   | Client  |----|A|-------| Server  |------------------|  Peer B |
   |         |    | |^      |         |^                ^|         |
   |         |    |T||      |         ||                ||         |
   +---------+    | ||      +---------+|                |+---------+
                  | ||                 |                |
                  | ||                 |                |
                  +-+|                 |                |
                     |                 |                |
                     |                 |                |
            Client's                   |             Peer B
            Server-Reflexive     Relayed             Transport
            Transport Address    Transport Address   Address
            192.0.2.1:7000       192.0.2.15:50000    192.0.2.210:49191
        
図1

図1は、一般的な配置を示しています. この図では、TURNクライアントとTURNサーバーはNATによって分離されており、クライアントはプライベート側にあり、サーバーはNATのパブリック側にあります. このNATは「悪い」NATであると想定されています. たとえば、「アドレスとポートに依存するマッピング」のマッピングプロパティがある場合があります（[RFC4787]を参照）. 

クライアントは、クライアントの「ホストトランスポートアドレス」と呼ばれる（IPアドレス、ポート）の組み合わせからサーバーと通信します. （IPアドレスとポートの組み合わせを「トランスポートアドレス」と呼びます. ）

クライアントは、ホストトランスポートアドレスから「TURNサーバートランスポートアドレス」と呼ばれるTURNサーバー上のトランスポートアドレスにTURNメッセージを送信します. クライアントは、不特定の手段（構成など）を介してTURNサーバーのトランスポートアドレスを学習します. このアドレスは通常、多くのクライアントによって同時に使用されます. 

クライアントはNATの背後にあるため、サーバーはクライアントからのパケットを、NAT自体のトランスポートアドレスから送信されたものと見なします. このアドレスは、クライアントの「Server-Reflexive Transport Address」と呼ばれます. サーバーからクライアントのServer-Reflexive Transport Addressに送信されたパケットは、NATによってクライアントのホストトランスポートアドレスに転送されます. 

クライアントはTURNコマンドを使用して、サーバー上でALLOCATIONを作成および操作します. Allocationは、サーバー上のデータ構造です. このデータ構造には、とりわけ、Allocation用の中継されたトランスポートアドレスが含まれます. Relayed Transport Addressは、ピアがサーバーにデータをクライアントにリレーさせるために使用できるサーバー上のトランスポートアドレスです. Allocationは、中継されたトランスポートアドレスによって一意に識別されます. 

Allocationが作成されると、クライアントはアプリケーションデータをサーバーに送信し、どのピアにデータを送信するかを示すことができます. サーバーはこのデータを目的のピアに中継します. クライアントはTURNメッセージ内でアプリケーションデータをサーバーに送信します. サーバーでは、TURNメッセージからデータが抽出され、UDPデータグラムでピアに送信されます. 逆方向では、ピアは、アプリケーションデータをUDPデータグラムで、Allocationのために中継されたトランスポートアドレスに送信できます. 次に、サーバーはこのデータをTURNメッセージ内にカプセル化し、どのピアがデータを送信したかを示すとともにクライアントに送信します. TURNメッセージには常にクライアントが通信しているピアの指示が含まれているため、クライアントは単一のAllocationを使用して複数のピアと通信できます. 

ピアがNATの背後にある場合、クライアントは、ホストトランスポートアドレスではなくServer-Reflexive Transport Addressを使用してピアを識別する必要があります. たとえば、上記の例でアプリケーションデータをピアAに送信するには、クライアントは203.0.113.2:49582（ピアAのホストトランスポートアドレス）ではなく192.0.2.150:32102（ピアAのServer-Reflexive Transport Address）を指定する必要があります. 

サーバー上の各Allocationは1つのクライアントに属し、そのAllocationでのみ使用される1つまたは2つの中継トランスポートアドレスを持っています. したがって、パケットがサーバー上の中継されたトランスポートアドレスに到着すると、サーバーはデータの対象となるクライアントを認識します. 

クライアントは、サーバー上で同時に複数のAllocationを持つ場合があります. 

3.1.  Transports
この仕様で定義されているTURNは、サーバーとピアの間で常にUDPを使用します. ただし、この仕様では、UDP、TCP、TCP上のトランスポート層セキュリティ（TLS）、またはUDP上のデータグラムトランスポート層セキュリティ（DTLS）のいずれかを使用して、クライアントとサーバー間でTURNメッセージを伝送できます. 

           +----------------------------+---------------------+
           | TURN client to TURN server | TURN server to peer |
           +============================+=====================+
           |            UDP             |         UDP         |
           +----------------------------+---------------------+
           |            TCP             |         UDP         |
           +----------------------------+---------------------+
           |        TLS-over-TCP        |         UDP         |
           +----------------------------+---------------------+
           |       DTLS-over-UDP        |         UDP         |
           +----------------------------+---------------------+
        
表1

クライアントとサーバーの間でTCPまたはTLS-over-TCPが使用されている場合、サーバーは、ピアとの間でデータを中継するときに、これらのトランスポートとUDPトランスポートの間で変換します. 

このバージョンのTURNはサーバーとピアの間のUDPのみをサポートしているため、ほとんどのクライアントはクライアントとサーバーの間でもUDPを使用することを好むと予想されます. そのため、一部の読者は疑問に思うかもしれません：なぜTCPとTLS-over-TCPもサポートするのですか？

一部のファイアウォールはUDPを完全にブロックするように構成されているため、TURNはクライアントとサーバー間のTCPトランスポートをサポートします. これらのファイアウォールはUDPをブロックしますが、TCPはブロックしません. これは、TCPには、ファイアウォールによって保護されているノードの意図をファイアウォールにわかりやすくするプロパティがあるためです. たとえば、TCPには3方向のハンドシェイクがあり、保護されたノードがその特定の接続を本当に確立したいと望んでいることが明確になりますが、UDPの場合、ファイアウォールが実行できる最善の方法は、フィルタリングルールを使用してどのフローが望ましいかを推測することです. また、TCPには明示的な接続ティアダウンがあります. 一方、UDPの場合、ファイアウォールはタイマーを使用してフローがいつ終了するかを推測する必要があります. 

TURNは、クライアントとサーバー間のTLS-over-TCPトランスポートとDTLS-over-UDPトランスポートをサポートします. これは、（D）TLSが、TURNのデフォルトのダイジェスト認証では提供されない追加のセキュリティプロパティを提供するためです. 特に、（D）TLSは、クライアントが正しいサーバーと通信していることを確認する方法を提供し、TURN制御メッセージの機密性を提供します. （D）TLSトランスポートがTURNクライアントとTURNサーバー間で使用される場合、暗号スイート、サーバー証明書の検証、およびTURNサーバーの認証の詳細については、[RFC8489]のセクション6.2.3を参照してください. （D）TLSへの攻撃を回避するために、[RFC7525]で提供されるガイダンスに従う必要があります. （D）TLSを使用するオーバーヘッドはダイジェスト認証のオーバーヘッドよりも高いため、TURNは（D）TLSを必要としません. 例えば、

サーバーとピア[RFC6062]の間のTCPトランスポートのTURNへの拡張があります. このため、サーバーとピア間でUDPを使用するAllocationは「UDPAllocation」と呼ばれ、サーバーとピア間でTCPを使用するAllocationは「TCPAllocation」と呼ばれます. この仕様では、UDPAllocationについてのみ説明しています. 

TURNの一部のアプリケーションでは、クライアントは、サーバーとの通信に使用するホストトランスポートアドレスでTURNパケット以外のパケットを送受信する場合があります. これは、ICEでTURNを使用する場合などに発生します. このような場合、クライアントは、到着するパケットの送信元アドレスを調べることにより、TURNパケットを他のパケットと区別できます. TURNサーバーから到着するものはTURNパケットです. ホストトランスポートアドレス上の複数のプロトコルから受信したパケットを逆多重化するアルゴリズムについては、[RFC7983]で説明されています. 

3.2. Allocation
サーバーでAllocationを作成するために、クライアントはAllocateトランザクションを使用します. クライアントはサーバーにAllocation要求を送信し、サーバーはAllocationされた中継トランスポートアドレスを含むAllocation成功応答で応答します. クライアントは、必要なAllocationのタイプ（たとえば、Allocationの有効期間）を記述する属性をAllocateリクエストに含めることができます. データの中継にはセキュリティの影響があるため、サーバーは、クライアントがサーバーを使用することを承認されていることを示すために、通常はSTUNの長期資格情報メカニズムまたはSTUN Extension for Third-Party Authorization [RFC7635]を使用してクライアント自体を認証する必要があります. 

Relayed Transport AddressがAllocationされると、クライアントはAllocationを有効に保つ必要があります. これを行うために、クライアントは定期的にサーバーに更新要求を送信します. TURNは、リフレッシュのために意図的に別のメソッド（AllocateではなくRefresh）を使用して、何らかの理由でAllocationが消えた場合にクライアントに通知されるようにします. 

更新トランザクションの頻度は、Allocationの有効期間によって決まります. Allocationのデフォルトのライフタイムは10分です. この値は、クライアントがタイムリーに予期せず終了したAllocationを期限切れにするときに、更新がクライアントに通常負担をかけないように、十分に長くなるように選択されました. ただし、クライアントはAllocateリクエストでより長いライフタイムをリクエストでき、Refreshリクエストでそのリクエストを変更でき、サーバーは常にレスポンスで実際のライフタイムを示します. クライアントは、前のAllocationまたはリフレッシュトランザクションの「ライフタイム」秒以内に新しいリフレッシュトランザクションを発行する必要があります. クライアントがAllocationを使用する必要がなくなったら、リクエストされたライフタイムがゼロのリフレッシュ要求を使用してAllocationを削除する必要があります. 

サーバーとクライアントの両方が、「5タプル」と呼ばれる値を追跡します. クライアントでは、5タプルはクライアントのホストトランスポートアドレス、サーバートランスポートアドレス、およびサーバーと通信するためにクライアントが使用するトランスポートプロトコルで構成されます. サーバーでは、5タプルの値は同じですが、クライアントのホストトランスポートアドレスが、サーバーから見たクライアントのアドレスであるため、クライアントのサーバー再帰アドレスに置き換えられます. 

クライアントとサーバーの両方が、Allocation要求で使用された5タプルを記憶しています. クライアントとサーバー間の後続のメッセージは、同じ5タプルを使用します. このようにして、クライアントとサーバーは、どのAllocationが参照されているかを認識します. クライアントが2番目の中継トランスポートアドレスをAllocationる場合は、別の5タプルを使用して（たとえば、別のクライアントホストアドレスまたはポートを使用して）2番目のAllocationを作成する必要があります. 

| 注：このドキュメントで使用されている用語は| 5タプルの場合、TURNサーバーはIDを保存できます. 同じ結果が得られることが好きです. 具体的には、| 実装では、5タプルの代わりにファイル記述子を使用できます. TCP接続を表します. 

   TURN                                 TURN          Peer         Peer
   client                               server         A            B
     |-- Allocate request --------------->|            |            |
     |   (invalid or missing credentials) |            |            |
     |                                    |            |            |
     |<--------------- Allocate failure --|            |            |
     |              (401 Unauthenticated) |            |            |
     |                                    |            |            |
     |-- Allocate request --------------->|            |            |
     |               (valid credentials)  |            |            |
     |                                    |            |            |
     |<---------- Allocate success resp --|            |            |
     |            (192.0.2.15:50000)      |            |            |
     //                                   //           //           //
     |                                    |            |            |
     |-- Refresh request ---------------->|            |            |
     |                                    |            |            |
     |<----------- Refresh success resp --|            |            |
     |                                    |            |            |
        
図2

図2では、クライアントは、無効なまたは欠落している資格情報を使用してサーバーにAllocation要求を送信します. サーバーはすべての要求がSTUNの長期資格情報メカニズムを使用して認証されることを要求するため、サーバーは401（無許可）エラーコードで要求を拒否します. 次に、クライアントは再試行しますが、今回は資格情報を含めます. 今回は、サーバーがAllocation要求を受け入れ、AllocationにAllocationられた中継トランスポートアドレスを（とりわけ）含むAllocation成功応答を返します. しばらくして、クライアントはAllocationを更新することを決定します. したがって、サーバーに更新要求を送信します. 更新が受け入れられ、サーバーは更新成功応答を返します. 

3.3. 許可
TURNを使用して企業のファイアウォールセキュリティを回避できるという企業のIT管理者の間の懸念を軽減するために、TURNには権限の概念が含まれています. TURNアクセス許可は、[RFC4787]に準拠するNATのアドレス制限されたフィルタリングメカニズムを模倣します. 

Allocationには0個以上のアクセス許可を設定できます. 各権限は、IPアドレスとライフタイムで構成されます. サーバーは、Allocationの中継トランスポートアドレスでUDPデータグラムを受信すると、最初にアクセス許可のリストを確認します. データグラムのソースIPアドレスが許可と一致する場合、アプリケーションデータはクライアントにリレーされます. それ以外の場合、UDPデータグラムは通知なく破棄されます. 

更新されない場合、権限は5分後に期限切れになり、権限を明示的に削除する方法はありません. この動作は、[RFC4787]に準拠するNATの動作と一致するように選択されました. 

クライアントは、CreatePermissionリクエストまたはChannelBindリクエストを使用して、権限をインストールまたは更新できます. CreatePermissionリクエストを使用すると、1つのリクエストで複数の権限をインストールまたは更新できます. これは、ICEを使用するアプリケーションにとって重要です. セキュリティ上の理由から、アクセス許可は、認証可能なトランザクションによってのみインストールまたは更新できます. したがって、送信表示とChannelDataメッセージ（ピアにデータを送信するために使用される）は、権限をインストールまたは更新しません. 

権限はAllocationのコンテキスト内にあるため、1つのAllocationで権限を追加または期限切れにしても、他のAllocationには影響しません. 

3.4. 送信メカニズム
クライアントとピアがTURNサーバーを使用してアプリケーションデータを交換するメカニズムは2つあります. 最初のメカニズムはSendメソッドとDataメソッドを使用し、2番目のメカニズムはチャネルを使用します. 両方のメカニズムに共通するのは、Allocationられた単一の中継トランスポートアドレスを使用して複数のピアと通信するクライアントの機能です. したがって、両方のメカニズムには、クライアントがサーバーにどのピアがデータを受信する必要があるかを示す手段と、サーバーがクライアントにどのピアがデータを送信したかを示す手段が含まれています. 

送信メカニズムは、送信およびデータ表示を使用します. 送信表示は、アプリケーションデータをクライアントからサーバーに送信するために使用され、データ表示は、アプリケーションデータをサーバーからクライアントに送信するために使用されます. 

送信メカニズムを使用する場合、クライアントは（a）ピアの（サーバー再帰）トランスポートアドレスを指定するXOR-PEER-ADDRESS属性と（b）アプリケーションデータを保持するDATA属性を含む送信指示をTURNサーバーに送信します.  . TURNサーバーは送信指示を受信すると、DATA属性からアプリケーションデータを抽出し、Allocationられたリレーアドレスをソースアドレスとして使用して、UDPデータグラムでピアに送信します. Relayed Transport Addressを指定する必要がないことに注意してください. これは、送信表示に使用される5タプルによって暗黙的に指定されるためです. 

逆方向では、TURNサーバー上のRelayed Transport Addressに到着するUDPデータグラムがデータ表示に変換され、クライアントに送信されます. ピアのServer-Reflexive Transport AddressはXOR-PEER-ADDRESS属性とデータに含まれますそれ自体はDATA属性にあります. Relayed Transport AddressはAllocationを一意に識別したため、サーバーはどのクライアントがデータを受信する必要があるかを認識しています. 

TURNサーバーの中継トランスポートアドレスに到着する一部のICMP（インターネット制御メッセージプロトコル）パケットは、データの表示に変換され、クライアントに送信されます. ピアのトランスポートアドレスは、XOR-PEER-ADDRESS属性とICMPに含まれていますICMP属性のタイプとコード. ICMP属性転送では、チャネルメカニズムを使用してUDPデータを転送する場合でも、常にXOR-PEER-ADDRESSおよびICMP属性を含むデータ表示が使用されます. 

STUNの長期クレデンシャルメカニズムは認証表示をサポートしていないため、送信およびデータ表示は認証できません. クライアントからサーバーへのレッグはピアへの合計パスの半分に過ぎないため、これは最初に現れるほど大きな問題ではありません. エンドツーエンドのセキュリティを必要とするアプリケーションは、クライアントとピアの間で送信されるデータを暗号化する必要があります. 

送信表示は認証されないため、攻撃者が偽の送信表示をサーバーに送信し、サーバーがこれらをピアに中継する可能性があります. この攻撃を部分的に緩和するために、TURNでは、クライアントが送信指示を使用してピアにデータを送信する前に、ピアに対する許可をインストールする必要があります. 攻撃を完全に軽減する手法については、セクション21.1.4で説明します. 

   TURN                                TURN           Peer          Peer
   client                              server          A             B
     |                                   |             |             |
     |-- CreatePermission req (Peer A) ->|             |             |
     |<- CreatePermission success resp --|             |             |
     |                                   |             |             |
     |--- Send ind (Peer A)------------->|             |             |
     |                                   |=== data ===>|             |
     |                                   |             |             |
     |                                   |<== data ====|             |
     |<------------- Data ind (Peer A) --|             |             |
     |                                   |             |             |
     |                                   |             |             |
     |--- Send ind (Peer B)------------->|             |             |
     |                                   | dropped     |             |
     |                                   |             |             |
     |                                   |<== data ==================|
     |                           dropped |             |             |
     |                                   |             |             |
        
図3

図3では、クライアントはすでにAllocationを作成しており、ピアにデータを送信しようとしています. クライアントは最初に、XOR-PEER-ADDRESS属性でピアA（サーバー再帰）のIPアドレスを指定するCreatePermissionリクエストをサーバーに送信することにより、権限を作成します. これを行わないと、サーバーはクライアントとサーバーの間でデータを中継しません. 次に、クライアントは送信指示を使用してピアAにデータを送信します. サーバーでは、アプリケーションデータが抽出され、Relayed Transport Addressをソーストランスポートアドレスとして使用して、UDPデータグラムでピアAに転送されます. ピアAからのUDPデータグラムがRelayed Transport Addressで受信されると、コンテンツはデータ表示に配置され、クライアントに転送されます. その後、クライアントはピアBとデータを交換しようとします. ただし、ピアBには権限がインストールされていません. 

3.5. チャンネル
一部のアプリケーション（Voi​​ce over IP（VoIP）など）では、送信表示またはデータ表示がアプリケーションデータに追加する36バイトのオーバーヘッドにより、クライアントとサーバー間で必要な帯域幅を大幅に増やすことができます. これを解決するために、TURNは、クライアントとサーバーがデータを特定のピアに関連付けるための2番目の方法を提供します. 

この2番目の方法は、「ChannelDataメッセージ」と呼ばれる代替パケット形式を使用します. ChannelDataメッセージは、他のTURNメッセージで使用されるSTUNヘッダーを使用しませんが、「チャネル番号」と呼ばれる番号を含む4バイトのヘッダーを持っています. 使用中の各チャネル番号は特定のピアにバインドされています. したがって、ピアのホストトランスポートアドレスの省略形として機能します. 

チャネルをピアにバインドするには、クライアントがChannelBind要求をサーバーに送信し、バインドされていないチャネル番号とピアのトランスポートアドレスを含めます. チャネルがバインドされると、クライアントはChannelDataメッセージを使用して、ピア宛のサーバーデータを送信できます. 同様に、サーバーはChannelDataメッセージを使用して、そのピアからクライアントに向けてデータを中継できます. 

更新されない限り、チャネルバインディングは10分間持続します. この存続期間は、許可の存続期間よりも長くなるように選択されました. チャネルバインディングは、チャネルに再バインドする別のChannelBind要求をピアに送信することによって更新されます. アクセス許可と同様（ただし、Allocationとは異なります）、チャネルバインディングを明示的に削除する方法はありません. クライアントは単にタイムアウトするまで待つ必要があります. 

   TURN                                TURN           Peer          Peer
   client                              server          A             B
     |                                   |             |             |
     |-- ChannelBind req --------------->|             |             |
     | (Peer A to 0x4001)                |             |             |
     |                                   |             |             |
     |<---------- ChannelBind succ resp -|             |             |
     |                                   |             |             |
     |-- (0x4001) data ----------------->|             |             |
     |                                   |=== data ===>|             |
     |                                   |             |             |
     |                                   |<== data ====|             |
     |<------------------ (0x4001) data -|             |             |
     |                                   |             |             |
     |--- Send ind (Peer A)------------->|             |             |
     |                                   |=== data ===>|             |
     |                                   |             |             |
     |                                   |<== data ====|             |
     |<------------------ (0x4001) data -|             |             |
     |                                   |             |             |
        
図4

図4は、使用中のチャネルメカニズムを示しています. クライアントは既にAllocationを作成しており、チャネルをピアAにバインドしようとしています. これを行うために、クライアントはサーバーにChannelBind要求を送信し、ピアAのトランスポートアドレスとチャネル番号（0x4001）を指定します. その後、クライアントはChannelDataメッセージ内にカプセル化されたアプリケーションデータをピアAに送信できます. これは「（0x4001）データ」として示されます. 0x4001はチャネル番号です. ChannelDataメッセージがサーバーに到着すると、サーバーはデータをUDPデータグラムに転送し、ピアA（チャネル番号0x4001にバインドされているピア）に送信します. 

逆方向では、ピアAがUDPデータグラムを中継トランスポートアドレスに送信すると、このUDPデータグラムは、AllocationにAllocationられた中継トランスポートアドレスでサーバーに到着します. チャネル番号がAllocationられているピアAからUDPデータグラムを受信したため、サーバーはデータをクライアントに送信するときに、データをChannelDataメッセージにカプセル化します. 

チャネルがバインドされると、クライアントは自由にChannelDataメッセージを混合し、表示を送信できます. 図では、クライアントは後でChannelDataメッセージではなく送信指示を使用してピアAに追加のデータを送信することを決定します. たとえば、クライアントはこれを行うことを決定し、DONT-FRAGMENT属性を使用できるようにします（次を参照）. セクション）. ただし、チャネルがバインドされると、呼び出しフローに示されているように、サーバーは常にChannelDataメッセージを使用します. 

ChannelDataメッセージは、クライアントがチャネルをバインドしたピアにのみ使用できることに注意してください. 上記の例では、ピアAはチャネルにバインドされていますが、ピアBはバインドされていないため、ピアBとの間のアプリケーションデータは送信メカニズムを使用します. 

3.6. 非特権TURNサーバー
このバージョンのTURNは、サーバーを、特別に特権を必要とせずに、一般的に利用可能なオペレーティングシステムのユーザースペースで実行されるアプリケーションとして実装できるように設計されています. この設計上の決定は、TURNサーバーのデプロイを容易にするために行われました. たとえば、1つのピアが別のピアにNATトラバーサルサービスを提供して使用できるように、TURNサーバーをピアツーピアアプリケーションに統合できるようにします.  D）TURN接続を保護するためのTLS. 

この設計上の決定は、TURNサーバーによって中継されるデータに次の影響を与えます. 

* Diffservフィールドの値はサーバー全体で保持されない場合があります. 

* Time to Live（TTL）フィールドは、サーバー全体で減少するのではなく、リセットされる場合があります. 

* Explicit Congestion Notification（ECN）フィールドはサーバーによってリセットされる場合があります. 

*パケットはサーバーで再構成されるため、エンドツーエンドの断片化はありません. 

今後の作業では、これらの制限に対処する代替TURNセマンティクスを指定する可能性があります. 

3.7. IPフラグメンテーションの回避
[FRAG-HARMFUL]で説明されている理由により、特に大量のデータを送信するアプリケーションは、パケットの断片化を回避する必要があります. [FRAG-FRAGILE]は、IPフラグメンテーションに関連する問題について説明し、IPフラグメンテーションの代替案を提案します. TCPを使用するアプリケーションは、フラグメンテーションの回避がTCPの標準部分になっているため、多かれ少なかれこの問題を無視できますが、UDPを使用するアプリケーション（したがって、このバージョンのTURNを使用するアプリケーション）は、十分に小さいメッセージを送信してIPフラグメンテーションを回避する必要がありますまたはUDPフラグメンテーション[UDP-OPT]を使用する. UDPフラグメンテーションオプションは両方のエンドポイントでサポートされる必要があることに注意してください. このドキュメントの執筆時点では、UDPフラグメンテーションサポートは検討中であり、展開されていません. 

クライアントとピアで実行されているアプリケーションは、UDPフラグメンテーションサポートが利用可能になるまで、IPフラグメンテーションを回避する2つのアプローチのいずれかを実行できます. 1つ目は、所定の固定最大値に制限されたメッセージを使用し、2つ目は、ネットワークフィードバックに依存してその最大値を適応させます. 

最初のアプローチは、クライアントとピア間で交換されるTURNメッセージ/ UDPデータグラムで大量のアプリケーションデータを送信しないようにすることです. これは、ほとんどのVoIPアプリケーションで採用されているアプローチです. このアプローチでは、[RFC8200]で指定されているように、IPv6ではインターネットのすべてのリンクに1280オクテット以上のMTUが必要であるため、アプリケーションは1280バイトのパスMTU（PMTU）を想定する必要があります. [RFC0791]で説明されているように、すべてのIPv4ホストは長さが576バイトのパケットを受信できる必要があるため、レガシーネットワークやその他の通常とは異なるネットワークでIPv4サポートが考慮される場合、アプリケーションはIPv4データグラムに対して576バイトの実効MTUを想定できます.  ]および[RFC1122]. 

断片化を回避しながら含めることができるアプリケーションデータの正確な量は、クライアントとサーバー間のTURNセッションの詳細によって異なります. UDP、TCP、または（D）TLSトランスポートのどちらを使用するか. ChannelDataメッセージまたは送信/データ指示が使用されるかどうか. 追加の属性（DONT-FRAGMENT属性など）が含まれているかどうか. 判断が難しいもう1つの要素は、IP-in-IPトンネリングの使用など、他の理由でMTUがパスのどこかで削減されているかどうかです. 

ガイドラインとして、1つのTURNメッセージで最大500バイトのアプリケーションデータ（クライアントからサーバーへのレッグのクライアントによる）またはUDPデータグラム（ピアからサーバーへのレッグのピアによる）を送信すると、通常、 IPフラグメンテーションを回避します. 断片化の可能性をさらに減らすために、ChannelDataメッセージのオーバーヘッドは送信およびデータ表示よりも少ないため、大量のデータを転送する場合は、クライアントがChannelDataメッセージを使用することをお勧めします. 

クライアントとピアが断片化を回避するために使用できる2番目のアプローチは、パスMTU検出アルゴリズムを使用して、断片化なしで送信できるアプリケーションデータの最大量を決定することです. [RFC1191]で定義されている従来のパスMTU発見アルゴリズムは、次の理由により、クライアントとピア間の伝送経路のMTUを発見できない場合があります. 

*より大きなMTUのパスをテストするためにIPv4ヘッダーにDo n't Fragment（DF）ビットが設定されたプローブパケットは、ルーターによってドロップされるか、

* ICMPエラーメッセージはミドルボックスによってドロップされる可能性があります. 

その結果、クライアントとサーバーは、ICMPメッセージを必要としないパスMTU発見アルゴリズムを使用する必要があります. [RFC4821]で定義されたパケット化パスMTU発見アルゴリズムはそのようなアルゴリズムの1つであり、アルゴリズムのセットは[MTU-DATAGRAM]で定義されています. 

[MTU-STUN]は、STUNを使用してパスMTUを検出する[RFC4821]の実装です. そのため、DONT-FRAGMENT属性をサポートするTURNサーバーと組み合わせて使用​​するのが適切なアプローチになる場合があります. クライアントが送信指示にDONT-FRAGMENT属性を含めると、これはサーバーに、ピアに送信する結果のUDPデータグラムにDFビットを設定するよう指示します. 一部のサーバーはDFビットを設定できない場合があるため、クライアントもこの属性をAllocateリクエストに含める必要があります. DONT-FRAGMENT属性をサポートしていないサーバーは、Allocation要求を拒否することでこれを示します. IPv4-to-IPv6からのパケット変換を実行するTURNサーバーがIPv4ヘッダーのDo n't Fragment（DF）ビットの状態にアクセスできない場合、DONT-FRAGMENT属性を持つAllocation要求を拒否する必要があります. 

3.8 RTPサポート
TURNの想定される用途の1つは、RTPを使用してリアルタイムデータ（音声やビデオなど）を交換したいクライアントやピアのリレーとして使用することです. この目的でのTURNの使用を容易にするために、TURNには、古いバージョンのRTPに対する特別なサポートが含まれています. 

古いバージョンのRTP [RFC3550]では、RTPストリームが偶数のポート番号にあり、関連するRTP制御プロトコル（RTCP）ストリームが存在する場合は、次に高いポートにある必要がありました. クライアントがまだこれを必要とするピアと連携できるようにするために、TURNはクライアントにサーバーが偶数のポート番号で中継されたトランスポートアドレスをAllocationることを要求し、オプションでサーバーに後続のAllocationのために次に大きいポート番号を予約することを要求します. 

3.9 TURNの幸せな眼球
TURNサーバーに到達するためのIPv4パスが見つかったが、TURNサーバーのIPv6パスが機能していない場合、デュアルスタックTURNクライアントは、IPv4のみのTURNクライアントと比較して、大幅な接続遅延が発生する可能性があります. これらの接続設定の問題を解決するには、TURNクライアントは、ドメイン名を使用して指定されたTURNサーバーのAレコードとAAAAレコードの両方を照会し、IPv6アドレスとIPv4アドレスの両方を使用して、定義されたHappy Eyeballsメカニズムと同様の方法でTURNサーバーに接続する必要があります.  [RFC8305]. TURNクライアントは、TURNサーバーへの接続に使用されているトランスポートプロトコルに基づいて、次の手順を実行します. 

* TCPまたはTLS-over-TCPの場合、Happy Eyeballsプロシージャ[RFC8305]の結果は、TURNメッセージをサーバーに送信するためにTURNクライアントによって使用されます. 

*クリアテキストのUDPの場合、[RFC8305]で説明されているように、認証情報なしでTURN Allocateリクエストを両方のIPアドレスファミリに送信します. TURNサーバーが認証を必要とする場合、サーバーは401認証されていない応答を返します. TURNクライアントは、401エラー応答を受信した最初のUDP接続を使用します. 401エラー応答が両方のIPアドレスファミリから受信された場合、TURNクライアントは、優先順位の低いIPアドレスファミリのUDP接続を黙って破棄できます. TURNサーバーが認証を必要としない場合（[RFC8155]のセクション9で説明されているように）、両方のAllocation要求が成功する可能性があります. この場合、TURNクライアントは、優先順位の低いIPアドレスファミリを使用してAllocationのLIFETIME値がゼロの更新を送信し、Allocationを削除します. 

* DTLS over UDPの場合、[RFC8305]で説明されているように、両方のIPアドレスファミリへのDTLSハンドシェイクを開始し、確立された最初のDTLSセッションを使用します. DTLSセッションが両方のIPアドレスファミリで確立されている場合、クライアントはDTLS close_notifyアラートを送信して、優先度の低いIPアドレスファミリを使用してDTLSセッションを終了します. TURN over DTLSサーバーがCookie交換を必要とするように構成され（[RFC6347]のセクション4.2）、HelloVerifyRequestが両方のIPアドレスファミリーのTURNサーバーから受信された場合、クライアントはIPアドレスファミリーの接続をサイレントに放棄できます. 優先順位が低くなります. 

4. TURN Serverの検出
エニーキャストの使用を含むTURNサーバー検出の方法は、[RFC8155]で説明されています. 複数のインターフェースを持つホストが各インターフェースでTURNサーバーを検出した場合、[RFC7982]で説明されているメカニズムをTURNクライアントが使用して、TURNサーバーの選択に影響を与えることができます. 「ターン」および「ターン」URIの構文は、[RFC7065]のセクション3.1で定義されています. TURNのトランスポートプロトコルとしてのDTLSは、[RFC7350]で定義されています. 

4.1. TURN URIスキームのセマンティクス
「ターン」および「ターン」URIスキームは、TURNプロトコルを使用してアクセス可能なインターネットホスト上のTURNサーバー（「リレー」とも呼ばれる）を指定するために使用されます. TURNプロトコルは、UDP、TCP、TLS-over-TCP、またはDTLS-over-UDPを介したメッセージの送信をサポートしています. 「ターン」URIスキームは、TURNがTLS-over-TCPまたはDTLS-over-UDPで実行される場合に使用する必要があり、「ターン」スキームはそれ以外の場合に使用する必要があります. 「turn」URIの必須の<host>部分は、TURNサーバーホストを示します. <port>部分は、存在する場合、TURNサーバーが接続要求を待機しているポートを示します. 存在しない場合、UDPとTCPの両方のデフォルトポートは3478です. TURN over TLSおよびTURN over DTLSのデフォルトポートは5349です. 

5.一般的な動作
このセクションには、すべてのTURNメッセージに適用される一般的なTURN処理規則が含まれています. 

TURNはSTUNの拡張です. ChannelDataメッセージを除くすべてのTURNメッセージは、STUN形式のメッセージです. [RFC8489]で説明されているすべての基本処理ルールは、STUN形式のメッセージに適用されます. これは、このドキュメントのすべてのメッセージ形成およびメッセージ処理の説明には、暗黙的に[RFC8489]の規則が前に付いていることを意味します. 

[RFC8489]は、「長期資格情報メカニズム」と呼ばれる認証メカニズムを指定しています. TURNサーバーとクライアントはこのメカニズムを実装する必要があり、認証オプションについてはセクション7.2で説明します. 

長期資格情報メカニズムはリクエストにのみ適用され、インジケーションの認証には使用できないことに注意してください. したがって、TURNの表示は認証されません. サーバーが要求に認証を要求する場合、サーバーの管理者は、クライアントが異なる管理下で複数のサーバーを使用する場合でも、クライアントが使用する必要があるユーザー名とパスワードの組み合わせを一意に識別するRealm値を選択する必要があります. サーバーの管理者は、各クライアントに一意のユーザー名をAllocationるか、同じユーザー名を複数のクライアント（たとえば、同じ部門または会社のすべてのクライアント）にAllocationるかを選択できます（MAY）. Allocationリクエストごとに、サーバーは、[RFC4086]のランダム性の推奨事項に従ってAllocationが最初に試行されたときに新しいランダムnonceを生成する必要があり（SHOULD）、Allocationの有効期間中に少なくとも1時間に1回nonceを期限切れにする必要があります. サーバーは、[RFC8489]のセクション9.2で説明されているメカニズムを使用して、[RFC8489]をサポートしていることを示します. 

最初のAllocation後のすべてのリクエストでは、攻撃者がクライアントのAllocationを乗っ取らないように、Allocationの作成に使用したものと同じユーザー名を使用する必要があります. 

具体的には：

*サーバーは、長期的な認証メカニズムの使用を必要とします. 

*非Allocationリクエストは、このメカニズムの下で認証を通過します. 

* 5タプルは既存のAllocationを識別しますが、

*リクエストはAllocationの作成に使用されたのと同じユーザー名を使用しません、

次に、441（Wrong Credentials）エラーでリクエストを拒否する必要があります. 

TURNメッセージがクライアントからサーバーに到着すると、サーバーはメッセージ内の5タプルを使用して、関連するAllocationを識別します. AllChannelリクエスト以外のすべてのTURNメッセージ（ChannelDataを含む）で、5タプルが既存のAllocationを識別しない場合、メッセージは437 Allocation Mismatchエラー（リクエストの場合）で拒否されるか、黙って無視されます（指示またはChannelDataメッセージの場合）. Allocate以外のリクエストに対する437エラー応答を受信するクライアントは、Allocationが存在しないと想定する必要があります. 

[RFC8489]は、SOFTWAREおよびFINGERPRINT属性を含む、いくつかの属性を定義しています. クライアントは、すべてのAllocation要求と更新要求にソフトウェア属性を含めるべきであり（SHOULD）、他の要求または指示にそれを含めてもよい（MAY）. サーバーはすべてのAllocationと更新応答（成功または失敗のいずれか）にソフトウェア属性を含めるべきで（SHOULD）、他の応答または指示にそれを含めてもよい（MAY）. クライアントとサーバーは、このドキュメントで定義されているSTUN形式のメッセージにFINGERPRINT属性を含めることができます. 

TURNは[RFC8489]で説明されている後方互換性メカニズムを使用しません. 

この仕様で定義されているTURNは、IPv4とIPv6の両方をサポートしています. TURNでのIPv6サポートには、IPv4-to-IPv6、IPv6-to-IPv6、およびIPv6-to-IPv4リレーが含まれます. 単一のアドレスタイプのみが必要な場合は、REQUESTED-ADDRESS-FAMILY属性を使用して、TURNサーバーがAllocationるアドレスタイプを明示的に要求します（たとえば、IPv4専用ノードがTURNサーバーにIPv6アドレスのAllocationを要求する場合があります）. IPv4とIPv6の両方が必要な場合、単一のADDITIONAL-ADDRESS-FAMILY属性は、1つのIPv4と1つのIPv6リレーアドレスを1つのAllocation要求にAllocationるサーバーへの要求を示します. これにより、クライアントのローカルポートが節約され、クライアントとTURNサーバーの間で送信されるメッセージの数が減ります. 

デフォルトでは、TURNはSTUNと同じポートで実行されます. UDPおよびTCPを介したTURNの場合は3478、（D）TLSを介したTURNの場合は5349です. ただし、TURNには独自のサービスレコード（SRV）名のセットがあります. UDPおよびTCPの場合は「turn」、（D）TLSの場合は「turns」です. DNS解決手順またはALTERNATE-SERVER手順（どちらもセクション7で説明）を使用して、別のポートでTURNを実行できます. 

相互運用性を確保するために、TURNサーバーはクライアントとサーバー間のUDPトランスポートの使用をサポートする必要があり、TCP、TLS-over-TCP、およびDTLS-over-UDPトランスポートの使用をサポートする必要があります. 

クライアントとサーバー間でUDPまたはDTLS-over-UDPトランスポートが使用されている場合、クライアントは、一定のタイムアウト期間内に応答を受信しないと、要求を再送信します. このため、サーバーは同じ5タプルと同じトランザクションIDを持つ2つ（またはそれ以上）のリクエストを受信する場合があります. STUNは、サーバーがこのケースを認識し、要求をべき等として扱うことを要求します（[RFC8489]を参照）. 一部の実装では、受信したすべてのリクエストと対応する応答を40秒間記憶することで、この要件を満たすことを選択する場合があります（[RFC8489]のセクション6.3.1）. 他の実装では、要求の再処理を選択して、そのような再処理で基本的に同じ応答が返されるように調整できます. 後者のアプローチ（いわゆる「ステートレススタックアプローチ」）を選択する実装者を支援するには、この仕様には、これがどのように行われるかに関するいくつかの実装上の注意が含まれています. 実装では、同じ結果が得られるアプローチまたは他のアプローチを自由に選択できます. 

有効なユーザー名とパスワードを使用するクライアントによるサーバーに対する意図的または非意図的なサービス拒否攻撃を軽減するために、サーバーは、特定のユーザー名に対して同時にアクティブなAllocationの数とその量の両方に制限を課すことをお勧めしますそれらのAllocationが使用できる帯域幅. サーバーは、486（Allocation Quota Exceeded）で同時にアクティブにできるAllocationの許容数の制限を超える新しいAllocationを拒否する必要があります（UDPには輻輳制御メカニズムが含まれていないため、アプリケーションを破棄する必要があります）帯域幅Allocationを超えるデータトラフィック. 

6.Allocation
すべてのTURN操作はAllocationを中心に展開され、すべてのTURNメッセージは単一または二重のAllocationに関連付けられています. Allocationは、概念的には次の状態データで構成されています. 

*中継されたトランスポートアドレスまたはアドレス. 

* 5タプル：（クライアントのIPアドレス、クライアントのポート、サーバーのIPアドレス、サーバーのポート、およびトランスポートプロトコル）. 

*認証情報. 

*各中継トランスポートアドレスの有効期限. 

*各中継トランスポートアドレスの権限のリスト. 

*各中継トランスポートアドレスのチャネルからピアへのバインディングのリスト. 

Relayed Transport Addressは、ピアと通信するためにサーバーによってAllocationられたトランスポートアドレスです. 5タプルは、クライアントとサーバー間の通信パスを示します. クライアントでは、5タプルはクライアントのホストトランスポートアドレスを使用します. サーバーでは、5タプルはクライアントのServer-Reflexive Transport Addressを使用します. Relayed Transport Addressは、すべてのAllocation全体で一意である必要があるため、Allocationを一意に識別するために使用できます. このコンテキストでのAllocationは、単一Allocationまたは二重Allocationのいずれかです. 

認証情報（ユーザー名、パスワード、Realm、ノンスなど）は、後続の要求の確認と応答のメッセージの整合性の計算の両方に使用されます. ユーザー名、Realm、およびnonceの値は、最初はAllocationを作成する認証済みのAllocateリクエストで使用される値ですが、サーバーは438（Stale Nonce）応答を使用してAllocationの有効期間中にnonce値を変更できます. セキュリティ上の理由から、サーバーはパスワードを明示的に保存してはならず（MUST）、ユーザー名、Realm、パスワードの暗号化ハッシュであるキー値を保存しなければなりません（[RFC8489]のセクション16.1.3を参照）. 

応答にPASSWORD-ALGORITHMS属性が含まれ、この属性にMD5アルゴリズムとSHA-256アルゴリズムの両方が含まれ、クライアントが両方のアルゴリズムもサポートしている場合、リクエストにはSHA-256アルゴリズムのPASSWORD-ALGORITHM属性が含まれている必要があります. 

有効期限までの時間は、Allocationが期限切れになるまでの残り時間（秒）です. 各Allocationトランザクションまたは更新トランザクションはこのタイマーを設定し、タイマーはゼロに向かって下降します. デフォルトでは、各Allocationまたは更新トランザクションはこのタイマーをデフォルトのライフタイム値600秒（10分）にリセットしますが、クライアントはAllocationおよび更新要求で異なる値を要求できます. Allocationは、更新リクエストを使用してのみ更新できます. ピアにデータを送信しても、Allocationは更新されません. Allocationが期限切れになると、Allocationに関連付けられている状態データを解放できます. 

権限のリストはセクション9で説明されており、チャネルのリストはセクション12で説明されています. 

7.Allocationの作成
サーバー上のAllocationは、Allocateトランザクションを使用して作成されます. 

7.1. Allocationリクエストの送信
クライアントは、次のようにAllocateリクエストを作成します. 

クライアントは最初にホストトランスポートアドレスを選択します. クライアントが現在使用されていないトランスポートアドレスを選択することをお勧めします. 通常は、基盤となるOSが現在使用されていないポートを選択できるようにします. 

次に、クライアントは、サーバーがサポートするトランスポートプロトコルに基づいて、クライアントとサーバー間で使用するためにサポートするトランスポートプロトコルを選択します. この仕様ではサーバーとピア間のUDPのみが許可されているため、別のトランスポートを使用する理由がない限り、クライアントがUDPを選択することをお勧めします. 別のトランスポートを選択する理由の1つは、クライアントが、構成または検出を通じて、または実験により、UDPを使用してTURNサーバーに接続できないと信じていることです. 詳細については、セクション3.1を参照してください. 

また、クライアントはサーバートランスポートアドレスを選択します. これは、次のように行う必要があります. クライアントは、[RFC8155]で説明されている1つ以上の手順を使用してTURNサーバーを検出し、[RFC5928]および[RFC7350]で定義されているTURNサーバー解決メカニズムを使用して、TURNAllocationの作成を試行できるサーバートランスポートアドレスのリストを取得します.  . 

クライアントはリクエストにREQUESTED-TRANSPORT属性を含めなければなりません. この属性は、サーバーとピア間のトランスポートプロトコルを指定します（これは、5タプルに表示されるトランスポートプロトコルではないことに注意してください）. この仕様では、REQUESTED-TRANSPORTタイプは常にUDPです. この属性は、将来の拡張で他のプロトコルを指定できるようにするために含まれています. 

クライアントが特定のアドレスタイプのRelayed Transport Addressを取得したい場合は、リクエストにREQUESTED-ADDRESS-FAMILY属性を含めます. この属性は、クライアントがTURNサーバーにAllocationたい特定のアドレスタイプを示します. クライアントは、Allocation要求に複数のREQUESTED-ADDRESS-FAMILY属性を含めてはなりません（MUST NOT）. クライアントは、RESERVATION-TOKEN属性を含むAllocationリクエストにREQUESTED-ADDRESS-FAMILY属性を含めてはなりません. これは、サーバーが含まれているトークンに対応する以前に予約されたトランスポートアドレスを使用し、クライアントがRelayed Transport Addressを取得できないためです. 特定のアドレスタイプ. 

クライアントが1つのIPv6および1つのIPv4中継トランスポートアドレスを取得したい場合は、リクエストにADDITIONAL-ADDRESS-FAMILY属性を含めます. この属性は、サーバーが両方のアドレスタイプをAllocationる必要があることを指定します. ADDITIONAL-ADDRESS-FAMILYの属性値は0x02（IPv6アドレスファミリ）に設定する必要があります. クライアントは、同じリクエストにREQUESTED-ADDRESS-FAMILY属性とADDITIONAL-ADDRESS-FAMILY属性を含めてはなりません. クライアントは、RESERVATION-TOKEN属性を含むAllocateリクエストにADDITIONAL-ADDRESS-FAMILY属性を含めてはなりません（MUST NOT）. クライアントは、R（予約済み）ビットが1に設定されたEVEN-PORT属性を含むAllocateリクエストにADDITIONAL-ADDRESS-FAMILY属性を含めてはなりません（MUST NOT）. 

クライアントがサーバーにAllocationの有効期限フィールドをデフォルトの有効期間以外の値に初期化することを希望する場合、希望する値を指定するLIFETIME属性を含めることができます（MAY）. これは単なるヒントであり、サーバーは別の値を使用することを選択する場合があります. サーバーは、フィールドをデフォルト値未満に初期化する要求を無視することに注意してください. 

クライアントが後でこのAllocationの1つ以上の送信指示でDONT-FRAGMENT属性を使用することを希望する場合、クライアントは、AllocationリクエストにDONT-FRAGMENT属性を含める必要があります（SHOULD）. これにより、クライアントはこの属性がサーバーでサポートされているかどうかをテストできます. 

クライアントがRelayed Transport Addressのポート番号を偶数にする必要がある場合、クライアントにはEVEN-PORT属性が含まれます. この属性が含まれていない場合、ポートは偶数または奇数になります. EVEN-PORT属性のRビットを1に設定することにより、クライアントは、サーバーが次にAllocationられる（同じIPアドレス上の）次に大きいポート番号を予約するように要求できます. Rビットが0の場合、そのような要求は行われません. 

また、クライアントはリクエストにRESERVATION-TOKEN属性を含めて、Allocation用に以前に予約されたポートを使用するようサーバーに要求してもよい（MAY）. RESERVATION-TOKEN属性が含まれている場合、クライアントはEVEN-PORT属性を省略しなければなりません（MUST）. 

構築されると、クライアントは5タプルでAllocation要求を送信します. 

7.2. Allocationリクエストの受信
サーバーは、Allocation要求を受信すると、次のチェックを実行します. 

1.ローカルネットワークまたはアクセスネットワークによって提供されるTURNサーバーは、STUN認証の長期的な資格情報を必ずしも持っていないネットワーク内の新規ユーザーやゲストユーザーからのAllocation要求を受け入れるために、認証されていない要求を許可する場合があります. STUNのセキュリティへの影響とSTUN認証のオプション化については、[RFC8155]で説明されています. それ以外の場合、サーバーは要求が認証されることを要求する必要があります. 要求が認証される場合、クライアントとサーバーが外部の何らかの手順で別のメカニズムを使用することに同意しない限り、認証は[RFC8489]の長期認証メカニズムを使用するか、サードパーティ認証用のSTUN拡張[RFC7635]を使用する必要があります. このドキュメントの範囲. 

2.サーバーは、5タプルが既存のAllocationによって現在使用されているかどうかを確認します. はいの場合、サーバーは437（Allocation不一致）エラーで要求を拒否します. 

3.サーバーは、リクエストにREQUESTED-TRANSPORT属性が含まれているかどうかを確認します. REQUESTED-TRANSPORT属性が含まれていないか、形式が正しくない場合、サーバーは400（Bad Request）エラーで要求を拒否します. それ以外の場合、属性が含まれていてもサーバーでサポートされていないプロトコルを指定すると、サーバーは442（サポートされていないトランスポートプロトコル）エラーで要求を拒否します. 

4.リクエストにはDONT-FRAGMENT属性が含まれる場合があります. サポートしているが、サーバーがDFビットが1に設定されたUDPデータグラムの送信をサポートしていない場合（セクション14および15を参照）、サーバーはAllocateリクエストのDONT-FRAGMENT属性を不明なcomprehension-required属性として扱います. 

5.サーバーは、リクエストにRESERVATION-TOKEN属性が含まれているかどうかを確認します. はいの場合、リクエストにEVEN-PORTまたはREQUESTED-ADDRESS-FAMILYまたはADDITIONAL-ADDRESS-FAMILY属性も含まれていると、サーバーはリクエストを400（Bad Request）エラーで拒否します. それ以外の場合は、トークンが有効であるかどうかを確認します（つまり、トークンは範囲内にあり、有効期限が切れておらず、対応する中継トランスポートアドレスは引き続き使用可能です）. トークンが何らかの理由で有効でない場合、サーバーは508（容量不足）エラーで要求を拒否します. 

6.サーバーは、リクエストにREQUESTED-ADDRESS-FAMILY属性とADDITIONAL-ADDRESS-FAMILY属性の両方が含まれているかどうかを確認します. はいの場合、サーバーは400（Bad Request）エラーで要求を拒否します. 

7.サーバーがREQUESTED-ADDRESS-FAMILYでクライアントから要求されたアドレスファミリーをサポートしていない場合、または要求されたアドレスファミリーのAllocationがローカルポリシーによって無効にされている場合は、Allocateエラー応答を生成し、 440（アドレスファミリはサポートされていません）応答コードを持つERROR-CODE属性. REQUESTED-ADDRESS-FAMILY属性がなく、サーバーがIPv4アドレスファミリーをサポートしていない場合、サーバーは440（アドレスファミリーはサポートされていません）応答コードとともにERROR-CODE属性を含める必要があります. REQUESTED-ADDRESS-FAMILY属性がなく、サーバーがIPv4アドレスファミリーをサポートしている場合、サーバーはTURNクライアントにIPv4中継トランスポートアドレスをAllocationる必要があります. 

8.サーバーは、リクエストにRビットが1に設定されたEVEN-PORT属性が含まれているかどうかを確認します. 含まれている場合、リクエストにADDITIONAL-ADDRESS-FAMILY属性も含まれていると、サーバーはリクエストを400（不正なリクエスト）で拒否しますエラー. それ以外の場合、サーバーは要求を満たすことができるかどうか（つまり、以下に説明するように中継トランスポートアドレスをAllocationることができるかどうか）をチェックします. サーバーが要求を満たせない場合、サーバーは508（不十分な容量）エラーで要求を拒否します. 

9.サーバーは、リクエストにADDITIONAL-ADDRESS-FAMILY属性が含まれているかどうかを確認します. はい、属性値が0x01（IPv4アドレスファミリ）の場合、サーバーは要求を400（不正な要求）エラーで拒否します. それ以外の場合、サーバーは、両方のアドレスタイプの中継トランスポートアドレスをAllocationることができるかどうかを確認します. サーバーが要求を満たせない場合、サーバーは508（不十分な容量）エラーで要求を拒否します. サーバーがリクエストに部分的に対応できる場合、つまり、特定のアドレスタイプの中継トランスポートアドレスを1つしかAllocationることができない場合は、成功応答にADDRESS-ERROR-CODE属性を含めて、クライアントに部分的な失敗の理由を通知しますリクエスト. ADDRESS-ERROR-CODE属性で通知されるエラーコード値は、440（アドレスファミリはサポートされていません）または508（容量不足）である可能性があります. 

10.いつでも、クライアントがローカルに定義されたAllocationAllocationを超えようとしていると感じた場合、サーバーは486（AllocationAllocationに到達）エラーでリクエストを拒否することを選択できます（MAY）. サーバーは自由にこのAllocationAllocationを自由に定義できますが、クライアントのトランスポートアドレスではなく、要求の認証に使用されるユーザー名に基づいて定義する必要があります（SHOULD）. 

11.また、クライアントを別のサーバーにリダイレクトする場合、サーバーはいつでも、300（代替試行）エラーで要求を拒否することを選択できます（MAY）. このエラーコードと属性の使用は、[RFC8489]の仕様に従います. 

すべてのチェックに合格すると、サーバーがAllocationを作成します. 5タプルはAllocateリクエストからの5タプルに設定されますが、権限のリストとチャネルのリストは最初は空です. 

サーバーは、次のようにAllocation用の中継トランスポートアドレスを選択します. 

*リクエストにRESERVATION-TOKEN属性が含まれている場合、サーバーは、含まれているトークンに対応する以前に予約されたトランスポートアドレスを使用します（まだ使用可能な場合）. RESERVATION-TOKENを含むAllocationリクエストは、予約を行ったAllocationリクエストとは異なる5タプルを使用するため、予約はサーバー全体の予約であり、特定のAllocationに固有のものではないことに注意してください. RESERVATION-TOKEN属性を含むAllocateリクエストの5タプルは、許可されている任意の5タプルにすることができます. 異なるクライアントIPアドレスとポート、異なるトランスポートプロトコル、さらには異なるサーバーIPアドレスとポートを使用できます（もちろん、サーバーのIPアドレスとポートがサーバーがTURN要求をリッスンしている場合） . 

*リクエストにRビットが0に設定されたEVEN-PORT属性が含まれている場合、サーバーは中継されたトランスポートアドレスを偶数のポート番号でAllocationます. 

*リクエストにRビットが1に設定されたEVEN-PORT属性が含まれている場合、サーバーは同じIPアドレスでポート番号NとN + 1のペアを探します（Nは偶数）. ポートNは現在のAllocationで使用され、ポートN + 1の中継されたトランスポートアドレスにはトークンがAllocationられ、将来のAllocationのために予約されます. サーバーはこの予約を少なくとも30秒間保持する必要があり、より長く保持することを選択できます（たとえば、ポートNでのAllocationが期限切れになるまで）. 次に、サーバーは成功応答のRESERVATION-TOKEN属性にトークンを含めます. 

*それ以外の場合、サーバーは使用可能な中継トランスポートアドレスをAllocationます. 

すべての場合において、サーバーは49152から65535の範囲（動的および/またはプライベートポート範囲[PORT-NUMBERS]）からのみポートをAllocationる必要があります. ただし、ここで指定されていない何らかの手段により、他のアプリケーションが実行していることをTURNサーバーアプリケーションが認識している場合を除きます.  TURNサーバーアプリケーションと同じホスト上では、この範囲外のポートをAllocationることによる影響はありません. この条件は、専用マシンでTURNサーバーアプリケーションを実行するか、マシン上の他のアプリケーションがTURNサーバーアプリケーションを起動する前にポートをAllocationるように設定することで、しばしば満たすことができます. いずれの場合も、TURNサーバーは、クライアントがTURNを使用して標準サービスを実行しないようにするために、0〜1023（既知のポート範囲）のポートをAllocationないでください. 

| 注：特定のポートを回避するためのランダムなポートAllocationの使用| 攻撃の種類は[RFC6056]で説明されています. お勧めです| TURNサーバーがランダム化されたポートAllocationを実装すること| [RFC6056]のアルゴリズム. これは特に|に適用されます |からいくつかのポートを事前にAllocationることを選択するサーバー 基礎となるOS、その後それらをAllocationにAllocationる. の| たとえば、サーバーはこの手法を選択して|を実装できます. EVEN-PORT属性. 

サーバーは、有効期限フィールドの初期値を次のように決定します. リクエストにLIFETIME属性が含まれている場合、サーバーはクライアントの提案されたライフタイムの最小値とサーバーの最大許容ライフタイムを計算します. この計算された値がデフォルトのライフタイムより大きい場合、サーバーは計算されたライフタイムを有効期限フィールドの初期値として使用します. それ以外の場合、サーバーはデフォルトの有効期間を使用します. サーバーは3600秒（1時間）以下の最大許容ライフタイム値を使用することをお勧めします. AllocationAllocationを実装するか、何らかの方法でAllocationに対してユーザーに課金するサーバーは、より短い最大許容ライフタイム（おそらくデフォルトのライフタイムと同じくらい）を使用して、孤立したAllocation（つまり、対応するクライアントがクラッシュまたは終了した、またはクライアント接続が何らかの理由で失われたAllocation. また、有効期限までの時間は、更新要求が成功するたびに再計算されるため、ここで計算される値は、最初の更新までしか適用されないことに注意してください. 

Allocationが作成されると、サーバーは成功の応答を返します. 成功の応答には以下が含まれます. 

*Relayed Transport Addressを含むXOR-RELAYED-ADDRESS属性、またはRelayed Transport Addressを含む2つのXOR-RELAYED-ADDRESS属性. 

*有効期限タイマーの現在の値を含むLIFETIME属性. 

* RESERVATION-TOKEN属性（2番目の中継トランスポートアドレスが予約されている場合）. 

*クライアントのIPアドレスとポートを含むXOR-MAPPED-ADDRESS属性（5タプルから）. 

| 注：XOR-MAPPED-ADDRESS属性は|に含まれています. クライアントへの便宜としての応答. TURN自体はしません| この値を利用しますが、ICEを実行しているクライアントはしばしば必要になることがあります. この値により、追加のバインディングを実行する必要を回避できます. それを学ぶためにいくつかのSTUNサーバーとのトランザクション. 

応答（成功またはエラー）は、5タプルでクライアントに送り返されます. 

| 注：AllocationリクエストがUDP経由で送信される場合、[RFC8489] | |の再送信の可能性をサーバーが処理する必要があります 再送信が複数の原因にならないようにリクエストを送信します. 作成するAllocation. 実装はこれを達成します| 次のように、いわゆる「ステートレススタックアプローチ」を使用します. へ| 元のリクエストが成功したときに再送信を検出する| Allocationの作成時に、サーバーはトランザクションを保存できます. Allocationデータと|を含むリクエストを作成したID 同じ5タプルの着信Allocateリクエストと比較してください. | このようなリクエストが検出されると、サーバーは解析を停止できます. リクエストを送信し、すぐに成功レスポンスを生成します. いつ| この応答を作成すると、LIFETIME属性の値は Allocation状態の有効期限フィールドから取得されます. データ、この値は|と少し異なる場合があります. 最初に返されたLIFETIME値. さらに、サーバー| 予約トークンの表示を保存する必要がある場合があります. これが返されるように、元の応答で返されます. 再送信された応答. | | |で元のリクエストが失敗した場合 Allocationを作成すると、サーバーは何もしないことを選択する場合があります. 特殊な. ただし、まれに|が発生する場合があることに注意してください. サーバーは元の要求を拒否しますが、|を受け入れます リクエストを再送信しました（条件が短い間に|変化したため）. クライアントが|を受け取った場合 最初の失敗応答、2番目（成功）を無視します. 応答し、Allocationが作成されなかったと考えています. | この方法で作成されたAllocationは、最終的にタイムアウトします. クライアントはそれを更新しないため. さらに、| クライアントは後で同じ5タプルで異なる再試行を行います. トランザクションID、それは437（Allocation不一致）を受け取ります. エラー応答. 異なる|で再試行します. 5タプル. サーバーはより短い最大ライフタイム値を使用する場合があります| これで「孤立した」Allocationの存続期間を最小限に抑えるには| マナー. 

7.3. Allocation成功応答の受信
クライアントがAllocate成功応答を受信した場合、マッピングされたアドレスと中継されたトランスポートアドレスが、クライアントが理解し、処理する準備ができているアドレスファミリの一部であることを確認する必要があります. これらのアドレスが、クライアントが処理する準備ができているアドレスファミリの一部ではない場合、クライアントはAllocationを削除し（セクション8）、不一致が修正されたと確信するまで、そのサーバーに別のAllocationを作成してはなりません（MUST NOT）.  . 

それ以外の場合、クライアントはAllocationデータ構造の独自のコピーを作成して、サーバーで何が起こっているかを追跡します. 特に、クライアントは、リクエストでサーバーに送信された値ではなく、サーバーから受信した実際の有効期間を覚えておく必要があります. クライアントは、リクエストに使用された5タプルと、リクエストの認証に使用されたユーザー名とパスワードを覚えて、後続のメッセージに確実に再利用する必要があります. クライアントは、サーバー上で確立するチャネルとアクセス許可も追跡する必要があります. 

クライアントがAllocate成功応答を受信したが、応答にADDRESS-ERROR-CODE属性があり、ADDRESS-ERROR-CODE属性で通知されたエラーコード値が440（アドレスファミリはサポートされていない）である場合、クライアントは要求を再試行してはならない（MUST NOT）拒否されたアドレスタイプ. クライアントが応答でADDRESS-ERROR-CODE属性を受信し、ADDRESS-ERROR-CODE属性で通知されたエラーコード値が508（不十分な容量）である場合、クライアントは、追加のAllocationを要求する前に少なくとも1分間待機する必要があります（SHOULD）. このサーバーで拒否されたアドレスの種類. 

クライアントはおそらく、Relayed Transport Addressをピアに送信し（ここで指定されていない方法を使用）、ピアが通信できるようにします. クライアントは、ICE処理のXOR-MAPPED-ADDRESS属性で受信したサーバー再帰アドレスを使用することもできます. 

7.4. Allocationエラー応答の受信
クライアントがAllocateエラー応答を受信した場合、処理は返された実際のエラーコードによって異なります. 

408（要求がタイムアウトしました）：サーバーに問題があるか、選択したトランスポートでサーバーに到達する問題があります. クライアントは現在のトランザクションが失敗したと見なしますが、別のトランスポート（UDPではなくTCPなど）を使用してAllocation要求を再試行することを選択できます（MAY）. 

300（代替を試行）：サーバーは、クライアントが代わりにALTERNATE-SERVER属性で指定されたサーバーを使用することを望んでいます. クライアントは現在のトランザクションが失敗したと見なしますが、他のサーバー（DNS解決手順を使用して発見された他のサーバーなど）を試す前に、代替サーバーでAllocation要求を試す必要があります（SHOULD）. 代替サーバーでAllocateリクエストを試行すると、クライアントは[RFC8489]で指定されているALTERNATE-SERVERプロシージャに従います. 

400（不正な要求）：サーバーは、クライアントの要求が何らかの理由で不正であると考えています. クライアントは、現在のトランザクションが失敗したと見なします. クライアントはユーザーまたはオペレーターに通知してもよい（MAY）、問題が修正されたと確信するまで、このサーバーで要求を再試行すべきではない（SHOULD NOT）. 

401（無許可）：クライアントが長期資格情報メカニズムの手順に従ってもこのエラーが発生する場合、サーバーはクライアントの資格情報を受け入れていません. この場合、クライアントは現在のトランザクションが失敗したと見なし、ユーザーまたはオペレーターに通知する必要があります（SHOULD）. クライアントは、問題が修正されたと確信するまで、このサーバーにそれ以上のリクエストを送信すべきではありません. 

403（禁止）：要求は有効ですが、サーバーはそれを実行することを拒否しています. 管理上の制限が原因である可能性があります. クライアントは、現在のトランザクションが失敗したと見なします. クライアントはユーザーまたはオペレーターに通知することができます（MAY）. 問題が修正されたと確信するまで、このサーバーで同じリクエストを再試行しないでください. 

420（不明な属性）：クライアントが要求にDONT-FRAGMENT属性を含め、サーバーが420エラーコードで要求を拒否し、エラー応答のUNKNOWN-ATTRIBUTES属性にDONT-FRAGMENT属性をリストした場合、クライアントはサーバーがDONT-FRAGMENT属性をサポートしていないことがわかりました. クライアントは現在のトランザクションが失敗したと見なしますが、DONT-FRAGMENT属性なしでAllocation要求を再試行することを選択できます（MAY）. 

437（Allocationの不一致）：これは、サーバーが既に使用していると見なす5タプルをクライアントが選択したことを示します. これが発生する可能性がある1つの方法は、介在するNATが、最近クラッシュした別のクライアントによって使用されたマップされたトランスポートアドレスをAllocationた場合です. クライアントは、現在のトランザクションが失敗したと見なします. クライアントは別のクライアントトランスポートアドレスを選択して（別のトランザクションIDを使用して）Allocation要求を再試行する必要があります（SHOULD）. クライアントは、このサーバーをあきらめる前に、3つの異なるクライアントトランスポートアドレスを試す必要があります. クライアントがサーバーをあきらめたら、2分間サーバーに別のAllocationを作成しようとしないでください. 

438（Stale Nonce）：長期資格情報メカニズムの手順[RFC8489]を参照してください. 

440（アドレスファミリはサポートされていません）：サーバーは、クライアントから要求されたアドレスファミリをサポートしていません. クライアントが440（アドレスファミリはサポートされていません）エラーコードを含むAllocationエラー応答を受信した場合、クライアントは要求を再試行してはなりません（MUST NOT）. 

441（間違った資格情報）：クライアントは、Allocation要求への応答としてこのエラーを受け取るべきではありません. クライアントはユーザーまたはオペレーターに通知することができます（MAY）. 問題が修正されたと確信するまで、このサーバーで同じリクエストを再試行しないでください. 

442（サポートされていないトランスポートアドレス）：クライアントは、UDPAllocationの要求に応答してこのエラーを受け取るべきではありません. クライアントはユーザーまたはオペレーターに通知することができます（MAY）、問題が修正されたと確信するまで、このサーバーで要求を再試行してはなりません（SHOULD NOT）. 

486（Allocationのクォータに達しました）：サーバーは現在、このユーザー名でこれ以上のAllocationを作成できません. クライアントは、現在のトランザクションが失敗したと見なします. クライアントは、サーバー上でさらにAllocationを作成する前に、少なくとも1分間待機する必要があります. 

508（容量不足）：サーバーで使用できる中継トランスポートアドレスがなくなったか、要求されたプロパティを持つものがないか、または予約されたアドレスが使用できなくなりました. クライアントは、現在の操作が失敗したと見なします. クライアントがEVEN-PORTまたはRESERVATION-TOKEN属性のいずれかを使用している場合、クライアントはこの属性を削除または変更して、すぐに再試行する場合があります. それ以外の場合、クライアントは、このサーバーでさらにAllocationを作成する前に、少なくとも1分間待機する必要があります（SHOULD）. 

エラーコード値486と508は、HTTPエラー応答コード503と同様に、現時点で他の複数のユーザーがサーバーを使用していることを盗聴者に示していますが、TURNサーバーを使用しているユーザーに関する情報は明らかにしていません.  . 

[RFC8489]で説明されているように、不明なエラー応答を処理する必要があります. 

8.Allocationの更新
更新トランザクションは、（a）既存のAllocationを更新して、有効期限までの時間を更新するか、（b）既存のAllocationを削除するために使用できます. 

クライアントがAllocationの使用を継続したい場合、クライアントは期限が切れる前にそれを更新する必要があります. クライアントは、有効期限が切れる約1分前にAllocationを更新することをお勧めします. クライアントがAllocationを使用したくない場合は、Allocationを明示的に削除する必要があります. クライアントは、他の理由でいつでもAllocationを更新できます（MAY）. 

8.1. 更新リクエストの送信
クライアントが既存のAllocationをすぐに削除したい場合は、ゼロの値を持つLIFETIME属性が含まれます. リクエストの他のすべての形式は、Allocationを更新します. 

二重Allocationを更新する場合、クライアントには、更新する必要があるアドレスファミリタイプを示すREQUESTED-ADDRESS-FAMILY属性が含まれます. REQUESTED-ADDRESS-FAMILY属性が含まれていない場合、要求は現在のすべてのAllocationに適用されるものとして扱われる必要があります. クライアントは、以前にAllocationられ、まだ削除されていないファミリタイプのみを含める必要があります. このプロセスを使用して、そのリフレッシュ要求の存続時間をゼロに設定することにより、特定のアドレスタイプのAllocationを削除することもできます. 単一のAllocationを削除すると、その特定のAllocationに関連付けられているすべての権限またはチャネルが破棄されます. 他のアドレスファミリのAllocationに関連するアクセス許可またはチャネルに影響を与えてはなりません. 

更新トランザクションは、Allocationの有効期限タイマーを更新します. クライアントがサーバーに有効期限までのタイマーをデフォルトの有効期間以外のものに設定することを希望する場合は、要求された値を持つLIFETIME属性が含まれます. 次に、サーバーは、Allocateトランザクションの場合と同じ方法で新しい有効期限の値を計算します. ただし、要求された存続期間がゼロの場合、サーバーはAllocationをすぐに削除します. 

8.2. 更新リクエストの受信
サーバーが更新要求を受信すると、セクション5とここで説明した特定のルールに従って要求を処理します. 

サーバーがREQUESTED-ADDRESS-FAMILY属性を持つ更新要求を受信し、その属性値がAllocationのアドレスファミリーと一致しない場合、サーバーは443（ピアアドレスファミリーの不一致）更新エラー応答で応答する必要があります. 

サーバーは、「望ましいライフタイム」と呼ばれる値を次のように計算します. リクエストにLIFETIME属性が含まれていて、属性値がゼロの場合、「望ましいライフタイム」はゼロです. それ以外の場合、要求にLIFETIME属性が含まれていれば、サーバーはクライアントの要求された存続期間の最小値とサーバーの最大許容存続期間を計算します. この計算された値がデフォルトのライフタイムより大きい場合、「望ましいライフタイム」は計算された値です. それ以外の場合、「目的のライフタイム」がデフォルトのライフタイムです. 

後続の処理は、「望ましいライフタイム」の値に依存します. 

*「希望するライフタイム」がゼロの場合、リクエストは成功し、Allocationは削除されます. 

*「望ましい存続期間」がゼロ以外の場合、要求は成功し、Allocationの有効期限は「望ましい存続期間」に設定されます. 

リクエストが成功すると、サーバーは以下を含む成功応答を送信します. 

*有効期限タイマーの現在の値を含むLIFETIME属性. 

| 注：サーバーは、実装するために特別なことをする必要はありません. 「ステートレス|スタックアプローチ」を使用したUDP経由のリフレッシュ要求のべき等性. 再送信された更新要求が非|である ゼロの「望ましいライフタイム」は、Allocationを更新するだけです. A | ゼロの「望ましいライフタイム」で再送信された更新要求| |の場合、437（Allocation Mismatch）応答が発生します. Allocationはすでに削除されていますが、クライアントは処理します| これは成功応答と同じです（下記を参照）. 

8.3. 更新応答の受信
クライアントがゼロ以外の存続時間でリフレッシュ要求への成功応答を受信した場合、クライアントはAllocationデータ構造のコピーを応答に含まれる有効期限までの値で更新します. クライアントが、Allocationを更新する要求に対する437（Allocation不一致）エラー応答を受け取った場合、Allocationが存在しないと見なす必要があります. クライアントは、Allocationを更新する要求に対して438（Stale Nonce）エラーを受信した場合、新しいnonce値で要求を再試行する必要があります. 

クライアントがAllocationの削除要求に対する437（Allocation Mismatch）エラー応答を受け取った場合、Allocationは存在せず、その要求は事実上成功したと見なす必要があります. 

9.権限
Allocationごとに、サーバーは0個以上の権限のリストを保持します. 各権限は、IPアドレスとそれに関連付けられた有効期限で構成されます. 権限が存在する間、権限内のIPアドレスを使用するすべてのピアは、クライアントへのデータの送信を許可されます. 有効期限は、許可が期限切れになるまでの秒数です. Allocationのコンテキスト内では、許可は関連するIPアドレスによって一意に識別されます. 

CreatePermission要求またはChannelBind要求のいずれかを送信することにより、クライアントはサーバーに、特定のIPアドレスのアクセス許可をインストールまたは更新させることができます. これにより、次のいずれかが発生します. 

*そのIPアドレスに対する権限が存在しない場合は、指定されたIPアドレスと、有効期限までの有効期限に基づいて、権限が作成されます. 

*そのIPアドレスの権限がすでに存在する場合、その権限の有効期限は、Permission Lifetimeにリセットされます. 

パーミッションの有効期間は300秒（= 5分）でなければなりません. 

各許可の有効期限は、ゼロに達するまで1秒に1回減少します. この時点で、許可は期限切れになり、削除されます. 

CreatePermissionリクエストとChannelBindリクエストは、パーミッション上で自由に混在させることができます. 特定の権限は、最初にインストールされるか、CreatePermissionリクエストで更新され、その後ChannelBindリクエストで更新されるか、またはその逆です. 

UDPデータグラムがAllocationの中継トランスポートアドレスに到着すると、サーバーはIPヘッダーからソースIPアドレスを抽出します. 次に、サーバーはこのアドレスを、Allocationのアクセス許可のリストにある各アクセス許可に関連付けられているIPアドレスと比較します. アドレスのみが比較され、ポート番号は考慮されないことに注意してください. 一致するものが見つからない場合、リレーは許可されず、サーバーはUDPデータグラムを通知なしで破棄します. 完全一致が見つかった場合、権限チェックは成功したと見なされ、サーバーは他の場所で指定されているUDPデータグラムの処理を続行します（セクション11.3）. 

1つのAllocationのアクセス許可は、別のAllocationのアクセス許可とはまったく無関係です. Allocationが期限切れになると、そのすべての権限がそれとともに期限切れになります. 

| 注：TURN権限は5分後に期限切れになりますが、多くのNAT | 公開時に展開されたUDPバインディングを期限切れにする| かなり速い. したがって、TURNを使用するアプリケーションは| おそらく、ある種のキープアライブトラフィックを大量に送信したいと思うでしょう. より速いレート. ICEを使用するアプリケーションは、keep- |に従う必要があります の生存ガイドライン[RFC8445]、および使用していないアプリケーション| ICEも同様のことを行うことをお勧めします. 

10. CreatePermission
TURNは、クライアントがサーバーにアクセス許可をインストールまたは更新するための2つの方法をサポートしています. このセクションでは、1つの方法、CreatePermissionリクエストについて説明します. 

CreatePermissionリクエストは、セクション11の送信メカニズムまたはセクション12のチャネルメカニズムと組み合わせて使用​​できます. 

10.1 CreatePermissionリクエストの作成
1つ以上の権限をインストールまたは更新したいクライアントは、CreatePermissionリクエストをサーバーに送信できます. 

CreatePermissionリクエストを作成する場合、クライアントは少なくとも1つのXOR-PEER-ADDRESS属性を含める必要があり、そのような属性を複数含めることができます（MAY）. 各XOR-PEER-ADDRESS属性のIPアドレス部分には、権限をインストールまたは更新する必要があるIPアドレスが含まれています. 各XOR-PEER-ADDRESS属性のポート部分は無視され、任意の値にすることができます. さまざまなXOR-PEER-ADDRESS属性が任意の順序で表示される場合があります. クライアントは、Allocationのために中継されたトランスポートアドレスと同じアドレスファミリのアドレスを持つXOR-PEER-ADDRESS属性のみを含める必要があります. ADDITIONAL-ADDRESS-FAMILY属性を使用して取得した二重Allocationの場合、クライアントはIPv4およびIPv6アドレスファミリのアドレスを持つXOR-PEER-ADDRESS属性を含めることができます（MAY）. 

10.2 CreatePermissionリクエストの受信
サーバーはCreatePermissionリクエストを受信すると、セクション5とここで説明した特定のルールに従って処理します. 

メッセージの有効性がチェックされます. CreatePermissionリクエストには、少なくとも1つのXOR-PEER-ADDRESS属性を含める必要があり、そのような属性を複数含めることができます（MAY）. そのような属性が存在しない場合、またはこれらの属性のいずれかが無効な場合は、400（Bad Request）エラーが返されます. リクエストは有効であるが、容量制限などが原因でサーバーがリクエストを満たすことができない場合は、508（不十分な容量）エラーが返されます. 

XOR-PEER-ADDRESS属性に、AllocationのRelayed Transport Addressと同じではないアドレスファミリのアドレスが含まれている場合、サーバーは443（ピアアドレスファミリミスマッチ）応答コードを含むエラー応答を生成する必要があります. 

サーバーは、XOR-PEER-ADDRESS属性で許可されるIPアドレスに制限を課してもよい（MAY）. 値が許可されていない場合、サーバーはリクエストを403（禁止）エラーで拒否します. 

メッセージが有効であり、サーバーが要求を実行できる場合、サーバーは、セクション9で説明されているように、各XOR-PEER-ADDRESS属性に含まれるIPアドレスの許可をインストールまたは更新します. 各属性のポート部分は、無視され、任意の値にすることができます. 

次に、サーバーはCreatePermission成功応答で応答します. 成功の応答には必須属性はありません. 

| 注：サーバーは、実装するために特別なことをする必要はありません. |を使用したUDPを介したCreatePermissionリクエストのべき等 「ステートレススタックアプローチ」. 再送信されたCreatePermission | リクエストは単に権限を更新します. 

10.3 CreatePermission応答の受信
クライアントが有効なCreatePermission成功応答を受信すると、クライアントはデータ構造を更新して、権限がインストールまたは更新されたことを示します. 

11.送信およびデータメソッド
TURNは、ピアとの間でデータを送受信するための2つのメカニズムをサポートしています. このセクションでは、送信メカニズムとデータメカニズムの使用について説明し、セクション12では、チャネルメカニズムの使用について説明します. 

11.1 送信表示の形成
クライアントは送信指示を使用して、ピアに中継するためにサーバーにデータを渡すことができます. チャネルがそのピアにバインドされている場合でも、クライアントは送信表示を使用できます. ただし、クライアントは、送信指示が送信されているピアのIPアドレスにインストールされている許可があることを確認する必要があります. これにより、第三者がTURNサーバーを使用してデータを任意の宛先に送信することを防ぎます. 

送信指示を形成するとき、クライアントはXOR-PEER-ADDRESS属性とDATA属性を含まなければなりません（MUST）. XOR-PEER-ADDRESS属性には、データの送信先となるピアのトランスポートアドレスが含まれ、DATA属性には、ピアに送信される実際のアプリケーションデータが含まれます. 

クライアントがサーバーにピアに送信されたUDPデータグラムにDFビットを設定することを望む場合、クライアントは送信指示にDONT-FRAGMENT属性を含めることができます. 

11.2 送信表示の受信
サーバーが送信指示を受信すると、セクション5とここで説明した特定のルールに従って処理します. 

メッセージは最初に妥当性がチェックされます. 送信表示には、XOR-PEER-ADDRESS属性とDATA属性の両方が含まれている必要があります. これらの属性の1つが欠落しているか無効である場合、メッセージは破棄されます. DATA属性には0バイトのデータを含めることができることに注意してください. 

送信指示には、DONT-FRAGMENT属性も含まれる場合があります. この属性が存在するときにサーバーが発信UDPデータグラムにDFビットを設定できない場合、サーバーは、DONT-FRAGMENT属性が不明な理解が必要な属性であるかのように動作します（したがって、送信表示は破棄されます）. 

また、サーバーは、XOR-PEER-ADDRESS属性に含まれているIPアドレスに対してインストールされている権限があることを確認します. そのような許可が存在しない場合、メッセージは破棄されます. 送信表示によって、サーバーがアクセス許可を更新することはありません. 

サーバーは、XOR-PEER-ADDRESS属性で許可されるIPアドレスとポート値に制限を課してもよい（MAY）. 値が許可されていない場合、サーバーは送信指示を通知なしで破棄します. 

すべて問題なければ、サーバーは次のようにUDPデータグラムを形成します. 

*ソーストランスポートアドレスは、Allocationの中継トランスポートアドレスです. Allocationは、送信指示が到着した5タプルによって決定されます. 

*宛先トランスポートアドレスはXOR-PEER-ADDRESS属性から取得されます. 

* UDPヘッダーに続くデータは、DATA属性の値フィールドの内容です. 

DONT-FRAGMENT属性（存在する場合）の処理については、セクション14および15で説明します. 

次に、結果のUDPデータグラムがピアに送信されます. 

11.3. UDPデータグラムの受信
サーバーは、現在Allocationられている中継トランスポートアドレスでUDPデータグラムを受信すると、中継トランスポートアドレスに関連付けられているAllocationを検索します. 次に、サーバーは、セクション9で説明されているように、Allocationの一連の権限がUDPデータグラムのリレーを許可するかどうかを確認します. 

リレーが許可されている場合、サーバーは、UDPデータグラムを送信したピアにバインドされたチャネルがあるかどうかをチェックします（セクション12を参照）. チャネルがバインドされている場合、処理はセクション12.7で説明されているように進行します. 

中継は許可されているが、チャネルがピアにバインドされていない場合、サーバーはデータ表示を形成して送信します. データ表示には、XOR-PEER-ADDRESSとDATA属性の両方が含まれている必要があります. DATA属性はデータグラムの「データオクテット」フィールドの値に設定され、XOR-PEER-ADDRESS属性は受信したUDPデータグラムのソーストランスポートアドレスに設定されます. 次に、データ表示は、Allocationに関連付けられた5タプルで送信されます. 

11.4. データ表示の受信
クライアントはデータ表示を受信すると、データ表示にXOR-PEER-ADDRESS属性が含まれていることを確認し、含まれていない場合は表示を破棄します. また、クライアントは、XOR-PEER-ADDRESS属性値に、アクティブなアクセス許可があるとクライアントが信じているIPアドレスが含まれていることを確認し、それ以外の場合はデータ表示を破棄する必要があります. 

| 注：後者のチェックは、攻撃者からクライアントを保護します. サーバーをだましてインストールさせた人| クライアントが望まない権限. 

XOR-PEER-ADDRESSが存在し、有効である場合、クライアントは、データ表示にDATA属性またはICMP属性が含まれていることを確認し、含まれていない場合はその表示を破棄します. DATA属性には0バイトのデータを含めることができることに注意してください. ICMP属性を持つデータ表示の処理については、セクション11.6で説明します. 

データ表示が上記のチェックに合格すると、クライアントはDATA属性内のデータオクテットを、トランスポートアドレスがXOR-PEER-ADDRESS属性で指定されているピアから受信されたという表示とともにアプリケーションに配信します. 

11.5. ICMPパケットの受信
サーバーはICMPパケットを受信すると、タイプがICMPv4 [RFC0792]パケットの場合は3または11、ICMPv6 [RFC4443]パケットの場合は1、2、または3であることを確認します. また、ICMPパケットペイロードのIPパケットにUDPヘッダーが含まれていることも確認します. これらの条件のいずれかが失敗した場合、ICMPパケットは通知なしでドロップされます. UDPヘッダーが存在する場合、サーバーは送信元と宛先のIPアドレスとUDPポート情報を抽出します. 

サーバーは、中継されたトランスポートアドレスがカプセル化されたパケットのソースIPアドレスとUDPポートに対応するAllocationを検索します. そのようなAllocationが存在しない場合、パケットは通知なしでドロップされます. 次に、サーバーは、Allocationの一連のアクセス許可がICMPパケットの中継を許可するかどうかを確認します. ICMPパケットの場合、送信元IPアドレスは、UDPパケットの場合と同様に、許可リストと照合してはならない（MUST NOT）. 代わりに、サーバーはカプセル化されたIPヘッダーから宛先IPアドレスを抽出します. 次に、サーバーはこのアドレスを、Allocationのアクセス許可のリストにある各アクセス許可に関連付けられているIPアドレスと比較します. 一致するものが見つからない場合、中継は許可されず、サーバーはICMPパケットを通知なしで破棄します. アドレスのみが比較され、ポート番号は考慮されないことに注意してください. 

リレーが許可されている場合、サーバーはデータ表示を形成して送信します. データ表示には、XOR-PEER-ADDRESSとICMP属性の両方が含まれている必要があります. ICMP属性は、ICMPパケットのタイプフィールドとコードフィールドの値に設定されます. XOR-PEER-ADDRESS属性のIPアドレス部分は、カプセル化されたIPヘッダーの宛先IPアドレスに設定されます. この仕様の執筆時点では、一部のオペレーティングシステムのソケットAPIは、スーパーユーザー権限なしでは、カプセル化されたUDPヘッダーの宛先ポートをアプリケーションに配信しません. カプセル化されたUDPヘッダーの宛先ポートがサーバーで使用可能な場合、XOR-PEER-ADDRESS属性のポート部分は宛先ポートに設定されます. それ以外の場合、ポート部分はゼロに設定されます. 次に、データ表示は、Allocationに関連付けられた5タプルで送信されます. 

| 実装メモ：新しいICMPタイプまたはコードは、|で定義できます. 将来の仕様. サーバーがICMPエラーを受信した場合| パケット、および新しいタイプまたはコードフィールドは、クライアントが ICMPエラー通知を利用してフィードバックを生成する| アプリケーション層に、サーバーはデータ表示を送信します. 新しいICMPタイプまたはコードを伝えるICMP属性を使用します. 

11.6. ICMP属性を含むデータ表示の受信
クライアントは、ICMP属性を持つデータ表示を受信すると、データ表示にXOR-PEER-ADDRESS属性が含まれていることを確認し、含まれていない場合はその表示を破棄します. クライアントは、XOR-PEER-ADDRESS属性値にアクティブな権限を持つIPアドレスが含まれていることも確認し、それ以外の場合はデータ表示を破棄する必要があります. 

データ表示が上記のチェックに合格した場合、クライアントは、トランスポートアドレスがXOR-PEER-ADDRESS属性で指定されているピアから受信したという表示とともに、エラー状態のアプリケーションに通知します. アプリケーションは、XOR-PEER-ADDRESS属性のファミリーフィールドを使用して、ICMP属性のタイプとコード値の意味を理解できます. 

12.チャネル
チャネルは、クライアントとサーバーがChannelDataメッセージを使用してアプリケーションデータを送信する方法を提供します. これは、送信とデータの指示よりもオーバーヘッドが少ないです. 

ChannelDataメッセージ（セクション12.4を参照）は、チャネル番号を運ぶ2バイトのフィールドで始まります. このフィールドの値は、次のようにAllocationられます. 

     + ------------------------ + ------------------------ -------------- +
     | 0x0000〜0x3FFF：| これらの値は|には決して使用できません. 
     | | チャンネル番号. |
     + ------------------------ + ------------------------ -------------- +
     | 0x4000から0x4FFFまで：| これらの値は許可されるチャネルです. 
     | | 数値（4096の可能な値）. |
     + ------------------------ + ------------------------ -------------- +
     | 0x5000〜0xFFFF：| 予約済み（DTLS-SRTP多重化の場合|
     | | 衝突回避、[RFC7983]を参照）. |
     + ------------------------ + ------------------------ -------------- +
        
表2

チャネル番号の範囲は[RFC5766]との下位互換性がないため、RFC 5766に準拠するクライアントが、この仕様に準拠するTURNサーバーとのチャネルバインディングを確立できない場合があることに注意してください. 

[RFC7983]によると、ChannelDataメッセージは、メッセージの最初のバイトを調べることにより、他の多重化プロトコルと区別できます. 

   + ------------ + ------------------------------------ ------------------ +
   | [0..3] | スタン|
   + ------------ + ------------------------------------ ------------------ +
   | [16..19] | ZRTP |
   + ------------ + ------------------------------------ ------------------ +
   | [20..63] | DTLS |
   + ------------ + ------------------------------------ ------------------ +
   | [64..79] | TURNチャンネル|
   + ------------ + ------------------------------------ ------------------ +
   | [128..191] | RTP / RTCP |
   + ------------ + ------------------------------------ ------------------ +
   | その他| 予約済み. ドロップする必要があります|
   | | とアラートが記録される場合があります. 
   + ------------ + ------------------------------------ ------------------ +
        
表3

予約された値は、将来、他のプロトコルによって使用される可能性があります. クライアントがチャネルバインディングを使用する場合、クライアントは上記で説明した逆多重化スキームに準拠する必要があります. 

チャネルバインディングは常にクライアントによって開始されます. クライアントは、Allocationの有効期間中いつでもチャネルをピアにバインドできます. クライアントは、データを交換する前、または（送信およびデータ表示を使用して）しばらくの間データを交換した後で、チャネルをピアにバインドするか、チャネルをバインドしないことを選択できます. クライアントは、チャネルを他のピアにバインドせずに、チャネルを一部のピアにバインドすることもできます. 

チャネルバインディングはAllocationに固有であるため、あるAllocationのチャネルバインディングでチャネル番号またはピアトランスポートアドレスを使用しても、別のAllocationでの使用には影響しません. Allocationが期限切れになると、そのすべてのチャネルバインディングがそれとともに期限切れになります. 

チャネルバインディングは以下で構成されます. 

*チャネル番号. 

*（ピアの）トランスポートアドレス. そして

*有効期限までのタイマー. 

Allocationのコンテキスト内で、チャネルバインディングは、チャネル番号またはピアのトランスポートアドレスによって一意に識別されます. したがって、同じチャネルを2つの異なるトランスポートアドレスにバインドしたり、同じトランスポートアドレスを2つの異なるチャネルにバインドしたりすることはできません. 

更新されない限り、チャネルバインディングは10分間持続します. （サーバーがChannelBind要求を受信して​​同じピアにチャネルを再バインドすることにより）バインディングを更新すると、有効期限までのタイマーが10分にリセットされます. 

チャネルバインディングの有効期限が切れると、チャネルはバインド解除されます. バインドを解除すると、チャネル番号を別のトランスポートアドレスにバインドでき、トランスポートアドレスを別のチャネル番号にバインドできます. 競合状態を防止するために、クライアントは、チャネルバインディングの有効期限が切れた後、チャネル番号を別のトランスポートアドレスまたはトランスポートアドレスを別のチャネル番号にバインドする前に5分間待機する必要があります. 

チャネルをピアにバインドするとき、クライアントは、ChannelBind要求を送信した直後に、サーバーからチャネル上のChannelDataメッセージを受信する準備をする必要があります. UDPでは、クライアントがChannelBind成功応答を受信する前に、サーバーからChannelDataメッセージを受信する可能性があります. 

逆方向では、クライアントはChannelBind成功応答を受信する前にChannelDataメッセージを送信することを選択できます（MAY）. ただし、そうすることは、ChannelBind要求が何らかの理由（たとえば、要求がUDP経由で送信されるか、サーバーが要求を実行できない場合にパケットが失われる）で成功しない場合、サーバーによってChannelDataメッセージがドロップされるリスクを負います. 安全を希望するクライアントは、チャネルバインディングが確認されるまで、データをキューに入れるか、送信表示を使用する必要があります. 

12.1. ChannelBindリクエストの送信
チャネルバインディングは、ChannelBindトランザクションを使用して作成または更新されます. ChannelBindトランザクションは、ピアに対する許可も作成または更新します（セクション9を参照）. 

ChannelBindトランザクションを開始するために、クライアントはChannelBindリクエストを形成します. バインドされるチャネルはCHANNEL-NUMBER属性で指定され、ピアのトランスポートアドレスはXOR-PEER-ADDRESS属性で指定されます. セクション12.2では、これらの属性の制限について説明します. クライアントは、Allocation用に中継されたトランスポートアドレスと同じアドレスファミリのアドレスを持つXOR-PEER-ADDRESS属性のみを含める必要があります. 

既にバインドされているのと同じトランスポートアドレスにチャネルを再バインドすると、ピアにデータを送信せずにチャネルバインドと対応する権限を更新する方法が提供されます. ただし、権限はチャネルよりも頻繁に更新する必要があることに注意してください. 

12.2. ChannelBindリクエストの受信
サーバーがChannelBindリクエストを受信すると、セクション5とここで説明した特定のルールに従って処理します. 

サーバーは以下をチェックします. 

*リクエストにはCHANNEL-NUMBERとXOR-PEER-ADDRESS属性の両方が含まれています. 

*チャネル番号の範囲は0x4000から0x4FFF（両端を含む）です. 

*現在、チャネル番号は別のトランスポートアドレスにバインドされていません（同じトランスポートアドレスで問題ありません）. 

*現在、トランスポートアドレスは別のチャネル番号にバインドされていません. 

これらのテストのいずれかが失敗すると、サーバーは400（Bad Request）エラーで応答します. XOR-PEER-ADDRESS属性に、Allocationの中継トランスポートアドレスと同じではないアドレスファミリのアドレスが含まれている場合、サーバーは443（ピアアドレスファミリミスマッチ）応答コードを含むエラー応答を生成する必要があります. 

サーバーは、XOR-PEER-ADDRESS属性で許可されるIPアドレスとポート値に制限を課してもよい（MAY）. 値が許可されていない場合、サーバーはリクエストを403（禁止）エラーで拒否します. 

リクエストは有効であるが、サーバーが何らかの容量制限などのためにリクエストを実行できない場合、サーバーは508（不十分な容量）エラーで応答します. 

それ以外の場合、サーバーはChannelBind成功応答で応答します. 成功したChannelBind応答には必須属性はありません. 

サーバーが要求を満たすことができる場合、サーバーはCHANNEL-NUMBER属性のチャネル番号とXOR-PEER-ADDRESS属性のトランスポートアドレスを使用してチャネルバインディングを作成または更新します. サーバーは、セクション9で説明されているように、XOR-PEER-ADDRESS属性のIPアドレスの権限をインストールまたは更新します. 

| 注：サーバーは、実装するために特別なことをする必要はありません. |を使用したUDP経由のChannelBindリクエストのべき等 「ステートレススタックアプローチ」. 再送信されたChannelBindリクエスト| 単にチャネルバインディングと対応する|を更新します. 許可. さらに、クライアントは5分待機する必要があります. 以前にバインドされたチャネル番号またはピアアドレスを|にバインドする 別のチャネル、|の可能性を排除 トランザクションは最初は失敗しますが、|で成功します 再送信. 

12.3. ChannelBind応答の受信
クライアントがChannelBind成功応答を受信すると、クライアントはデータ構造を更新して、チャネルバインディングがアクティブになったことを記録します. また、対応する権限がインストールまたは更新されたことを記録するために、データ構造を更新します. 

クライアントが、チャネル情報がクライアントとサーバーの間で同期していないことを示すChannelBind失敗応答（たとえば、予期しない400 "Bad Request"応答）を受け取った場合、クライアントが直ちにAllocationを削除して開始することが推奨されます. 新しいAllocationで新たに. 

12.4 ChannelDataメッセージ
ChannelDataメッセージは、クライアントとサーバーの間でアプリケーションデータを運ぶために使用されます. 次の形式があります. 

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
   | チャンネル番号| 長さ|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
   | |
   / アプリケーションデータ /
   / /
   | |
   | + ------------------------------- +
   | |
   + ------------------------------- +
        
図5

Channel Numberフィールドは、データが移動しているチャネルの番号を指定します. したがって、データを送信している、または受信するピアのアドレスを指定します. 

Lengthフィールドは、アプリケーションデータフィールドの長さをバイト単位で指定します（つまり、ChannelDataヘッダーのサイズは含みません）. 0は有効な長さであることに注意してください. 

Application Dataフィールドには、クライアントがピアに送信しようとしているデータ、またはピアがクライアントに送信しているデータが含まれています. 

12.5. ChannelDataメッセージの送信
クライアントがチャネルをピアにバインドした後、クライアントがそのピアに送信するデータを持っている場合、クライアントはChannelDataメッセージまたは送信指示を使用できます. つまり、クライアントはチャネルが存在する場合にチャネルを使用する義務がなく、ピアにデータを送信するときに2つのメッセージタイプを自由に混在させることができます. 一方、チャネルがピアにバインドされている場合、サーバーはChannelDataメッセージを使用する必要があります. サーバーはデータ表示を使用して、チャネルがピアにバインドされている場合でも、XOR-PEER-ADDRESSおよびICMP属性をクライアントに通知します. 

ChannelDataメッセージのフィールドは、セクション12.4で説明されているように入力されます. 

TCPおよびTLS-over-TCPでは、後続のメッセージの整列を保証するために、ChannelDataメッセージを4バイトの倍数にパディングする必要があります. パディングはChannelDataメッセージの長さフィールドに反映されないため、ChannelDataメッセージの実際のサイズ（パディングを含む）は（4 +長さ）を最も近い4の倍数に切り上げます（[RFC8489]のセクション14を参照）. UDPでは、パディングは必須ではありませんが、含めることができます. 

次に、ChannelDataメッセージが、Allocationに関連付けられた5タプルで送信されます. 

12.6 ChannelDataメッセージの受信
ChannelDataメッセージの受信側は、最初のバイトを使用して、表3で説明されている他の多重化プロトコルと区別します. メッセージが予約範囲（0x5000〜0xFFFF）の値を使用する場合、メッセージは通知なく破棄されます. 

ChannelDataメッセージがUDPデータグラムで受信され、UDPデータグラムが短すぎてChannelDataメッセージの要求された長さを含めることができない場合（つまり、UDPヘッダー長フィールド値がChannelDataヘッダー長フィールド値+ 4 + 8より小さい場合） ）の場合、メッセージは通知なく破棄されます. 

ChannelDataメッセージがTCPまたはTLS-over-TCP経由で受信された場合、ChannelDataメッセージの実際の長さは、セクション12.5で説明されています. 

ChannelDataメッセージがピアにバインドされていないチャネルで受信された場合、メッセージは通知なく破棄されます. 

クライアントでは、ピアに対するアクティブなアクセス許可がないとクライアントが確信している場合、クライアントがChannelDataメッセージを破棄することをお勧めします. サーバーでは、ChannelDataメッセージの受信は、チャネルバインディングまたはピアへの許可のいずれも更新してはなりません（MUST NOT）. 

サーバーでエラーが検出されない場合、サーバーは次のようにUDPデータグラムを形成することにより、アプリケーションデータをピアに中継します. 

*ソーストランスポートアドレスは、Allocationの中継トランスポートアドレスです. Allocationは、ChannelDataメッセージが到着した5タプルによって決定されます. 

*宛先トランスポートアドレスは、チャネルがバインドされているトランスポートアドレスです. 

* UDPヘッダーに続くデータは、ChannelDataメッセージのデータフィールドの内容です. 

次に、結果のUDPデータグラムがピアに送信されます. ChannelDataメッセージのLengthフィールドが0の場合、UDPデータグラムにはデータがありませんが、UDPデータグラムは引き続き形成および送信されることに注意してください（[RFC6263]のセクション4.1）. 

12.7. ピアからのデータの中継
サーバーは、Allocationに関連付けられた中継トランスポートアドレスでUDPデータグラムを受信すると、セクション11.3で説明されているようにそれを処理します. そのセクションがChannelDataメッセージを送信する必要があることを示す場合（UDPデータグラムに送信されたピアにバインドされたチャネルがあるため）、サーバーはセクション12.5で説明されているようにChannelDataメッセージを形成して送信します. 

サーバーはICMPパケットを受信すると、セクション11.5で説明されているようにそれを処理します. 

13.パケット変換
このセクションでは、IPv4-to-IPv6、IPv6-to-IPv4、およびIPv6-to-IPv6変換について説明します. パケットのIPアドレスとポート番号の変換の要件については、上記で説明しています. 以下のセクションでは、他のヘッダーフィールドを変換する方法を指定します. 

セクション3.6で説明したように、TURNの翻訳は、一般に利用可能なオペレーティングシステムの下でユーザー空間で実行され、特別な権限を必要としないアプリケーションとしてTURNサーバーを実装できるように設計されています. 以下のセクションで指定する翻訳は、この原則に従います. 

以下の説明には、推奨動作と代替動作の2つの部分があります. サーバーは好ましい振る舞いを実装すべきですが、特定のフィールドでそれが不可能な場合、サーバーは代替の振る舞いを実装しなければならず（MUST）、[RFC7915]で詳述されている理由のために他のことをしてはなりません. TURNサーバーは、IPv4ヘッダーのDFビットとIPv6ヘッダーのフラグメントヘッダーのみに依存して、[RFC7915]で説明されているアプローチを使用してフラグメンテーションを処理し、DONT-FRAGMENT属性に依存しません. DONT-FRAGMENT属性を無視することは、UDPからUDPへのリレーにのみ適用され、TCPからUDPへのリレーには適用されません. 

13.1. IPv4-to-IPv6変換
存続可能時間（TTL）フィールド

推奨される動作：[RFC7915]のセクション4で指定されています. 

代替動作：発信パケットのデフォルトに発信値を設定します. 

交通クラス

推奨される動作：[RFC7915]のセクション4で指定されています. 

代替動作：TURNサーバーは、トラフィッククラスを発信パケットのデフォルト値に設定します. 

フローラベル

推奨される動作：TURNサーバーは、Relayed Transport Address、ピアトランスポートアドレス、およびUDPプロトコル番号の5タプルを使用して、各フローを識別し、[RFC6437のセクション3で説明されているように、IPv6パケットでフローラベル値を生成および設定できます.  ]. TURNサーバーがIPv6パケットの5タプルからフローラベル値を生成できない場合、TURNサーバーはフローラベルをゼロに設定します. 

代替動作：代替動作は、フローラベルをサポートしないTURNサーバーの優先動作と同じです. 

ホップ限界

推奨される動作：[RFC7915]のセクション4で指定されています. 

代替動作：TURNサーバーは、発信パケットのホップ制限をデフォルト値に設定します. 

断片化

推奨される動作：[RFC7915]のセクション4で指定されています. 

代替動作：TURNサーバーは着信フラグメントをアセンブルします. TURNサーバーは、デフォルトの動作に従って発信パケットを送信します. 

優先動作と代替動作の両方で、サーバーはDONT-FRAGMENT属性を無視する必要があります. 

拡張ヘッダー

推奨される動作：送信パケットは、前述のフラグメントヘッダーを除いて、IPv6拡張ヘッダーのシステムデフォルトを使用します. 

代替動作：優先と同じ. 

13.2. IPv6-to-IPv6変換
フローラベル

注：TURNサーバーは、2つの異なるIPv6フローを処理していることを考慮する必要があります. したがって、フローラベル[RFC6437]は、翻訳の一部としてコピーするべきではありません. 

推奨される動作：TURNサーバーは、Relayed Transport Address、ピアトランスポートアドレス、およびUDPプロトコル番号の5タプルを使用して、各フローを識別し、[RFC6437のセクション3で説明されているように、IPv6パケットでフローラベル値を生成および設定できます.  ]. TURNサーバーがIPv6パケットの5タプルからフローラベル値を生成できない場合、TURNサーバーはフローラベルをゼロに設定します. 

代替動作：代替動作は、フローラベルをサポートしないTURNサーバーの優先動作と同じです. 

ホップ限界

推奨される動作：TURNサーバーは、ホップ制限を減らし、ICMPv6エラーがゼロに達した場合にICMPv6エラーを生成することに関して、通常のルーターとして機能します. 

代替動作：TURNサーバーは、発信パケットのホップ制限をデフォルト値に設定します. 

断片化

推奨される動作：受信パケットにフラグメントヘッダーが含まれておらず、送信パケットのサイズが送信リンクのMTUを超えていない場合、TURNサーバーはフラグメントヘッダーなしで送信パケットを送信します. 

着信パケットにフラグメントヘッダーが含まれておらず、発信パケットのサイズが発信リンクのMTUを超えている場合、TURNサーバーは発信パケットをドロップし、タイプ2コード0（「パケットが大きすぎます」）のICMPメッセージをの送信者に送信します着信パケット. ICMPv6パケット（「パケットが大きすぎる」）がピアに送信されている場合、TURNサーバーは、ICMPメッセージで報告されるMTUを48バイト削減して、データ表示のオーバーヘッドのためのスペースを確保する必要があります（SHOULD）. 

着信パケットにフラグメントヘッダーが含まれていて、発信パケットのサイズ（フラグメントヘッダーが含まれている）が発信リンクのMTUを超えていない場合、TURNサーバーはフラグメントヘッダー付きの発信パケットを送信します. TURNサーバーは、サーバーから送信されたパケットに応じて、フラグメントヘッダーのフィールドを設定します. 

着信パケットにフラグメントヘッダーが含まれ、発信パケットのサイズが発信リンクのMTUを超える場合、TURNサーバーは発信パケットを1280バイト以下のフラグメントに断片化する必要があります. TURNサーバーは、サーバーから送信されたパケットに応じて、フラグメントヘッダーのフィールドを設定します. 

代替動作：TURNサーバーは着信フラグメントをアセンブルします. TURNサーバーは、デフォルトの動作に従って発信パケットを送信します. 

優先動作と代替動作の両方で、サーバーはDONT-FRAGMENT属性を無視する必要があります. 

拡張ヘッダー

推奨される動作：送信パケットは、前述のフラグメントヘッダーを除いて、IPv6拡張ヘッダーのシステムデフォルトを使用します. 

代替動作：優先と同じ. 

13.3. IPv6-to-IPv4変換
サービスの種類と優先順位

推奨される動作：[RFC7915]のセクション5で指定されています. 

代替動作：TURNサーバーは、送信パケットのタイプオブサービスと優先順位をデフォルト値に設定します. 

有効期間

推奨される動作：[RFC7915]のセクション5で指定されています. 

別の動作：TURNサーバーは、送信パケットの存続時間をデフォルト値に設定します. 

断片化

推奨される動作：[RFC7915]のセクション5で指定されています. さらに、発信パケットのサイズが発信リンクのMTUを超える場合、TURNサーバーはMTUサイズを報告するICMPエラー（ICMPv6 "Packet too big"）を生成する必要があります. ICMPv4パケット（Destination Unreachable（Type 3）with Code 4）がピアに送信されている場合、TURNサーバーは、ICMPメッセージで報告されるMTUを48バイト減らして、データ表示のオーバーヘッドのためのスペースを確保する必要があります. 

代替動作：TURNサーバーは着信フラグメントをアセンブルします. TURNサーバーは、デフォルトの動作に従って発信パケットを送信します. 

優先動作と代替動作の両方で、サーバーはDONT-FRAGMENT属性を無視する必要があります. 

14. UDPからUDPへのリレー
このセクションでは、サーバーがクライアントからピアへ、またはその逆にUDPからUDPへのリレー用にIPヘッダーのさまざまなフィールドを設定する方法について説明します. このセクションの説明は、（a）サーバーがUDPデータグラムをピアに送信するとき、または（b）サーバーがデータ表示またはChannelDataメッセージをUDPトランスポートを介してクライアントに送信するときに適用されます. このセクションの説明は、TCPまたはTLSトランスポートを介してサーバーからクライアントに送信されるTURNメッセージには適用されません. 

以下の説明には、推奨動作と代替動作の2つの部分があります. サーバーは推奨される動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替の動作を実装する必要があります（SHOULD）. 

DiffServコードポイント（DSCP）フィールド[RFC2474]

推奨される動作：サーバーに差別化されたサービス分類子とマーカーが含まれていない限り、発信値を着信値に設定します[RFC2474]. 

代替動作：発信値を固定値に設定します. 特に設定しない限り、デフォルトではベストエフォートです. 

どちらの場合も、サーバーが差別化されたサービスの分類子とマーカーに直接隣接している場合、DSCPは分類子の方向に任意の値に設定できます（MAY）. 

明示的輻輳通知（ECN）フィールド[RFC3168]

推奨される動作：発信値を着信値に設定します. サーバーはアクティブキュー管理を実行できます. その場合、サーバーはECN対応ルーター[RFC3168]として動作し、パケットをドロップする代わりに輻輳経験（CE）でトラフィックをマークできます. ECT（1）の使用は実験的な使用法[RFC8311]の対象となります. 

代替動作：出力値をNot-ECT（= 0b00）に設定します. 

IPv4フラグメンテーションフィールド（IPv4-to-IPv4リレーにのみ適用可能）

推奨される動作：サーバーがDONT-FRAGMENT属性を含む送信指示に応答してピアにパケットを送信する場合、フラグメント化しないように送信UDPパケットを設定します. 他のすべての場合、アプリケーションデータを含む送信パケットを送信するとき（たとえば、データ表示、ChannelDataメッセージ、または送信表示に含まれていないDONT-FRAGMENT属性）、受信パケットのDFビットからDFビットをコピーします. アプリケーションデータが含まれていました. 

サーバーから発信されたパケットに応じて、他のフラグメンテーションフィールド（識別、その他のフラグメント、フラグメントオフセット）を設定します. 

代替動作：推奨される動作で説明したとおり. ただし、着信DFビットが0であると常に想定します. 

優先動作と代替動作の両方で、結果のパケットが発信リンクには大きすぎる可能性があります. この場合、通常の断片化規則が適用されます[RFC1122]. 

IPv4オプション

推奨される動作：発信パケットは、IPv4オプションのシステムデフォルトを使用します. 

代替動作：優先と同じ. 

15. TCPからUDPへのリレー
このセクションでは、サーバーがクライアントからピアへのTCP-to-UDPリレーのIPヘッダーにさまざまなフィールドを設定する方法について説明します. このセクションの説明は、サーバーがUDPデータグラムをピアに送信するときに適用されます. サーバーはTCPからUDPへのリレーのパケット単位の変換を実行しないことに注意してください. 

マルチパスTCP [TCP-EXT]は、このバージョンのTURNではサポートされません. TCPマルチパスは、メディアデータと非メディアデータのSIPまたはWebRTCプロトコル[RFC7478]では使用されないためです. TURNクライアントとサーバー間のTCP接続は、TCP認証オプション（TCP-AO）[RFC5925]を使用できますが、UDPは同様のタイプの認証を提供しませんが、将来[UDP-OPT]で追加される可能性があります. TCP-AOとUDPの両方の認証がTURNクライアントとサーバー間で使用される場合でも、リレーされるアプリケーションペイロードのエンドツーエンドのセキュリティプロパティは変更されません. したがって、TURNを使用するアプリケーションは、アプリケーションデータを適切にエンドツーエンドで保護する必要があります. たとえば、RTPアプリケーションの場合はSecure Real-time Transport Protocol（SRTP）です. TCP-AOオプションはTCP MD5オプションを廃止することに注意してください. 

UDPとは異なり、TCP Fast Open拡張機能なしの[RFC7413]は0-RTTセッション再開をサポートしていません. TURNによってリレーされるアプリケーションデータに相当するTCPユーザータイムアウト[RFC5482]は、RTP制御プロトコル（RTCP）の使用です. 注意として、RTCPはRTPの基本的かつ不可欠な部分です. 

以下の説明には、推奨動作と代替動作の2つの部分があります. サーバーは推奨される動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替の動作を実装する必要があります（SHOULD）. 

TCPトランスポートを介してTURNサーバーに到着するSend IndicationまたはChannelDataメッセージに基づいてピアに送信されるUDPデータグラムの場合、サーバーは次のようにIPヘッダーのさまざまなフィールドを設定します. 

DiffServコードポイント（DSCP）フィールド[RFC2474]

推奨される動作：TCP接続は単一のDSCPのみを使用できるため、フロー間の区別はできません. [RFC7657]のセクション5.1を参照してください. サーバーが差別化されたサービス分類子とマーカー[RFC2474]を含まない限り、サーバーは発信値をTCP接続で使用されるDSCPに設定します. 

代替動作：発信値を固定値に設定します. 特に設定しない限り、デフォルトではベストエフォートです. 

どちらの場合も、サーバーが差別化されたサービスの分類子とマーカーに直接隣接している場合、DSCPは分類子の方向に任意の値に設定できます（MAY）. 

明示的輻輳通知（ECN）フィールド[RFC3168]

推奨される動作：Allocationの発信UDPデータグラムに使用するECN値を示すメカニズムは定義されていません. したがって、発信値をNot-ECT（= 0b00）に設定します. 

代替動作：優先と同じ. 

IPv4フラグメンテーションフィールド（IPv4-to-IPv4リレーにのみ適用可能）

推奨される動作：サーバーがDONT-FRAGMENT属性を含む送信指示に応答してピアにパケットを送信する場合、発信UDPパケットがフラグメント化しないように設定します. それ以外の場合はすべて、アプリケーションデータを含む送信UDPパケットを送信するとき（たとえば、データ表示、ChannelDataメッセージ、または送信表示に含まれていないDONT-FRAGMENT属性）、送信IPヘッダーのDFビットを0に設定します. 

代替動作：優先と同じ. 

IPv6フラグメンテーションフィールド

推奨される動作：TCPトラフィックがIPv6経由で到着した場合、サーバーは送信指示のDONT-FRAGMENT属性の存在に依存して、発信UDPパケットをフラグメント化しないように設定します. 

代替動作：優先と同じ. 

IPv4オプション

推奨される動作：発信パケットは、IPv4オプションのシステムデフォルトを使用します. 

代替動作：優先と同じ. 

16. UDP-to-TCPリレー
このセクションでは、サーバーがピアからクライアントへのUDP-to-TCPリレーのIPヘッダーにさまざまなフィールドを設定する方法について説明します. このセクションの説明は、サーバーがデータ表示またはChannelDataメッセージをTCPまたはTLS トランスポートを介してクライアントに送信するときに適用されます. サーバーはUDPからTCPへのリレーのパケット単位の変換を実行しないことに注意してください. 

以下の説明には、推奨動作と代替動作の2つの部分があります. サーバーは推奨される動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替の動作を実装する必要があります（SHOULD）. 

TURNサーバーは、次のように、TCP接続の接続ごとにTCPパケットのIPヘッダーフィールドを設定します. 

DiffServコードポイント（DSCP）フィールド[RFC2474]

推奨される動作：着信DSCP値を無視します. クライアントとサーバー間でTCPを使用する場合、そのTCP接続のすべてのトラフィックに単一のDSCPを使用する必要があります. TURN / ICEは、アプリケーションデータが交換される前に発生することに注意してください. 

代替動作：優先と同じ. 

明示的輻輳通知（ECN）フィールド[RFC3168]

推奨される動作：無視. ECN信号は、ピアからの着信UDPデータグラムのTURNサーバーでドロップされます. 

代替動作：優先と同じ. 

断片化

推奨される動作：フラグメント化されたパケットはサーバーで再構成され、TCP接続を介してクライアントに転送されます. ピアに送信されたUDPデータグラムから生成されたICMPメッセージは、セクション11.5で説明されているようにサーバーによって処理され、関連するICMPタイプとコードに対するTURNのメカニズムを使用してクライアントに転送されます. 

代替動作：優先と同じ. 

拡張ヘッダー

推奨される動作：発信パケットは、IPv6拡張ヘッダーのシステムデフォルトを使用します. 

代替動作：優先と同じ. 

IPv4オプション

推奨される動作：発信パケットは、IPv4オプションのシステムデフォルトを使用します. 

代替動作：優先と同じ. 

17. STUNメソッド
このセクションでは、この仕様で定義されているSTUNメソッドのコードポイントを示します. これらのメソッドのセマンティクスについては、このドキュメントの他の場所を参照してください. 

           + ------- + ------------------ + ---------------------- -+
           | 0x003 | Allocationる| （リクエスト/レスポンスのみ|
           | | | セマンティクスの定義）|
           + ------- + ------------------ + ---------------------- -+
           | 0x004 | 更新| （リクエスト/レスポンスのみ|
           | | | セマンティクスの定義）|
           + ------- + ------------------ + ---------------------- -+
           | 0x006 | 送信| （表示のみ|
           | | | セマンティクスの定義）|
           + ------- + ------------------ + ---------------------- -+
           | 0x007 | データ| （表示のみ|
           | | | セマンティクスの定義）|
           + ------- + ------------------ + ---------------------- -+
           | 0x008 | CreatePermission | （リクエスト/レスポンスのみ|
           | | | セマンティクスの定義）|
           + ------- + ------------------ + ---------------------- -+
           | 0x009 | ChannelBind | （リクエスト/レスポンスのみ|
           | | | セマンティクスの定義）|
           + ------- + ------------------ + ---------------------- -+
        
表4

18. STUN属性
このSTUN拡張は、次の属性を定義します. 

                  + -------- + --------------------------- +
                  | 0x000C | チャンネル番号|
                  + -------- + --------------------------- +
                  | 0x000D | ライフタイム|
                  + -------- + --------------------------- +
                  | 0x0010 | 予約済み（以前はBANDWIDTH）|
                  + -------- + --------------------------- +
                  | 0x0012 | XOR-PEER-ADDRESS |
                  + -------- + --------------------------- +
                  | 0x0013 | データ|
                  + -------- + --------------------------- +
                  | 0x0016 | XOR-RELAYED-ADDRESS |
                  + -------- + --------------------------- +
                  | 0x0017 | 要求されたアドレスファミリ|
                  + -------- + --------------------------- +
                  | 0x0018 | EVEN-PORT |
                  + -------- + --------------------------- +
                  | 0x0019 | リクエストされたトランスポート|
                  + -------- + --------------------------- +
                  | 0x001A | DONT-FRAGMENT |
                  + -------- + --------------------------- +
                  | 0x0021 | 予約済み（以前はTIMER-VAL）|
                  + -------- + --------------------------- +
                  | 0x0022 | 予約トークン|
                  + -------- + --------------------------- +
                  | 0x8000 | ADDITIONAL-ADDRESS-FAMILY |
                  + -------- + --------------------------- +
                  | 0x8001 | ADDRESS-ERROR-CODE |
                  + -------- + --------------------------- +
                  | 0x8004 | ICMP |
                  + -------- + --------------------------- +
        
表5

これらの属性の一部の長さは4の倍数ではありません. STUNの規則により、長さが4バイトの倍数ではない属性の直後には、次の属性（存在する場合）を確実にするために1から3のパディングバイトが続く必要があります4バイト境界で開始します（[RFC8489]を参照）. 

18.1. チャンネル番号
CHANNEL-NUMBER属性には、チャネルの番号が含まれています. この属性の値の部分は4バイト長で、16ビットの符号なし整数とそれに続く2オクテットのRFFU（予約済み）フィールドで構成されます. 送信時には0に設定し、受信時には無視する必要があります. 

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
   | チャンネル番号| RFFU = 0 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
図6

18.2. 一生
LIFETIME属性は、更新がない場合にサーバーがAllocationを維持する期間を表します. TURNクライアントは、Allocation要求と更新要求に必要なライフタイムを含むLIFETIME属性を含めることができます. この属性の値の部分は4バイト長で、有効期限までの残り秒数を表す32ビットの符号なし整数値で構成されています. 

18.3. XOR-ピア-アドレス
XOR-PEER-ADDRESS属性は、TURNサーバーから見たピアのアドレスとポートを指定します. （たとえば、ピアがNATの背後にある場合、ピアのServer-Reflexive Transport Address）. XOR-MAPPED-ADDRESS属性[RFC8489]と同じ方法でエンコードされます. 

18.4. データ
DATA属性は、すべての送信表示に存在します. ICMP属性がデータ表示に存在しない場合は、DATA属性が含まれています. この属性の値の部分は可変長であり、アプリケーションデータ（つまり、データがクライアントとピアの間で直接送信された場合、UDPヘッダーの直後に続くデータ）で構成されます. アプリケーションデータは「UDPユーザーデータ」に相当し、[UDP-OPT]のセクション4で定義された「余剰領域」を含みません. この属性の長さが4の倍数でない場合は、この属性の後にパディングを追加する必要があります. 

18.5. XORリレーアドレス
XOR-RELAYED-ADDRESS属性は、Allocation応答に存在します. サーバーがクライアントにAllocationたアドレスとポートを指定します. XOR-MAPPED-ADDRESS属性[RFC8489]と同じ方法でエンコードされます. 

18.6. 要求されたアドレス家族
この属性は、クライアントが要求するアドレスの種類を指定するために、Allocation要求と更新要求で使用されます. この属性の値は、次の形式の4バイトです. 

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
   | 家族| 予約済み|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
図7

ファミリ：このフィールドには2つの値が定義され、[RFC8489]のセクション14.1で指定されています. IPv4アドレスの場合は0x01、IPv6アドレスの場合は0x02です. 

予約済み：この時点で、予約済みフィールドの24ビットはクライアントによってゼロに設定されなければならず、サーバーによって無視されなければなりません（MUST）. 

18.7. イーブンポート
この属性により、クライアントは、中継されたトランスポートアドレスのポートが偶数であること、および（オプションで）サーバーが次に大きいポート番号を予約することを要求できます. この属性の値の部分は1バイト長です. その形式は次のとおりです. 

      0
      0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+
     | R | RFFU |
     +-+-+-+-+-+-+-+-+
        
図8

値には1つの1ビットフラグが含まれます. 

R：1の場合、サーバーは次のAllocationのために（同じIPアドレスで）次に大きいポート番号を予約するように要求されます. 0の場合、そのような予約は要求されません. 

RFFU：将来の使用のために予約されています. 

RFFUフィールドは、送信時にはゼロに設定し、受信時には無視する必要があります. 

この属性の長さは4の倍数ではないため、パディングはこの属性の直後に続く必要があります. 

18.8 要求された輸送
この属性は、Allocationられたトランスポートアドレスに対して特定のトランスポートプロトコルを要求するためにクライアントによって使用されます. この属性の値は、次の形式の4バイトです. 

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
   | プロトコル| RFFU |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
図9

「プロトコル」フィールドは、目的のプロトコルを指定します. このフィールドで使用されるコードポイントは、IPv4ヘッダーの[プロトコル]フィールドとIPv6ヘッダー[PROTOCOL-NUMBERS]のNextHeaderフィールドで許可されているものから取得されます. この仕様では、コードポイント17（ユーザーデータグラムプロトコル）のみを使用できます. 

RFFUフィールドは、送信時にゼロに設定する必要があり、受信時には無視する必要があります. 将来の使用のために予約されています. 

18.9 断片化しない
クライアントがこの属性を使用して、アプリケーションデータをピアに中継するときにサーバーがIPヘッダーにDF（Do n't Fragment）ビットを設定することを要求し、Allocation要求でサーバーの機能を決定します. この属性には値の部分がないため、属性の長さフィールドは0です. 

18.10. 予約トークン
RESERVATION-TOKEN属性には、サーバーによって予約されている中継トランスポートアドレスを一意に識別するトークンが含まれています. サーバーは、この属性を成功の応答に含めて、クライアントにトークンを通知します. クライアントは、この属性を後続のAllocate要求に含めて、サーバーがAllocationの中継トランスポートアドレスを使用するように要求します. 

属性値は8バイトで、トークン値が含まれています. 

18.11. 追加の住所家族
この属性は、サーバーからIPv4およびIPv6アドレスタイプのAllocationを要求するためにクライアントによって使用されます. REQUESTED-ADDRESS-FAMILY属性と同じ方法でエンコードされます. セクション18.6を参照してください. ADDITIONAL-ADDRESS-FAMILY属性は、Allocationリクエストに存在する場合があります. 0x02（IPv6アドレス）の属性値は、Allocation要求で唯一有効な値です. 

18.12. アドレスエラーコード
サーバーはこの属性を使用して、要求されたアドレスファミリーをAllocationない理由を通知します. この属性の値の部分は、次の形式の可変長です. 

       0 1 2 3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
      | 家族| 予約済み|クラス| 番号|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
      | 理由フレーズ（可変）..
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
図10

ファミリ：このフィールドには2つの値が定義され、[RFC8489]のセクション14.1で指定されています. IPv4アドレスの場合は0x01、IPv6アドレスの場合は0x02です. 

予約済み：この時点で、予約済みフィールドの13ビットはサーバーによってゼロに設定されなければならず、クライアントによって無視されなければなりません（MUST）. 

クラス：クラスは、エラーコードの数百桁を表し、[RFC8489]のセクション14.8で定義されています. 

番号：この8ビットのフィールドには、サーバーが要求されたアドレスタイプの1つをAllocationることができない理由が含まれています. エラーコードの値は、440（アドレスファミリはサポートされていません）または508（容量不足）のいずれかです. 数値表現は、[RFC8489]のセクション14.8で定義されています. 

理由フレーズ：エラーコード440および508の推奨理由フレーズについては、セクション19で説明します. 理由フレーズは、UTF-8 [RFC3629]でエンコードされた128文字未満のシーケンスである必要があります（エンコード時に509バイトまでの長さにすることができます）またはそれらをデコードするとき763バイト）. 

18.13. ICMP
この属性は、UDPパケットがドロップされた理由を通知するためにサーバーによって使用されます. ICMP属性の形式は次のとおりです. 

       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
      | 予約済み| ICMPタイプ| ICMPコード|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
      | エラーデータ|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
図11

予約済み：このフィールドは送信時に0に設定する必要があり、受信時に無視する必要があります. 

ICMPタイプ：このフィールドには、ICMPタイプの値が含まれます. その解釈は、ICMPがIPv4で受信されたかIPv6で受信されたかによって異なります. 

ICMPコード：このフィールドには、ICMPコードの値が含まれます. その解釈は、ICMPがIPv4で受信されたかIPv6で受信されたかによって異なります. 

エラーデータ：このフィールドサイズは4バイトです. ICMPv6タイプが2（「Packet too big」メッセージ）またはICMPv4タイプが3（Destination Unreachable）で、コードが4（フラグメンテーションが必要で、DFが設定されている）の場合、Error Dataフィールドは次のMaximum Transmission Unitに設定されます.  -hopリンク（[RFC4443]のセクション3.2および[RFC1191]のセクション4）. 他のICMPv6タイプおよびICMPv4タイプとコードの場合、エラーデータフィールドはゼロに設定する必要があります. 

19. STUNエラー応答コード
このドキュメントでは、次のエラー応答コードを定義しています. 

403（禁止）：リクエストは有効でしたが、管理上の制限または同様の制限により実行できません. 

437（Allocation Mismatch）：Allocationを設定する必要があるサーバーによって要求が受信されましたが、Allocationが存在しないか、Allocationが必要ないがAllocationが存在する要求を受信しました. 

440（アドレスファミリはサポートされていません）：サーバーは、クライアントから要求されたアドレスファミリをサポートしていません. 

441（Wrong Credentials）：（Wrong Credentials）：（non-Allocate）request内のクレデンシャルが、Allocationの作成に使用されたものと一致しません. 

442（サポートされていないトランスポートプロトコル）：Allocation要求は、サーバーと、サーバーがサポートしていないピア間でトランスポートプロトコルを使用するようにサーバーに要求しました. 注：これは、5タプルで使用されるトランスポートプロトコルを指すものではありません. 

443（ピアアドレスファミリの不一致）：ピアアドレスは、Allocationの中継されたトランスポートアドレスのアドレスファミリとは異なるアドレスファミリの一部です. 

486（AllocationのAllocationに達しました）：現在、このユーザー名を使用してAllocationを作成することはできません. 

508（容量不足）：容量制限に達したため、サーバーは要求を実行できません. Allocate応答では、サーバーがその時点で中継トランスポートアドレスを使用できなくなっているか、要求されたプロパティが何もないか、または指定された予約トークンに対応するアドレスが使用できないことが原因である可能性があります. 

20.詳細な例
このセクションでは、TURNの使用例を示し、交換されるメッセージの内容を詳細に示します. この例では、概要（図1）に示されているネットワーク図を使用しています. 

メッセージごとに、メッセージに含まれる属性とその値が表示されます. 便宜上、値は実際のオクテットではなく、人間が読める形式で表示されます. たとえば、「XOR-RELAYED-ADDRESS = 192.0.2.15：9000」は、XOR-RELAYED-ADDRESS属性がアドレス192.0.2.15およびポート9000に含まれていることを示しています. ここでは、アドレスとポートがxor-ingが実行される前に表示されています. 文字列のような値を持つ属性（たとえば、SOFTWARE = "Example client、version 1.03"およびNONCE = "obMatJos2gAAAadl7W7PeDU4hKE72jda"）の場合、属性の値は読みやすくするために引用符で示されていますが、これらの引用符は実際の値には表示されません. 

   TURN                                 TURN          Peer         Peer
   client                               server         A            B
     |                                    |            |            |
     |--- Allocate request -------------->|            |            |
     |    Transaction-Id=0xA56250D3F17ABE679422DE85    |            |
     |    SOFTWARE="Example client, version 1.03"      |            |
     |    LIFETIME=3600 (1 hour)          |            |            |
     |    REQUESTED-TRANSPORT=17 (UDP)    |            |            |
     |    DONT-FRAGMENT                   |            |            |
     |                                    |            |            |
     |<-- Allocate error response --------|            |            |
     |    Transaction-Id=0xA56250D3F17ABE679422DE85    |            |
     |    SOFTWARE="Example server, version 1.17"      |            |
     |    ERROR-CODE=401 (Unauthorized)   |            |            |
     |    REALM="example.com"             |            |            |
     |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
     |                                    |            |            |
     |--- Allocate request -------------->|            |            |
     |    Transaction-Id=0xC271E932AD7446A32C234492    |            |
     |    SOFTWARE="Example client 1.03"  |            |            |
     |    LIFETIME=3600 (1 hour)          |            |            |
     |    REQUESTED-TRANSPORT=17 (UDP)    |            |            |
     |    DONT-FRAGMENT                   |            |            |
     |    USERNAME="George"               |            |            |
     |    REALM="example.com"             |            |            |
     |    NONCE="obMatJos2gAAAadl7W7PeDU4hKE72jda"     |            |
     |    PASSWORD-ALGORITHMS=MD5 and SHA256           |            |
     |    PASSWORD-ALGORITHM=SHA256       |            |            |
     |    MESSAGE-INTEGRITY=...           |            |            |
     |    MESSAGE-INTEGRITY-SHA256=...    |            |            |
     |                                    |            |            |
     |<-- Allocate success response ------|            |            |
     |    Transaction-Id=0xC271E932AD7446A32C234492    |            |
     |    SOFTWARE="Example server, version 1.17"      |            |
     |    LIFETIME=1200 (20 minutes)      |            |            |
     |    XOR-RELAYED-ADDRESS=192.0.2.15:50000         |            |
     |    XOR-MAPPED-ADDRESS=192.0.2.1:7000            |            |
     |    MESSAGE-INTEGRITY-SHA256=...    |            |            |

                                 Figure 12



クライアントは、最初にTURNセッションに使用するホストトランスポートアドレスを選択します. この例では、クライアントは図1に示すように198.51.100.2:49721を選択しています. 次に、クライアントはサーバートランスポートアドレスでサーバーにAllocation要求を送信します. クライアントは、このトランザクションに対して0xA56250D3F17ABE679422DE85の96ビットトランザクションIDをランダムに選択します. これは、固定ヘッダーのトランザクションIDフィールドでエンコードされます. クライアントには、クライアントのソフトウェアに関する情報を提供するSOFTWARE属性が含まれています. ここでは、値は「サンプルクライアント、バージョン1.03」であり、これは「サンプルクライアント」と呼ばれるバージョン1.03であることを示しています. クライアントにはLIFETIME属性が含まれています. これは、Allocationがデフォルトの10分よりも長い有効期間を持つことを望んでいるためです. この属性の値は3600秒です. これは1時間に相当します. クライアントは常にREQUESTED-TRANSPORT属性をAllocateリクエストに含める必要があります. この仕様で許可される唯一の値は17で、サーバーとピア間のUDPトランスポートを示します. 送信指示の後半でDONT-FRAGMENT属性を使用したいため、クライアントにはDONT-FRAGMENT属性も含まれています. この属性は属性ヘッダーのみで構成されます. 価値のある部分はありません. クライアントが最近サーバーと対話していないことを想定しています. したがって、クライアントには、USERNAME、USERHASH、REALM、NONCE、PASSWORD-ALGORITHMS、PASSWORD-ALGORITHM、MESSAGE-INTEGRITY、またはMESSAGE-INTEGRITY-SHA256属性は含まれません. 最後に、メッセージの属性の順序は任意です（MESSAGE-INTEGRITY、MESSAGE-INTEGRITY-SHA256、およびFINGERPRINT属性を除く）. 

サーバーは、要求を認証する必要があります. したがって、サーバーは最初のAllocate要求を受信すると、要求に認証属性が含まれていないため、要求を拒否します. STUN [RFC8489]の長期資格情報メカニズムの手順に従って、サーバーには401（Unauthorized）の値を持つERROR-CODE属性、サーバーが使用する認証Realmを指定するREALM属性（この場合、サーバーのドメイン "example.com"）、およびNONCE属性のnonce値. NONCE属性は、STUNセキュリティ機能の「パスワードアルゴリズム」ビットが1に設定された「ノンスCookie」で始まります. サーバーには、サーバーが長期パスワードを導出するために使用できるアルゴリズムのリストを指定するPASSWORD-ALGORITHMS属性が含まれています. サーバーがSTUNセキュリティ機能の「ユーザー名の匿名性」ビットを1に設定した場合、クライアントは、Allocation要求のUSERNAME属性の代わりにUSERHASH属性を使用して、ユーザー名を匿名化します. サーバーには、サーバーのソフトウェアに関する情報を提供するソフトウェア属性も含まれています. 

クライアントは401エラーを受信すると、今回は認証属性を含めて、Allocation要求を再試行します. クライアントは新しいトランザクションIDを選択し、新しいAllocateリクエストに以前と同じ属性を設定します. クライアントにはUSERNAME属性が含まれており、サーバーから受け取ったRealm値を使用して、使用する値を決定します. ここでは、クライアントは、Realm「example.com」にユーザー名「George」を使用するように構成されています. クライアントには、サーバーが長期パスワードを取得するために使用する必要があるアルゴリズムを示すPASSWORD-ALGORITHM属性が含まれています. クライアントには、401エラー応答からコピーされたREALM、PASSWORD-ALGORITHMS、およびNONCE属性も含まれています. 最後に、クライアントには、メッセージの最後の属性としてMESSAGE-INTEGRITY-SHA256属性が含まれます. その値は、ハッシュメッセージ認証コード-メッセージのコンテンツに対するセキュアハッシュアルゴリズム2（HMAC-SHA2）ハッシュ（上記の「...」として示されています） ）; このHMAC-SHA2計算にはパスワード値が含まれます. したがって、攻撃者は何らかの方法で秘密のパスワードを知らなければ、メッセージの整合性の値を計算できません. 

サーバーは、認証されたAllocateリクエストを受信すると、すべてがOKであることを確認し、Allocationを作成します. サーバーはAllocate成功応答で応答します. サーバーには、Allocationの有効期間を示すLIFETIME属性が含まれています. ここでは、サーバーはクライアントの要求された1時間の有効期間を20分に短縮しています. これは、この特定のサーバーが20分を超える有効期間を許可していないためです. サーバーにはXOR-RELAYED-ADDRESS属性が含まれており、その値はAllocationの中継トランスポートアドレスです. サーバーにはXOR-MAPPED-ADDRESS属性が含まれており、その値はクライアントのサーバー再帰アドレスです. この値は他の場合はTURNでは使用されませんが、クライアントの便宜のために返されます. サーバーにはMESSAGE-INTEGRITY-SHA256属性が含まれており、応答を認証して完全性を保証します. 応答には、USERNAME、REALM、およびNONCE属性が含まれていないことに注意してください. サーバーには、SOFTWARE属性も含まれています. 

   TURN TURNピアピア
   クライアントサーバーAB
     | --- CreatePermissionリクエスト------> | | |
     | Transaction-Id = 0xE5913A8F460956CA277D3319 | |
     | XOR-PEER-ADDRESS = 192.0.2.150：0 | | |
     | USERNAME = "George" | | |
     | REALM = "example.com" | | |
     | NONCE = "obMatJos2gAAAadl7W7PeDU4hKE72jda" | |
     | PASSWORD-ALGORITHMS = MD5およびSHA256 | |
     | PASSWORD-ALGORITHM = SHA256 | | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
     | | | |
     | <-CreatePermission成功レスポンス-| | |
     | Transaction-Id = 0xE5913A8F460956CA277D3319 | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
        
図13

次に、クライアントは、アプリケーションデータを送信する準備として、ピアAに対する許可を作成します. これはCreatePermissionリクエストを通じて行われます. XOR-PEER-ADDRESS属性には、許可が確立されているIPアドレス（ピアAのIPアドレス）が含まれます. 属性のポート番号はCreatePermissionリクエストで使用されると無視され、ここでは0に設定されていることに注意してください. また、クライアントがピアAのサーバー再帰IPアドレスを使用し、その（プライベート）ホストアドレスを使用していないことにも注意してください. クライアントは、Allocationに関する前回のリクエストと同じユーザー名、Realm、ノンス値を使用します. 許可されていますが、クライアントはこのリクエストにソフトウェア属性を含めないことを選択しています. 

サーバーはCreatePermissionリクエストを受信し、対応する権限を作成してから、CreatePermission成功レスポンスで応答します. クライアントと同様に、サーバーは応答にSOFTWARE属性を含めないことを選択します. ここでも、成功応答にMESSAGE-INTEGRITY-SHA256属性が含まれていることに注意してください（サーバーが長期資格情報メカニズムを使用している場合）. ただし、USERNAME、REALM、およびNONCE属性は含まれていません. 

   TURN TURNピアピア
   クライアントサーバーAB
     | ---表示を送信---------------> | | |
     | Transaction-Id = 0x1278E9ACA2711637EF7D3328 | |
     | XOR-PEER-ADDRESS = 192.0.2.150：32102 | |
     | DONT-FRAGMENT | | |
     | DATA = ... | | |
     | |-UDP dgm-> | |
     | | データ= ... | |
     | | | |
     | | <-UDP dgm-| |
     | | データ= ... | |
     | <-データ表示---------------- | | |
     | Transaction-Id = 0x8231AE8F9242​​DA9FF287FEFF | |
     | XOR-PEER-ADDRESS = 192.0.2.150：32102 | |
     | DATA = ... | | |
        
図14

クライアントは、送信表示を使用してアプリケーションデータをピアAに送信します. ピアAのServer-Reflexive Transport AddressはXOR-PEER-ADDRESS属性で指定され、アプリケーションデータ（ここでは単に「...」として示されています）はDATA属性で指定されています. クライアントはアプリケーション層でパスMTUディスカバリーの形式を実行しているため、サーバーがピアに送信するためにUDPデータグラムのDFビットを設定する必要があることを（DONT-FRAGMENT属性を含めることによって）指定します. STUNの長期資格情報メカニズムを使用して表示を認証することはできないため、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性はメッセージに含まれていません. データが変更されたり偽造されたりしないことを保証するアプリケーションは、アプリケーションレベルでデータを整合性保護する必要があります. 

送信指示を受信すると、サーバーはアプリケーションデータを抽出し、UDPデータグラムでピアAに送信します. 中継されたトランスポートアドレスはデータグラムのソーストランスポートアドレスとして、DFビットは要求どおりに設定されています. クライアントがピアAのサーバー再帰IPアドレスのアクセス許可を以前に確立していなかった場合、サーバーは送信指示を代わりに静かに破棄していたことに注意してください. 

次に、ピアAは、アプリケーションデータを含む独自のUDPデータグラムで応答します. データグラムは、サーバー上の中継されたトランスポートアドレスに送信されます. これが到着すると、サーバーは、XOR-PEER-ADDRESS属性のUDPデータグラムのソースとDATA属性のUDPデータグラムからのデータを含むデータ表示を作成します. 次に、結果のデータ表示がクライアントに送信されます. 

   TURN TURNピアピア
   クライアントサーバーAB
     | --- ChannelBindリクエスト-----------> | | |
     | Transaction-Id = 0x6490D3BC175AFF3D84513212 | |
     | CHANNEL-NUMBER = 0x4000 | | |
     | XOR-PEER-ADDRESS = 192.0.2.210：49191 | |
     | USERNAME = "George" | | |
     | REALM = "example.com" | | |
     | NONCE = "obMatJos2gAAAadl7W7PeDU4hKE72jda" | |
     | PASSWORD-ALGORITHMS = MD5およびSHA256 | |
     | PASSWORD-ALGORITHM = SHA256 | | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
     | | | |
     | <-ChannelBind成功応答--- | | |
     | Transaction-Id = 0x6490D3BC175AFF3D84513212 | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
        
図15

これで、クライアントはチャネルをピアBにバインドし、CHANNEL-NUMBER属性で空きチャネル番号（0x4000）を指定し、XOR-PEER-ADDRESS属性でピアBのトランスポートアドレスを指定します. 以前と同様に、クライアントはユーザー名、Realm、メッセージの最後のリクエストからのナンスを再利用します. 

要求を受信すると、サーバーはチャネル番号をピアにバインドし、ピアBのIPアドレスのアクセス許可をインストールしてから、ChannelBind成功応答を返します. 

   TURN TURNピアピア
   クライアントサーバーAB
     | --- ChannelData ------------------> | | |
     | チャネル番号= 0x4000 | --- UDPデータグラム---------> |
     | データ= ... | データ= ... |
     | | | |
     | | <-UDPデータグラム---------- |
     | | データ= ... | |
     | <-ChannelData ------------------- | | |
     | チャネル番号= 0x4000 | | |
     | データ= ... | | |
        
図16

これで、クライアントはピアB宛てのデータとともにChannelDataメッセージをサーバーに送信します. ChannelDataメッセージはSTUNメッセージではありません. したがって、トランザクションIDはありません. 代わりに、チャネル番号、データ、データ長の3つのフィールドしかありません. ここでは、チャネル番号フィールドは0x4000（クライアントがピアBにバインドしたばかりのチャネル）です. サーバーはChannelDataメッセージを受信すると、チャネルが現在バインドされている（バインドされている）ことを確認し、Relayed Transport Addressをソーストランスポートアドレスとして使用してピアBにデータを送信します.  ：49191（ChannelBindリクエストのXOR-PEER-ADDRESS属性の値）を宛先トランスポートアドレスとして指定します. 

その後、ピアBはUDPデータグラムを中継されたトランスポートアドレスに送り返します. これにより、サーバーは、UDPデータグラムからのデータを含むChannelDataメッセージをクライアントに送信します. サーバーは、UDPデータグラムが到着した中継トランスポートアドレスが原因でChannelDataメッセージを送信するクライアントを認識し、これが192.0.2.210:49191にバインドされているチャネルであるため、チャネル0x4000を使用することを認識しています. そのアドレスにバインドされたチャネル番号がなかった場合、サーバーは代わりにデータ表示を使用したことに注意してください. 

   TURN TURNピアピア
   クライアントサーバーAB
     | --- ChannelBindリクエスト-----------> | | |
     | Transaction-Id = 0xE5913A8F46091637EF7D3328 | |
     | CHANNEL-NUMBER = 0x4000 | | |
     | XOR-PEER-ADDRESS = 192.0.2.210：49191 | |
     | USERNAME = "George" | | |
     | REALM = "example.com" | | |
     | NONCE = "obMatJos2gAAAadl7W7PeDU4hKE72jda" | |
     | PASSWORD-ALGORITHMS = MD5およびSHA256 | |
     | PASSWORD-ALGORITHM = SHA256 | | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
     | | | |
     | <-ChannelBind成功応答--- | | |
     | Transaction-Id = 0xE5913A8F46091637EF7D3328 | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
        
図17

更新されない限り、チャネルバインディングは10分間持続します. TURNクライアントは、チャネルを同じピア（ピアBのIPアドレス）に再バインドするChannelBind要求を送信して、バインディングを更新します. サーバーはChannelBind要求を処理し、チャネルを同じピアに再バインドし、有効期限までのタイマーを10分にリセットします. 

   TURN TURNピアピア
   クライアントサーバーAB
     | ---更新リクエスト---------------> | | |
     | Transaction-Id = 0x0864B3C27ADE9354B4312414 | |
     | SOFTWARE = "Example client 1.03" | | |
     | USERNAME = "George" | | |
     | REALM = "example.com" | | |
     | NONCE = "oobMatJos2gAAAadl7W7PeDU4hKE72jda" | |
     | PASSWORD-ALGORITHMS = MD5およびSHA256 | |
     | PASSWORD-ALGORITHM = SHA256 | | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
     | | | |
     | <-エラー応答の更新--------- | | |
     | Transaction-Id = 0x0864B3C27ADE9354B4312414 | |
     | SOFTWARE = "Example server、version 1.17" | |
     | ERROR-CODE = 438（古いナンス）| | |
     | REALM = "example.com" | | |
     | NONCE = "obMatJos2gAAAadl7W7PeDU4hKE72jda" | |
     | PASSWORD-ALGORITHMS = MD5およびSHA256 | |
     | | | |
     | ---更新リクエスト---------------> | | |
     | Transaction-Id = 0x427BD3E625A85FC731DC4191 | |
     | SOFTWARE = "Example client 1.03" | | |
     | USERNAME = "George" | | |
     | REALM = "example.com" | | |
     | NONCE = "obMatJos2gAAAadl7W7PeDU4hKE72jda" | |
     | PASSWORD-ALGORITHMS = MD5およびSHA256 | |
     | PASSWORD-ALGORITHM = SHA256 | | |
     | MESSAGE-INTEGRITY-SHA256 = ... | | |
     | | | |
     | <-成功の応答を更新します------- | | |
     | Transaction-Id = 0x427BD3E625A85FC731DC4191 | |
     | SOFTWARE = "Example server、version 1.17" | |
     | LIFETIME = 600（10分）| | |
     | MESSAGE-INTEGRITY = ... | | |
        
図18

20分のライフタイムがアップする前のある時点で、クライアントはAllocationを更新します. これは、更新要求を使用して行われます. 以前と同様に、クライアントは最新のユーザー名、Realm、ノンス値をリクエストに含めます. クライアントにはSOFTWARE属性も含まれています. この属性は常に、Allocationメッセージと更新メッセージにこの属性を含めることをお勧めします. サーバーは更新要求を受信すると、nonce値の有効期限が切れていることに気づき、新しいnonce値が与えられると438（Stale Nonce）エラーで応答します. 次に、クライアントはリクエストを再試行しますが、今回は新しいnonce値を使用します. この2回目の試行は受け入れられ、サーバーは成功の応答を返します. クライアントがリクエストにLIFETIME属性を含めなかったことに注意してください. 

21.セキュリティに関する考慮事項
このセクションでは、TURN展開で発生する可能性のある攻撃について検討し、プロトコルのメカニズムまたは実装の推奨プラクティスによってそれらがどのように軽減されるかについて説明します. 

TURNへの攻撃のほとんどは、リクエストの認証を要求するサーバーによって軽減されます. したがって、この仕様では認証を使用する必要があります. 必須から実装までのメカニズムは、STUNの長期的な認証メカニズムです. 同等またはより強力なセキュリティプロパティの他の認証メカニズムを使用できます. ただし、相互運用可能な方法でそれらを呼び出すことができるようにすることが重要です. 

21.1. 部外者の攻撃
部外者による攻撃とは、攻撃者がシステムに資格情報を持たず、クライアントまたはサーバーから見たサービスを妨害しようとする攻撃です. 

21.1.1. 不正なAllocationの取得
攻撃者は、悪意のある目的のためにTURNサーバーでAllocationを取得したい場合があります. TURNサーバーは、クライアントの実際のIPアドレスを隠蔽しながらパケットを送受信するメカニズムを提供します. このため、TURNサーバーを使用して本当のIDをマスクする攻撃者にとって魅力的なターゲットになります. 

攻撃者は、TURNサーバーのサービスにお金を払うことなく、単にそれらのサービスを利用したい場合もあります. TURNサービスはプロバイダーからのリソースを必要とするため、その使用にはコストがかかることが予想されます. 

これらの攻撃は、長期の資格情報メカニズムを使用して防止されます. これにより、TURNサーバーはリクエスタのIDと、リクエスタがAllocationを取得できるかどうかを判断できます. 

21.1.2. オフライン辞書攻撃
TURNで使用される長期的な認証メカニズムは、オフラインの辞書攻撃の影響を受けます. クライアントとサーバー間のメッセージ交換を傍受できる攻撃者は、複数の候補パスワードを試し、そのうちの1つが正しいかどうかを確認することにより、パスワードを特定できます. この攻撃は、パスワードが辞書の単語のようにエントロピーが低い場合に機能します. この攻撃は、エントロピーが大きい強力なパスワードを使用することで軽減できます. さらに強力な緩和が必要な状況では、クライアントとサーバー間の（D）TLSトランスポートを使用できます. 

21.1.3. 偽の更新と権限
攻撃者は、アクティブなAllocationを削除してクライアントへのサービスを中断させるために、すぐに期限切れになる更新リクエストを送信してアクティブなAllocationを攻撃する可能性があります. これは、リフレッシュの認証によって防止されます. 同様に、望ましくない宛先へのアクセス許可を作成するためのCreatePermissionリクエストを送信しようとする攻撃者は、認証を介してこれを行うことができません. このような攻撃の動機については、21.2項を参照してください. 

21.1.4. 偽のデータ
攻撃者は、クライアントまたはピアに、それぞれピアまたはクライアントから送信されたかのようにデータを送信したい場合があります. これを行うには、攻撃者はクライアントに偽のデータ表示またはChannelDataメッセージを送信するか、TURNサーバーに偽の送信表示またはChannelDataメッセージを送信します. 

インジケーションとChannelDataメッセージは認証されないため、この攻撃はTURNによって防止されません. ただし、この攻撃は一般にIPベースの通信に存在し、TURNによって大幅に悪化することはありません. ホストAとB間の通常のTURN以外のIPセッションを考えてみます. 攻撃者は、偽装されたIPアドレスAを使用してパケットをBに送信することにより、パケットをAから送信されたかのようにBに送信できます. この攻撃では、攻撃者がIP AおよびBのアドレス. TURNを使用して、データ表示を使用してクライアントにパケットを送信しようとする攻撃者は、そのIPアドレス（およびポート）、TURNサーバーのIPアドレスとポート、およびIPアドレスとポートを知る必要があります. ピア（XOR-PEER-ADDRESS属性に含めるため）. 偽のChannelDataメッセージをクライアントに送信するには、攻撃者はクライアントのIPアドレスとポートを知っている必要があります. TURNサーバーのIPアドレスとポート、およびチャネル番号. この特定の組み合わせは、TURN以外の場合よりも少し推測可能です. 

これらの攻撃は、アプリケーション層の認証技術によってより適切に軽減されます. リアルタイムトラフィックの場合、SRTP [RFC3711]を使用すると、これらの攻撃を防止できます. 

状況によっては、クライアントが直接送信できないホストに送信できるように、TURNサーバーがネットワークに配置されている場合があります. これは、たとえば、サーバーがファイアウォールの背後にあり、ファイアウォールの外側からのパケットをサーバーに配信できるが、ファイアウォールの背後にある他のホストには配信できない場合に発生する可能性があります. これらの状況では、攻撃者は、ファイアウォールの背後にある他のホストの1つのトランスポートアドレスを含むXOR-PEER-ADDRESS属性を含む送信指示をサーバーに送信する可能性があります. サーバーが任意のピアへのトラフィックの中継を許可する場合、これは攻撃者がファイアウォールの背後にある任意のホストを攻撃する方法を提供します. 

この攻撃を緩和するために、TURNでは、クライアントがホストにデータを送信する前に、ホストへの許可を確立する必要があります. したがって、攻撃者は、認証された要求を作成できない限り、クライアントがすでに通信しているホストのみを攻撃できます. さらに、サーバー管理者は、サーバーがデータを中継するIPアドレスとポートの範囲を制限するようにサーバーを構成する場合があります. さらに優れたセキュリティを提供するために、サーバー管理者は、クライアントとサーバー間のすべての通信にクライアントが（D）TLSを使用することを要求できます. 

21.1.5. サーバーの偽装
クライアントは、TURNサーバーからリレーされたアドレスを学習すると、アプリケーションプロトコルでそのリレーされたアドレスを使用してトラフィックを受信します. したがって、そのトラフィックを傍受またはリダイレクトしようとする攻撃者は、TURNサーバーになりすまして、偽の中継アドレスをクライアントに提供しようとする可能性があります. 

この攻撃は、サーバーから送信されたものであることを確認することに加えて、応答のメッセージの整合性を提供する長期資格情報メカニズムによって防止されます. さらに、STUNヘッダーのトランザクションIDがこれを防ぐため、攻撃者は古いサーバー応答を再生できません. ナンス値を頻繁に変更することにより、リプレイ攻撃はさらに阻止されます. 

21.1.6. 盗聴トラフィック
TURNクライアントとサーバーがサードパーティ認証のためのSTUN拡張[RFC7635]を使用している場合（たとえば、WebRTCで使用されている場合）、ユーザー名は実際のユーザーのIDを明らかにしません. USERNAME属性は、一時的な一意のキー識別子を保持します. TURNクライアントとサーバーがSTUN長期資格情報メカニズムを使用し、ユーザー名が実際のユーザーのIDを明らかにする場合、クライアントはユーザー名を匿名化するためにUSERNAME属性の代わりにUSERHASH属性を使用するか、クライアント間で（D）TLSトランスポートを使用する必要がありますとサーバー. 

TURNクライアントとサーバーがSTUN長期資格情報メカニズムを使用し、Realm情報がプライバシーに敏感な場合、TURNは（D）TLSで実行できます. 注意として、サードパーティ認証のためのSTUN拡張はRealmを使用しません. 

SOFTWARE属性は、TURNクライアントとサーバーの特定のソフトウェアバージョンを盗聴者に明らかにする可能性があり、セキュリティの脆弱性が含まれていることがわかっている脆弱なソフトウェアに対する攻撃を許可する可能性があります. ソフトウェアのバージョンにセキュリティの脆弱性が含まれていることがわかっている場合は、（D）TLSを介してTURN SHOULDを実行し、クリアテキストのソフトウェア属性のリークを防止する必要があります. ソフトウェアバージョンでゼロデイ脆弱性が検出された場合は、エンドポイントポリシーを変更して、パッチを適用して欠陥を修正するまで（D）TLSの使用を義務付けることができます. 

TURNは、主に認証とメッセージの整合性に関係しています. TURN制御メッセージには、USERNAME、REALM、およびSOFTWAREを除いて特に機密性の高い情報が含まれていないため、機密性は二次的な問題にすぎません. メッセージの主要なプロトコルコンテンツは、ピアのIPアドレスです. TURN接続の盗聴者がこれを学習しないようにすることが重要な場合は、（D）TLSでTURNを実行できます. 

TURN over（D）TLSを実行してもサーバーとピア間のアプリケーションデータは保護されないため、TURNによってリレーされるアプリケーションデータの機密性は、アプリケーションプロトコル自体によって提供されるのが最適です. アプリケーションデータの機密性が重要な場合、アプリケーションはデータを暗号化するか、保護する必要があります. たとえば、リアルタイムメディアの場合、SRTPを使用して機密性を提供できます. 

21.1.7. ターンループ攻撃
攻撃者は、2つのTURNサーバー間でデータパケットを無期限にループさせる可能性があります. 攻撃は次のように行われます. 最初に、攻撃者はサーバーBの送信元アドレスを使用してサーバーAにAllocation要求を送信します. サーバーAはその応答をサーバーBに送信し、攻撃を成功させるためには、攻撃者は次のいずれかを行う必要があります. 攻撃者がAllocationられた中継トランスポートアドレスを知ることができるように、この応答の内容を表示または推測します. 次に、攻撃者はサーバーAのソースアドレスを使用してサーバーBにAllocation要求を送信します. ここでも、攻撃者はAllocationられた中継トランスポートアドレスを知ることができるように、応答の内容を表示または推測できる必要があります. 同じスプーフィングされたソースアドレス技術を使用して、

結果は、サーバーAのRelayed Transport AddressからサーバーBのRelayed Transport Addressにループし、次にサーバーBのトランスポートアドレスからサーバーAのトランスポートアドレスにループし、その後再びループするデータパケットです. 

この攻撃は次のように軽減されます. すべての要求の認証を要求したり、中継されたトランスポートアドレスにAllocationられたポート番号をランダム化したりすることにより、サーバーは攻撃者に第三者に送信された応答を傍受または表示するように強制します（この場合、攻撃者が要求を認証し、中継されたトランスポートアドレスを知ることができるようにするため. これらの2つの対策のいずれかがなければ、攻撃者は応答を見る必要なく応答の内容を推測できるため、攻撃の実行がはるかに簡単になります. さらに、認証された要求を要求することにより、サーバーは攻撃者にサーバーに受け入れられる資格情報を要求します. これにより、これは部外者の攻撃から内部者の攻撃に変わり、攻撃を開始したクライアントまで追跡できます. 

他のAllocationに対するこの攻撃の影響を制限するために、そのユーザー名が所有するAllocationによってデータを中継するために使用される帯域幅にユーザー名ごとの制限を課すことにより、攻撃をさらに軽減できます. データパケットをリレーするときにTTLをデクリメントすることで、より多くの緩和策を実現で​​きます（基盤となるOSで許可されている場合）. 

21.2. ファイアウォールに関する考慮事項
TURNのセキュリティに関する重要な考慮事項は、クライアントとTURNサーバーの間に配置されたファイアウォールによって提供される保護を弱めるべきではないということです. TURNサーバーは公共のインターネット上に存在することが多く、クライアントは企業のファイアウォールを備えた企業ネットワーク内にあることが予想されます. TURNサーバーが企業に到達するための「バックドア」を提供する場合、TURNはこれらのファイアウォールによってブロックされます. 

したがって、TURNサーバーは、アドレス依存フィルタリング[RFC4787]を実装するNATデバイスの動作をエミュレートします. これは、多くのファイアウォールにも共通のプロパティです. NATまたはファイアウォールがこの動作を実装すると、内部IPアドレスとポートが最近その外部IPアドレスにパケットを送信した場合にのみ、外部IPアドレスからのパケットを内部IPアドレスとポートに送信できます. TURNサーバーでは、許可の概念が導入されています. これにより、TURNサーバーでまったく同じ動作が提供されます. クライアントが攻撃者に最初に連絡を試みない限り、攻撃者はパケットをTURNサーバーに送信して、クライアントに向けて中継されることを期待できません. 

一部のファイアウォールには、アドレス依存のフィルタリングよりもさらに制限の厳しいポリシーがあることに注意することが重要です. ファイアウォールは、アドレスとポートに依存するフィルタリングで構成することも、受信トラフィックを完全に禁止するように構成することもできます. これらの場合、クライアントがTURNサーバーへの接続を許可されていると、クライアントへの通信はファイアウォールが通常許可するものよりも制限が少なくなります. 

21.2.1. 偽の権限
ファイアウォールとNATデバイスでは、ネットワークの内部から外部のピアに向かうパケットの通過を通じて、権限が暗黙的に付与されます. したがって、ファイアウォールまたはNATの内部にあるエンティティを除いて、定義によってアクセス許可を作成することはできません. TURNを使用すると、この制限はなくなります. TURNサーバーはファイアウォールの外側にあるため、ファイアウォールの外側にいる攻撃者はTURNサーバーにメッセージを送信し、自分自身のアクセス許可を作成することができます. 

アクセス許可を作成するすべてのメッセージ（つまり、ChannelBindとCreatePermission）が認証されるため、この攻撃は防止されます. 

21.2.2. ブラックリストに登録されたIPアドレス
多くのファイアウォールには、ファイアウォールの背後にあるクライアントがブラックリストに登録されたIPアドレスの範囲にパケットを送信したり、IPアドレスの範囲からパケットを受信したりできないようにするブラックリストを設定できます. これは、ファイアウォールに出入りするパケットの送信元アドレスと宛先アドレスをそれぞれ検査することによって行われます. 

TURNサーバーはリレー先のピアのアドレスの範囲を任意に制限できるため、この機能はTURNにも存在します. 

21.2.3. 既知のポートでのサーバーの実行
ファイアウォールの背後にある悪意のあるクライアントは、TURNサーバーに接続して、サーバーの実行に使用するAllocationを取得しようとする可能性があります. たとえば、クライアントがDNSサーバーまたはFTPサーバーを実行しようとする場合があります. 

これはTURNでは不可能です. TURNサーバーは、クライアントが権限をインストールしていないピアからのトラフィックを決して受け入れません. したがって、ピアはサービスを取得するためにAllocationられたポートに接続することはできません. 

21.3. インサイダー攻撃
インサイダー攻撃では、クライアントは正当な資格情報を持っていますが、それらの資格情報に伴う信頼関係を否定します. これらの攻撃は暗号化の手段では防止できませんが、プロトコルの設計で考慮する必要があります. 

21.3.1. TURN Serverに対するDoS
他のクライアントへのサービスを中断したいクライアントは、Allocationを取得し、それをトラフィックでフラッディングして、サーバーを圧迫し、他の正当なクライアントにサービスを提供できないようにする可能性があります. これは、サーバーが特定のユーザー名に対してリレーする帯域幅の量を制限するという推奨事項によって緩和されます. これにより、クライアントが大量のトラフィックを送信するのを防ぐことはできませんが、サーバーは超過したトラフィックをすぐに破棄できます. 

各AllocationはTURNサーバーのIPアドレスのポート番号を使用するため、サーバー上のAllocationの数は有限です. 攻撃者は、大量のAllocationを要求することにより、それらすべてを消費しようとする可能性があります. これは、サーバーが特定のユーザー名に対して一度にアクティブなAllocationの数に制限を課すという推奨事項によって防止されます. 

21.3.2. 悪意のあるトラフィックの匿名中継
TURNサーバーはある程度の匿名化を提供します. クライアントは、自身のIPアドレスを明かさずにデータをピアに送信できます. したがって、TURNサーバーは、攻撃者が検出を恐れずにターゲットに対して攻撃を仕掛けるための魅力的な手段になる可能性があります. 実際、ターゲットがパケットを受信する前に任意の数のリレーを使用できるように、クライアントが複数のTURNサーバーをチェーンすることが可能です. 

この攻撃を心配している管理者は、クライアントの実際のソースIPとポート、さらにはクライアントがインストールするすべての権限をキャプチャするログを維持できます. これにより、攻撃がTURNサーバーを介して中継されていることが発見された場合に、フォレンジックトレースで元のソースを特定できます. 

21.3.3. その他のAllocationの操作
攻撃者は、（送信元アドレスのスプーフィングによって）TURNサーバーの別のユーザーから送信されているように見えるリフレッシュ要求またはCreatePermission要求を送信することにより、TURNサーバーの他のユーザーへのサービスを妨害しようとする可能性があります. TURNは、CreatePermission、Refresh、およびChannelBindメッセージで使用される資格情報が、初期Allocationの作成に使用される資格情報と一致することを要求することで、これを防ぎます. したがって、攻撃者からの偽のリクエストは拒否されます. 

21.4. トンネル増幅攻撃
攻撃者は、TURNサーバーとIPv4とIPv6の間のトンネルの間でデータパケットを何度もループさせる可能性があります. 攻撃は次のようになります. 

攻撃者がトンネルエンドポイントが特定のIPv6アドレスからカプセル化されたパケットを転送することを知っているとします（これは必ずしもトンネルエンドポイントのアドレスである必要はありません）. 次に、このアドレスから2つのパケットをスプーフィングするとします. 

1. v4アドレスを要求するAllocateリクエスト、および

2.トンネルエンドポイントのIPv4アドレスへのチャネルを確立するChannelBind要求. 

次に、増幅攻撃を設定しました. 

* TURNサーバーはIPv6 UDPデータをv4に再カプセル化し、トンネルエンドポイントに送信します. 

*トンネルエンドポイントは、v4インターフェイスからのパケットのカプセル化を解除し、v6に送信します. 

したがって、攻撃者が次の形式のパケットを送信した場合：

IPv6：src = 2001：DB8：1 :: 1 dst = 2001：DB8 :: 2 UDP：<ポート> TURN：<チャネルID> IPv6：src = 2001：DB8：1 :: 1 dst = 2001：DB8 :: 2 UDP：<ポート> TURN：<チャネルID> IPv6：src = 2001：DB8：1 :: 1 dst = 2001：DB8 :: 2 UDP：<ポート> TURN：<チャネルID> ...

図19

次に、TURNサーバーとトンネルエンドポイントは、最後のTURNヘッダーが消費されるまで、前後に送信します. この時点で、TURNサーバーは、トンネルエンドポイントがドロップする空のパケットを送信します. 

ここでの増幅の可能性はMTUによって制限されるため、それほど大きくはありません. IPv6+ UDP + TURNは334バイトかかるため、1500バイトのパケットから4対1の増幅が可能です. ただし、攻撃者は、複数のパケットを送信するか、同じトンネルエンドポイントの背後にある異なるアドレスから偽装された複数のチャネルを確立することにより、トラフィック量を増加させる可能性があります. 

攻撃は次のように軽減されます. TURNサーバーは、トンネリングされることがわかっているアドレスからのAllocationまたはチャネルバインディング要求を受け入れないこと、およびそのようなアドレスにデータを転送しないことをお勧めします. 特に、TURNサーバーはこれらの要求でTeredoまたは6to4アドレスを受け入れてはなりません（MUST NOT）. 

21.5. その他の考慮事項
Allocate要求によって学習されたリレーアドレスは、トランスポートモードまたはトンネルモードのIPsec認証ヘッダー（AH）[RFC4302]で正しく動作しません. ただし、トンネルモードのIPsecカプセル化セキュリティペイロード（ESP）[RFC4303]は引き続き動作するはずです. 

22. IANAに関する考慮事項
この仕様で定義されているSTUNメソッドのコードポイントはセクション17にリストされています. IANAは[RFC5766]からこのドキュメントへの参照を更新しました（セクション17にリストされているSTUNメソッドについて）. 

この仕様で定義されているSTUN属性のコードポイントはセクション18にリストされています. IANAは、[RFC5766]からこのドキュメントへの参照を更新しました（STUN属性のCHANNEL-NUMBER、LIFETIME、予約済み（BANDWIDTHでした）、XOR-PEER- ADDRESS、DATA、XOR-RELAYED-ADDRESS、REQUESTED-ADDRESS-FAMILY、EVEN-PORT、REQUESTED-TRANSPORT、DONT-FRAGMENT、予約済み（以前はTIMER-VAL）、およびRESERVATION-TOKEN（セクション18に記載）. 

この仕様で定義されているSTUNエラーコードのコードポイントはセクション19にリストされています. IANAは[RFC5766]および[RFC6156]からこのドキュメントへの参照を更新しました（セクション19にリストされているSTUNエラーコード用）. 

IANAは、[RFC5766]への参照をこのドキュメントに更新して、TURN over UDPまたはTCPの「turn」のSRVサービス名と、TURN over（D）TLSの「turns」のサービス名を示しました. 

IANAはTURNチャネル番号のレジストリ（「NAT（TURN）チャネル番号の周りのリレーを使用したトラバーサル」レジストリ）を作成し、最初は次のように入力されています. 

   + ------------------------ + ------------------------ ------------------ +
   | 0x0000から| 予約済みのため、使用できません|
   | 0x3FFF：| それらはSTUNヘッダーと競合します. |
   + ------------------------ + ------------------------ ------------------ +
   | 0x4000から| TURN実装は無料で使用できます. 
   | 0x4FFF：| この範囲のチャネル番号. |
   + ------------------------ + ------------------------ ------------------ +
   | 0x5000から| 予約済み（DTLS-SRTP多重化の場合|
   | 0xFFFF：| 衝突回避、[RFC7983]を参照）|
   + ------------------------ + ------------------------ ------------------ +
        
表6

このレジストリの変更は、IETF標準アクションを通じて行う必要があります. 

23. IABに関する考慮事項
IABは、クライアントが共同プロトコルリフレクションメカニズム[RFC3424]を介して、NATの反対側にある別のRealmでアドレスを決定しようとする一般的なプロセスである、ユニラテラルセルフアドレスフィックス（UNSAF）の問題を調査しました. TURN拡張は、このタイプの機能を実行するプロトコルの例です. IABは、この目的のために開発されたすべてのプロトコルが特定の一連の考慮事項を文書化することを義務付けています. これらの考慮事項とTURNに対する応答は、このセクションに記載されています. 

考慮事項1：UNSAF提案で解決される特定の範囲限定問題の正確な定義. 短期的な修正は、他の問題を解決するために一般化されるべきではありません. このような一般化により、想定された短期的な修正への依存と使用が長期化します. つまり、これを「短期的」と呼ぶことはもはや正確ではなくなります. 

応答：TURNは、リレー（= TURNサーバー）とそのクライアント間の通信のためのプロトコルです. このプロトコルにより、NATの背後にあるクライアントは、リレー上のパブリックIPアドレスを取得して使用できます. クライアントの利便性として、TURNはクライアントがServer-Reflexive Transport Addressを決定することもできます. 

考慮事項2：出口戦略/移行計画の説明. 適切なテクノロジーが導入されるにつれて、より良い短期的な修正は、当然ながら使用がますます少なくなる修正です. 

応答：NATがなくなると、TURNは不要になります. 残念ながら、このドキュメントの発行日現在、NATがすぐになくなることはほとんどありません. ただし、エンドポイントに依存しないマッピング[RFC4787]のマッピングプロパティを持つNATの数が増えると、TURNの必要性も減少します. 

考慮事項3：システムをより「脆弱」にする可能性のある特定の問題についての議論. たとえば、複数のネットワークレイヤーでデータを使用するアプローチでは、依存関係が増え、デバッグの課題が増え、移行が困難になります. 

応答：TURNは、クライアントとサーバー間のNATバインディングをAllocationの存続期間中、変更せずに維持する必要があるという点で「脆弱」です. これは通常、キープアライブを使用して行われます. これを行わないと、クライアントはAllocationを失い、ピアとデータを交換できなくなります. 

考慮事項4：長期的で健全な技術ソリューションの要件を特定します. 適切な長期的な解決策を見つけるプロセスに貢献する. 

応答：NATが[RFC4787]で文書化されているNAT UDP動作の推奨事項を実装すると、TURNの必要性は減少します. アプリケーションはまた、ICE [RFC8445]を使用してピアと通信することを強くお勧めします. ICEはTURNを使用しますが、これは最後の手段としてのみ使用し、制御された方法で使用します. 

考慮事項5：展開された既存のNATと経験報告で指摘された実際的な問題の影響についての議論. 

応答：現在展開されている一部のNATは、エンドポイントに依存しないマッピング以外のマッピング動作を示します. これらのNATは、ICEなどのプロトコルがこれらのNATでServer-Reflexive Transport Addressを使用することを困難または不可能にするため、操作が困難です. このようなNATの背後にあるクライアントは、「UDPホールパンチング」技術[RFC5128]が機能しないため、TURNのようなリレープロトコルを使用せざるを得ないことがよくあります. 

24. RFC 5766以降の変更
このセクションでは、元の[RFC5766]仕様からのTURNプロトコルの主な変更点を示します. 

* IPv6サポート. 

* REQUESTED-ADDRESS-FAMILY属性. 

*トンネル増幅攻撃の説明. 

* DTLSサポート. 

* ICMPパケットを受信するためのサポートを追加します. 

* PMTUDを更新します. 

* TURNサーバーの検出. 

* TURN URIスキームのセマンティクス. 

* TURNのハッピーアイボール. 

* STUN [RFC8489]の変更に合わせます. 

25. RFC 6156の更新
このセクションでは、この仕様における[RFC6156]の主要な更新を示します. 

* ADDITIONAL-ADDRESS-FAMILYおよびADDRESS-ERROR-CODE属性. 

* 440（アドレスファミリはサポートされていません）および443（ピアアドレスファミリの不一致）応答. 

*パケット変換の詳細. 

* TCP-to-UDPおよびUDP-to-TCPリレー. 

26.リファレンス
26.1. 規範的な参考文献
[PROTOCOL-NUMBERS] IANA、「プロトコル番号」、<https://www.iana.org/assignments/protocol-numbers>. 

[RFC0792] Postel、J. 、「インターネット制御メッセージプロトコル」、STD 5、RFC 792、DOI 10.17487 / RFC0792、1981年9月、<https://www.rfc-editor.org/info/rfc792>. 

[RFC1122] Braden、R. 、編、「インターネットホストの要件-通信層」、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<https://www.rfc-editor.org/info/ rfc1122>. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>. 

[RFC2474] Nichols、K.、Blake、S.、Baker、F. 、およびD. Black、「IPv4およびIPv6ヘッダーのDiffServフィールド（DSフィールド）の定義」、RFC 2474、DOI 10.17487 / RFC2474、 1998年12月、<https://www.rfc-editor.org/info/rfc2474>. 

[RFC3168]ラマクリシュナン、K. 、フロイド、S. 、およびD.ブラック、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<https：// www.  rfc-editor.org/info/rfc3168>. 

[RFC3629] Yergeau、F. 、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/ rfc3629>. 

[RFC4443] Conta、A.、Deering、S. 、およびM. Gupta、編、「インターネットプロトコルバージョン6（IPv6）仕様のためのインターネット制御メッセージプロトコル（ICMPv6）」、STD 89、RFC 4443、DOI 10.17487 / RFC4443、2006年3月、<https://www.rfc-editor.org/info/rfc4443>. 

[RFC6347] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>. 

[RFC6437] Amante、S.、Carpenter、B.、Jiang、S. 、およびJ. Rajahalme、「IPv6 Flow Label Specification」、RFC 6437、DOI 10.17487 / RFC6437、2011年11月、<https：//www.rfc- editor.org/info/rfc6437>. 

[RFC7065] Petit-Huguenin、M.、Nandakumar、S.、Salgueiro、G. 、およびP. Jones、「NAT（TURN）Uniform Resource Identifiersのリレーを使用したトラバーサル」、RFC 7065、DOI 10.17487 / RFC7065、2013年11月、 <https://www.rfc-editor.org/info/rfc7065>. 

[RFC7350] Petit-Huguenin、M. およびG. Salgueiro、「NATのセッショントラバーサルユーティリティ（STUN）のトランスポートとしてのデータグラムトランスポート層セキュリティ（DTLS）」、RFC 7350、DOI 10.17487 / RFC7350、2014年8月、<https：/ /www.rfc-editor.org/info/rfc7350>. 

[RFC7525] Sheffer、Y.、Holz、R. 、およびP. Saint-Andre、「Transport Layer Security（TLS）およびDatagram Transport Layer Security（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<https://www.rfc-editor.org/info/rfc7525>. 

[RFC7915] Bao、C.、Li、X.、Baker、F.、Anderson、T. 、およびF. Gont、「IP / ICMP変換アルゴリズム」、RFC 7915、DOI 10.17487 / RFC7915、2016年6月、<https： //www.rfc-editor.org/info/rfc7915>. 

[RFC7982] Martinsen、P.、Reddy、T.、Wing、D. 、およびV. Singh、「NATのセッショントラバーサルユーティリティ（STUN）を使用した往復時間とフラクショナルロスの測定」、RFC 7982、DOI 10.17487 / RFC7982、2016年9月、<https://www.rfc-editor.org/info/rfc7982>. 

[RFC8174] Leiba、B. 、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>. 

[RFC8200] Deering、S. およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487 / RFC8200、2017年7月、<https://www.rfc-editor.org / info / rfc8200>. 

[RFC8305] Schinazi、D. およびT. Pauly、「Happy Eyeballs Version 2：Better Connectivity Using Concurrency」、RFC 8305、DOI 10.17487 / RFC8305、2017年12月、<https://www.rfc-editor.org/info/ rfc8305>. 

[RFC8446] Rescorla、E. 、「The Transport Layer Security（TLS）Protocol Version 1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>. 

[RFC8489] Petit-Huguenin、M.、Salgueiro、G.、Rosenberg、J.、Wing、D.、Mahy、R.、and P. Matthews、 "Session Traversal Utilities for NAT（STUN）"、RFC 8489、DOI 10.17487 / RFC8489、2020年2月、<https://www.rfc-editor.org/info/rfc8489>. 

26.2. 参考情報
[FRAG-FRAGILE] Bonica、R.、Baker、F.、Huston、G.、Hinden、R.、Troan、O. 、およびF. Gont、「壊れそうなIPフラグメンテーション」、進行中の作業、インターネットドラフト、 draft-ietf-intarea-frag-fragile-17、2019年9月30日、<https://tools.ietf.org/html/draft-ietf-intarea-frag-fragile-17>. 

[FRAG-HARMFUL]ケント、CおよびJ.モーグル、「フラグメンテーションは有害と見なされる」、1987年12月、<https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-87-3.pdf> . 

[MTU-DATAGRAM] Fairhurst、G.、Jones、T.、Tuexen、M.、Ruengeler、I. 、およびT. Voelker、「データグラムトランスポートのパケット化レイヤーパスMTU検出」、進行中の作業、インターネットドラフト、ドラフト-ietf-tsvwg-datagram-plpmtud-14、2020年2月12日、<https://tools.ietf.org/html/draft-ietf-tsvwg-datagram-plpmtud-14>. 

[MTU-STUN] Petit-Huguenin、M.、Salgueiro、G. 、およびF. Garrido、「NAT用のセッショントラバーサルユーティリティ（STUN）を使用したUDPトランスポートのパケット化レイヤーパスMTU検出（PLMTUD）」、作業中、インターネット-Draft、draft-ietf-tram-stun-pmtud-15、2019年12月17日、<https://tools.ietf.org/html/draft-ietf-tram-stun-pmtud-15>. 

[ポート番号] IANA、「サービス名とトランスポートプロトコルのポート番号レジストリ」、<https://www.iana.org/assignments/port-numbers>. 

[RFC0791] Postel、J. 、「インターネットプロトコル」、STD 5、RFC 791、DOI 10.17487 / RFC0791、1981年9月、<https://www.rfc-editor.org/info/rfc791>. 

[RFC1191] Mogul、J. およびS. Deering、「Path MTU discovery」、RFC 1191、DOI 10.17487 / RFC1191、1990年11月、<https://www.rfc-editor.org/info/rfc1191>. 

[RFC1918] Rekhter、Y.、Moskowitz、B.、Karrenberg、D.、de Groot、GJ、およびE. Lear、「プライベートインターネットのアドレスAllocation」、BCP 5、RFC 1918、DOI 10.17487 / RFC1918、1996年2月、 <https://www.rfc-editor.org/info/rfc1918>. 

[RFC1928] Leech、M.、Ganis、M.、Lee、Y.、Kuris、R.、Koblas、D. 、およびL. Jones、「SO​​CKS Protocol Version 5」、RFC 1928、DOI 10.17487 / RFC1928、1996年3月、<https://www.rfc-editor.org/info/rfc1928>. 

[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. 、およびE. Schooler、「SIP：Session Initiation Protocol」 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>. 

[RFC3424]ダイグル、L. 、エド. とIAB、「ネットワークアドレス変換を介したUNilateral Self-Address Fixing（UNSAF）ARF考慮事項」、RFC 3424、DOI 10.17487 / RFC3424、2002年11月、<https://www.rfc-editor.org/info/rfc3424>. 

[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R. 、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <https://www.rfc-editor.org/info/rfc3550>. 

[RFC3711]バウアー、M. 、マクルー、D. 、ナスルンド、M. 、カララ、E. 、およびK.ノーマン、「The Secure Real-time Transport Protocol（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、March 2004、<https://www.rfc-editor.org/info/rfc3711>. 

[RFC4086] Eastlake 3rd、D.、Schiller、J.、and S. Crocker、 "Randomness Requirements for Security"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、June 2005、<https：//www.rfc-editor .org / info / rfc4086>. 

[RFC4302]ケント、S. 、「IP認証ヘッダー」、RFC 4302、DOI 10.17487 / RFC4302、2005年12月、<https://www.rfc-editor.org/info/rfc4302>. 

[RFC4303]ケント、S. 、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、DOI 10.17487 / RFC4303、2005年12月、<https://www.rfc-editor.org/info/rfc4303>. 

[RFC4787]オーデ、F、エド. およびC.ジェニングス、「ユニキャストUDPのネットワークアドレス変換（NAT）動作要件」、BCP 127、RFC 4787、DOI 10.17487 / RFC4787、2007年1月、<https://www.rfc-editor.org/info/rfc4787> . 

[RFC4821] Mathis、M. およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<https://www.rfc-editor.org/info/rfc4821>. 

[RFC5128] Srisuresh、P.、Ford、B. 、およびD. Kegel、「State of Peer-to-Peer（P2P）Communication through Network Address Translators（NATs）」、RFC 5128、DOI 10.17487 / RFC5128、March 2008、 <https://www.rfc-editor.org/info/rfc5128>. 

[RFC5482] Eggert、L. およびF. Gont、「TCPユーザータイムアウトオプション」、RFC 5482、DOI 10.17487 / RFC5482、2009年3月、<https://www.rfc-editor.org/info/rfc5482>. 

[RFC5766] Mahy、R.、Matthews、P. 、およびJ. Rosenberg、「NATのリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）」、RFC 5766、DOI 10.17487 / RFC5766、4月2010、<https://www.rfc-editor.org/info/rfc5766>. 

[RFC5925] Touch、J.、Mankin、A. 、およびR. Bonica、「The TCP Authentication Option」、RFC 5925、DOI 10.17487 / RFC5925、2010年6月、<https://www.rfc-editor.org/info / rfc5925>. 

[RFC5928] Petit-Huguenin、M. 、「NAT（TURN）解決メカニズムの周りのリレーを使用したトラバーサル」、RFC 5928、DOI 10.17487 / RFC5928、2010年8月、<https://www.rfc-editor.org/info/rfc5928 >. 

[RFC6056] Larsen、M. およびF. Gont、「Recommendations for Transport-Protocol Port Randomization」、BCP 156、RFC 6056、DOI 10.17487 / RFC6056、2011年1月、<https://www.rfc-editor.org/info / rfc6056>. 

[RFC6062] Perreault、S.、Ed. およびJ. Rosenberg、「TCPAllocationのためのNAT（TURN）拡張の周りのリレーを使用したトラバーサル」、RFC 6062、DOI 10.17487 / RFC6062、2010年11月、<https://www.rfc-editor.org/info/rfc6062>. 

[RFC6156] Camarillo、G.、Novo、O. 、およびS. Perreault、編、「NAT（TURN）Extension for IPv6のリレーを使用したトラバーサル」、RFC 6156、DOI 10.17487 / RFC6156、2011年4月、<https：/ /www.rfc-editor.org/info/rfc6156>. 

[RFC6263] Marjou、X. およびA. Sollaud、「RTP / RTP制御プロトコル（RTCP）フローに関連付けられたNATマッピングを維持するためのアプリケーションメカニズム」、RFC 6263、DOI 10.17487 / RFC6263、2011年6月、<https：// www.rfc-editor.org/info/rfc6263>. 

[RFC7413] Cheng、Y.、Chu、J.、Radhakrishnan、S. 、およびA. Jain、「TCP Fast Open」、RFC 7413、DOI 10.17487 / RFC7413、2014年12月、<https：//www.rfc-editor .org / info / rfc7413>. 

[RFC7478] Holmberg、C.、Hakansson、S. 、およびG. Eriksson、「Web Real-Time Communication Use Cases and Requirements」、RFC 7478、DOI 10.17487 / RFC7478、2015年3月、<https：//www.rfc- editor.org/info/rfc7478>. 

[RFC7635] Reddy、T.、Patil、P.、Ravindranath、R. 、およびJ. Uberti、「サードパーティ認証のためのNAT（STUN）拡張用のセッショントラバーサルユーティリティ」、RFC 7635、DOI 10.17487 / RFC7635、2015年8月、<https://www.rfc-editor.org/info/rfc7635>. 

[RFC7657]ブラック、D. 、エド. およびP.ジョーンズ、「Differentiated Services（Diffserv）and Real-Time Communication」、RFC 7657、DOI 10.17487 / RFC7657、2015年11月、<https://www.rfc-editor.org/info/rfc7657>. 

[RFC7983] Petit-Huguenin、M. およびG. Salgueiro、「データグラムトランスポート層セキュリティ（DTLS）のセキュアリアルタイムトランスポートプロトコル（SRTP）拡張のための多重化方式の更新」、RFC 7983、DOI 10.17487 / RFC7983、2016年9月、 <https://www.rfc-editor.org/info/rfc7983>. 

[RFC8155] Patil、P.、Reddy、T. 、およびD. Wing、「NAT（TURN）サーバー自動検出の周りのリレーを使用したトラバーサル」、RFC 8155、DOI 10.17487 / RFC8155、2017年4月、<https：// www.  rfc-editor.org/info/rfc8155>. 

[RFC8311]ブラック、D. 、「明示的な輻輳通知（ECN）実験に関する制限の緩和」、RFC 8311、DOI 10.17487 / RFC8311、2018年1月、<https://www.rfc-editor.org/info/rfc8311>. 

[RFC8445] Keranen、A.、Holmberg、C. 、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、< https://www.rfc-editor.org/info/rfc8445>. 

[SDP-ICE] Petit-Huguenin、M.、Nandakumar、S.、Holmberg、C.、Keranen、A.、and R. Shpount、 "Session Description Protocol（SDP）Offer / Answer procedure for Interactive Connectivity Establishment（ICE） "、Work in Progress、Internet-Draft、draft-ietf-mmusic-ice-sip-sdp-39、2019年8月13日、<https://tools.ietf.org/html/draft-ietf-mmusic-ice-sip -sdp-39>. 

[SEC-WEBRTC] Rescorla、E. 、「WebRTCのセキュリティに関する考慮事項」、Work in Progress、Internet-Draft、draft-ietf-rtcweb-security-12、2019年7月5日、<https://tools.ietf.org/ html / draft-ietf-rtcweb-security-12>. 

[TCP-EXT] Ford、A.、Raiciu、C.、Handley、M.、Bonaventure、O. 、およびC. Paasch、「複数のアドレスを持つマルチパス操作のためのTCP拡張機能」、作業中、インターネットドラフト、ドラフト-ietf-mptcp-rfc6824bis-18、2019年6月8日、<https://tools.ietf.org/html/draft-ietf-mptcp-rfc6824bis-18>. 

[UDP-OPT] Touch、J. 、「UDPのトランスポートオプション」、Work in Progress、Internet-Draft、draft-ietf-tsvwg-udp-options-08、2019年9月12日、<https：//tools.ietf.  org / html / draft-ietf-tsvwg-udp-options-08>. 

謝辞

このメモのテキストのほとんどは、元のTURN仕様[RFC5766]からのものです. 元のTURN仕様の共著者であるRohan Mahyと、そのドキュメントに貢献してくれたすべての人に感謝します. 著者はまた、この文書が[RFC6156]から材料を継承することを認めたいと思います. 

ADDITIONAL-ADDRESS-FAMILYメカニズムに関する支援をしてくれたJustin Uberti、Pal Martinsen、Oleg Moskalenko、Aijun Wang、およびSimon Perreaultに感謝します. 著者は、ゴンザロ・サルゲイロ、サイモン・ペロー、ジョナサン・レノックス、ブランドン・ウィリアムズ、カール・スタール、ノリユキ・トリイ、ニルス・オールマイヤー、ダン・ウィング、ビジェイ・グルバニ、ジョセフ・タッチ、ジャスティン・ウベルティ、クリストファー・ウッド、ローマン・ダニーリウ、エリック・ヴィンケ、アダム・ローチに感謝します、Suresh Krishnan、Mirja Kuehlewind、Benjamin Kaduk、Oleg Moskalenkoのコメントとレビュー. 著者は、テキストへの貢献に対してMarc Petit-Hugueninに感謝します. 

詳細なADレビューをしてくれたMagnus Westerlundに特に感謝します. 

著者のアドレス

Tirumaleswar Reddy（editor）McAfee、Inc. Embassy Golf Link Business Park Ba​​ngalore 560071 Karnataka India

   メール：kondtir@gmail.com
        
アラン・ジョンストン（編集者）Villanova University Villanova、PAアメリカ合衆国

   メール：alan.b.johnston@gmail.com
        
フィリップマシューズアルカテルルーセント600マーチロードオタワオンタリオカナダ

   メール：philip_matthews@magma.ca
        
ジョナサン・ローゼンバーグjdrosen.netエジソン、ニュージャージー州アメリカ合衆国

   メール：jdrosen@jdrosen.net
   URI：http://www.jdrosen.net
        