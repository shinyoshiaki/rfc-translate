RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
4960
RFC 4960-ストリーム制御伝送プロトコル
URL：https://tools.ietf.org/html/rfc4960
タイトル：RFC 4960-Stream Control Transmission Protocol
翻訳編集：自動生成
ネットワークワーキンググループR.スチュワート、エド. 
コメントの要求：4960 2007年9月
廃止：2960、3309
カテゴリ：標準化過程
        
ストリーム制御伝送プロトコル

このメモのステータス

このドキュメントは、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します. このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください. このメモの配布は無制限です. 

概要

このドキュメントはRFC 2960とRFC 3309を廃止します. ストリーム制御伝送プロトコル（SCTP）について説明します. SCTPは、公衆交換電話網（PSTN）シグナリングメッセージをIPネットワーク経由で転送するように設計されていますが、より広範なアプリケーションに対応できます. 

SCTPは、IPなどのコネクションレス型パケットネットワーク上で動作する信頼性の高いトランスポートプロトコルです. ユーザーに次のサービスを提供します. 

-ユーザーデータのエラーのない重複のない転送を認め、

-検出されたパスMTUサイズに準拠するためのデータの断片化、

-複数のストリーム内でのUser messageの順次配信、および個々のUser messageの到着順配信オプション

-単一のSCTPパケットへの複数のUser messageのオプションのバンドル、および

-アソシエーションの一端または両端でのマルチホーミングのサポートによるネットワークレベルのフォールトトレランス. 

SCTPの設計には、適切な輻輳回避動作と、フラッディングおよびマスカレード攻撃に対する耐性が含まれます. 

目次

   1.はじめに............................................... ..... 5
      1.1. 動機 ................................................. 5
      1.2. SCTPのアーキテクチャビュー................................. 6
      1.3. 主な用語................................................ ..6
      1.4. 略語............................................. 10
      1.5. SCTPの機能ビュー................................... 10
           1.5.1. アソシエーションの開始と削除................... 11
           1.5.2. ストリーム内の順次配信................................. 12
           1.5.3. ユーザーデータの断片化................................................ 12
           1.5.4. 確認と混雑回避........... 12
           1.5.5. チャンクBundling..................................... 13
           1.5.6. パケット検証.................................. 13
           1.5.7. パス管理................................................... 13
      1.6. シリアル番号演算................................................. 14
      1.7. RFC 2960からの変更点..................................... 15
   2.表記法......................................................... ..... 15
   3. SCTPパケット形式............................................. 15
      3.1. SCTP共通ヘッダーフィールドの説明..................... 16
      3.2. チャンクフィールドの説明.................................. 17
           3.2.1. オプション/可変長パラメーターのフォーマット.......... 19
           3.2.2. 認識されないパラメータの報告............... 21
      3.3. SCTPチャンクの定義.................................... 21
           3.3.1. ペイロードデータ（DATA）（0）............................ 22
           3.3.2. 開始（INIT）（1）.............................. 24
                  3.3.2.1. オプション/可変長
                           INITのパラメータ........................ 27
           3.3.3. 開始確認（INIT ACK）（2）.......... 30
                  3.3.3.1. オプションまたは可変長のパラメータ.... 33
           3.3.4. 選択的確認応答（SACK）（3）............... 34
           3.3.5. ハートビートリクエスト（HEARTBEAT）（4）.................. 38
           3.3.6. Heartbeat Acknowledgement（HEARTBEAT ACK）（5）...... 39
           3.3.7. アボートアソシエーション（ABORT）（6）...................... 40
           3.3.8. シャットダウンアソシエーション（SHUTDOWN）（7）................ 41
           3.3.9. シャットダウン確認（SHUTDOWN ACK）（8）........ 41
           3.3.10. 操作エラー（ERROR）（9）................................. 42
                  3.3.10.1. 無効なストリーム識別子（1）............ 44
                  3.3.10.2. 必須パラメーターがありません（2）.......... 44
                  3.3.10.3. 古いCookieエラー（3）................... 45
                  3.3.10.4. リソース不足（4）............ 45
                  3.3.10.5. 解決できないアドレス（5）................. 46
                  3.3.10.6. 認識されないチャンクタイプ（6）.............. 46
                  3.3.10.7. 無効な必須パラメーター（7）.......... 47
                  3.3.10.8. 認識されないパラメータ（8）.............. 47
                  3.3.10.9. ユーザーデータなし（9）......................... 48
                  3.3.10.10. シャットダウン中に受信したCookie
                             ダウン（10）............................... 48
        
                  3.3.10.11. とのassociationの再開
                             新しいアドレス（11）............ 49
                  3.3.10.12. ユーザー開始の中止（12）............... 49
                  3.3.10.13. プロトコル違反（13）................. 50
           3.3.11. クッキーエコー（COOKIE ECHO）（10）.................... 50
           3.3.12. Cookieの確認（COOKIE A​​CK）（11）.......... 51
           3.3.13. シャットダウン完了（SHUTDOWN COMPLETE）（14）........ 51
   4. SCTPアソシエーションの状態図................................. 52
   5.アソシエーションの初期化................................................. 56
      5.1. Associationの通常の設立................................. 56
           5.1.1. ストリームパラメータの処理........................... 58
           5.1.2. アドレスパラメータの処理.......................... 58
           5.1.3. 状態Cookieの生成............................ 61
           5.1.4. 状態Cookie処理............................ 62
           5.1.5. 状態Cookie認証.................................. 62
           5.1.6. 通常のアソシエーション確立の例..... 64
      5.2. 重複または予期しないINIT、INIT ACK、
           COOKIE ECHO、および.......................................... 65
           5.2.1. INITはCOOKIE-WAITまたは
                  COOKIE-ECHOED状態（アイテムB）....................... 66
           5.2.2. 以外の状態での予期しないINIT
                  閉鎖、クッキーが響く、............................. 66
           5.2.3. 予期しないINIT ACK ................................ 67
           5.2.4. TCBが存在するときにCOOKIE ECHOを処理する............. 67
                  5.2.4.1. アソシエーションの再起動の例....... 69
           5.2.5. 重複するCOOKIE-ACKを処理します. ................................. 71
           5.2.6. 古いCOOKIEエラーの処理.......................... 71
      5.3. その他の初期化の問題............................... 72
           5.3.1. タグ値の選択............................. 72
      5.4. パス検証................................................. 72
   6.ユーザーデータ転送............................................. 73
      6.1. DATA Chunksの送信............................... 75
      6.2. DATA Chunksの受信に関する謝辞............... 78
           6.2.1. 受信したSACKの処理......................... 81
      6.3. 再送タイマーの管理........................ 83
           6.3.1. RTOの計算................................................... 83
           6.3.2. 再送信タイマールール......................... 85
           6.3.3. T3-rtxの有効期限の処理........................... 86
      6.4. マルチホームSCTPエンドポイント................................ 87
           6.4.1. 非アクティブな宛先アドレスからのフェイルオーバー...... 88
      6.5. ストリーム識別子とStream Sequence Number.............. 88
      6.6. 注文した商品と注文していない商品............................ 88
      6.7. 受信したデータTSNのギャップの報告......................... 89
      6.8. CRC32cチェックサム計算............................... 90
      6.9 断片化と再構成.............................. 91
      6.10. バンドル................................................................. 92
   7.輻輳制御............................................. 93
      7.1. SCTPとTCP輻輳制御の違い.............. 94
        
      7.2. SCTPスロースタートと輻輳回避.................. 95
           7.2.1. スロースタート......................................... 96
           7.2.2. 輻輳回避............................... 97
           7.2.3. 輻輳制御................................. 98
           7.2.4. ギャップレポートでの高速再送信..................... 98
      7.3. パスMTU検出................................................. 100
   8.障害管理.............................................................. 100
      8.1. エンドポイント障害検出............................... 100
      8.2. パス障害検出................................................ 101
      8.3. パスハートビート........................................... 102
      8.4. 「Out of the Blue」パケットの処理......................... 104
      8.5. Verification Tag......................................... 105
           8.5.1. Verification Tagルールの例外.............. 105
   9.Associationの終了................................................. 106
      9.1. アソシエーションの中止.................................. 107
      9.2. アソシエーションのシャットダウン............................... 107
   10.上位層とのインターフェース................................... 110
      10.1 ULP-to-SCTP ............................................. 110
      10.2 SCTP-to-ULP ............................................. 120
   11.セキュリティに関する考慮事項................................................ 123
      11.1 セキュリティ対策方針..................................... 123
      11.2 潜在的な脅威に対するSCTPの対応..................... 124
           11.2.1. インサイダー攻撃に対抗する................................. 124
           11.2.2. でのデータ破損からの保護
                   ネットワーク......................................................... 124
           11.2.3. 機密性の保護....................... 124
           11.2.4. ブラインドからの保護
                   サービス拒否攻撃........................ 125
                  11.2.4.1. 洪水................................ 125
                  11.2.4.2. ブラインドマスカレード....................................... 126
                  11.2.4.3. サービスの不適切な独占..... 127
      11.3. ファイアウォールとのSCTPの相互作用........................ 127
      11.4. SCTP非対応ホストの保護..................... 128
   12.ネットワーク管理に関する考慮事項............................ 128
   13.推奨されるトランスミッションコントロールブロック（TCB）パラメータ...... 129
      13.1. SCTPインスタンスに必要なパラメータ.............. 129
      13.2. アソシエーションごとに必要なパラメーター（つまり、TCB）.... 129
      13.3. トランスポートアドレスごとのデータ........................................ 131
      13.4. 必要な一般的なパラメータ............................... 132
   14. IANAの考慮事項.......................................... 132
      14.1. IETF定義のチャンク拡張............................ 132
      14.2. IETF-Defined Chunk Parameter Extension .................. 133
      14.3. IETF定義の追加エラーの原因.................... 133
      14.4. ペイロードプロトコル識別子............................ 134
      14.5 ポート番号レジストリ................................... 134
   15.推奨されるSCTPプロトコルパラメータ値..................... 136
   16.謝辞....................................................... 137
   付録A.明示的な輻輳通知..................... 139
        
   付録B. CRC32cチェックサムの計算.......................................... 140
   付録C. ICMP処理................................................................. 142
   参考資料................................................................ ...... 149
      規範的な参考文献.......................................... 149
      参考資料.................................................................. 150
        
1.はじめに
このセクションでは、ストリーム制御伝送プロトコル（SCTP）の開発の背後にある理由、それが提供するサービス、およびプロトコルの詳細な説明を理解するために必要な基本概念について説明します. 

このドキュメントは[RFC2960]と[RFC3309]を廃止しました. 

1.1. 動機
TCP [RFC0793]は、IPネットワークにおける信頼できるデータ転送の主要な手段として、計り知れないサービスを実行しました. しかし、最近のアプリケーションの増加により、TCPの制限が厳しくなり、UDP [RFC0768]に独自の信頼できるデータ転送プロトコルが組み込まれています. ユーザーが回避したいと考えていた制限には、次のものがあります. 

-TCPは、信頼性の高いデータ転送と厳密な送信順序のデータ配信の両方を提供します. 一部のアプリケーションはシーケンスのメンテナンスなしで信頼できる転送を必要としますが、他のアプリケーションはデータの部分的な順序付けで満足します. これらのどちらの場合でも、TCPによって提供される行頭ブロッキングにより、不要な遅延が発生します. 

-多くの場合、TCPのストリーム指向の性質は不便です. アプリケーションは、独自のレコードマーキングを追加してメッセージの輪郭を描き、プッシュ機能を明示的に使用して、完全なメッセージが妥当な時間内に確実に転送されるようにする必要があります. 

-TCPソケットの範囲が限定されているため、マルチホームホストを使用して高可用性データ転送機能を提供するタスクが複雑になります. 

-TCPは、SYN攻撃などのサービス拒否攻撃に対して比較的脆弱です. 

IPネットワークを介したPSTNシグナリングの転送は、TCPのこれらすべての制限が関連するアプリケーションです. このアプリケーションはSCTPの開発を直接動機づけましたが、他のアプリケーションはSCTPが彼らの要件によく一致していると感じるかもしれません. 

1.2. SCTPのアーキテクチャービュー
SCTPは、SCTPユーザーアプリケーション（略して「SCTPユーザー」）とIPなどのコネクションレス型パケットネットワークサービスの間のレイヤーと見なされます. このドキュメントの残りの部分では、SCTPがIPの上で実行されることを前提としています. SCTPが提供する基本的なサービスは、ピアSCTPユーザー間でのUser messageの信頼できる転送です. 2つのSCTPエンドポイント間のassociationのコンテキスト内でこのサービスを実行します. このドキュメントのセクション10は、SCTPとSCTPユーザー層の間の境界に存在する必要があるAPIをスケッチしています. 

SCTPは本質的にコネクション型ですが、SCTPアソシエーションはTCP接続よりも広い概念です. SCTPは、各SCTPエンドポイント（セクション1.3）が他のエンドポイント（アソシエーションの起動時）に、そのエンドポイントに到達およびそこから到達できるトランスポートアドレス（SCTPポートと組み合わせた複数のIPアドレス）のリストを提供する手段を提供しますSCTPパケットを発信します. associationは、各エンドポイントのリストから生成される可能性のあるすべての送信元/宛先の組み合わせにわたる転送にまたがります. 

       _____________                                      _____________
      |  SCTP User  |                                    |  SCTP User  |
      | Application |                                    | Application |
      |-------------|                                    |-------------|
      |    SCTP     |                                    |    SCTP     |
      |  Transport  |                                    |  Transport  |
      |   Service   |                                    |   Service   |
      |-------------|                                    |-------------|
      |             |One or more    ----      One or more|             |
      | IP Network  |IP address      \/        IP address| IP Network  |
      |   Service   |appearances     /\       appearances|   Service   |
      |_____________|               ----                 |_____________|

        SCTP Node A |<-------- Network transport ------->| SCTP Node B

                         Figure 1: An SCTP Association

1.3. 主な用語
SCTPの説明に使用される言語の一部は、前のセクションで紹介されています. このセクションでは、主要な用語とその定義の統合リストを提供します. 

oActive destination transport address：送信側エンドポイントがUser messageの受信に使用できると見なすピアエンドポイント上のトランスポートアドレス. 

oBundling：オプションの多重化操作. これにより、複数のUser messageを同じSCTPパケットで伝送できます. 各User messageは、独自のDATA Chunksを占有します. 

oチャンク：チャンクヘッダーとチャンク固有のコンテンツで構成される、SCTPパケット内の情報の単位. 

oCongestion window 輻輳ウィンドウ（cwnd）：送信者が確認を受信する前に特定の宛先トランスポートアドレスに送信できるデータのバイト数を制限するSCTP変数. 

o累積TSN Ackポイント：SACKの累積TSN Ackフィールドを介して確認応答された最後のDATA ChunksのTSN. 

oアイドル宛先アドレス：一定時間（通常はハートビート間隔以上）内にUser messageが送信されなかったアドレス. 

o.Inactive destination transport address：エラーのために非アクティブと見なされ、User messageをトランスポートすることができないアドレス. 

oメッセージ=User message：上位層プロトコル（ULP）によってSCTPに送信されたデータ. 

oMessage Authentication Code（MAC）：秘密鍵を使用した暗号化ハッシュ関数に基づく完全性チェックメカニズム. 通常、Message Authentication Codeは、秘密鍵を共有する2つのパーティ間で使用され、これらのパーティ間で送信される情報を検証します. SCTPでは、COOKIE ECHOチャンクでピアから返された状態Cookie情報を検証するためにエンドポイントによって使用されます. 「MAC」という用語は、文脈によって意味が異なります. SCTPはこの用語を[RFC2104]と同じ意味で使用します. 

oネットワークバイトオーダー：最上位バイトが最初、つまりビッグエンディアン. 

oOrdered Message：メッセージが送信されたストリーム内で送信された以前のすべてのUser messageに関して順番に配信されるUser message. 

oOutstanding TSN（SCTPエンドポイントで）：エンドポイントから送信されたが、まだ確認応答を受け取っていないTSN（および関連するDATA Chunks）. 

oパス：1つのSCTPエンドポイントがピアSCTPエンドポイントの特定の宛先トランスポートアドレスに送信するSCTPパケットがたどるルート. 異なる宛先トランスポートアドレスに送信しても、必ずしも個別のパスを取得できるとは限りません. 

oプライマリパス：プライマリパスは、デフォルトでピアエンドポイントに送信されるパケットに入れられる宛先および送信元アドレスです. 実装は宛先チャンクと送信元アドレスの両方を指定して、応答チャンクがたどるリターンパスと、データ送信者がマルチホームの場合にパケットが送信されるインターフェイスをより適切に制御する必要があるため、定義には送信元アドレスが含まれます. 

oReceiver Window（rwnd）：データ送信者がピアの最後に計算されたReceiver Windowをバイト数で格納するために使用するSCTP変数. これにより、送信側は受信側のインバウンドバッファーで使用可能なスペースを示します. 

o SCTPアソシエーション：2つのSCTPエンドポイントで構成されるSCTPエンドポイント間のプロトコル関係と、Verification Tagや現在アクティブな一連の伝送シーケンス番号（TSN）などのプロトコル状態情報. アソシエーションは、使用するトランスポートアドレスによって一意に識別できます. associationのエンドポイントによって. 2つのSCTPエンドポイントは、それらの間に複数のSCTPアソシエーションを同時に持つことはできません（MUST NOT）. 

o SCTPエンドポイント：SCTPパケットの論理的な送信者/受信者. マルチホームホストでは、SCTPエンドポイントは、SCTPパケットを送信できる適格な宛先トランスポートアドレスのセットと、SCTPパケットを受信できる適格なソーストランスポートアドレスのセットの組み合わせとして、ピアに対して表されます. SCTPエンドポイントが使用するすべてのトランスポートアドレスは同じポート番号を使用する必要がありますが、複数のIPアドレスを使用できます. SCTPエンドポイントが使用するトランスポートアドレスは、別のSCTPエンドポイントが使用することはできません. つまり、トランスポートアドレスはSCTPエンドポイントに固有です. 

o SCTPパケット（またはパケット）：SCTPとコネクションレス型パケットネットワーク（IPなど）間のインターフェースを介したデータ配信の単位. SCTPパケットには、共通のSCTPヘッダー、可能なSCTP制御チャンク、およびSCTP DATA Chunks内にカプセル化されたユーザーデータが含まれます. 

o SCTPユーザーアプリケーション（SCTPユーザー）：SCTPのサービスを使用する論理的な上位層アプリケーションエンティティ. 上位層プロトコル（ULP）とも呼ばれます. 

oSlow-Start Threshold（ssthresh）：SCTP変数. これは、特定の宛先トランスポートアドレスでスロースタートまたは輻輳回避を実行するかどうかを判断するためにエンドポイントが使用するしきい値です. Ssthreshはバイト数です. 

oストリーム：associationられたSCTPエンドポイント間で確立された単一方向の論理チャネル内で、順序付けされていない配信サービスに送信されたものを除くすべてのUser messageが順番に配信されます. 

注：反対方向のストリーム番号間の関係は、アプリケーションがストリーム番号をどのように使用するかに厳密に依存します. 必要に応じてこれらの相関を作成および管理するのは、SCTPユーザーの責任です. 

oStream Sequence Number：特定のストリーム内でUser messageのシーケンス配信を保証するためにSCTPが内部で使用する16ビットのシーケンス番号. 1つのStream Sequence Numberが各User messageに添付されます. 

oTie-Tags：2つの32ビット乱数により、64ビットのナンスが作成されます. これらのタグは、状態CookieおよびTCB内で使用されるため、新しく再起動するassociationは、再起動せず、既存のassociationの真のVerification Tagを明らかにしないエンドポイント内の元のassociationにリンクできます. 

oTransmission Control Block（TCB）：他のSCTPエンドポイントへの既存のSCTPアソシエーションごとに、SCTPエンドポイントによって作成された内部データ構造. TCBには、エンドポイントが対応するassociationを維持および管理するためのすべてのステータスおよび操作情報が含まれています. 

o Transmission Sequence Number（TSN）：SCTPが内部で使用する32ビットのシーケンス番号. ユーザーデータを含む各チャンクに1つのTSNがアタッチされ、受信SCTPエンドポイントが受信を確認し、重複した配信を検出できるようにします. 

oトランスポートアドレス：従来、トランスポートアドレスは、ネットワーク層アドレス、トランスポート層プロトコル、およびトランスポート層ポート番号によって定義されていました. IPを介して実行されるSCTPの場合、トランスポートアドレスは、IPアドレスとSCTPポート番号の組み合わせによって定義されます（SCTPはトランスポートプロトコルです）. 

oUnacknowledged TSN（SCTPエンドポイントで）：エンドポイントによって受信されたが、確認がまだ送信されていないTSN（および関連するDATA Chunks）. または、反対の場合、送信されたが確認応答が受信されていないパケットの場合. 

oUnordered Message：Unordered Messageは、他のメッセージに対して「順不同」です. これには、他の順序付けされていないメッセージと他のOrdered Messageの両方が含まれます. 順序付けられていないメッセージは、同じストリームで送信されるOrdered Messageの前または後に配信される場合があります. 

oUser message：SCTPとそのユーザー間のインターフェイスを介したデータ配信の単位. 

oVerification Tag：ランダムに生成される32ビットの符号なし整数. Verification Tagは、SCTPパケットが現在のアソシエーションに属し、以前のアソシエーションからの古いパケットや古いパケットではないことを受信者が確認できるようにするキーを提供します. 

1.4. 略語
MAC-Message Authentication Code[RFC2104]

RTO-再送信タイムアウト

RTT-往復時間

RTTVAR-ラウンドトリップ時間変動

SCTP-ストリーム制御伝送プロトコル

SRTT-平滑化されたRTT

TCB-Transmission Control Block

TLV-Type-Length-Valueコーディング形式

TSN-送信シーケンス番号

ULP-上位層プロトコル

1.5. SCTPの機能ビュー
SCTPトランスポートサービスは、いくつかの機能に分解できます. これらを図2に示し、このセクションの残りの部分で説明します. 

                           SCTP User Application

            -----------------------------------------------------
             _____________                  ____________________
            |             |                | Sequenced Delivery |
            | Association |                |   within Streams   |
            |             |                |____________________|
            |   Startup   |
            |             |         ____________________________
            |     and     |        |    User Data Fragmentation |
            |             |        |____________________________|
            |   Takedown  |
            |             |         ____________________________
            |             |        |     Acknowledgement        |
            |             |        |          and               |
            |             |        |    Congestion Avoidance    |
            |             |        |____________________________|
            |             |
            |             |         ____________________________
            |             |        |       Chunk Bundling       |
            |             |        |____________________________|
            |             |
            |             |     ________________________________
            |             |    |      Packet Validation         |
            |             |    |________________________________|
            |             |
            |             |     ________________________________
            |             |    |     Path Management            |
            |_____________|    |________________________________|

              Figure 2: Functional View of the SCTP Transport Service

1.5.1. associationの開始と削除
associationは、SCTPユーザーからの要求によって開始されます（セクション10のASSOCIATE（またはSEND）プリミティブの説明を参照してください）. 

[RFC2522]でKarnとSimpsonによって説明されたものと同様のCookieメカニズムが初期化中に採用され、同期攻撃に対する保護を提供します. Cookieメカニズムは4ウェイハンドシェイクを使用し、その最後の2つのレッグは高速セットアップのためにユーザーデータを運ぶことができます. 起動シーケンスについては、このドキュメントのセクション5で説明しています. 

SCTPは、SCTPユーザーからの要求に応じて、アクティブなassociationの正常なクローズ（つまり、シャットダウン）を提供します. セクション10のSHUTDOWNプリミティブの説明を参照してください. SCTPは、ユーザーからの要求に応じて（ABORTプリミティブ）、またはSCTPレイヤー内で検出されたエラー条件の結果として、異常なクローズ（つまり、中止）も許可します. セクション9では、正常なクローズ手順と異常なクローズ手順の両方について説明します. 

SCTPは、片側がデータの送信を継続し、もう一方の端が閉じている（TCPのような）ハーフオープン状態をサポートしていません. いずれかのエンドポイントがシャットダウンを実行すると、各ピアのassociationは、ユーザーからの新しいデータの受け入れを停止し、正常なクローズ時にのみキュー内のデータを配信します（セクション9を参照）. 

1.5.2. ストリーム内の順次配信
SCTPでは、「ストリーム」という用語は、同じストリーム内の他のメッセージに関して、上位層プロトコルに配信される一連のUser messageを指します. これは、バイトのシーケンスを参照するTCPでの使用とは対照的です（このドキュメントでは、1バイトは8ビットであると想定されています）. 

SCTPユーザーは、associationの起動時に、associationによってサポートされるストリームの数を指定できます. この番号はリモートエンドとネゴシエートされます（セクション5.1.1を参照）. User messageはストリーム番号にassociationられています（SEND、RECEIVEプリミティブ、セクション10）. 内部的には、SCTPは、SCTPユーザーから渡された各メッセージにStream Sequence Numberを割り当てます. 受信側では、SCTPはメッセージが指定されたストリーム内で順番にSCTPユーザーに配信されるようにします. ただし、1つのストリームがブロックされて次のシーケンス内のUser messageを待機している間に、他のストリームからの配信が続行される場合があります. 

SCTPは、シーケンス配信サービスをバイパスするメカニズムを提供します. このメカニズムを使用して送信されたUser messageは、受信されるとすぐにSCTPユーザーに配信されます. 

1.5.3. ユーザーデータの断片化
必要に応じて、SCTPはUser messageをフラグメント化して、下位層に渡されるSCTPパケットがパスMTUに準拠するようにします. 受信すると、フラグメントはSCTPユーザーに渡される前に完全なメッセージに再構成されます. 

1.5.4. 確認と混雑回避
SCTPは、各ユーザーデータフラグメントまたはフラグメント化されていないメッセージに送信シーケンス番号（TSN）を割り当てます. TSNは、ストリームレベルで割り当てられたStream Sequence Numberから独立しています. シーケンスにギャップがある場合でも、受信側は受信したすべてのTSNを確認します. このようにして、信頼性の高い配信は、シーケンス化されたストリーム配信から機能的に分離されます. 

確認応答および輻輳回避機能は、タイムリーな確認応答が受信されなかった場合のパケット再送信を担当します. パケットの再送信は、TCPに使用されるものと同様の輻輳回避手順によって調整されます. この機能に関連するプロトコル手順の詳細については、セクション6およびセクション7を参照してください. 

1.5.5. チャンクBundling
セクション3で説明したように、下位層に配信されるSCTPパケットは、共通ヘッダーとそれに続く1つ以上のチャンクで構成されます. 各チャンクには、ユーザーデータまたはSCTP制御情報を含めることができます. SCTPユーザーは、複数のUser messageを1つのSCTPパケットにまとめることを要求するオプションがあります. SCTPのチャンクBundling機能は、完全なSCTPパケットの組み立てと受信側での分解を担当します. 

輻輳が発生している間、ユーザーがSCTPをバンドルしないように要求した場合でも、SCTP実装はバンドルを実行する場合があります. ユーザーによるBundlingの無効化は、（Bundlingを促進するために）送信前に少しの間遅延する可能性があるSCTP実装にのみ影響します. ユーザーレイヤーがBundlingを無効にすると、この小さな遅延は禁止されますが、輻輳または再送信中に実行されるBundlingは禁止されません. 

1.5.6. パケット検証
必須のVerification Tagフィールドと32ビットチェックサムフィールド（CRC32cチェックサムの説明については、付録Bを参照）がSCTP共通ヘッダーに含まれています. Verification Tagの値は、associationの開始時にassociationの両端によって選択されます. 予期されるVerification Tag値なしで受信されたパケットは、ブラインドマスカレード攻撃に対する保護として、および以前のアソシエーションからの古いSCTPパケットに対する保護として破棄されます. CRC32cチェックサムは、ネットワーク内のデータ破損に対する追加の保護を提供するために、各SCTPパケットの送信者が設定する必要があります. CRC32cチェックサムが無効なSCTPパケットの受信者は、パケットをサイレントに破棄します. 

1.5.7. パス管理
送信側SCTPユーザーは、セクション10で説明するプリミティブを介して、SCTPパケットの宛先として使用されるトランスポートアドレスのセットを操作できます. SCTPパス管理機能は、SCTPユーザーの指示に基づいて、各発信SCTPパケットの宛先トランスポートアドレスを選択します. 適格な宛先セットの現在認識されている到達可能性ステータス. パス管理機能は、他のパケットトラフィックがこの情報を提供するのに不十分である場合にハートビートを介して到達可能性を監視し、遠端トランスポートアドレスの到達可能性が変化した場合にSCTPユーザーに通知します. パス管理機能は、アソシエーションの起動時にローカルトランスポートアドレスの適格なセットを遠端に報告し、遠端からSCTPユーザーに返されたトランスポートアドレスを報告する役割も果たします. 

アソシエーションの起動時に、SCTPエンドポイントごとにプライマリパスが定義され、SCTPパケットの通常の送信に使用されます. 

受信側では、パス管理は、インバウンドSCTPパケットが属する有効なSCTPアソシエーションが存在することを確認してから、それをさらに処理するために渡します. 

注：パス管理とパケット検証は同時に行われるため、上記で個別に説明しましたが、実際には個別のアイテムとして実行することはできません. 

1.6. シリアル番号演算
実際の送信シーケンス番号空間は有限ですが、非常に大きいことを忘れないでください. このスペースの範囲は0〜2 ** 32-1です. スペースは有限であるため、送信シーケンス番号を扱うすべての演算は2 ** 32を法として実行する必要があります. この符号なし演算では、シーケンス番号の関係が2 ** 32-1から0に再び循環するときに保持されます. コンピュータのモジュロ演算にはいくつかの微妙な点があるので、そのような値の比較のプログラミングには細心の注意を払う必要があります. TSNを参照する場合、記号「= <」は「以下」（2 ** 32を法とする）を意味します. 

このドキュメントのTSNの比較と算術は、[RFC1982]で定義されているシリアル番号算術を使用する必要があります（SHOULD、SERIAL_BITS = 32）. 

エンドポイントは、現在の送信ウィンドウの開始TSNより2 ** 31-1以上大きいTSNを持つDATA Chunksを送信してはなりません（SHOULD NOT）. これを行うと、TSNの比較で問題が発生します. 

送信シーケンス番号は、2 ** 32-1に達したときにラップアラウンドします. つまり、データチャンクがTSN = 2 * 32-1を送信した後に使用する次のTSNはTSN = 0です. 

Stream Sequence Numberで行われるすべての算術は、[RFC1982]で定義されているシリアル番号算術を使用する必要があります（SHOULD）. SERIAL_BITS=16. このドキュメントの他のすべての算術および比較では、通常の算術を使用します. 

1.7. RFC 2960からの変更
SCTPはもともと[RFC2960]で定義されていましたが、このドキュメントでは廃止されました. このドキュメントに組み込まれているさまざまな変更の詳細に興味がある読者は、[RFC4460]に相談してください. 

2.規約
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [RFC2119]で説明されているように解釈されます. 

3. SCTPパケット形式
SCTPパケットは、共通のヘッダーとチャンクで構成されています. チャンクには、制御情報またはユーザーデータが含まれます. 

SCTPパケットのフォーマットを以下に示します. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        Common Header                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          Chunk #1                             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           ...                                 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          Chunk #n                             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
INIT、INIT ACK、およびSHUTDOWN COMPLETEチャンクを除き、複数のチャンクをMTUサイズまでの1つのSCTPパケットにバンドルできます. これらのチャンクは、パケット内の他のチャンクとバンドルしてはいけません. チャンクBundlingの詳細については、セクション6.10を参照してください. 

ユーザーデータメッセージが1つのSCTPパケットに収まらない場合は、セクション6.9で定義されている手順を使用して、複数のチャンクにフラグメント化できます. 

特に明記されていない限り、SCTPパケットのすべての整数フィールドはネットワークバイトオーダーで送信する必要があります. 

3.1. SCTP共通ヘッダーフィールドの説明
SCTP共通ヘッダー形式

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Source Port Number        |     Destination Port Number   |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      Verification Tag                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           Checksum                            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
送信元ポート番号：16ビット（符号なし整数）

これはSCTP送信者のポート番号です. 受信者は、送信元IPアドレス、SCTP宛先ポート、および場合によっては宛先IPアドレスと組み合わせて使用​​して、このパケットが属するアソシエーションを識別できます. ポート番号0は使用してはなりません. 

宛先ポート番号：16ビット（符号なし整数）

これは、このパケットの宛先であるSCTPポート番号です. 受信ホストはこのポート番号を使用して、SCTPパケットを正しい受信エンドポイント/アプリケーションに逆多重化します. ポート番号0は使用してはなりません. 

Verification Tag：32ビット（符号なし整数）

このパケットの受信者は、Verification Tagを使用して、このSCTPパケットの送信者を検証します. 送信時に、このVerification Tagの値は、associationの初期化中にピアエンドポイントから受信した開始タグの値に設定する必要があります. ただし、次の例外があります. 

-INITチャンクを含むパケットにはゼロVerification Tagが必要です. 

-Tビットが設定されたSHUTDOWN COMPLETEチャンクを含むパケットは、SHUTDOWN ACKチャンクを含むパケットからVerification Tagをコピーする必要があります. 

-ABORTチャンクを含むパケットには、ABORTが送信される原因となったパケットからコピーされたVerification Tagが含まれる場合があります. 詳細については、セクション8.4およびセクション8.5を参照してください. 

INITチャンクは、それを運ぶSCTPパケット内の唯一のチャンクである必要があります. 

チェックサム：32ビット（符号なし整数）

このフィールドには、このSCTPパケットのチェックサムが含まれています. その計算については、セクション6.8で説明します. SCTPは、チェックサムの計算に付録Bで説明されているCRC32cアルゴリズムを使用します. 

3.2. チャンクフィールドの説明
次の図は、SCTPパケットで送信されるチャンクのフィールドフォーマットを示しています. 各チャンクは、チャンクタイプフィールド、チャンク固有のフラグフィールド、チャンク長フィールド、および値フィールドでフォーマットされます. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Chunk Type  | Chunk  Flags  |        Chunk Length           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                          Chunk Value                          /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクタイプ：8ビット（符号なし整数）

このフィールドは、「チャンク値」フィールドに含まれる情報のタイプを識別します. 値は0〜254です. 255の値は、拡張フィールドとして将来使用するために予約されています. 

チャンクタイプの値は次のように定義されます. 

   ID値チャンクタイプ
   ----- ----------
   0-ペイロードデータ（DATA）
   1-開始（INIT）
   2-開始確認（INIT ACK）
   3-選択的確認応答（SACK）
   4-ハートビート要求（HEARTBEAT）
   5-ハートビート確認（HEARTBEAT ACK）
   6-中止（ABORT）
   7-シャットダウン（SHUTDOWN）
   8-シャットダウン確認（SHUTDOWN ACK）
   9-操作エラー（ERROR）
   10-State Cookie（COOKIE ECHO）
   11-Cookie確認（COOKIE A​​CK）12-明示的な輻輳通知エコー用に予約済み
                （ECNE）
   13-Congestion windowの削減のために予約（CWR）
   14-シャットダウン完了（SHUTDOWN COMPLETE）
   15から62-利用可能
   63-IETF定義のチャンク拡張用に予約済み
   64から126-利用可能
   127-IETF定義のチャンク拡張用に予約済み
   128から190-利用可能
   191-IETF定義のチャンク拡張用に予約済み
   192から254-利用可能
   255-IETF定義のチャンク拡張用に予約済み
        
チャンクタイプは、最上位の2ビットが処理エンドポイントがチャンクタイプを認識しない場合に実行する必要があるアクションを指定するようにエンコードされます. 

00-このSCTPパケットの処理を停止して破棄し、その中のそれ以上のチャンクを処理しないでください. 

01-このSCTPパケットの処理を停止して破棄し、その中のそれ以上のチャンクを処理せず、認識されていないチャンクを「Unrecognized Chunk Type」で報告します. 

10-このチャンクをスキップして、処理を続行します. 

11-このチャンクをスキップして処理を続行しますが、エラーの「認識できないチャンクタイプ」の原因を使用してERRORチャンクで報告します. 

注：ECNEおよびCWRチャンクタイプは、明示的輻輳通知（ECN）の将来の使用のために予約されています. 付録Aを参照してください. 

チャンクフラグ：8ビット

これらのビットの使用は、チャンクタイプフィールドで指定されたチャンクタイプによって異なります. 特に指定のない限り、送信時には0に設定され、受信時には無視されます. 

チャンク長：16ビット（符号なし整数）

この値は、チャンクタイプ、チャンクフラグ、チャンク長、チャンク値フィールドなど、チャンクのサイズをバイト単位で表します. したがって、「チャンク値」フィールドの長さがゼロの場合、「長さ」フィールドは4に設定されます. 「チャンクの長さ」フィールドは、チャンクのパディングをカウントしません. 

チャンク（タイプ、長さ、および値フィールドを含む）は、すべてゼロバイトで長さが4バイトの倍数になるように送信者によって埋め込まれます. このパディングは、合計で3バイトを超えてはなりません. Chunk Length値には、チャンクの終了パディングは含まれません. ただし、チャンク内の最後のパラメーターを除くすべての可変長パラメーターのパディングが含まれます. レシーバーはパディングを無視しなければなりません. 

注：堅牢な実装では、最後のパディングがチャンク長に含まれているかどうかに関係なく、チャンクを受け入れる必要があります. 

チャンク値：可変長

チャンク値フィールドには、チャンクで転送される実際の情報が含まれています. このフィールドの使用法と形式は、チャンクタイプによって異なります. 

チャンクの合計の長さ（Type、Length、Valueフィールドを含む）は、4バイトの倍数でなければなりません. チャンクの長さが4バイトの倍数でない場合、送信者はチャンクをすべてゼロバイトで埋める必要があり、この埋め込みは[チャンク長]フィールドに含まれません. 送信者は、3バイトを超えてパディングしてはなりません（MUST NOT）. レシーバーはパディングバイトを無視する必要があります. 

SCTPで定義されたチャンクについては、3.3節で詳しく説明します. IETFで定義されたチャンク拡張のガイドラインは、このドキュメントのセクション14.1に記載されています. 

3.2.1. オプション/可変長のパラメーター形式
SCTP制御チャンクのチャンク値は、必須フィールドのチャンクタイプ固有のヘッダーで構成され、その後に0個以上のパラメーターが続きます. チャンクに含まれるオプションの可変長パラメーターは、以下に示すようにType-Length-Value形式で定義されます. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Parameter Type       |       Parameter Length        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                       Parameter Value                         /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクパラメータタイプ：16ビット（符号なし整数）

Typeフィールドは、パラメータのタイプの16ビットの識別子です. 値は0〜65534です. 

65535の値は、IETF定義の拡張用に予約されています. 特定のSCTPチャンクの説明で定義されている値以外の値は、IETFが使用するために予約されています. 

チャンクパラメータの長さ：16ビット（符号なし整数）

パラメータ長フィールドには、パラメータタイプ、パラメータ長、パラメータ値フィールドなど、パラメータのサイズがバイト単位で含まれています. したがって、長さがゼロのパラメーター値フィールドを持つパラメーターは、長さフィールドが4になります. パラメーター長には、埋め込みバイトは含まれません. 

チャンクパラメータ値：可変長

パラメータ値フィールドには、パラメータで転送される実際の情報が含まれています. 

パラメーター（タイプ、パラメーター長、および値フィールドを含む）の全長は、4バイトの倍数でなければなりません. パラメータの長さが4バイトの倍数でない場合、送信側はパラメータを最後（つまり、[パラメータ値]フィールドの後）にすべて0バイトで埋めます. パディングの長さは、[パラメーターの長さ]フィールドには含まれません. 送信者は、3バイトを超えてパディングしてはいけません. レシーバーはパディングバイトを無視する必要があります. 

パラメータタイプは、最上位の2ビットが処理エンドポイントがパラメータタイプを認識しない場合に実行する必要があるアクションを指定するようにエンコードされます. 

00-このパラメーターの処理を停止します. このチャンク内でこれ以上パラメーターを処理しないでください. 

01-このパラメーターの処理を停止し、このチャンク内でこれ以上パラメーターを処理せず、セクション3.2.2で説明されているように、「認識されないパラメーター」で認識されないパラメーターを報告します. 

10-このパラメーターをスキップして、処理を続行します. 

11-このパラメーターをスキップして処理を続行しますが、セクション3.2.2で説明されているように、「認識されないパラメーター」で認識されないパラメーターを報告します. 

4つのケースすべてで、INIT ACKまたはCOOKIE ECHOチャンクが送信されることに注意してください. 00または01の場合、不明なパラメーターの後のパラメーターの処理は取り消されますが、すでに行われた処理はロールバックされません. 

実際のSCTPパラメータは、特定のSCTPチャンクセクションで定義されます. IETF定義のパラメータ拡張のルールは、セクション14.2で定義されています. パラメータタイプはすべてのチャンクで一意である必要があることに注意してください. たとえば、パラメータタイプ「5」は、IPv4アドレスを表すために使用されます（3.3.2.1項を参照）. 次に、値「5」は、IPv4アドレスを表すためにすべてのチャンクにわたって予約され、他のチャンクでは異なる意味で再利用してはいけません. 

3.2.2. 認識されないパラメータの報告
INITチャンクの受信者が認識されないパラメーターを検出し、セクション3.2.1に従ってそれらを報告する必要がある場合、INITチャンクに応答して送信されるINIT ACKチャンクに「Unrecognized Parameter」パラメーターを配置する必要があります. INITチャンクの受信側がassociationを確立しない場合（リソースの不足など）、 'Unrecognized Parameter'は、INITの送信側に送信されるABORTに含まれないことに注意してください. 

INIT ACKチャンクのレシーバーが認識されないパラメーターを検出し、セクション3.2.1に従ってそれらを報告する必要がある場合、「認識できないパラメーター」エラーの原因を含むERRORチャンクを、INIT ACKチャンクに応答して送信されるCOOKIE ECHOチャンクにバンドルする必要があります（SHOULD）.  . INIT ACKの受信者がCOOKIE ECHOチャンクをERRORチャンクとバンドルできない場合、ERRORチャンクは個別に送信できますが、COOKIE A​​CKを受信する前に送信することはできません. 

注：COOKIE ECHOがパケットで送信されるときは常に、それが最初のチャンクでなければなりません. 

3.3. SCTPチャンクの定義
このセクションでは、さまざまなSCTPチャンクタイプの形式を定義します. 

3.3.1. ペイロードデータ（DATA）（0）
DATA Chunksには次の形式を使用する必要があります. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 0    | Reserved|U|B|E|    Length                     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                              TSN                              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |      Stream Identifier S      |   Stream Sequence Number n    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                  Payload Protocol Identifier                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                 User Data (seq n of Stream S)                 /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
予約済み：5ビット

すべて「0」に設定し、レシーバーで無視する必要があります. 

Uビット：1ビット

（U）norderedビットは、「1」に設定されている場合、これが順序付けされていないDATA Chunksであり、このDATA ChunksにStream Sequence Numberが割り当てられていないことを示します. したがって、受信者はStream Sequence Numberフィールドを無視する必要があります. 

再構成後（必要な場合）、順序付けされていないDATA Chunksは、順序付けを再試行することなく、レシーバーによって上位層にディスパッチされる必要があります. 

順序付けられていないUser messageが断片化されている場合は、メッセージの各断片のUビットを「1」に設定する必要があります. 

Bビット：1ビット

（B）開始フラグメントビットは、設定されている場合、User messageの最初のフラグメントを示します. 

Eビット：1ビット

（E）ndingフラグメントビットは、設定されている場合、User messageの最後のフラグメントを示します. 

フラグメント化されていないUser messageでは、BビットとEビットの両方が「1」に設定されます. BビットとEビットの両方を「0」に設定すると、次の表に要約されているように、マルチフラグメントUser messageの中間フラグメントを示します. 

               BE説明
            ================================================== ==========
            | 1 0 | 断片化されたUser messageの最初の部分|
            + ------------------------------------------------- --------- +
            | 0 0 | 断片化されたUser messageの真ん中|
            + ------------------------------------------------- --------- +
            | 0 1 | 断片化されたUser messageの最後の部分|
            + ------------------------------------------------- --------- +
            | 1 1 | 断片化されていないメッセージ|
            ================================================== ==========
            | 表1：フラグメント説明フラグ|
            ================================================== ==========
        
User messageが複数のチャンクにフラグメント化されると、TSNはメッセージを再構成するために受信者によって使用されます. これは、断片化されたUser messageの各フラグメントのTSNが厳密に連続している必要があることを意味します. 

長さ：16ビット（符号なし整数）

このフィールドは、タイプフィールドの先頭からユーザーデータフィールドの末尾までのDATA Chunksの長さをバイト単位で示します. ユーザーデータが1バイトのDATA Chunksでは、長さが17に設定されます（17バイトを示します）. 

長さLのユーザーデータフィールドを持つDATA Chunksは、長さフィールドが（16 + L）（16 + Lバイトを示す）に設定され、Lは0より大きい必要があります. 

TSN：32ビット（符号なし整数）

この値は、このDATA ChunksのTSNを表します. TSNの有効範囲は0〜4294967295（2 ** 32-1）です. TSNは、4294967295に達した後、0に戻ります. 

ストリーム識別子S：16ビット（符号なし整数）

次のユーザーデータが属するストリームを識別します. 

Stream Sequence Numbern：16ビット（符号なし整数）

この値は、ストリームS内の次のユーザーデータのStream Sequence Numberを表します. 有効な範囲は0〜65535です. 

User messageがトランスポートのためにSCTPによってフラグメント化されるとき、同じStream Sequence Numberがメッセージの各フラグメントで運ばれる必要があります. 

ペイロードプロトコル識別子：32ビット（符号なし整数）

この値は、アプリケーション（または上位層）が指定したプロトコル識別子を表します. この値は、上位層によってSCTPに渡され、ピアに送信されます. この識別子はSCTPでは使用されませんが、このDATA Chunksで伝送される情報のタイプを識別するために、特定のネットワークエンティティやピアアプリケーションで使用できます. このフィールドは、断片化されたDATA Chunksでも送信する必要があります（ネットワークの途中のエージェントが使用できるようにするため）. このフィールドはSCTP実装によって影響を受けないことに注意してください. したがって、そのバイトオーダーは必ずしもビッグエンディアンではありません. 上位層は、このフィールドへのバイト順変換を担当します. 

値0は、このペイロードデータの上位層でアプリケーション識別子が指定されていないことを示します. 

ユーザーデータ：可変長

これは、ペイロードのユーザーデータです. 実装は、すべてゼロのバイトで4バイト境界までデータの終わりを埋めなければなりません（MUST）. 長さフィールドにパディングを含めることはできません. 送信者は、3バイトを超えるパディングを追加してはなりません（MUST）. 

3.3.2. 開始（INIT）（1）
このチャンクは、2つのエンドポイント間のSCTPアソシエーションを開始するために使用されます. INITチャンクのフォーマットを以下に示します. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 1    |  Chunk Flags  |      Chunk Length             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         Initiate Tag                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Advertised Receiver Window Credit (a_rwnd)          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Number of Outbound Streams   |  Number of Inbound Streams    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          Initial TSN                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /              Optional/Variable-Length Parameters              /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
INITチャンクには、次のパラメーターが含まれています. 特に明記しない限り、各パラメーターはINITチャンクに1回だけ含める必要があります. 

            固定パラメータステータス
            ----------------------------------------------
            タグを開始する必要があります
            アドバタイズされたReceiver Windowのクレジットが必須
            必須アウトバウンドストリーム数
            必須の受信ストリーム数
            初期TSN必須
        
          変数パラメーターステータスタイプ値
          -------------------------------------------------- -----------
          IPv4アドレス（注1）オプション5 IPv6アドレス
          （注1）オプションの6 Cookie Preservative
          オプション9 ECN対応に予約済み（注2）オプション
          32768（0x8000）ホスト名アドレス（注3）オプション
          11サポートされているアドレスタイプ（注4）オプション12
        
注1：INITチャンクには、IPv4またはIPv6、あるいはその両方を任意の組み合わせで使用できる複数のアドレスを含めることができます. 

注2：ECN Capableフィールドは、明示的な輻輳通知の将来の使用のために予約されています. 

注3：INITチャンクに複数のホスト名アドレスパラメータを含めることはできません. さらに、INITの送信者は、他のアドレスタイプをINITのホスト名アドレスと組み合わせてはなりません（MUST NOT）. 受信したINITチャンクにホスト名アドレスパラメータが存在する場合、INITの受信者は他のアドレスタイプを無視する必要があります. 

注4：このパラメーターが存在する場合、送信エンドポイントがサポートできるすべてのアドレスタイプを指定します. このパラメーターがない場合は、送信エンドポイントが任意のアドレスタイプをサポートできることを示しています. 

実装上の注意：INITチャンクのオプションパラメーターではない既知のパラメーターを使用してINITチャンクを受信した場合、受信者はINITチャンクを処理してINIT ACKを返信する必要があります（SHOULD）. INITチャンクのレシーバーは、後でERRORチャンクをCOOKIE A​​CKチャンクにバンドルする場合があります. ただし、制限のある実装は、INITチャンクへの応答としてABORTチャンクを送り返す場合があります. 

INITのChunk Flagsフィールドは予約されており、その中のすべてのビットは送信者によって0に設定され、受信者によって無視される必要があります. INIT内の一連のパラメーターは、任意の順序で処理できます. 

タグの開始：32ビット（符号なし整数）

INITの受信側（応答側）は、Initiate Tagパラメータの値を記録します. この値は、INITの受信側がこのassociation内で送信するすべてのSCTPパケットのVerification Tagフィールドに配置する必要があります. 

開始タグには、0以外の値を指定できます. タグ値の選択の詳細については、セクション5.3.1を参照してください. 

受信したINITチャンクのInitiate Tagの値が0であることがわかった場合、受信者はそれをエラーとして扱い、ABORTを送信してassociationを閉じる必要があります. 

アドバタイズされたReceiver Windowクレジット（a_rwnd）：32ビット（符号なし整数）

この値は、INITの送信側がこのウィンドウに関連して予約した専用のバッファスペースをバイト数で表します. アソシエーションの存続期間中は、このバッファースペースを減らすべきではありません（つまり、このアソシエーションから削除された専用バッファー）. ただし、エンドポイントは、SACKチャンクで送信するa_rwndの値を変更する場合があります. 

   アウトバウンドストリーム数（OS）：16ビット（符号なし整数）
        
このINITチャンクの送信者がこのアソシエーションで作成したいアウトバウンドストリームの数を定義します. 値0は使用してはなりません. 

注：OS値が0に設定されたINITの受信側は、associationを中止する必要があります（SHOULD）. 

   インバウンドストリーム数（MIS）：16ビット（符号なし整数）
        
このINITチャンクの送信者がピア側がこのassociationで作成できるストリームの最大数を定義します. 値0は使用してはなりません. 

注：実際のストリーム数のネゴシエーションはありませんが、代わりに2つのエンドポイントがmin（requested、offer）を使用します. 詳細については、セクション5.1.1を参照してください. 

注：MIS値が0のINITの受信側は、associationを中止する必要があります（SHOULD）. 

   初期TSN（I-TSN）：32ビット（符号なし整数）
        
送信者が使用する初期TSNを定義します. 有効な範囲は0〜4294967295です. このフィールドは、Initiate Tagフィールドの値に設定される場合があります. 

3.3.2.1. INITのオプション/可変長パラメーター
次のパラメータは、セクション3.2.1で定義されているType-Length-Value形式に従います. Type-Length-Valueフィールドは、前のセクションで定義された固定長フィールドの後に来る必要があります. 

IPv4アドレスパラメータ（5）

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |        Type = 5               |      Length = 8               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                        IPv4 Address                           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
IPv4アドレス：32ビット（符号なし整数）

送信エンドポイントのIPv4アドレスが含まれます. バイナリエンコードされています. 

IPv6アドレスパラメータ（6）

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Type = 6           |          Length = 20          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       |                         IPv6 Address                          |
       |                                                               |
       |                                                               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
IPv6アドレス：128ビット（符号なし整数）

送信エンドポイントのIPv6 [RFC2460]アドレスが含まれています. バイナリエンコードされています. 

注：送信者はIPv4にマッピングされたIPv6アドレス[RFC4291]を使用してはなりません（MUST）. 代わりに、IPv4アドレスのIPv4アドレスパラメータを使用する必要があります. 

SCTP共通ヘッダーの送信元ポート番号と組み合わせて、IPv4またはIPv6アドレスパラメーターで渡される値は、INITの送信者が開始されるassociationに対してサポートするトランスポートアドレスを示します. つまり、このassociationの存続期間中、このIPアドレスは、INITの送信側から送信されたIPデータグラムの送信元アドレスフィールドに表示され、受信側から送信されたIPデータグラムの宛先アドレスとして使用できます.  INIT. 

INIT送信側がマルチホームの場合、INITチャンクに複数のIPアドレスパラメータを含めることができます. さらに、マルチホームのエンドポイントは、さまざまなタイプのネットワークにアクセスできます. したがって、1つのINITチャンクに複数のアドレスタイプを含めることができます. つまり、IPv4アドレスとIPv6アドレスは同じINITチャンクで許可されます. 

INITに少なくとも1つのIPアドレスパラメータが含まれている場合、INITチャンクを含むIPデータグラムのソースアドレスと、INIT内で提供される追加のアドレスを、INITを受信するエンドポイントが宛先として使用できます. INITにIPアドレスパラメータが含まれていない場合、INITを受信するエンドポイントは、受信したIPデータグラムにassociationられているソースアドレスを、associationの唯一の宛先アドレスとして使用する必要があります. 

INITおよびINIT ACKでIPアドレスパラメータを使用しないことは、NATボックス全体でアソシエーションが機能する可能性を高める代替策であることに注意してください. 

Cookie Preservative（9）

INITの送信側は、このパラメーターを使用して、状態Cookieの寿命を延長するようINITの受信側に提案します. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Type = 9             |          Length = 8           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |         Suggested Cookie Life-Span Increment (msec.)          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
推奨されるCookieの有効期間の増分：32ビット（符号なし整数）

このパラメーターは、送信者が受信者にデフォルトのCookieの有効期間に追加することを希望するミリ秒単位の増分を受信者に示します. 

このオプションのパラメーターは、古いCookie操作エラーのためにassociationを確立する以前の試行が失敗したピアとのassociationの確立を再試行するときに、送信者がINITチャンクに追加する必要があります. 受信者は、独自のセキュリティ上の理由から、提案されたCookieの寿命の延長を無視することを選択できます. 

ホスト名アドレス（11）

INITの送信側は、このパラメーターを使用して（IPアドレスの代わりに）ホスト名をピアに渡します. ピアは名前を解決する責任があります. このパラメーターを使用すると、associationがNATボックス全体で機能する可能性が高くなります. 

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Type = 11            |          Length               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                          Host Name                            /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
ホスト名：可変長

このフィールドには、RFC 1123セクション2.1 [RFC1123]に基づく「ホスト名構文」のホスト名が含まれています. ホスト名を解決する方法はSCTPの範囲外です. 

注：少なくとも1つのNULLターミネーターがホスト名ストリングに含まれており、長さに含まれている必要があります. 

サポートされているアドレスの種類（12）

INITの送信者は、このパラメーターを使用して、サポートできるすべてのアドレスタイプをリストします. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Type = 12            |          Length               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |        Address Type #1        |        Address Type #2        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                            ......                             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+
        
アドレスタイプ：16ビット（符号なし整数）

これには、対応するアドレスTLVのタイプ値が入力されます（たとえば、IPv4 = 5、IPv6 = 6、ホスト名= 11）. 

3.3.3. 開始確認（INIT ACK）（2）
INIT ACKチャンクは、SCTPアソシエーションの開始を確認するために使用されます. 

INIT ACK のパラメーター部分は、INITチャンクと同様にフォーマットされます. 2つの追加の変数パラメーターを使用します. 状態Cookieと認識されないパラメーター：INIT ACKチャンクの形式を以下に示します. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 2    |  Chunk Flags  |      Chunk Length             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         Initiate Tag                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |              Advertised Receiver Window Credit                |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Number of Outbound Streams   |  Number of Inbound Streams    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                          Initial TSN                          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /              Optional/Variable-Length Parameters              /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
タグの開始：32ビット（符号なし整数）

INIT ACKの受信側は、Initiate Tagパラメータの値を記録します. この値は、このアソシエーション内でINIT ACKレシーバーが送信するすべてのSCTPパケットのVerification Tagフィールドに配置する必要があります. 

開始タグは値0をとってはなりません. 開始タグ値の選択の詳細については、セクション5.3.1を参照してください. 

受信したINIT ACKチャンクのInitiate Tagの値が0であることが判明した場合、受信者はそのTCBを破棄するassociationを破棄する必要があります. 受信者はデバッグ目的でABORTを送信してもよい（MAY）. 

アドバタイズされたReceiver Windowクレジット（a_rwnd）：32ビット（符号なし整数）

この値は、このウィンドウに関連してINIT ACKの送信者が予約した専用バッファースペースをバイト数で表します. アソシエーションの存続期間中は、このバッファースペースを減らすべきではありません（つまり、このアソシエーションから専用バッファーを削除します）. 

   アウトバウンドストリーム数（OS）：16ビット（符号なし整数）
        
このINIT ACKチャンクの送信者がこのassociationで作成することを望むアウトバウンドストリームの数を定義します. 値0は使用してはならず（MUST NOT）、その値はINITチャンクで送信されたMIS値よりも大きくしてはなりません（MUST NOT）. 

注：OS値が0に設定されたINIT ACKの受信者は、そのTCBを破棄してassociationを破棄する必要があります（SHOULD）. 

   インバウンドストリーム数（MIS）：16ビット（符号なし整数）
        
このINIT ACKチャンクの送信者がピア側がこのassociationで作成できるストリームの最大数を定義します. 値0は使用してはなりません. 

注：実際のストリーム数のネゴシエーションはありませんが、代わりに2つのエンドポイントがmin（requested、offer）を使用します. 詳細については、セクション5.1.1を参照してください. 

注：MIS値が0に設定されたINIT ACKの受信者は、そのTCBを破棄してassociationを破棄する必要があります（SHOULD）. 

   初期TSN（I-TSN）：32ビット（符号なし整数）
        
INIT ACK送信側が使用する初期TSNを定義します. 有効な範囲は0〜4294967295です. このフィールドは、Initiate Tagフィールドの値に設定される場合があります. 

         固定パラメータステータス
         ----------------------------------------------
         タグを開始する必要があります
         アドバタイズされたReceiver Windowのクレジットが必須
         必須アウトバウンドストリーム数
         必須の受信ストリーム数
         初期TSN必須
        
         変数パラメーターステータスタイプ値
         -------------------------------------------------- -----------
         State Cookie必須7
         IPv4アドレス（注1）オプション5
         IPv6アドレス（注1）オプション6
         認識されないパラメータオプション8
         ECN対応（注2）用に予約済みオプション32768（0x8000）
         ホスト名アドレス（注3）オプション11
        
注1：INIT ACKチャンクには、IPv4またはIPv6、あるいはその両方を任意の組み合わせで使用できる、任意の数のIPアドレスパラメータを含めることができます. 

注2：ECN Capableフィールドは、明示的な輻輳通知の将来の使用のために予約されています. 

注3：INIT ACKチャンクには、複数のホスト名アドレスパラメータを含めることはできません. さらに、INIT ACKの送信者は、他のアドレスタイプをINIT ACKのホスト名アドレスと組み合わせてはなりません（MUST NOT）. INIT ACKの受信者は、Host Name Addressパラメータが存在する場合、他のアドレスタイプを無視する必要があります. 

実装上の注意：ステートCookieの可変サイズと可変アドレスリストにより、非常に大きい（1500バイトを超える）INIT ACKを受信できるように実装を準備する必要があります. たとえば、INITへのレスポンダに送信したいIPv4アドレスが1000ある場合、これをINIT ACKにエンコードするには少なくとも8,000バイトが必要です. 

実装上の注意：INIT ACKチャンクのオプションのパラメーターではない既知のパラメーターを使用してINIT ACKチャンクを受信した場合、受信者はINIT ACKチャンクを処理してCOOKIE ECHOを送信する必要があります（SHOULD）. INIT ACKチャンクの受信側は、ERRORチャンクをCOOKIE ECHOチャンクにバンドルしてもよい（MAY）. ただし、制限のある実装は、INIT ACKチャンクへの応答としてABORTチャンクを送り返す場合があります. 

SCTP共通ヘッダーで送信される送信元ポートと組み合わせて、INIT ACKの各IPアドレスパラメータは、INIT ACKの受信者に、開始されるアソシエーションの存続期間中、INIT ACKの送信者によってサポートされる有効なトランスポートアドレスを示します. 

INIT ACKに少なくとも1つのIPアドレスパラメータが含まれている場合、INIT ACKを含むIPデータグラムの送信元アドレスと、INIT ACK内で提供される追加のアドレスは、INIT ACKの受信者が宛先として使用できます. INIT ACKにIPアドレスパラメータが含まれていない場合、INIT ACKの受信者は、受信したIPデータグラムにassociationられているソースアドレスを、associationの唯一の宛先アドレスとして使用する必要があります. 

状態Cookieと認識されないパラメーターは、セクション3.2.1で定義されているType-Length-Value形式を使用します. 他のフィールドは、INITチャンクの対応するフィールドと同じように定義されます. 

3.3.3.1. オプションまたは可変長のパラメーター
State Cookie

パラメータタイプ値：7

パラメータの長さ：Cookieのサイズに応じて可変サイズ. 

パラメータ値：

このパラメーター値には、このINIT ACKの送信者がassociationを作成するために必要なすべての必要な状態とパラメーター情報、およびMessage Authentication Code（MAC）が含まれている必要があります. 状態Cookieの定義の詳細については、セクション5.1.3を参照してください. 

認識されないパラメータ：

パラメータタイプ値：8

パラメータの長さ：可変サイズ. 

パラメータ値：

送信者に報告する必要があることを示す値を持つ認識されないパラメーターがINITに含まれている場合、このパラメーターはINITチャンクの発信者に返されます. このパラメーター値フィールドには、パラメータータイプ、長さ、および値フィールドを備えたINITチャンクからコピーされた認識されないパラメーターが含まれます. 

3.3.4. 選択的確認（SACK）（3）
このチャンクはピアエンドポイントに送信され、受信したDATA Chunksを確認し、ピアエンドポイントにTSNで表されるDATA Chunksの受信したサブシーケンスのギャップを通知します. 

SACKには、累積TSN Ack、アドバタイズされたReceiver Windowクレジット（a_rwnd）、ギャップAckブロックの数、および重複TSNフィールドの数が含まれている必要があります. 

定義により、累積TSN Ackパラメータの値は、受信したTSNのシーケンスの中断が発生する前に受信した最後のTSNです. これに続く次のTSN値は、SACKを送信するエンドポイントでまだ受信されていません. したがって、このパラメーターは、その値以下のすべてのTSNの受信を確認します. 

SACKの受信側によるa_rwndの処理については、セクション6.2.1で詳しく説明します. 

SACKには0個以上のギャップACKブロックも含まれます. 各ギャップACKブロックは、受信したTSNのシーケンスの中断に続いて、受信したTSNのサブシーケンスを確認します. 定義により、ギャップACKブロックによって確認応答されたすべてのTSNは、累積TSN ACKの値よりも大きくなります. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 3    |Chunk  Flags   |      Chunk Length             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      Cumulative TSN Ack                       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |          Advertised Receiver Window Credit (a_rwnd)           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       | Number of Gap Ack Blocks = N  |  Number of Duplicate TSNs = X |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |  Gap Ack Block #1 Start       |   Gap Ack Block #1 End        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                                                               /
       \                              ...                              \
       /                                                               /
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Gap Ack Block #N Start      |  Gap Ack Block #N End         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                       Duplicate TSN 1                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                                                               /
       \                              ...                              \
       /                                                               /
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                       Duplicate TSN X                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時にはすべて「0」に設定され、受信時には無視されます. 

累積TSN Ack：32ビット（符号なし整数）

このパラメータには、ギャップの前に順番に受信された最後のDATA ChunksのTSNが含まれています. DATA Chunksが受信されなかった場合、この値はピアの初期TSN-1に設定されます. 

アドバタイズされたReceiver Windowクレジット（a_rwnd）：32ビット（符号なし整数）

このフィールドは、このSACKの送信側の更新された受信バッファースペースをバイト単位で示します. 詳細については、セクション6.2.1を参照してください. 

ギャップACKブロックの数：16ビット（符号なし整数）

このSACKに含まれるギャップACKブロックの数を示します. 

重複TSNの数：16ビット

このフィールドには、エンドポイントが受信した重複TSNの数が含まれています. 重複する各TSNは、Gap Ack Blockリストの後にリストされます. 

ギャップACKブロック：

これらのフィールドには、ギャップACKブロックが含まれます. これらは、各ギャップACKブロックに対して、[ギャップACKブロックの数]フィールドで定義されたギャップACKブロックの数まで繰り返されます. 各Gap Ackブロックの（累積TSN Ack +ギャップAckブロックの開始）以上で（累積TSN Ack +ギャップAckブロックの終了）以下のTSNを持つすべてのDATA Chunksは、正しく受信されたと見なされます. 

ギャップ確認ブロック開始：16ビット（符号なし整数）

このギャップACKブロックの開始オフセットTSNを示します. 実際のTSN番号を計算するために、累積TSN Ackがこのオフセット番号に追加されます. この計算されたTSNは、このギャップACKブロック内で受信された最初のTSNを識別します. 

ギャップ確認ブロック終了：16ビット（符号なし整数）

このギャップACKブロックの終了オフセットTSNを示します. 実際のTSN番号を計算するために、累積TSN Ackがこのオフセット番号に追加されます. この計算されたTSNは、このギャップACKブロックで受信された最後のDATA ChunksのTSNを識別します. 

たとえば、選択的ACKを送信することを決定したときに、受信者が次のDATA Chunksを新しく到着したと仮定します. 

                           ----------
                           | TSN=17 |
                           ----------
                           |        | <- still missing
                           ----------
                           | TSN=15 |
                           ----------
                           | TSN=14 |
                           ----------
                           |        | <- still missing
                           ----------
                           | TSN=12 |
                           ----------
                           | TSN=11 |
                           ----------
                           | TSN=10 |
                           ----------
        
次に、SACKのパラメーター部分を次のように構成する必要があります（送信者によって新しいa_rwndが4660に設定されていると想定）. 

                     +--------------------------------+
                     |   Cumulative TSN Ack = 12      |
                     +--------------------------------+
                     |        a_rwnd = 4660           |
                     +----------------+---------------+
                     | num of block=2 | num of dup=0  |
                     +----------------+---------------+
                     |block #1 strt=2 |block #1 end=3 |
                     +----------------+---------------+
                     |block #2 strt=5 |block #2 end=5 |
                     +----------------+---------------+
        
重複TSN：32ビット（符号なし整数）

最後のSACKが送信されてからTSNが重複して受信された回数を示します. レシーバーは、（SACKを送信する前に）重複するTSNを取得するたびに、重複するTSNのリストに追加します. 重複カウントは、各SACKを送信した後にゼロに再初期化されます. 

たとえば、受信者がTSN 19を3回取得した場合、送信SACKに19が2回リストされます. SACKを送信した後、さらに1つのTSN 19を受信した場合、次の発信SACKで19を重複として一度にリストします. 

3.3.5. ハートビートリクエスト（ハートビート）（4）
エンドポイントはこのチャンクをピアエンドポイントに送信して、現在のassociationで定義されている特定の宛先トランスポートアドレスの到達可能性を調査する必要があります. 

パラメータフィールドには、送信者だけが理解できる可変長の不透明なデータ構造であるハートビート情報が含まれています. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 4    | Chunk  Flags  |      Heartbeat Length         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /            Heartbeat Information TLV (Variable-Length)        /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時には0に設定され、受信時には無視されます. 

ハートビートの長さ：16ビット（符号なし整数）

チャンクヘッダーとハートビート情報フィールドを含む、チャンクのサイズをバイト単位で設定します. 

ハートビート情報：可変長

セクション3.2.1で説明されている形式を使用して、可変長パラメーターとして定義されます. 

         Variable Parameters                  Status     Type Value
         -------------------------------------------------------------
         Heartbeat Info                       Mandatory   1

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |    Heartbeat Info Type=1      |         HB Info Length        |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                  Sender-Specific Heartbeat Info               /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
送信者固有のハートビート情報フィールドには、通常、このHEARTBEATチャンクが送信される送信者の現在時刻と、このHEARTBEATが送信される宛先トランスポートアドレスに関する情報が含まれている必要があります（セクション8.3を参照）. この情報は、受信者によってHEARTBEAT ACKメッセージに単純に反映されます（セクション3.3.6を参照）. また、HEARTBEATメッセージは到達可能性チェックとパス検証の両方に使用されることにも注意してください（セクション5.4を参照）. HEARTBEATチャンクがパス検証の目的で使用されている場合、64ビットのランダムnonceを保持する必要があります. 

3.3.6. ハートビート確認（HEARTBEAT ACK）（5）
エンドポイントは、このチャンクをHEARTBEATチャンクへの応答としてピアエンドポイントに送信する必要があります（セクション8.3を参照）. HEARTBEAT ACKは常に、このackが応答するHEARTBEATチャンクを含むIPデータグラムのソースIPアドレスに送信されます. 

パラメータフィールドには、可変長の不透明なデータ構造が含まれます. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 5    | Chunk  Flags  |    Heartbeat Ack Length       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /            Heartbeat Information TLV (Variable-Length)        /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時には0に設定され、受信時には無視されます. 

ハートビート確認長：16ビット（符号なし整数）

チャンクヘッダーとハートビート情報フィールドを含む、チャンクのサイズをバイト単位で設定します. 

ハートビート情報：可変長

このフィールドには、このハートビート確認応答が応答するハートビート要求のハートビート情報パラメーターを含める必要があります. 

         変数パラメーターステータスタイプ値
         -------------------------------------------------- -----------
         ハートビート情報必須1
        
3.3.7. アボートアソシエーション（ABORT）（6）
ABORTチャンクは、アソシエーションのピアに送信され、アソシエーションを閉じます. ABORTチャンクには、中止の理由をレシーバーに通知する原因パラメーターが含まれている場合があります. DATA ChunksはABORTにバンドルしてはなりません. 制御チャンク（INIT、INIT ACK、およびSHUTDOWN COMPLETEを除く）はABORTにバンドルされる場合がありますが、SCTPパケットのABORTの前に配置する必要があります. そうしないと、受信側で無視されます. 

エンドポイントがフォーマットエラーのあるABORTを受け取った場合、またはTCBが見つからなかった場合、エンドポイントはそれを黙って破棄する必要があります. さらに、どのような状況でも、ABORTを受信するエンドポイントは、自身のABORTを送信してそのABORTに応答してはなりません. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 6    |Reserved     |T|           Length              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                   zero or more Error Causes                   /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

予約済み：7ビット

送信時には0に設定され、受信時には無視されます. 

Tビット：1ビット

送信者がピアが予期するVerification Tagを入力した場合、Tビットは0に設定されます. Verification Tagが反映されている場合は、Tビットを1に設定する必要があります. 反映とは、送信されたVerification Tagが受信したVerification Tagと同じであることを意味します. 

注：検証のためにこのチャンクには特別なルールが適用されます. 詳細はセクション8.5.1を参照してください. 

長さ：16ビット（符号なし整数）

チャンクヘッダーと存在するすべてのエラー原因フィールドを含む、バイト単位のチャンクのサイズに設定します. 

エラー原因の定義については、セクション3.3.10を参照してください. 

3.3.8. シャットダウンアソシエーション（SHUTDOWN）（7）
アソシエーションのエンドポイントは、このチャンクを使用して、ピアとのアソシエーションの正常なクローズを開始する必要があります. このチャンクの形式は次のとおりです. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 7    | Chunk  Flags  |      Length = 8               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      Cumulative TSN Ack                       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時には0に設定され、受信時には無視されます. 

長さ：16ビット（符号なし整数）

パラメータの長さを示します. 8に設定します. 

累積TSN Ack：32ビット（符号なし整数）

このパラメーターには、ギャップの前に順番に受信された最後のチャンクのTSNが含まれます. 

注：SHUTDOWNメッセージにはギャップACKブロックが含まれていないため、順不同で受信したTSNの確認には使用できません. SACKで、以前に含まれていたギャップACKブロックの欠如は、データレシーバーが関連するDATA Chunksを破棄したことを示します. SHUTDOWNにはGap Ackブロックが含まれていないため、SHUTDOWNの受信者はGap Ackブロックがないことを根拠として解釈すべきではありません. （破棄の詳細については、セクション6.2を参照してください. ）

3.3.9. シャットダウン確認（SHUTDOWN ACK）（8）
このチャンクは、シャットダウンプロセスの完了時にSHUTDOWNチャンクの受信を確認するために使用する必要があります. 詳細については、セクション9.2を参照してください. 

SHUTDOWN ACKチャンクにはパラメーターがありません. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 8    |Chunk  Flags   |      Length = 4               |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時には0に設定され、受信時には無視されます. 

3.3.10. 操作エラー（ERROR）（9）
エンドポイントは、このチャンクをピアエンドポイントに送信して、特定のエラー状態を通知します. 1つ以上のエラー原因が含まれています. 操作エラー自体は致命的とは見なされませんが、ABORTチャンクと共に使用して致命的な状態を報告できます. 次のパラメーターがあります. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Type = 9    | Chunk  Flags  |           Length              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       \                                                               \
       /                    one or more Error Causes                   /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時には0に設定され、受信時には無視されます. 

長さ：16ビット（符号なし整数）

チャンクヘッダーと存在するすべてのエラー原因フィールドを含む、バイト単位のチャンクのサイズに設定します. 

エラーの原因は、セクション3.2.1で説明されている形式を使用した可変長パラメーターとして定義されます. 

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           Cause Code          |       Cause Length            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                    Cause-Specific Information                 /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
原因コード：16ビット（符号なし整数）

報告されるエラー状態のタイプを定義します. 

         原因コード
         値        原因コード
         --------- ----------------
          1         無効なストリーム識別子
          2         欠落している必須パラメーター
          3         古いCookieエラー
          4         リソース不足
          5         解決できないアドレス
          6         認識されないチャンクタイプ
          7         無効な必須パラメーター
          8         認識されないパラメーター
          9         ユーザーデータなし
         10         シャットダウン中に受信したCookie
         11         新しいアドレスとのassociationの再開
         12         ユーザーが開始した中止
         13         プロトコル違反
        
原因の長さ：16ビット（符号なし整数）

[原因コード]、[原因の長さ]、[原因固有の情報]フィールドを含む、パラメータのサイズをバイト単位で設定します. 

原因固有の情報：可変長

このフィールドには、エラー状態の詳細が含まれます. 

セクション3.3.10.1-セクション3.3.10.13は、SCTPのエラー原因を定義します. IETFが新しいエラー原因値を定義するためのガイドラインについては、セクション14.3で説明します. 

3.3.10.1. 無効なストリーム識別子（1）
   エラーの原因
   ---------------
        
無効なストリーム識別子：エンドポイントが、存在しないストリームに送信されたDATA Chunksを受信したことを示します. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Cause Code=1              |      Cause Length=8           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |        Stream Identifier      |         (Reserved)            |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
ストリーム識別子：16ビット（符号なし整数）

エラーで受信されたDATA Chunksのストリーム識別子が含まれます. 

予約済み：16ビット

このフィールドは予約されています. 送信時にはすべて0に設定され、受信時には無視されます. 

3.3.10.2. 必須パラメーターがありません（2）
   エラーの原因
   ---------------
        
欠落している必須パラメーター：受信したINITまたはINIT ACKで1つ以上の必須TLVパラメーターが欠落していることを示します. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Cause Code=2              |      Cause Length=8+N*2       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   Number of missing params=N                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Missing Param Type #1       |   Missing Param Type #2       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |   Missing Param Type #N-1     |   Missing Param Type #N       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
欠落しているパラメーターの数：32ビット（符号なし整数）

このフィールドには、Cause-Specific Informationフィールドに含まれているパラメーターの数が含まれています. 

パラメータタイプがありません：16ビット（符号なし整数）

各フィールドには、欠落している必須パラメーター番号が含まれます. 

3.3.10.3. 古いCookieエラー（3）
   エラーの原因
   --------------
        
古いCookieエラー：有効期限が切れた有効な状態Cookieの受信を示します. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Cause Code=3              |       Cause Length=8          |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                 Measure of Staleness (usec.)                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
古さの測定：32ビット（符号なし整数）

このフィールドには、現在の時刻と状態Cookieの有効期限が切れた時刻の差がマイクロ秒単位で含まれています. 

このエラーの原因の送信者は、「古さの測定」フィールドにゼロ以外の値を含めることにより、状態Cookieの有効期限が経過した期間を報告することを選択できます. 送信者がこの情報を提供したくない場合は、[古さの測定]フィールドをゼロの値に設定する必要があります. 

3.3.10.4. リソース不足（4）
   エラーの原因
   ---------------
        
リソース不足：送信者がリソース不足であることを示します. これは通常、ABORTと組み合わせて、またはABORT内で送信されます. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 4 | 原因の長さ= 4 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
3.3.10.5. 解決できないアドレス（5）
   エラーの原因
   ---------------
        
Unresolvable Address：送信者が指定されたアドレスパラメータを解決できないことを示します（たとえば、アドレスのタイプは送信者によってサポートされていません）. これは通常、ABORTと組み合わせて、またはABORT内で送信されます. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 5 | 原因の長さ|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       /解決できないアドレス/
       \ \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
解決できないアドレス：可変長

解決できないアドレスフィールドには、解決できないアドレスまたはホスト名を含むアドレスパラメータ（またはホスト名パラメータ）の完全なタイプ、長さ、および値が含まれます. 

3.3.10.6. 認識されないチャンクタイプ（6）
   エラーの原因
   ---------------
        
Unrecognized Chunk Type：このエラーの原因は、受信者がチャンクを理解せず、「チャンクタイプ」の上位ビットが01または11に設定されている場合、チャンクの発信者に返されます. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 6 | 原因の長さ|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       /認識できないチャンク/
       \ \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
認識されないチャンク：可変長

Unrecognized Chunkフィールドには、チャンクタイプ、チャンクフラグ、およびチャンク長を備えたSCTPパケットからの認識されないチャンクが含まれます. 

3.3.10.7. 無効な必須パラメーター（7）
   エラーの原因
   ---------------
        
無効な必須パラメーター：このエラーの原因は、必須パラメーターの1つが無効な値に設定されている場合、INITまたはINIT ACKチャンクの発信者に返されます. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 7 | 原因の長さ= 4 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
3.3.10.8. 認識されないパラメーター（8）
   エラーの原因
   ---------------
        
認識されないパラメーター：このエラー原因は、レシーバーがINIT ACKチャンク内の1つ以上のオプションのTLV(Type-Length-Value coding format)パラメーターを認識しない場合、INIT ACKチャンクの発信者に返されます. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |     Cause Code=8              |      Cause Length             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       /                  Unrecognized Parameters                      /
       \                                                               \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
        
認識されないパラメーター：可変長

Unrecognized Parametersフィールドには、TLVを備えたINIT ACKチャンクからコピーされた認識されないパラメーターが含まれています. このエラーの原因は、通常、INIT ACKに応答するときにCOOKIE ECHOチャンクにバンドルされているERRORチャンクに含まれています. COOKIEECHOチャンクの送信者が認識できないパラメータを報告する場合です. 

3.3.10.9. ユーザーデータなし（9）
   エラーの原因
   ---------------
        
ユーザーデータなし。受信したDATAチャンクにユーザーデータがない場合、DATAチャンクの送信元にこのエラー原因が返されます。

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 9 | 原因長さ= 8 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       / TSN値/
       \ \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
TSN値：32ビット（符号なし整数）

TSN値フィールドには、ユーザーデータフィールドなしで受信したDATA ChunksのTSNが含まれます. 

この原因コードは通常、ABORTチャンクで返されます（セクション6.2を参照）. 

3.3.10.10. シャットダウン中に受信したCookie（10）
   エラーの原因
   ---------------
        
シャットダウン中に受信したCookie：エンドポイントがSHUTDOWN-ACK-SENT状態のときにCOOKIE ECHOを受信しました. このエラーは通常、再送信されたSHUTDOWN ACKにバンドルされているERRORチャンクで返されます. 

       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 10 | 原因の長さ= 4 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
3.3.10.11. 新しいアドレスとのassociationの再開（11）
   エラーの原因
   --------------
        
新しいアドレスとのassociationの再開：既存のassociationでINITが受信されました. しかし、INITは以前はassociationの一部ではなかったアドレスをassociationに追加しました. 新しいアドレスはエラーコードにリストされます. このエラーは通常、INITを拒否するABORTの一部として送信されます（セクション5.2を参照）. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 11 | 原因長さ=変数|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       /新しいアドレスTLV /
       \ \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
注：各新しいアドレスTLVは、パラメータータイプとパラメーター長を含む、新しいINITチャンクで見つかったTLVの正確なコピーです. 

3.3.10.12. ユーザー開始の中止（12）
   エラーの原因
   --------------
        
このエラーの原因は、上位層の要求が原因で送信されるABORTチャンクに含まれる場合があります. 上位層は、SCTPによって透過的に転送される上位層中止理由を指定でき、ピアの上位層プロトコルに配信される場合があります. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 12 | 原因長さ=変数|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       /上層中止理由/
       \ \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
3.3.10.13. プロトコル違反（13）
   エラーの原因
   --------------
        
SCTPエンドポイントが、セクション3.3.10.1からセクション3.3.10.12で説明されているエラー原因でカバーされていないピアのプロトコル違反を検出するため、このエラー原因は送信されるABORTチャンクに含まれる場合があります. 実装は、検出されたプロトコル違反の種類を指定する追加情報を提供する場合があります. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 原因コード= 13 | 原因長さ=変数|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       / 追加情報 /
       \ \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
3.3.11. クッキーエコー（COOKIE ECHO）（10）
このチャンクは、associationの初期化中にのみ使用されます. アソシエーションのイニシエーターによってピアに送信され、初期化プロセスを完了します. このチャンクは、アソシエーション内で送信されるDATA Chunksの前になければなりません（MUST）が、同じパケット内の1つ以上のDATA Chunksにバンドルされる場合があります（MAY）. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | タイプ= 10 |チャンクフラグ| 長さ|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       / クッキー /
       \ \
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時には0に設定され、受信時には無視されます. 

長さ：16ビット（符号なし整数）

チャンクヘッダーの4バイトとCookieのサイズを含む、チャンクのサイズをバイト単位で設定します. 

Cookie：可変サイズ

このフィールドには、以前のINIT ACKからState Cookieパラメータで受け取った正確なCookieが含まれている必要があります. 

相互運用性を確保するために、実装ではCookieを可能な限り小さくする必要があります（SHOULD）. 

注：Cookieエコーには、State Cookieパラメーターは含まれていません. 代わりに、状態Cookieのパラメーター値内のデータは、Cookieエコーのチャンク値内のデータになります. これにより、実装でState Cookieパラメータの最初の2バイトのみを変更してCOOKIE ECHOチャンクにすることができます. 

3.3.12. Cookieの確認（COOKIE A​​CK）（11）
このチャンクは、associationの初期化中にのみ使用されます. COOKIE ECHOチャンクの受信を確認するために使用されます. このチャンクは、アソシエーション内で送信されるすべてのDATAまたはSACKチャンクの前になければなりません（MUST）が、同じSCTPパケット内の1つ以上のDATA ChunksまたはSACKチャンクとバンドルされる場合があります. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | タイプ= 11 |チャンクフラグ| 長さ= 4 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

送信時には0に設定され、受信時には無視されます. 

3.3.13. シャットダウン完了（SHUTDOWN COMPLETE）（14）
このチャンクは、シャットダウンプロセスの完了時にSHUTDOWN ACKチャンクの受信を確認するために使用する必要があります. 詳細については、セクション9.2を参照してください. 

SHUTDOWN COMPLETEチャンクにはパラメーターがありません. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | タイプ= 14 |予約済み| T | 長さ= 4 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
チャンクフラグ：8ビット

予約済み：7ビット

送信時には0に設定され、受信時には無視されます. 

Tビット：1ビット

送信者がピアが予期するVerification Tagを入力した場合、Tビットは0に設定されます. Verification Tagが反映されている場合は、Tビットを1に設定する必要があります. 反映とは、送信されたVerification Tagが受信したVerification Tagと同じであることを意味します. 

注：検証のためにこのチャンクに特別なルールが適用されます. 詳細については、セクション8.5.1を参照してください. 


4. SCTPアソシエーションの状態図
SCTPアソシエーションの存続期間中、SCTPエンドポイントのアソシエーションは、さまざまなイベントに応じて、ある状態から別の状態に進みます. Associationの状態を進める可能性のあるイベントには、次のものがあります. 

o SCTPユーザープリミティブコール、たとえば、[ASSOCIATE]、[SHUTDOWN]、[ABORT]、

o INIT、COOKIE ECHO、ABORT、SHUTDOWNなどの受信、チャンクの制御、または

oいくつかのタイムアウトイベント. 

下の図の状態図は、状態の変化を、原因となるイベントと結果のアクションとともに示しています. 一部のエラー状態は状態図に表示されないことに注意してください. すべての特殊なケースの完全な説明は、テキストに記載されています. 

注：チャンク名はすべて大文字で表記されますが、パラメーター名は最初の文字が大文字になります（例：COOKIE ECHOチャンクタイプとState Cookieパラメーター）. 状態遷移の原因となる複数のイベント/メッセージが発生する可能性がある場合は、（A）、（B）などのラベルが付けられます. 


                      -----          -------- (from any state)
                    /       \      /  rcv ABORT      [ABORT]
   rcv INIT        |         |    |   ----------  or ----------
   --------------- |         v    v   delete TCB     snd ABORT
   generate Cookie  \    +---------+                 delete TCB
   snd INIT ACK       ---|  CLOSED |
                         +---------+
                          /      \      [ASSOCIATE]
                         /        \     ---------------
                        |          |    create TCB
                        |          |    snd INIT
                        |          |    strt init timer
         rcv valid      |          |
       COOKIE  ECHO     |          v
   (1) ---------------- |      +------------+
       create TCB       |      | COOKIE-WAIT| (2)
       snd COOKIE ACK   |      +------------+
                        |          |
                        |          |    rcv INIT ACK
                        |          |    -----------------
                        |          |    snd COOKIE ECHO
                        |          |    stop init timer
                        |          |    strt cookie timer
                        |          v
                        |      +--------------+
                        |      | COOKIE-ECHOED| (3)
                        |      +--------------+
                        |          |
                        |          |    rcv COOKIE ACK
                        |          |    -----------------
                        |          |    stop cookie timer
                        v          v
                      +---------------+
                      |  ESTABLISHED  |
                      +---------------+
        
                    (from the ESTABLISHED state only)
                                  |
                                  |
                         /--------+--------\
     [SHUTDOWN]         /                   \
     -------------------|                   |
     check outstanding  |                   |
     DATA chunks        |                   |
                        v                   |
                   +---------+              |
                   |SHUTDOWN-|              | rcv SHUTDOWN
                   |PENDING  |              |------------------
                   +---------+              | check outstanding
                        |                   | DATA chunks
   No more outstanding  |                   |
   ---------------------|                   |
   snd SHUTDOWN         |                   |
   strt shutdown timer  |                   |
                        v                   v
                   +---------+        +-----------+
               (4) |SHUTDOWN-|        | SHUTDOWN- |  (5,6)
                   |SENT     |        | RECEIVED  |
                   +---------+        +-----------+
                        |  \                |
   (A) rcv SHUTDOWN ACK  |   \               |
   ----------------------|    \              |
   stop shutdown timer   |     \rcv:SHUTDOWN |
   send SHUTDOWN COMPLETE|      \  (B)       |
   delete TCB            |       \           |
                         |        \          | No more outstanding
                         |         \         |-----------------
                         |          \        | send SHUTDOWN ACK
   (B)rcv SHUTDOWN       |           \       | strt shutdown timer
   ----------------------|            \      |
   send SHUTDOWN ACK     |             \     |
   start shutdown timer  |              \    |
   move to SHUTDOWN-     |               \   |
   ACK-SENT              |                |  |
                         |                v  |
                         |             +-----------+
                         |             | SHUTDOWN- | (7)
                         |             | ACK-SENT  |
                         |             +----------+-
                         |                   | (C)rcv SHUTDOWN COMPLETE
                         |                   |-----------------
                         |                   | stop shutdown timer
                         |                   | delete TCB
                         |                   |
        
                         |                   | (D)rcv SHUTDOWN ACK
                         |                   |--------------
                         |                   | stop shutdown timer
                         |                   | send SHUTDOWN COMPLETE
                         |                   | delete TCB
                         |                   |
                         \    +---------+    /
                          \-->| CLOSED  |<--/
                              +---------+
        
図3：SCTPの状態遷移図

ノート：

1）受信したCOOKIE ECHOの状態Cookieが無効である（つまり、整合性チェックに合格しなかった）場合、受信者は静かにパケットを破棄する必要があります. または、受信した状態Cookieが期限切れの場合（セクション5.1.5を参照）、受信者はERRORチャンクを返送しなければなりません（MUST）. どちらの場合も、レシーバーはCLOSED状態のままです. 

2）T1-initタイマーの期限が切れた場合、エンドポイントはINITを再送信し、状態を変更せずにT1-initタイマーを再起動する必要があります. これは、 'Max.Init.Retransmits'回まで繰り返す必要があります. その後、エンドポイントは初期化プロセスを中止し、SCTPユーザーにエラーを報告する必要があります. 

3）T1-cookieタイマーの期限が切れた場合、エンドポイントはCOOKIE ECHOを再送信し、状態を変更せずにT1-cookieタイマーを再起動する必要があります. これは、 'Max.Init.Retransmits'回まで繰り返す必要があります. その後、エンドポイントは初期化プロセスを中止し、SCTPユーザーにエラーを報告する必要があります. 

4）SHUTDOWN-SENT状態では、エンドポイントは受信したDATA Chunksを遅延なく確認する必要があります. 

5）SHUTDOWN-RECEIVED状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません（MUST NOT）. 

6）SHUTDOWN-RECEIVED状態では、エンドポイントはデータを送信または再送信し、キュー内のすべてのデータが送信されたときにこの状態のままにする必要があります. 

7）SHUTDOWN-ACK-SENT状態では、エンドポイントはSCTPユーザーからの新しい送信要求を受け入れてはなりません（MUST NOT）. 

CLOSED状態は、associationが作成されていない（つまり、存在しない）ことを示すために使用されます. 


5.associationの初期化

最初のデータ転送が1つのSCTPエンドポイント（ "A"）から別のSCTPエンドポイント（ "Z"）に行われる前に、2つのエンドポイントは、それらの間のSCTPアソシエーションをセットアップするために初期化プロセスを完了する必要があります. 

エンドポイントのSCTPユーザーは、ASSOCIATEプリミティブを使用して、別のSCTPエンドポイントへのSCTPアソシエーションを初期化する必要があります. 

実装上の注意：SCTPユーザーの観点からすると、開始エンドポイントが最初のユーザーデータを宛先エンドポイントに送信することにより、ASSOCIATEプリミティブ（セクション10.1 Bを参照）を呼び出さなくても、associationを暗黙的に開くことができます. 開始SCTPは、INIT / INIT ACKのすべての必須パラメーターとオプションパラメーターのデフォルト値を想定します. 

アソシエーションが確立されると、片方向のストリームが両端のデータ転送用に開かれます（セクション5.1.1を参照）. 

5.1. Associationの通常の設立
初期化プロセスは次の手順で構成されます（SCTPエンドポイント「A」がSCTPエンドポイント「Z」とのassociationを設定しようとし、「Z」が新しいassociationを受け入れると想定）. 

A）「A」は最初に「Z」にINITチャンクを送信します. INITでは、 "A"はVerification Tag（Tag_A）を[開始タグ]フィールドに入力する必要があります. Tag_Aは、1から4294967295の範囲の乱数にする必要があります（タグ値の選択については、セクション5.3.1を参照）. INITの送信後、「A」はT1-initタイマーを開始し、COOKIE-WAIT状態に入ります. 

B）「Z」はINIT ACKチャンクで即座に応答するものとします. INIT ACKの宛先IPアドレスは、このINIT ACKが応答するINITのソースIPアドレスに設定する必要があります. 応答では、他のパラメータを入力するほかに、「Z」はVerification TagフィールドをTag_Aに設定し、独自のVerification Tag（Tag_Z）を開始タグフィールドに提供する必要があります. 

さらに、「Z」はINIT ACKとともに状態Cookieを生成して送信する必要があります. 状態Cookieの生成については、セクション5.1.3を参照してください. 

注：状態Cookieパラメーターを使用してINIT ACKを送信した後、 "Z"は新しいassociationのためにリソースを割り当てたり、状態を保持してはなりません（MUST NOT）. それ以外の場合、「Z」はリソース攻撃に対して脆弱になります. 

C）「Z」からINIT ACKを受信すると、「A」はT1初期化タイマーを停止し、COOKIE-WAIT状態を終了します. 次に、「A」は、INIT ACKチャンクで受信した状態CookieをCOOKIE ECHOチャンクで送信し、T1-cookieタイマーを開始して、COOKIE-ECHOED状態に入ります. 

注：COOKIE ECHOチャンクは、保留中の送信DATA Chunksとバンドルできますが、パケット内の最初のチャンクでなければならず、COOKIE A​​CKが返されるまで、送信者は他のパケットをピアに送信してはなりません. 

D）COOKIE ECHOチャンクを受信すると、TCBを構築してESTABLISHED状態に移行した後、エンドポイント "Z"はCOOKIE A​​CKチャンクで応答します. COOKIE A​​CKチャンクは保留中のDATA Chunks（またはSACKチャンク、あるいはその両方）にバンドルできますが、COOKIE A​​CKチャンクはパケットの最初のチャンクでなければなりません（MUST）. 

実装上の注意：実装は、有効なCOOKIE ECHOチャンクを受信すると、通信アップ通知をSCTPユーザーに送信することを選択できます. 

E）COOKIE A​​CKを受信すると、エンドポイント「A」はCOOKIE-ECHOED状態からESTABLISHED状態に移行し、T1- cookieタイマーを停止します. また、Communication Up通知でアソシエーションの確立が成功したことをULPに通知する場合もあります（セクション10を参照）. 

INITまたはINIT ACKチャンクは、他のチャンクとバンドルしてはいけません. それらは、それらを運ぶSCTPパケットに存在する唯一のチャンクでなければなりません. 

エンドポイントは、INITを受信したIPアドレスにINIT ACKを送信する必要があります. 

注：T1-initタイマーとT1-cookieタイマーは、セクション6.3で指定されたのと同じルールに従うものとします. 

エンドポイントがINIT、INIT ACK、またはCOOKIE ECHOチャンクを受信したが、受信したINITまたはINIT ACKに必須パラメーターが欠落している、無効なパラメーター値、またはローカルリソースがないために、新しいassociationを確立しないことを決定した場合、エンドポイントは、 ABORTチャンク. また、エラーの原因パラメーターをABORTチャンクに含めることで、欠落している必須パラメーターのタイプなど、中止の原因を指定する必要があります（SHOULD）. ABORTチャンクを含む発信SCTPパケットの共通ヘッダーのVerification Tagフィールドは、ピアの開始タグ値に設定する必要があります. 

整合性チェックに合格しないCOOKIE ECHOチャンクは「無効なパラメーター」とは見なされず、特別な処理が必要です. セクション5.1.5を参照してください. 

associationで最初のDATA Chunksを受信した後、エンドポイントはすぐにSACKで応答してDATA Chunksを確認する必要があります. その後の確認応答は、セクション6.2で説明されているように実行する必要があります. 

TCBが作成されると、各エンドポイントは、内部の累積TSN Ackポイントを、送信された初期TSN-1の値に設定する必要があります. 

実装上の注意：IPアドレスとSCTPポートは、通常、SCTPインスタンス内でTCBを見つけるためのキーとして使用されます. 

5.1.1. ストリームパラメータの処理
INITおよびINIT ACKチャンクでは、チャンクの送信者は、アソシエーションに含めたいアウトバウンドストリーム（OS）の数と、他のエンドポイントから受け入れる最大インバウンドストリーム（MIS）を示さなければなりません（MUST）. 

反対側からストリーム構成情報を受け取った後、各エンドポイントは次のチェックを実行する必要があります：ピアのMISがエンドポイントのOSより小さい場合、つまり、エンドポイントが構成するすべての送信ストリームをピアがサポートできない場合、エンドポイントMISアウトバウンドストリームを使用する必要があり、不足を上位層に報告する場合があります. 上位層は、リソース不足が許容できない場合、associationを中止することを選択できます. 

アソシエーションが初期化された後、いずれかのエンドポイントの有効なアウトバウンドストリーム識別子の範囲は0〜min（ローカルOS、リモートMIS）-1になります. 

5.1.2. アドレスパラメータの処理
アソシエーションの初期化中に、エンドポイントは次のルールを使用して、ピアの宛先トランスポートアドレスを検出および収集します. 

A）受信したINITまたはINIT ACKチャンクにアドレスパラメータが存在しない場合、エンドポイントは、チャンクの到着元の送信元IPアドレスを取得し、SCTP送信元ポート番号と組み合わせて、唯一の宛先トランスポートアドレスとして記録します. このピアのために. 

B）受信したINITまたはINIT ACKチャンクにホスト名パラメーターが存在する場合、エンドポイントはそのホスト名をIPアドレスのリストに解決し、解決されたものを組み合わせることにより、このピアのトランスポートアドレスを導出します.  SCTP送信元ポートのIPアドレス. 

エンドポイントは、受信したINITまたはINIT ACKチャンクにも存在する場合、他のIPアドレスパラメータを無視する必要があります. 

INITの受信者がホスト名を解決する時間は、SCTPに潜在的なセキュリティ上の影響があります. INITのレシーバーがチャンクの受信時にホスト名を解決し、ホスト名を解決するためにレシーバーが使用するメカニズムに潜在的な長い遅延（DNSクエリなど）が含まれる場合、レシーバーは、状態Cookieを構築してローカルリソースを解放する前に、名前解決の結果を待機している時間. 

したがって、名前の変換に潜在的な長い遅延が含まれる場合、INITの受信者は、ピアからのCOOKIE ECHOチャンクの受信まで名前解決を延期する必要があります. このような場合、INITの受信者は、（宛先トランスポートアドレスではなく）受信したホスト名を使用して状態Cookieを作成し、INITの送信元IPアドレスにINIT ACKを送信する必要があります（SHOULD）. 

INIT ACKの受信者は、チャンクを受信するとすぐに名前を解決しようとします. 

INITまたはINIT ACKの受信者は、ホスト名が正常に解決されるまで、ユーザーデータ（ピギーバックまたはスタンドアロン）をピアに送信してはなりません（MUST NOT）. 

名前解決が成功しなかった場合、エンドポイントは、「Unresolvable Address」エラーの原因を伴うABORTをすぐにピアに送信する必要があります. ABORTは、最後のピアパケットが受信された送信元IPアドレスに送信されます. 

C）受信したINITまたはINIT ACKチャンクにIPv4 / IPv6アドレスしかない場合、受信者は受信したチャンクからすべてのトランスポートアドレスと、INITまたはINIT ACKを送信したソースIPアドレスを導出して記録する必要があります. トランスポートアドレスは、（共通ヘッダーからの）SCTPソースポートと、INITまたはINIT ACKチャンクで伝送されるIPアドレスパラメータおよびIPデータグラムのソースIPアドレスの組み合わせによって導出されます. 受信者は、後続のパケットをピアに送信するときに、これらのトランスポートアドレスのみを宛先トランスポートアドレスとして使用する必要があります. 

D）チャンク内に含まれる有効なアドレスパラメータのいずれかを使用して既存のTCBを識別する場合、INITまたはINIT ACKチャンクは、すでに確立されたassociation（または確立中のassociation）に属するものとして扱われなければなりません（MUST）. 

実装上の注意：場合によっては（たとえば、実装が送信に使用されるソースIPアドレスを制御しない場合）、エンドポイントは、ピアへのパケットが送信できるすべての可能なIPアドレスをINITまたはINIT ACKに含める必要がある場合があります. 送信されます. 

上記のルールを使用してすべてのトランスポートアドレスがINITまたはINIT ACKチャンクから導出された後、エンドポイントはトランスポートアドレスの1つを初期プライマリパスとして選択する必要があります. 

注：INIT ACKは、INITのソースアドレスに送信する必要があります. 

INITの送信者は、どのタイプのアドレスが受け入れられるかを示すために、INITに「サポートされているアドレスタイプ」パラメータを含めることができます. このパラメーターが存在する場合、INIT（開始）の受信者は、INITに応答するときに、サポートされているアドレスタイプパラメーターに示されているアドレスタイプの1つを使用するか、または、「解決できないアドレス」エラーの原因でアソシエーションを中止する必要があります. または、そのピアが示すアドレスタイプを使用できません. 

実装上の注意：サポートされていないタイプが原因でINIT ACKの受信者がアドレスパラメータを解決できない場合、初期化プロセスを中止し、新しいINITの「サポートされているアドレスタイプ」パラメータを使用して再初期化を試みることができます. 優先するアドレスのタイプを示します. 

実装上の注意：IPv4またはIPv6のみをサポートするSCTPエンドポイントが、ピアからINITまたはINIT ACKチャンクでIPv4およびIPv6アドレスを受信する場合、サポートされているアドレスファミリに属する​​すべてのアドレスを使用する必要があります. 他のアドレスは無視されるかもしれません. エンドポイントは、いかなる種類のエラー表示でも応答してはなりません（SHOULD NOT）. 

実装上の注意：SCTPエンドポイントがIPv4またはIPv6の「サポートされているアドレスタイプ」パラメーターにリストされているが、INITチャンクを含むパケットの送信に他のファミリーを使用している場合、またはINITチャンクに他のファミリーのアドレスもリストされている場合、次に、「サポートされているアドレスタイプ」パラメータにリストされていないアドレスファミリも、INITチャンクの受信側によってサポートされていると見なされるべきです（SHOULD）. INITチャンクの受信者は、いかなる種類のエラー表示でも応答してはなりません（SHOULD NOT）. 

5.1.3. 状態Cookieの生成
INITチャンクへの応答としてINIT ACKを送信する場合、INIT ACKの送信者は状態Cookieを作成し、それをINIT ACKの状態Cookieパラメータで送信します. この状態Cookie内に、送信者はMAC（例として[RFC2104]を参照）、状態Cookieが作成されたときのタイムスタンプ、および状態Cookieの存続期間、およびそれを確立するために必要なすべての情報を含める必要がありますAssociation. 

状態Cookieを生成するには、次の手順を実行する必要があります. 

1）受信したINITと発信INIT ACKチャンクの両方からの情報を使用して、associationTCBを作成します. 

2）TCBで、作成時刻を現在の時刻に設定し、ライフスパンをプロトコルパラメータ 'Valid.Cookie.Life'に設定します（セクション15を参照）. 

3）TCBから、TCBを再作成するために必要な最小限の情報のサブセットを識別および収集し、この情報のサブセットと秘密鍵を使用してMACを生成します（MACの生成例については[RFC2104]を参照）. 

4）この情報のサブセットと結果のMACを組み合わせて、ステートCookieを生成します. 

State Cookieパラメーターを使用してINIT ACKを送信した後、送信者は、リソースの攻撃を防ぐために、TCBおよび新しいassociationに関連するその他のローカルリソースを削除する必要があります（SHOULD）. 

MACを生成するために使用されるハッシュ方式は、厳密にはINITチャンクの受信者の個人的な問題です. サービス拒否攻撃を防ぐには、MACの使用が必須です. 秘密鍵はランダムである必要があります（[RFC4086]はランダム性ガイドラインに関する情報を提供します）. それは合理的に頻繁に変更されるべきであり、状態クッキーのタイムスタンプは、どのキーがMACを検証するために使用されるべきかを決定するために使用されるかもしれません. 

相互運用性を確保するために、実装ではCookieを可能な限り小さくする必要があります（SHOULD）. 

5.1.4. 状態Cookie処理
エンドポイント（COOKIE-WAIT状態）が状態Cookieパラメーターを含むINIT ACKチャンクを受信すると、受信した状態Cookieを含むピアにCOOKIE ECHOチャンクをすぐに送信する必要があります. 送信者は、COOKIE ECHOチャンクの後に、保留中のDATA Chunksをパケットに追加してもよい（MAY）. 

エンドポイントは、COOKIE ECHOチャンクを送信した後、T1-cookieタイマーも開始します. タイマーの期限が切れた場合、エンドポイントはCOOKIE ECHOチャンクを再送信し、T1-cookieタイマーを再起動します. これは、COOKIE A​​CKが受信されるか、「Max.Init.Retransmits」（セクション15を参照）に到達するまで繰り返され、ピアエンドポイントが到達不能としてマークされます（したがって、associationはCLOSED状態になります）. 

5.1.5. 状態Cookie認証
エンドポイントは、associationのない別のエンドポイントからCOOKIE ECHOチャンクを受信すると、次のアクションを実行します. 

1）StateのCookieと秘密鍵で運ばれるTCBデータを使用してMACを計算します（StateのCookieのタイムスタンプを使用して、使用する秘密鍵を決定できます）. [RFC2104]は、MACを生成するためのガイドラインとして使用できます. 

2）計算されたMACを状態Cookieで運ばれたものと比較することにより、以前に生成したものとして状態Cookieを認証します. この比較が失敗した場合、COOKIE ECHOとDATA Chunksを含むSCTPパケットは、警告なしで破棄されます. 

3）COOKIE ECHOチャンク内に含まれるポート番号とVerification Tagを、受信したパケットのSCTP共通ヘッダー内の実際のポート番号とVerification Tagと比較します. これらの値が一致しない場合、パケットは静かに破棄されなければなりません（MUST）. 

4）状態Cookieの作成タイムスタンプを現在の現地時間と比較します. 経過時間がState Cookieで運ばれる寿命よりも長い場合、COOKIE ECHOおよび添付されたDATA Chunksを含むパケットは破棄する必要があり、エンドポイントは、「古いCookie」エラーの原因を含むERRORチャンクを送信する必要があります. ピアエンドポイント. 

5）状態Cookieが有効な場合、COOKIE ECHOで伝送されるTCBデータの情報を使用してCOOKIE ECHOチャンクの送信者へのassociationを作成し、ESTABLISHED状態に入ります. 

6）COOKIEエコーの受信を確認するピアにCOOKIE A​​CKチャンクを送信します. COOKIE A​​CKは、送信DATA ChunksまたはSACKチャンクにバンドルされる場合があります. ただし、COOKIE A​​CKはSCTPパケットの最初のチャンクでなければなりません. 

7）COACKIE ECHOにバンドルされているDATA ChunksをSACKですぐに確認します（後続のDATA Chunksの確認応答は、セクション6.2で定義されたルールに従う必要があります）. ステップ6で述べたように、SACKがCOOKIE A​​CKにバンドルされている場合、COOKIE A​​CKはSCTPパケットの最初に現れる必要があります. 

COOKIE ECHOの受信者が既存のassociationを持つエンドポイントからCOOKIE ECHOを受信した場合は、セクション5.2の手順に従う必要があります. 

5.1.6. 通常のアソシエーション確立の例
次の例では、「A」がassociationを開始してから「Z」にUser messageを送信し、その後「Z」が2つのUser messageを「A」に送信します（Bundlingまたはフラグメンテーションが発生しないと想定）. 

    Endpoint A                                          Endpoint Z
    {app sets association with Z}
    (build TCB)
    INIT [I-Tag=Tag_A
          & other info]  ------\
    (Start T1-init timer)       \
    (Enter COOKIE-WAIT state)    \---> (compose temp TCB and Cookie_Z)
                                    /-- INIT ACK [Veri Tag=Tag_A,
                                   /             I-Tag=Tag_Z,
    (Cancel T1-init timer) <------/              Cookie_Z, & other info]
                                         (destroy temp TCB)
    COOKIE ECHO [Cookie_Z] ------\
    (Start T1-init timer)         \
    (Enter COOKIE-ECHOED state)    \---> (build TCB enter ESTABLISHED
                                          state)
                                   /---- COOKIE-ACK
                                  /
    (Cancel T1-init timer, <-----/
     Enter ESTABLISHED state)
    {app sends 1st user data; strm 0}
    DATA [TSN=initial TSN_A
        Strm=0,Seq=0 & user data]--\
    (Start T3-rtx timer)            \
                                     \->
                                   /----- SACK [TSN Ack=init
                                  /           TSN_A,Block=0]
    (Cancel T3-rtx timer) <------/
                                          ...
                                         {app sends 2 messages;strm 0}
                                   /---- DATA
                                  /        [TSN=init TSN_Z
                              <--/          Strm=0,Seq=0 & user data 1]
    SACK [TSN Ack=init TSN_Z,      /---- DATA
          Block=0]     --------\  /        [TSN=init TSN_Z +1,
                                \/          Strm=0,Seq=1 & user data 2]
                         <------/\
                                  \
                                   \------>

                        Figure 4: INITIATION Example

INITまたはCOOKIE ECHOチャンクが送信された後にT1-initタイマーが「A」で期限切れになる場合、同じINITまたはCOOKIE ECHOチャンクが同じ開始タグ（つまり、Tag_A）または状態Cookieを使用して再送信され、タイマーが再開されます. これは、 "A"が "Z"に到達できないと見なし、障害を上位層に報告する（したがって、associationがCLOSED状態になる）前に、Max.Init.Retransmitsの回数繰り返されます. 

INITを再送信するとき、エンドポイントは適切なタイマー値を決定するためにセクション6.3で定義されたルールに従う必要があります. 

5.2. 重複または予期しないINIT、INIT ACK、COOKIE ECHO、およびCOOKIE A​​CKの処理

アソシエーションの存続期間中（可能な状態の1つ）、エンドポイントは、ピアエンドポイントからセットアップチャンク（INIT、INIT ACK、COOKIE ECHO、およびCOOKIE A​​CK）の1つを受信する場合があります. 受信者は、このようなセットアップチャンクを複製として扱い、このセクションで説明するように処理します. 

注：チャンクがSCTPトランスポートアドレスに送信され、このエンドポイントにassociationられたSCTPトランスポートアドレスからのものでない限り、エンドポイントはチャンクを受信しません. したがって、エンドポイントはそのようなチャンクを現在のassociationの一部として処理します. 

次のシナリオは、チャンクの重複または予期しないチャンクを引き起こす可能性があります. 

A）ピアは検出されずにクラッシュし、再起動し、associationを復元しようとする新しいINITチャンクを送信しました、

B）両側がほぼ同時にassociationを初期化しようとしている、

C）チャンクは、現在のassociationまたは存在しなくなった過去のassociationを確立するために使用された古いパケットからのものです. 

D）チャンクは、攻撃者によって生成された偽のパケット、または

E）ピアがCOOKIE A​​CKを受信したことがなく、COOKIE ECHOを再送信しています. 

これらのケースを識別して正しく処理するために、次のセクションのルールが適用されます. 

5.2.1. COOKIE-WAITまたはCOOKIE-ECHOED状態で受信したINIT（項目B）
これは通常、初期化の衝突を示します. つまり、各エンドポイントがほぼ同時に、他のエンドポイントとのassociationを確立しようとしています. 

COOKIE-WAIT状態でINITを受信すると、エンドポイントは、元のINITチャンクで送信したのと同じパラメーター（変更されていない開始タグを含む）を使用して、INIT ACKで応答する必要があります. 応答するとき、エンドポイントは、元のINIT（このエンドポイントによって送信された）が送信されたのと同じアドレスにINIT ACKを送信する必要があります. 

COOKIE-ECHOED状態のINITを受信すると、新しいアドレスがに追加されていない限り、エンドポイントは、元のINITチャンクで送信したのと同じパラメーター（変更されていない初期化タグを含む）を使用して、INIT ACKで応答する必要があります. Associationを結成. 新しいアドレスがassociationに追加されたことをINITメッセージが示している場合は、INIT全体を破棄する必要があり、既存のassociationは変更しないでください. ABORT SHOULDは、「新しいアドレスとのアソシエーションの再開」というエラーを含む可能性があるという応答として送信する必要があります. エラーは、再起動アソシエーションに追加されたアドレスをリストする必要があります（SHOULD）. 

どちらかの状態（COOKIE-WAITまたはCOOKIE-ECHOED）でINIT ACKを使用して応答すると、元のパラメーターは、新しく受信したINITチャンクからのパラメーターと結合されます. エンドポイントは、INIT ACKを使用して状態Cookieも生成します. エンドポイントは、INITで送信されたパラメーターを使用して、状態Cookieを計算します. 

その後、エンドポイントはその状態を変更してはならず（MUST NOT）、T1-initタイマーは実行されたままであり、対応するTCBは破棄されてはなりません（MUST NOT）. TCBが存在する場合に状態Cookieを処理する通常の手順では、重複するINITを単一のassociationに解決します. 

COOKIE-ECHOED状態にあるエンドポイントの場合、アソシエーションTCB内と状態Cookie内の両方にそのTieタグを設定する必要があります（Tieタグの説明については、セクション5.2.2を参照してください）. 

5.2.2. CLOSED、COOKIE-ECHOED、COOKIE-WAIT、およびSHUTDOWN-ACK-SENT以外の状態での予期しないINIT

特に明記されていない限り、このassociationの予期しないINITを受信すると、エンドポイントは状態Cookieを使用してINIT ACKを生成します. 応答する前に、エンドポイントは、予期しないINITが新しいアドレスをassociationに追加するかどうかを確認する必要があります. アソシエーションに新しいアドレスが追加された場合、エンドポイントはABORTで応答する必要があり、予期しないINITの「開始タグ」を、ABORTを運ぶ送信パケットの「Verification Tag」にコピーする必要があります. ABORT応答では、エラーの原因は「新しいアドレスとのassociationの再開」に設定される場合があります. エラーは、再起動アソシエーションに追加されたアドレスをリストする必要があります（SHOULD）. 新しいアドレスが追加されない場合、アウトバウンドINIT ACKのINITに応答するとき、エンドポイントは、現在のTie-Tagsを状態CookieとAssociationのTCB内の予約された場所にコピーする必要があります. Cookie内のこれらの場所を、Peer's-Tie-TagおよびLocal-Tie-Tagと呼びます. AssociationのTCB内のコピーをローカルタグおよびピアのタグと呼びます. このINIT ACKを含むアウトバウンドSCTPパケットは、予期しないINITで見つかった開始タグと等しいVerification Tag値を運ぶ必要があります. また、INIT ACKには新しい開始タグ（ランダムに生成されます. セクション5.3.1を参照）を含める必要があります. エンドポイントの他のパラメーターは、associationの既存のパラメーター（たとえば、送信ストリームの数）からINIT ACKおよびCookieにコピーする必要があります（SHOULD）. AssociationのTCB内のコピーをローカルタグおよびピアのタグと呼びます. このINIT ACKを含むアウトバウンドSCTPパケットは、予期しないINITで見つかった開始タグと等しいVerification Tag値を運ぶ必要があります. また、INIT ACKには新しい開始タグ（ランダムに生成されます. セクション5.3.1を参照）を含める必要があります. エンドポイントの他のパラメーターは、associationの既存のパラメーター（たとえば、送信ストリームの数）からINIT ACKおよびCookieにコピーする必要があります（SHOULD）. AssociationのTCB内のコピーをローカルタグおよびピアのタグと呼びます. このINIT ACKを含むアウトバウンドSCTPパケットは、予期しないINITで見つかった開始タグと等しいVerification Tag値を運ぶ必要があります. また、INIT ACKには新しい開始タグ（ランダムに生成されます. セクション5.3.1を参照）を含める必要があります. エンドポイントの他のパラメーターは、associationの既存のパラメーター（たとえば、送信ストリームの数）からINIT ACKおよびCookieにコピーする必要があります（SHOULD）. 

INIT ACKまたはABORTを送信した後、エンドポイントはそれ以上のアクションを実行してはなりません. つまり、現在の状態を含む既存のassociation、および対応するTCBを変更してはなりません（MUST NOT）. 

注：TCBが存在し、associationがCOOKIE-WAITまたはSHUTDOWN-ACK-SENT状態でない場合にのみ、Tie-Tagsに0以外の値が入力されます. 通常のassociationINITの場合（つまり、エンドポイントはCLOSED状態）、Tie-Tagは0に設定する必要があります（以前のTCBが存在しなかったことを示します）. 

5.2.3. 予期しないINIT ACK
INIT ACKがCOOKIE-WAIT状態以外の状態のエンドポイントによって受信された場合、エンドポイントはINIT ACKチャンクを破棄する必要があります. 予期しないINIT ACKは、通常、古いまたは重複したINITチャンクの処理を示します. 

5.2.4. TCBが存在する場合のCOOKIE ECHOの処理
COOKIE ECHOチャンクが既存のアソシエーションの任意の状態（つまり、CLOSED状態ではない）のエンドポイントによって受信された場合、次のルールが適用されます. 

1）セクション5.1.5のステップ1の説明に従ってMACを計算します. 

2）セクション5.1.5のステップ2で説明されているように、ステートCookieを認証します（これは上記のケースCまたはDです）. 

3）状態Cookieのタイムスタンプを現在の時刻と比較します. 状態Cookieが状態Cookieに含まれる寿命よりも古く、状態Cookieに含まれているVerification Tagが現在のassociationのVerification Tagと一致しない場合、COOKIE ECHOおよびすべてのDATA Chunksを含むパケットを破棄する必要があります. エンドポイントはまた、「古いCookie」エラーの原因を含むERRORチャンクをピアエンドポイントに送信する必要があります（これは、セクション5.2のケースCまたはDです）. 

状態Cookieの両方のVerification Tagが現在のassociationのVerification Tagと一致する場合、寿命を超えていても、状態Cookieは有効である（セクション5.2のケースE）と見なします. 

4）StateのCookieが有効であることが判明した場合は、TCBを一時的なTCBに解凍します. 

5）表2を参照して、実行する正しいアクションを判別してください. 

+ ------------ + ------------ + --------------- + ------- ------- + ------------- +
| ローカルタグ| ピアのタグ| ローカルTie-Tags|ピアのTie-Tags| アクション/ |
| | | | | 説明|
+ ------------ + ------------ + --------------- + ------- ------- + ------------- +
| X | X | M | M | （A）|
+ ------------ + ------------ + --------------- + ------- ------- + ------------- +
| M | X | A | A | （B）|
+ ------------ + ------------ + --------------- + ------- ------- + ------------- +
| M | 0 | A | A | （B）|
+ ------------ + ------------ + --------------- + ------- ------- + ------------- +
| X | M | 0 | 0 | （C）|
+ ------------ + ------------ + --------------- + ------- ------- + ------------- +
| M | M | A | A | （D）|
+ ================================================= ===================== +
| 表2：TCBが存在する場合のCOOKIE ECHOの処理|
+ ================================================= ===================== +
        
Legend：

X-タグが既存のTCBと一致しません. M-タグは既存のTCBと一致します. 0-CookieにTie-Tagsがありません（不明）. A-すべてのケース、つまりM、X、または0. 

注：表2に示されていないケースでは、Cookieは暗黙的に破棄されます. 

アクション

A）この場合、ピアは再起動している可能性があります. エンドポイントがこの「再起動」の可能性を認識すると、既存のセッションは、次の例外を除いて、ABORTの後に新しいCOOKIE ECHOが続く場合と同じように扱われます. 

-SCTP DATA Chunksは保持される場合があります（これは実装固有のオプションです）. 

-RESTARTの通知は、「COMMUNICATION LOST」通知の代わりにULPに送信する必要があります. 

このピアに関連するすべての輻輳制御パラメータ（cwnd、ssthreshなど）は、初期値にリセットする必要があります（セクション6.2.1を参照）. 

この後、エンドポイントはESTABLISHED状態に入ります. 

エンドポイントがSHUTDOWN-ACK-SENT状態にあり、ピアが再起動したことを認識する場合（アクションA）、新しいアソシエーションをセットアップしてはならず、代わりにSHUTDOWN ACKを再送信して、「シャットダウン中に受信したCookieを含む」エラーチャンクを送信する必要があります. ピアへの「ダウン」エラーの原因. 

B）この場合、両側がほぼ同時にアソシエーションを開始しようとしている可能性がありますが、ピアエンドポイントはローカルエンドポイントのINITに応答した後にINITを開始しました. したがって、このエンドポイントに送信した以前のタグを認識せずに、新しいVerification Tagを選択した可能性があります. エンドポイントはESTABLISHED状態を維持または開始する必要がありますが、ピアのVerification Tagを状態Cookieから更新し、実行中の可能性のあるinitまたはcookieタイマーを停止し、COOKIE A​​CKを送信する必要があります. 

C）この場合、ローカルエンドポイントのCookieの到着が遅れています. 到着する前に、ローカルエンドポイントはINITを送信してINIT ACKを受信し、最後にピアの同じタグを使用して独自の新しいタグを付けたCOOKIE ECHOを送信しました. クッキーは黙って破棄されるべきです. エンドポイントは状態を変更してはならず（SHOULD NOT）、タイマーを実行したままにしておく必要があります. 

D）ローカルタグとリモートタグの両方が一致する場合、エンドポイントがCOOKIE-ECHOED状態であれば、エンドポイントはESTABLISHED状態に入る必要があります. 実行中の可能性があるCookieタイマーを停止し、COOKIE A​​CKを送信する必要があります. 

注：「ピアのVerification Tag」は、INITまたはINIT ACKチャンクのInitiate Tagフィールドで受信されたタグです. 

5.2.4.1. An Example of a Association Restart
   次の例では、 "A"はaの後にassociationを開始します. 
   再起動が発生しました. エンドポイント "Z"は再起動を認識していませんでした
   交換まで（つまり、ハートビートはまだ障害を検出していませんでした）
   「A」）（Bundlingまたはフラグメンテーションが発生しないと想定）：
   
      Endpoint A                                          Endpoint Z
   <-------------- Association is established---------------------->
   Tag=Tag_A                                             Tag=Tag_Z
   <--------------------------------------------------------------->
   {A crashes and restarts}
   {app sets up a association with Z}
   (build TCB)
   INIT [I-Tag=Tag_A'
         & other info]  --------\
   (Start T1-init timer)         \
   (Enter COOKIE-WAIT state)      \---> (find an existing TCB
                                         compose temp TCB and Cookie_Z
                                         with Tie-Tags to previous
                                         association)
                                   /--- INIT ACK [Veri Tag=Tag_A',
                                  /               I-Tag=Tag_Z',
   (Cancel T1-init timer) <------/                Cookie_Z[TieTags=
                                                  Tag_A,Tag_Z
                                                   & other info]
                                        (destroy temp TCB,leave original
                                         in place)
   COOKIE ECHO [Veri=Tag_Z',
                Cookie_Z
                Tie=Tag_A,
                Tag_Z]----------\
   (Start T1-init timer)         \
   (Enter COOKIE-ECHOED state)    \---> (Find existing association,
                                         Tie-Tags match old tags,
                                         Tags do not match, i.e.,
                                         case X X M M above,
                                         Announce Restart to ULP
                                         and reset association).
                                  /---- COOKIE ACK
   (Cancel T1-init timer, <------/
    Enter ESTABLISHED state)
   {app sends 1st user data; strm 0}
   DATA [TSN=initial TSN_A
       Strm=0,Seq=0 & user data]--\
   (Start T3-rtx timer)            \
                                    \->
                                 /--- SACK [TSN Ack=init TSN_A,Block=0]
   (Cancel T3-rtx timer) <------/

                        Figure 5: A Restart Example
        
図5：再起動の例

5.2.5. 重複するCOOKIE-ACKを処理します. 

COOKIE-ECHOED以外の状態では、エンドポイントは受信したCOOKIE A​​CKチャンクをサイレントに破棄する必要があります. 

5.2.6. 古いCOOKIEエラーを処理する
「古くなったCookie」エラーの原因を含むERRORチャンクを受け取った場合、考えられるいくつかのイベントの1つを示します. 

A）送信者が発行した状態Cookieが処理される前に、associationを完全にセットアップできませんでした. 

B）セットアップの完了後に、古い状態のCookieが処理されました. 

C）受信者がアソシエーションを持つことに興味がなく、ABORTチャンクが失われた誰かから古いState Cookieが受信された. 

「古くなったCookie」エラーが発生したERRORチャンクを処理する場合、エンドポイントはまず、associationが設定中かどうか、つまりassociationがCOOKIE-ECHOED状態にあるかどうかを調べる必要があります. すべてのケースで、associationがCOOKIE-ECHOED状態でない場合、ERRORチャンクは通知なく破棄されます. 

associationがCOOKIE-ECHOED状態にある場合、エンドポイントは次の3つの選択肢のいずれかを選択できます. 

1）新しいINITチャンクをエンドポイントに送信して、新しい状態Cookieを生成し、セットアップ手順を再試行します. 

2）TCBを破棄し、associationをセットアップできないことを上位層に報告します. 

3）ステートCookieの存続期間の延長を要求するCookie Preservativeパラメーターを追加して、新しいINITチャンクをエンドポイントに送信します. 時間延長を計算するとき、実装は、以前のCOOKIE ECHO / ERROR交換に基づいて測定されたRTT情報を使用する必要があり、測定されたRTTを1秒以内に追加する必要があります. リプレイ攻撃. 

5.3. その他の初期化の問題
5.3.1. タグ値の選択
開始タグの値は、1から2 ** 32-1の範囲から選択する必要があります. 「中間者」および「シーケンス番号」の攻撃から保護するには、開始タグの値をランダム化することが非常に重要です. [RFC4086]で説明されている方法は、タグのランダム化の開始に使用できます. 以前のアソシエーションからの古い重複パケットが現在のアソシエーションに属するものとして誤って処理されるのを防ぐために、開始タグを慎重に選択することも必要です. 

さらに、特定のアソシエーションのいずれかのエンドポイントで使用されるVerification Tagの値は、アソシエーションの存続期間中に変更してはなりません. エンドポイントが切断され、同じピアへのassociationを再確立するたびに、新しいVerification Tag値を使用する必要があります. 

5.4. パス検証
アソシエーションの確立中に、2つのピアはアドレスのリストを交換します. 主なケースでは、これらのリストは各ピアが所有するアドレスを正確に表します. ただし、正常に動作しないピアが、所有していないアドレスを提供する可能性があります. これを防ぐために、次のルールが新しいassociationのすべてのアドレスに適用されます. 

1）上位層によってINITの送信側に渡されたアドレスは、自動的にCONFIRMEDと見なされます. 

2）COOKIE ECHOの受信側の場合、CONFIRMEDアドレスは、INIT-ACKが送信されたアドレスのみです. 

3）ルール1および2でカバーされていない他のすべてのアドレスは、未確認と見なされ、検証のためにプローブの対象となります. 

検証のためにアドレスをプローブするために、エンドポイントは、HEARTBEATパラメーター内で64ビットのランダムnonceと（HEARTBEATの送信先アドレスを識別するための）パスインジケーターを含むHEARTBEATを送信します. 

HEARTBEAT ACKを受信すると、HEARTBEATパラメータに含まれているnonceがHEARTBEATパラメータ内に示されたアドレスに送信されたものであることが確認されます. この一致が発生すると、元のHEARTBEATが送信されたアドレスはCONFIRMEDと見なされ、通常のデータ転送に使用できるようになります. 

これらのプロービング手順は、associationがESTABLISHED状態に移行したときに開始され、すべてのパスが確認されたときに終了します. 

各RTOで、プローブをCONFIRMED状態に移動しようとして、アクティブなUNCONFIRMEDパスでプローブが送信される場合があります. このプローブ中にパスが非アクティブになると、このレートは通常のハートビートレートまで低下します. RTOタイマーの満了時に、セクション8.2で定義されているように、プローブされたがCONFIRMEDでなかったすべてのパスのエラーカウンターが1つインクリメントされ、パス障害検出が行われます. ただし、UNCONFIRMEDアドレスをプローブする場合、アソシエーション全体のエラーカウントは増加しません. 

各RTOで送信されるHEARTBEATSの数は、HB.Max.Burstパラメーターによって制限されるべきです（SHOULD）. これは、パス検証のためにハートビートをピアのアドレスに配布する方法に関する実装の決定です. 

パスが確認されるときはいつでも、上位層に通知が与えられてもよい（MAY）. 

エンドポイントは、次の例外を除いて、チャンクをUNCONFIRMEDアドレスに送信してはなりません（MUST NOT）. 

-nonceを含むHEARTBEATは、UNCONFIRMEDアドレスに送信される場合があります. 

-ハートビートACKは、確認されていないアドレスに送信される場合があります. 

-COOKIE A​​CKは、確認されていないアドレスに送信される場合がありますが、ノンスを含むハートビートにバンドルされている必要があります. Bundlingをサポートしない実装は、COOKIE A​​CKをUNCONFIRMEDアドレスに送信してはなりません（MUST NOT）. 

-クッキーエコーは未確認のアドレスに送信される場合がありますが、ナンスを含むハートビートにバンドルされている必要があり、パケットはパスMTUを超えてはなりません. 実装がバンドルをサポートしていない場合、またはバンドルされたCOOKIE ECHOとHEARTBEAT（nonceを含む）がパスMTUを超える場合、実装はCOOKIE ECHOをUNCONFIRMEDアドレスに送信してはなりません（MUST NOT）. 

6.ユーザーデータ転送
データ送信は、ESTABLISHED、SHUTDOWN-PENDING、およびSHUTDOWN-RECEIVED状態でのみ発生する必要があります. これの唯一の例外は、COOKIE-WAIT状態の場合、DATA ChunksをアウトバウンドCOOKIE ECHOチャンクにバンドルできることです. 

DATA Chunksは、下記のESTABLISHED、SHUTDOWN-PENDING、およびSHUTDOWN-SENTのルールに従ってのみ受信する必要があります. CLOSEDで受信されたDATA Chunksは不意に使用されており、セクション8.4に従って処理する必要があります. 他の状態で受信したDATA Chunksは破棄する必要があります（SHOULD）. 

SACKは、ESTABLISHED、SHUTDOWN-PENDING、およびSHUTDOWN-RECEIVEDで処理する必要があります. 着信SACKはCOOKIE-ECHOEDで処理される場合があります. CLOSED状態のSACKは予定外であり、セクション8.4のルールに従って処理する必要があります（SHOULD）. 他の状態で受信したSACKチャンクは破棄する必要があります（SHOULD）. 

SCTPレシーバーは、1つのSCTPパケットで最小1500バイトを受信できる必要があります. これは、SCTPエンドポイントがINITまたはINIT ACKで送信された最初のa_rwndで1500バイト未満を示してはならないことを意味します. 

伝送効率を高めるために、SCTPは小さなUser messageのBundlingと大きなUser messageのフラグメンテーションのメカニズムを定義しています. 次の図は、SCTPを介したUser messageのフローを示しています. 

このセクションでは、「データ送信者」という用語はDATA Chunksを送信するエンドポイントを指し、「データ受信者」という用語はDATA Chunksを受信するエンドポイントを指します. データレシーバーはSACKチャンクを送信します. 

                 +--------------------------+
                 |      User Messages       |
                 +--------------------------+
       SCTP user        ^  |
      ==================|==|=======================================
                        |  v (1)
             +------------------+    +--------------------+
             | SCTP DATA Chunks |    |SCTP Control Chunks |
             +------------------+    +--------------------+
                        ^  |             ^  |
                        |  v (2)         |  v (2)
                     +--------------------------+
                     |      SCTP packets        |
                     +--------------------------+
       SCTP                      ^  |
      ===========================|==|===========================
                                 |  v
             Connectionless Packet Transfer Service (e.g., IP)
        
ノート：

1）User messageをDATA Chunksに変換すると、エンドポイントは現在のassociationパスMTUよりも大きいUser messageを複数のDATA Chunksにフラグメント化します. データレシーバーは通常、DATA Chunksからの断片化されたメッセージをユーザーに配信する前に再構成します（詳細については、セクション6.9を参照してください）. 

2）パケットの最終的なサイズが現在のパスMTUを超えない限り、複数のDATA Chunksと制御チャンクが送信側によって1つのSCTPパケットにバンドルされて送信されます. レシーバーはパケットを元のチャンクにアンバンドルします. 制御チャンクは、パケットのDATA Chunksの前に来る必要があります. 

図6：ユーザーデータ転送の図

セクション6.9とセクション6.10で説明されているように、断片化とBundlingのメカニズムは、データ送信者が実装するオプションですが、データ受信者が実装する必要があります. つまり、エンドポイントは、バンドルまたはフラグメント化されたデータを適切に受信して処理する必要があります. 

6.1. DATA Chunksの送信
このドキュメントは、あて先トランスポートアドレスごとに単一の再送信タイマーがあるかのように指定されていますが、実装では、各DATA Chunksに再送信タイマーがある場合があります. 

次の一般的なルールは、送信DATA Chunksの送信および/または再送信のためにデータ送信者によって適用される必要があります. 

A）ピアのrwndがピアにバッファスペースがないことを示している場合（rwndが0、セクション6.2.1を参照）、データ送信者は常に新しいトランスポートアドレスに新しいデータを送信してはなりません（MUST NOT）. ただし、rwndの値（0の場合も含む）に関係なく、cwndで許可されていれば、データ送信者は常に1つのDATA Chunksを受信者に送信できます（以下のルールBを参照）. このルールにより、送信者は、データ受信者からデータ送信者への転送中にSACKが失われたために送信者が見逃したrwndの変更をプローブできます. 

レシーバーのアドバタイズされたウィンドウがゼロの場合、このプローブはゼロウィンドウプローブと呼ばれます. ゼロウィンドウプローブは、すべての未処理のDATA Chunksが累積的に確認され、DATA Chunksが実行されていない場合にのみ送信する必要があることに注意してください. ゼロウィンドウプローブをサポートする必要があります. 

ゼロウィンドウプローブを実行している間、送信側が受信側から新しいパケットを受信し続ける場合、未確認ウィンドウプローブは、アソシエーションまたは宛先トランスポートアドレスのエラーカウンターをインクリメントしないでください. これは、レシーバーがウィンドウを無期限に閉じたままにする可能性があるためです. ゼロウィンドウをアドバタイズするときのレシーバーの動作については、セクション6.2を参照してください. 送信側は、受信側がウィンドウを閉じたことを検出すると、1 RTOの後に最初のゼロウィンドウプローブを送信する必要があり（SHOULD）、その後、プローブ間隔を指数関数的に増加させる必要があります（SHOULD）. また、cwndはセクション7.2.1に従って調整する必要があることに注意してください. ゼロウィンドウプローブは、cwndの計算に影響を与えません. 

[RFC0813]で説明されているように、送信者は新しいDATA Chunksを送信して愚かなウィンドウシンドローム（SWS）を回避するアルゴリズムも持っている必要があります. アルゴリズムは、[RFC1122]のセクション4.2.3.4で説明されているものと同様にすることができます. 

ただし、rwndの値（0の場合も含む）に関係なく、cwndで許可されている場合、データ送信側は常に1つのDATA Chunksを受信側に送信できます（以下のルールBを参照）. このルールにより、送信者は、データ受信者からデータ送信者への転送中にSACKが失われたために送信者が見逃したrwndの変更をプローブできます. 

B）常に、送信者がそのトランスポートアドレスに対して未処理のデータのバイト数以上のバイトを持っている場合、そのトランスポートアドレスに新しいデータを送信してはなりません. 

C）送信者が送信する時間になると、新しいDATA Chunksを送信する前に、送信者は最初に再送信のマークが付けられている未処理のDATA Chunksを送信する必要があります（現在のcwndによって制限されます）. 

D）送信者が新しいDATA Chunksを送信する時間になると、プロトコルパラメーターMax.Burstを使用して、送信されるパケットの数を制限する必要があります. この制限は、cwndを次のように調整することで適用できます（MAY）. 

      if（（flightsize + Max.Burst * MTU）<cwnd）cwnd = flightize +
      Max.Burst * MTU
        
または、出力ルーチンによって送信されるパケットの数を厳密に制限することで適用できます. 

E）次に、送信者は、ルールAとルールBが許可するだけの新しいDATA Chunksを送信できます. 

送信用にコミットされた複数のDATA Chunksは、単一のパケットにバンドルされる場合があります. さらに、再送信されるDATA Chunksは、結果のパケットサイズがパスMTUを超えない限り、新しいDATA Chunksにバンドルされる場合があります. ULPはBundlingを実行しないことを要求する場合がありますが、これはSCTP実装がBundling効率を高めるために使用している可能性がある遅延をオフにするだけです. それ自体は、すべてのBundlingの発生を停止しません（つまり、輻輳または再送信の場合）. 

エンドポイントがDATA Chunksを送信する前に、受信したDATA Chunksが確認応答されていない場合（ACKの遅延などにより）、送信者はSACKを作成し、最終的なSCTPのサイズである限り、送信DATA Chunksにバンドルする必要があります. パケットは現在のMTUを超えません. セクション6.2を参照してください. 

実装上の注意：ウィンドウがいっぱいの場合（つまり、ルールAやルールBによって送信が許可されていない場合）、送信者は上位層からの送信要求を受け入れることができますが、未解決のデータの一部またはすべてが送信されるまで、DATA Chunksを送信してはなりません（MUST）.  DATA Chunksが確認され、ルールAとルールBによって送信が再び許可されます. 

送信または再送信がいずれかのアドレスに対して行われる場合は常に、そのアドレスのT3-rtxタイマーが現在実行されていない場合、送信者はそのタイマーを開始する必要があります. そのアドレスのタイマーがすでに実行されている場合、そのアドレスに送信された最も早い（つまり、最低のTSN）未処理のDATA Chunksが再送信されている場合、送信者はタイマーを再起動する必要があります. それ以外の場合、データ送信者はタイマーを再起動してはなりません（MUST NOT）. 

T3-rtxタイマーを開始または再起動する場合、セクション6.3.2および6.3.3で定義されているタイマールールに従ってタイマー値を調整する必要があります. 

注：データ送信側は、現在の送信ウィンドウの開始TSNの2 ** 31-1以上のTSNを使用してはなりません（SHOULD NOT）. 

6.2. DATA Chunksの受信に関する確認応答(ACK)
受信したDATA Chunksが受信ウィンドウ内にある場合、SCTPエンドポイントは常に有効な各DATA Chunksの受信を確認する必要があります. 

受信者のアドバタイズされたウィンドウが0の場合、受信者は、これまでに受信した最大のTSNよりも大きいTSNを持つ新しい着信DATA Chunksをドロップする必要があります. 新しい着信DATA Chunksがこれまでに受信した最大のTSNよりも小さいTSN値を保持している場合、受信者は並べ替えのために保持されている最大のTSNを破棄し、新しい着信DATA Chunksを受け入れる必要があります. どちらの場合でも、そのようなDATA Chunksが削除された場合、受信者は、現在の受信ウィンドウに現在まで受信および受け入れられたDATA Chunksのみを示すSACKをすぐに送信する必要があります. ドロップされたDATA Chunksは受け入れられなかったため、SACKに含めることはできません. [RFC0813]で説明されているように、受信者は、受信者の愚かなウィンドウシンドローム（SWS）を回避するために、受信ウィンドウをアドバタイズするアルゴリズムも持っている必要があります. このアルゴリズムは、[RFC1122]のセクション4.2.3.3で説明されているものと同様にすることができます. 

[RFC2581]のセクション4.2で指定された遅延確認アルゴリズムのガイドラインに従う必要があります. 具体的には、受信確認は、受信された少なくとも1秒おきのパケット（毎秒のDATA Chunksではなく）に対して生成されるべきであり（SHOULD）、未確認のDATA Chunksの到着から200 ms以内に生成されるべきです（SHOULD）. 状況によっては、SCTPトランスミッタが、このドキュメントで詳細に説明されているアルゴリズムで許可されているよりも保守的であることが有益な場合があります. ただし、SCTPトランスミッタは、次のアルゴリズムで許可されているよりも強力であってはなりません. 

SCTPレシーバーは、受信アプリケーションが新しいデータを消費するときに提供されたウィンドウを更新する以外に、すべての着信パケットに対して複数のSACKを生成してはなりません（MUST NOT）. 

実装上の注意：確認応答を生成するための最大遅延は、伝送されるプロトコルの特定のタイミング要件を満たすために、静的または動的にSCTP管理者が構成できます. 

実装では、最大遅延を500ミリ秒以上に構成することを許可してはなりません（MUST NOT）. 言い換えれば、実装はこの値を500ミリ秒未満にしてもよいが、500ミリ秒を超えてはならない（MUST NOT）. 

ULPによってシャットダウンが要求されない限り、確認応答はSACKチャンクで送信する必要があります. この場合、エンドポイントはSHUTDOWNチャンクで確認応答を送信できます（MAY）. SACKチャンクは、複数のDATA Chunksの受信を確認できます. SACKチャンク形式については、セクション3.3.4を参照してください. 特に、SCTPエンドポイントは、それが受信した（有効なDATA Chunksの）最新の順次TSNを示すために、累積TSN Ackフィールドに入力する必要があります. TSNが累積TSN Ackフィールドの値より大きい受信DATA Chunksは、ギャップAckブロックフィールドで報告されます. SCTPエンドポイントは、現在のパスMTUによって制限される単一のSACKチャンクに収まるだけの数のギャップACKブロックを報告する必要があります. 

注：SHUTDOWNチャンクにはGap Ack Blockフィールドは含まれません. したがって、エンドポイントは、順不同で受信したDATA Chunksを確認するために、SHUTDOWNチャンクの代わりにSACKを使用する必要があります. 

パケットが重複するDATA Chunksで到着し、新しいDATA Chunksがない場合、エンドポイントは遅延なしですぐにSACKを送信する必要があります. パケットが新しいDATA Chunksにバンドルされた重複したDATA Chunksで到着した場合、エンドポイントはすぐにSACKを送信できます（MAY）. 通常、重複するDATA Chunksの受信は、元のSACKチャンクが失われ、ピアのRTOが期限切れになったときに発生します. 重複するTSN番号は、SACKで重複として報告する必要があります（SHOULD）. 

エンドポイントがSACKを受信すると、重複したTSN情報を使用して、SACK損失が発生しているかどうかを判断できます. このデータのさらなる使用は将来の研究のためです. 

データレシーバーは、受信バッファーの維持を担当します. データ受信者は、データを受信する能力の変化をタイムリーにデータ送信者に通知する必要があります（SHOULD）. 実装がその受信バッファを管理する方法は、多くの要因（オペレーティングシステム、メモリ管理システム、メモリ容量など）に依存します. ただし、セクション6.2.1で定義されているデータセンダー戦略は、次のようなレシーバー操作を前提としています. 

A）アソシエーションの初期化時に、エンドポイントはピアに、INITまたはINIT ACKでアソシエーションに割り当てた受信バッファースペースの量を通知します. エンドポイントはa_rwndをこの値に設定します. 

B）DATA Chunksが受信されてバッファーに入れられたら、a_rwndを受信して​​バッファーに入れられたバイト数だけデクリメントします. これは事実上、データ送信側でrwndを閉じ、送信できるデータの量を制限しています. 

C）DATA ChunksがULPに配信され、受信バッファーから解放されると、上位層に配信されたバイト数だけa_rwndをインクリメントします. これは、事実上、データ送信側でrwndを開いて、さらにデータを送信できるようにします. データレシーバーは、受信バッファーからバイトを解放しない限り、a_rwndをインクリメントしないでください（SHOULD NOT）. たとえば、レシーバーが再構成キューにフラグメント化されたDATA Chunksを保持している場合、a_rwndをインクリメントしないでください. 

D）SACKを送信するとき、データレシーバーはa_rwndの現在の値をa_rwndフィールドに配置する必要があります（SHOULD）. データ受信者は、データ送信者が累積TSN Ackを介して確認応答されたDATA Chunksを再送信しない（つまり、再送信キューからドロップする）ことを考慮に入れる必要があります（SHOULD）. 

特定の状況下では、データレシーバーは、受信したが受信バッファーから解放されていない（ULPに配信されていない）DATA Chunksを削除する必要がある場合があります. これらのDATA Chunksは、ギャップACKブロックで確認応答された可能性があります. たとえば、データレシーバーは、受信バッファースペースが足りなくなったときに、ピアからの断片化されたUser messageを再構成しながら、受信バッファーにデータを保持している可能性があります. これらのDATA Chunksは、ギャップACKブロックで確認済みであっても、ドロップする可能性があります. データレシーバーがDATA Chunksをドロップした場合、再送信によって再度受信されるまで、後続のSACKのギャップACKブロックにそれらを含めてはなりません（MUST NOT）. さらに、エンドポイントは、a_rwndを計算するときに、ドロップされたデータを考慮する必要があります. 

エンドポイントはSACKを取り消してデータを破棄するべきではありません（SHOULD NOT）. 極端な状況でのみ、エンドポイントはこの手順を使用する必要があります（バッファー領域不足など）. データレシーバーは、ギャップACKブロックで確認応答されたデータをドロップすると、データセンダーで再送信戦略が最適化されず、パフォーマンスが最適化されない可能性があることを考慮する必要があります. 

次の例は、遅延確認の使用を示しています. 

    Endpoint A                                      Endpoint Z

    {App sends 3 messages; strm 0}
    DATA [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)
    (Start T3-rtx timer)

    DATA [TSN=8,Strm=0,Seq=4] ------------> (send ack)
                                  /------- SACK [TSN Ack=8,block=0]
    (cancel T3-rtx timer)  <-----/

    DATA [TSN=9,Strm=0,Seq=5] ------------> (ack delayed)
    (Start T3-rtx timer)
                                           ...
                                           {App sends 1 message; strm 1}
                                           (bundle SACK with DATA)
                                    /----- SACK [TSN Ack=9,block=0] \
                                   /         DATA [TSN=6,Strm=1,Seq=2]
    (cancel T3-rtx timer)  <------/        (Start T3-rtx timer)

    (ack delayed)
    (send ack)
    SACK [TSN Ack=6,block=0] -------------> (cancel T3-rtx timer)

           Figure 7:  Delayed Acknowledgement Example

エンドポイントがユーザーデータのないDATA Chunksを受信した場合（つまり、Lengthフィールドが16に設定されている場合）、エンドポイントはエラー原因を「ユーザーデータなし」に設定してABORTを送信する必要があります. 

エンドポイントは、ユーザーデータ部分のないDATA Chunksを送信してはなりません（SHOULD NOT）. 

6.2.1. 受信したSACKの処理
エンドポイントが受信する各SACKには、a_rwnd値が含まれています. この値は、SACKの送信時にデータレシーバーが（INIT / INIT ACKで指定された）合計受信バッファースペースから残したバッファースペースの量を表します. データ送信者は、a_rwnd、累積TSN Ack、およびギャップAckブロックを使用して、ピアの受信バッファースペースの表現を作成できます. 

SACKの処理時にデータ送信者が考慮しなければならない問題の1つは、SACKが順不同で受信される可能性があることです. つまり、データ受信側から送信されたSACKは、以前のSACKを通過して、データ送信側から最初に受信されます. SACKが順不同で受信された場合、データ送信側はピアの受信バッファスペースの誤ったビューを作成する可能性があります. 

順不同のSACKを検出するために使用できる明示的な識別子がないため、データ送信者はヒューリスティックを使用してSACKが新しいかどうかを判断する必要があります. 

エンドポイントは、a_rwnd値、累積TSN Ack、および受信したSACKのギャップAckブロックを使用して、以下のルールを使用してrwndを計算する必要があります（SHOULD）. 

A）associationの確立時に、エンドポイントはrwndを初期化して、INITまたはINIT ACKで指定されたピアをアドバタイズされたReceiver Windowクレジット（a_rwnd）に設定します. 

B）DATA Chunksがピアに送信（または再送信）されるたびに、エンドポイントはそのピアのrwndからチャンクのデータサイズを差し引きます. 

C）T3-rtxタイマーの有効期限（セクション6.3.3）または高速再送信（セクション7.2.4）のいずれかを介してDATA Chunksが再送信用にマークされている場合は常に、それらのチャンクのデータサイズをrwndに追加します. 

注：実装が各DATA Chunksでタイマーを維持している場合、タイマーの期限が切れたDATA Chunksのみが再送信対象としてマークされます. 

D）SACKが到着するたびに、エンドポイントは以下を実行します. 

i）累積TSN Ackが累積TSN Ackポイントよりも小さい場合、SACKをドロップします. 累積TSN Ackは単調に増加しているため、累積TSN Ackが累積TSN Ackポイントよりも小さいSACKは、順序が正しくないSACKを示します. 

ii）rwndを、新しく受信したa_rwndから、累積TSN AckおよびギャップACKブロックの処理後にまだ未処理のバイト数を引いた値に設定します. 

iii）SACKに、ギャップACKブロックを介して以前に確認応答されたTSNが欠落している場合（たとえば、データレシーバーがデータを破棄した場合）、欠落している可能性がある対応するDATAを検討します. セクション7.2.4で、DATA Chunksが最初に送信された宛先アドレスに対して再送信タイマーが実行されていない場合、その宛先アドレスに対してT3-rtxが開始されます. 

iv）累積TSN Ackが高速復旧出口点（7.2.4項）と一致するか超える場合、高速復旧は終了します. 

6.3. 再送タイマーの管理
SCTPエンドポイントは、再送信タイマーT3-rtxを使用して、ピアからのフィードバックがない場合のデータ配信を保証します. このタイマーの持続時間は、RTO（再送信タイムアウト）と呼ばれます. 

エンドポイントのピアがマルチホームである場合、エンドポイントは、ピアエンドポイントの異なる宛先トランスポートアドレスごとに個別のRTOを計算します. 

SCTPでのRTOの計算と管理は、TCPによる再送信タイマーの管理方法に厳密に従っています. 現在のRTOを計算するために、エンドポイントは宛先トランスポートアドレスごとに2つの状態変数を維持します. SRTT（スムーズラウンドトリップ時間）とRTTVAR（ラウンドトリップ時間変動）です. 

6.3.1. RTOの計算
SRTT、RTTVAR、およびRTOの計算を管理する規則は次のとおりです. 

C1）指定された宛先トランスポートアドレスに送信されたパケットに対してRTT測定が行われるまで、RTOをプロトコルパラメータ「RTO.Initial」に設定します. 

C2）最初のRTT測定Rが行われると、

SRTT <-R、

RTTVAR <-R / 2、および

RTO <-SRTT + 4 * RTTVAR. 

C3）新しいRTT測定R 'が行われると、

        RTTVAR <-（1-RTO.Beta）* RTTVAR + RTO.Beta * | SRTT-R '|
        
そして

        SRTT <-（1-RTO.Alpha）* SRTT + RTO.Alpha * R '
        
注：RTTVARへの更新で使用されるSRTTの値は、2番目の割り当てを使用してSRTT自体を更新する前の値です. 

計算後、RTO <-SRTT + 4 * RTTVAR を更新します. 

C4）データが処理中の場合、および以下のルールC5で許可されている場合は、新しいRTT測定を毎回行う必要があります. さらに、新しいRTT測定は、指定された宛先トランスポートアドレスのラウンドトリップごとに1回だけ行う必要があります. この推奨には2つの理由があります. 1つ目は、より頻繁に測定しても実際には大きなメリットが得られないことです[ALLMAN99]. 2番目に、測定がより頻繁に行われる場合、SRTTとRTTVARがほぼ同じ割合で変化に調整できるように、上記のルールC3のRTO.AlphaとRTO.Betaの値を調整する必要があります（ラウンドトリップの数に関して）ルールC3で指定されているように、RTO.AlphaとRTO.Betaを使用して、往復ごとに1つの測定のみを行う場合と同じように、新しい値を反映するようにします. ただし、これらの調整の正確な性質は研究課題のままです. 

C5）Karnのアルゴリズム：再送信されたパケットを使用してRTT測定を行うことはできません（したがって、応答がチャンクの最初のインスタンスに対するものか、それ以降のインスタンスに対するものか不明です）

実装に関する注意：RTTの測定は、rが最初に送信されてからTSNがr以下のチャンクが再送信されない場合にのみ、TSN rのチャンクを使用して行う必要があります. 

C6）RTOが計算されるときはいつでも、RTO.Min秒未満の場合、RTO.Min秒に切り上げられます. このルールの理由は、高い最小値を持たないRTOが不必要なタイムアウトの影響を受けやすいためです[ALLMAN99]. 

C7）最大値は、RTO.max秒以上であれば、RTOに設定できます. 

RTT測定値とさまざまな状態変数の計算に使用されるクロック粒度Gには、以下の要件以外は必要ありません. 

G1）RTTVAR = 0の場合、RTTVARが計算されるときは常に、RTTVAR <-Gを調整します. 

経験[ALLMAN99]は、より細かいクロック粒度（<= 100ミリ秒）は、より粗い粒度よりもいくらか優れていることを示しています. 

6.3.2. 再送信タイマールール
再送信タイマーの管理規則は次のとおりです. 

R1）DATA Chunksが任意のアドレス（再送信を含む）に送信されるたびに、そのアドレスのT3-rtxタイマーが実行されていない場合は、そのアドレスのRTO後に期限切れになるように実行を開始します. ここで使用されるRTOは、以下のルールE2で説明するように、対応する宛先アドレスで以前のT3-rtxタイマーが期限切れになったために2倍になった後に取得されたものです. 

R2）アドレスに送信されたすべての未処理のデータが確認されたときは常に、そのアドレスのT3-rtxタイマーをオフにします. 

R3）そのアドレスの最も早い未解決のTSNでDATA Chunksを確認するSACKを受信するたびに、そのアドレスのT3-rtxタイマーを現在のRTOで再起動します（そのアドレスにまだ未解決のデータがある場合）. 

R4）ギャップACKブロックを介して以前に確認応答されたTSNが欠落しているSACKを受信した場合は、DATA Chunksが最初に送信された宛先アドレスに対してT3-rtxを開始します（まだ実行されていない場合）. 

次の例は、さまざまなタイマールールの使用法を示しています（受信者が遅延ACKを使用していると想定しています）. 

   Endpoint A                                         Endpoint Z
   {App begins to send}
   Data [TSN=7,Strm=0,Seq=3] ------------> (ack delayed)
   (Start T3-rtx timer)
                                           {App sends 1 message; strm 1}
                                           (bundle ack with data)
   DATA [TSN=8,Strm=0,Seq=4] ----\     /-- SACK [TSN Ack=7,Block=0]
                                  \   /      DATA [TSN=6,Strm=1,Seq=2]
                                   \ /     (Start T3-rtx timer)
                                    \
                                   / \
   (Restart T3-rtx timer)  <------/   \--> (ack delayed)
   (ack delayed)
   {send ack}
   SACK [TSN Ack=6,Block=0] --------------> (Cancel T3-rtx timer)
                                           ..
                                           (send ack)
   (Cancel T3-rtx timer)  <-------------- SACK [TSN Ack=8,Block=0]

                       Figure 8: Timer Rule Examples

6.3.3. T3-rtx期限切れの処理
宛先アドレスの再送信タイマーT3-rtxが期限切れになるたびに、以下を実行します. 

E1）タイマーが期限切れになる宛先アドレスについて、セクション7.2.3で定義されたルールでssthreshを調整し、cwnd <-MTUを設定します. 

E2）タイマーが期限切れになる宛先アドレスに対して、RTO <-RTO * 2（「タイマーのバックオフ」）を設定します. 上記のルールC7で説明されている最大値（RTO.max）を使用して、この2倍演算の上限を指定できます. 

E3）宛先トランスポートアドレスに対応するパスのMTU制約に従って、T3-rtxの有効期限が切れたアドレスの最も早い（つまり、最も低いTSN）未処理DATA Chunksが単一のパケットに適合する数を決定します. 再送信が送信されています（これは、タイマーが期限切れになるアドレスとは異なる場合があります. セクション6.4を参照してください）. この値をKと呼び、バンドルして、それらのK DATA Chunksを1つのパケットで宛先エンドポイントに再送信します. 

E4）上記のルールR1で指示されている場合は、再送信の送信先の宛先アドレスで再送信タイマーT3-rtxを開始します. T3-rtxの開始に使用されるRTOは、再送信が送信される宛先アドレスのRTOである必要があります. これは、レシーバーがマルチホームの場合、タイマーの期限が切れた宛先アドレスとは異なる場合があります（セクションを参照） 6.4以下）. 

再送信後、新しいRTT測定が取得されると（これは、新しいデータが送信されて確認された場合にのみ、ルールC5に従って、またはHEARTBEATから行われた測定の場合に発生します. セクション8.3を参照）、ルールC3の計算が実行されます.  RTOの計算を含みます. これにより、RTOが2倍になった後、RTOが「崩壊」する可能性があります（ルールE2）. 

注：T3-rtxタイマーの期限が切れたが1つのMTU（上記のルールE3）に収まらなかったアドレスに送信されたDATA Chunksは、再送信のマークを付け、cwndが許可すると同時に（通常、SACKが到着したときに）送信する必要があります）. 

再送信タイマーを管理するための最後のルールは、フェイルオーバーに関するものです（セクション6.4.1を参照）. 

F1）エンドポイントが現在の宛先トランスポートアドレスから別のトランスポートアドレスに切り替えるたびに、現在の再送信タイマーは実行されたままになります. エンドポイントがDATA Chunksを含むパケットを新しいトランスポートアドレスに送信するとすぐに、ルールR1が指示する場合は、データが送信される宛先アドレスのRTO値を使用して、そのトランスポートアドレスでタイマーを開始します. そう. 

6.4. マルチホームSCTPエンドポイント
SCTPエンドポイントは、そのエンドポイントに到達するための宛先アドレスとして使用できるトランスポートアドレスが複数ある場合、マルチホームと見なされます. 

さらに、エンドポイントのULPは、マルチホームピアエンドポイントの複数の宛先アドレスの1つをプライマリパスとして選択する必要があります（詳細については、セクション5.1.2およびセクション10.1を参照）. 

デフォルトでは、SCTPユーザーが使用する宛先トランスポートアドレス（および場合によってはソーストランスポートアドレス）を明示的に指定しない限り、エンドポイントは常にプライマリパスに送信する必要があります（SHOULD）. 

エンドポイントは、応答チャンク（SACK、HEARTBEAT ACKなど）を、送信先のDATAまたは制御チャンクと同じ宛先トランスポートアドレスに送信する必要があります（SHOULD）. エンドポイントが応答チャンクと一緒にDATA Chunksをバンドルしている場合も、このルールに従う必要があります. 

ただし、単一のSACKで異なる送信元アドレスからパケットで受信した複数のDATA Chunksを確認する場合、SACKチャンクは、確認中のDATAまたは制御チャンクが受信された宛先トランスポートアドレスの1つに送信されることがあります. 

重複するDATA Chunksの受信者がSACKをマルチホームエンドポイントに送信する場合、宛先アドレスを変更し、DATA Chunksの送信元アドレスを使用しないことが有益な場合があります. その理由は、マルチホームのエンドポイントから重複を受信すると、SACKの戻りパス（DATA Chunksのソースアドレスで指定されている）が壊れている可能性があるためです. 

さらに、ピアがマルチホームの場合、エンドポイントは、タイムアウトしたチャンクを、DATA Chunksが送信された最後の宛先アドレスとは異なるActive destination transport addressに再送する必要があります（SHOULD）. 

再送信は、未処理の合計データ数には影響しません. ただし、DATA Chunksが別の宛先アドレスに再送信される場合、新しい宛先アドレスの未処理のデータ数と、データチャンクが最後に送信された古い宛先アドレスの両方がそれに応じて調整されます. 

6.4.1. 非アクティブな宛先アドレスからのフェイルオーバー
マルチホームSCTPエンドポイントのトランスポートアドレスの一部は、特定のエラー条件の発生（セクション8.2を参照）またはSCTPユーザーからの調整により非アクティブになる場合があります. 

送信する送信データがあり、プライマリパスが非アクティブになった（障害などにより）場合、またはSCTPユーザーが.Inactive destination transport addressにデータを送信するよう明示的に要求する場合、ULPにエラーを報告する前に、SCTPエンドポイントはデータが存在する場合は、代替のActive destination transport addressにデータを送信してみてください. 

タイムアウトしたデータを再送信するとき、エンドポイントがマルチホームの場合、再送信選択ポリシーで各送信元と宛先のアドレスのペアを考慮する必要があります. タイムアウトしたデータを再送信する場合、エンドポイントは、パケットが送信された元の送信元と宛先のペアから最も異なる送信元と宛先のペアを選択する必要があります. 

注：最も分岐している送信元と宛先のペアを選択するためのルールは実装上の決定であり、このドキュメントでは指定されていません. 

6.5. ストリーム識別子とStream Sequence Number
すべてのDATA Chunksは、有効なストリーム識別子を運ぶ必要があります. エンドポイントが無効なストリーム識別子を持つDATA Chunksを受信した場合、通常の手順に従ってDATA Chunksの受信を確認し、原因を「無効なストリーム識別子」に設定したエラーチャンクを直ちに送信します（セクション3.3.10を参照）.  DATA Chunksを破棄します. エンドポイントは、ERRORチャンクをSACKに続くパケットである限り、SACKと同じパケットにバンドルできます. 

すべてのストリームのStream Sequence Numberは、associationが確立されたときに0から開始する必要があります. また、Stream Sequence Numberが値65535に達すると、次のStream Sequence Numberを0に設定する必要があります. 

6.6. 注文した商品と注文していない商品
ストリーム内では、エンドポイントは、Uフラグが0に設定されて受信されたDATA Chunksを、Stream Sequence Numberの順序に従って上位層に配信する必要があります. DATA ChunksがStream Sequence Numberの順不同で到着した場合、エンドポイントは、再注文されるまで、受信したDATA ChunksをULPへの配信から保持しなければなりません（MUST）. 

ただし、SCTPエンドポイントは、DATA ChunksのUフラグを1に設定することにより、ストリーム内で送信される特定のDATA Chunksに順序付けされた配信が不要であることを示すことができます. 

エンドポイントは、Uフラグが1に設定されたDATA Chunksを受信すると、順序付けメカニズムをバイパスし、すぐにデータを上位層に配信する必要があります（ユーザーデータがデータ送信者によってフラグメント化されている場合は、再構築後）. 

これにより、特定のストリームで「帯域外」データを送信する効果的な方法が提供されます. また、ストリームは、そのストリームを通じて送信されるすべてのDATA ChunksでUフラグを1に設定するだけで、「順序付けされていない」ストリームとして使用できます. 

実装上の注意：順序付けされていないDATA Chunksを送信する場合、実装は、可能であれば、送信チャンクの先頭にある送信パケットにDATA Chunksを配置することを選択できます. 

Uフラグが1に設定されたDATA Chunksの「Stream Sequence Number」フィールドには意味がありません. 送信者は任意の値を入力できますが、受信者はフィールドを無視する必要があります. 

注：順序付けされたデータと順序付けされていないデータを送信する場合、エンドポイントは、Uフラグが1に設定されたDATA Chunksを送信するときに、Stream Sequence Numberをインクリメントしません. 

6.7. 受信したデータTSNのギャップの報告
新しいDATA Chunksを受信すると、エンドポイントは受信したTSNの連続性を検査します. エンドポイントが受信したDATA Chunksシーケンスでギャップを検出した場合、エンドポイントはギャップACKブロックを含むSACKをすぐに送信する必要があります（SHOULD）. データレシーバーは、ギャップを埋めない各SCTPパケットを受信した後、SACKを送信し続けます. 

エンドポイントは、受信したSACKからのギャップACKブロックに基づいて、欠落しているDATA Chunksを計算し、それらを再送信するかどうかを決定できます（詳細については、セクション6.2.1を参照）. 

1つのSACKで複数のギャップを報告できます（セクション3.3.4を参照）. 

ピアがマルチホームの場合、SCTPエンドポイントは常に、最後のDATA Chunksが受信されたのと同じ宛先アドレスにSACKを送信しようとする必要があります（SHOULD）. 

SACKを受信すると、エンドポイントは、SACKの累積TSN Ackによって確認応答されたすべてのDATA Chunksを送信キューから削除する必要があります. エンドポイントは、SACKによって報告されたギャップACKブロックに含まれていないTSNを持つすべてのDATA Chunksも「欠落」として扱わなければなりません（MUST）. 再送信の決定を行うために、未解決の各DATA Chunksの「欠落」レポートの数をデータ送信者が記録する必要があります. 詳細については、7.2.4項を参照してください. 

次の例は、SACKを使用してギャップを報告する方法を示しています. 

       Endpoint A                                    Endpoint Z {App
       sends 3 messages; strm 0} DATA [TSN=6,Strm=0,Seq=2] ----------
       -----> (ack delayed) (Start T3-rtx timer)

       DATA [TSN=7,Strm=0,Seq=3] --------> X (lost)

       DATA [TSN=8,Strm=0,Seq=4] ---------------> (gap detected,
                                                   immediately send ack)
                                       /----- SACK [TSN Ack=6,Block=1,
                                      /             Start=2,End=2]
                               <-----/ (remove 6 from out-queue,
        and mark 7 as "1" missing report)

                  Figure 9: Reporting a Gap using SACK

1つのSACKチャンク内でレポートできるギャップACKブロックの最大数は、現在のパスMTUによって制限されます. MTUの制限により、1つのSACKで報告する必要のあるすべてのギャップACKブロックをカバーできない場合、エンドポイントは1つのSACKのみを送信し、MTUによって設定されたサイズ制限内で最低から最高のTSNまでのギャップACKブロックを報告する必要があります. 残りの最大のTSN番号は未確認のままにします. 

6.8. CRC32cチェックサムの計算
SCTPパケットを送信する場合、エンドポイントは、以下で説明するように、パケットで計算されたCRC32cチェックサム値を含めることにより、送信のデータ整合性を強化する必要があります. 

パケットが構築された後（SCTP共通ヘッダーと1つ以上の制御またはDATA Chunksを含む）、送信機は

1）SCTP共通ヘッダーに適切なVerification Tagを入力し、チェックサムフィールドを「0」に初期化します. 

2）SCTP共通ヘッダーとすべてのチャンクを含む、パケット全体のCRC32cチェックサムを計算します（CRC32cアルゴリズムの詳細については、付録Bを参照してください）. そして

3）結果の値を共通ヘッダーのチェックサムフィールドに入力し、残りのビットは変更しません. 

SCTPパケットが受信されると、受信者は最初に次のようにCRC32cチェックサムを確認する必要があります. 

1）受信したCRC32cチェックサム値を保存します. 

2）受信したSCTPパケットのチェックサムフィールドの32ビットをすべて「0」に置き換え、受信したパケット全体のCRC32cチェックサム値を計算します. 

3）計算されたCRC32cチェックサムが受信したCRC32cチェックサムと同じであることを確認します. そうでない場合、受信者はパケットを無効なSCTPパケットとして扱わなければなりません（MUST）. 

無効なSCTPパケットを処理するためのデフォルトの手順は、それらをサイレントに破棄することです. 

ハードウェアの実装は、ソフトウェアで検証可能な方法で行う必要があります. 

6.9 断片化と再構成
エンドポイントは、DATA Chunksを送信するときの断片化をサポートできますが、DATA Chunksを受信するときの再構成をサポートする必要があります. エンドポイントが断片化をサポートしている場合、送信されるUser messageのサイズによって送信SCTPパケットサイズが現在のMTUを超える場合、エンドポイントはUser messageを断片化する必要があります. 実装が送信User messageの断片化をサポートしていない場合、エンドポイントはその上位層にエラーを返し、User messageの送信を試みてはなりません（MUST）. 

注：断片化をサポートする実装が、その上位層で断片化をオフにするメカニズムを利用できるようにする場合、そうする可能性があります. ただし、そうすることで、フラグメンテーションをサポートしない実装と同じように反応する必要があります. つまり、現在のパスMTU（P-MTU）を超える送信を拒否する必要があります. 

実装上の注意：このエラーの場合、セクション10.1で説明した送信プリミティブは、上位層にエラーを返す必要があります. 

ピアがマルチホームである場合、エンドポイントはアソシエーションパスMTU以下のサイズを選択する必要があります. 関連パスMTUは、すべての宛先アドレスの最小パスMTUです. 

注：メッセージが断片化されると、再度断片化することはできません. 代わりに、PMTUが削減されている場合は、IPフラグメンテーションを使用する必要があります. PMTUディスカバリーの詳細については、セクション7.3を参照してください. 

いつフラグメント化するかを決定するとき、SCTP実装は、SCTPパケットヘッダーとDATA Chunksヘッダーを考慮する必要があります. SACKチャンクをDATA Chunksとバンドルする場合、実装はSACKチャンクに必要なスペースも考慮しなければなりません（MUST）. 

断片化は次の手順を実行します. 

1）データ送信者は、User messageを一連のDATA Chunksに分割して、各チャンクとSCTPオーバーヘッドをassociationたパスMTU以下のIPデータグラムに適合させる必要があります. 

2）次に、送信機は、順番に、一連のDATA Chunksのそれぞれに個別のTSNを割り当てなければなりません（MUST）. 送信機は、DATA Chunksのそれぞれに同じSSNを割り当てます. User messageが順序なし配信を使用して配信されることをユーザーが示す場合、User messageの各DATA ChunksのUフラグを1に設定する必要があります. 

3）送信機は、シリーズの最初のDATA ChunksのB / Eビットを「10」に、シリーズの最後のDATA ChunksのB / Eビットを「01」に、そしてB / Eビットをシリーズ内の他のすべてのDATA Chunksは「00」に. 

エンドポイントは、受信した各DATA ChunksのB / Eビットを調べて断片化されたDATA Chunksを認識し、断片化されたDATA Chunksを再構成のためにキューに入れなければなりません（MUST）. User messageが再構成されると、SCTPは、再構成されたUser messageを特定のストリームに渡して、並べ替えと最終的なディスパッチを実行できるようにします. 

注：データレシーバーは、メッセージの再構成が完了するまでさらにフラグメントを待機している間にバッファースペースが不足すると、部分的な配信API（セクション10を参照）を介して受信メッセージの一部をディスパッチし、受信バッファーの一部を解放する必要がありますメッセージの残りの部分を受信できるようにスペース. 

6.10. Bundling
エンドポイントは、1つの送信SCTPパケットに複数のチャンクを含めるだけで、チャンクをバンドルします. 結果のIPデータグラムの合計サイズ、

SCTPパケットとIPヘッダーを含め、現在のパスMTU以下である必要があります. 

ピアエンドポイントがマルチホームの場合、送信エンドポイントは、現在のプライマリパスの最新のMTU以下のサイズを選択する必要があります. 

制御チャンクをDATA Chunksとバンドルする場合、エンドポイントは、送信SCTPパケットの最初に制御チャンクを配置する必要があります. 送信機は、SCTPパケット内でTSNの昇順でDATA Chunksを送信する必要があります. 

注：制御チャンクはパケットの最初に配置する必要があり、DATA ChunksはSHUTDOWNまたはSHUTDOWN ACKチャンクの前に送信する必要があるため、DATA ChunksはSHUTDOWNまたはSHUTDOWN ACKチャンクとバンドルできません. 

部分的なチャンクはSCTPパケットに配置してはなりません（MUST NOT）. 部分チャンクは、SCTPパケットに完全には含まれていないチャンクです. つまり、SCTPパケットは、チャンクの長さで示されるように、チャンクのすべてのバイトを含めるには短すぎます. 

エンドポイントは、パケット内の順序で受信したチャンクを処理する必要があります. 受信者は、チャンク長フィールドを使用して、すべてのチャンクが4バイト境界で終了するという事実を考慮して、チャンクの終わりと次のチャンクの始まりを決定します. レシーバーが部分的なチャンクを検出した場合は、チャンクをドロップする必要があります. 

エンドポイントは、INIT、INIT ACK、またはSHUTDOWN COMPLETEを他のチャンクとバンドルしてはなりません（MUST NOT）. 

7.輻輳制御
輻輳制御は、SCTPの基本機能の1つです. 一部のアプリケーションでは、タイムクリティカルなデータの迅速な配信を保証するために、SCTPトラフィックに適切なリソースが割り当てられる可能性があります. そのため、通常の操作中に、送信で深刻な輻輳状態が発生する可能性は低いと思われます. ただし、SCTPは、部分的なネットワーク障害や予期しないトラフィックの急増が発生する可能性のある悪質な動作条件下で動作する必要があります. そのような状況では、SCTPは正しい輻輳制御手順に従って、輻輳からすばやく回復し、データをできるだけ早く配信する必要があります. ネットワークの輻輳がない場合、これらの予防的輻輳制御アルゴリズムは、プロトコルのパフォーマンスに影響を与えません. 

実装上の注意：特定のパフォーマンス要件が満たされている限り、実装は常に、以下で定義されているものよりも保守的な輻輳制御アルゴリズムを採用できます. 

SCTPで使用される輻輳制御アルゴリズムは、[RFC2581]に基づいています. このセクションでは、[RFC2581]で定義されたアルゴリズムがSCTPでの使用にどのように適合されるかについて説明します. まず、TCPとSCTPのプロトコル設計の違いを示し、次にSCTPの輻輳制御方式について説明します. 説明では、必要に応じて、TCP輻輳制御と同じ用語を使用します. 

SCTPの輻輳制御は、常に個々のストリームではなく、association全体に適用されます. 

7.1. SCTPとTCP輻輳制御の違い
SCTP SACKのギャップACKブロックは、TCP SACKと同じセマンティックな意味を持っています. TCPは、SACKで伝送される情報を参考情報としてのみ見なします. SCTPは、SACKチャンクのギャップACKブロックで運ばれる情報を助言と見なします. SCTPでは、SACKによって確認応答されたDATA Chunks（受信側に順不同で到着したDATAを含む）は、累積TSN AckポイントがDATA ChunksのTSNを通過するまで完全に配信されたとは見なされません（つまり、DATA ChunksはSACKのCumulative TSN Ackフィールドで確認されました）. したがって、cwndの値は、（非SACK TCPの場合のように）確認応答された最大のシーケンス番号とCongestion window内で送信できる最新のDATA Chunksとの間の上限ではなく、未処理のデータの量を制御します. SCTP SACKは、非SACK TCPとは異なる高速再送信および高速リカバリの実装につながります. 例として、[FALL96]を参照してください. 

ただし、SCTPとTCPの最大の違いはマルチホーミングです. SCTPは、2つ以上のトランスポートアドレスから到達可能な2つのエンドポイント間に堅牢な通信アソシエーションを確立するように設計されています. 潜在的に異なるアドレスは、2つのエンドポイント間の異なるデータパスにつながる可能性があります. したがって、理想的には、パスごとに輻輳制御パラメータの個別のセットが必要になる場合があります. ここでのマルチホームレシーバーの輻輳制御の扱いはSCTPで新しく、将来的に改良が必要になる可能性があります. 現在のアルゴリズムでは、次のことを前提としています. 

o送信者は通常、上位層からの指示がない限り、同じ宛先アドレスを使用します. ただし、アドレスが非アクティブとしてマークされた場合、SCTPは代替の宛先に変更されることがあります（セクション8.2を参照）. また、SCTPは元の送信とは異なるトランスポートアドレスに再送信する場合があります. 

o送信者は、送信可能な宛先アドレスごとに個別の輻輳制御パラメーターセットを保持します（各送信元-宛先ペアではなく、各宛先に対して）. アドレスが十分に長い期間使用されない場合、パラメータは減衰するはずです. 

o各宛先アドレスについて、エンドポイントはそのアドレスへの最初の送信時にスロースタートします. 

注：TCPは、単一のTCPセッション内の上位層プロトコルへのデータの順次配信を保証します. これは、TCPが受信したシーケンス番号のギャップに気づいた場合、欠落したデータよりも大きいシーケンス番号で受信されたデータを配信する前に、ギャップが埋められるまで待機することを意味します. 一方、Stream Sequence Numberが特定のストリームに対して連続している場合（つまり、欠落しているDATA Chunksが異なるストリームの場合）、またはTSNにギャップがある場合でも、SCTPはその上位層プロトコルにデータを配信できます. 未注文の配送が表示されます. これはcwndには影響しませんが、rwndの計算に影響する可能性があります. 

7.2. SCTPスロースタートと輻輳回避
スロースタートおよび輻輳回避アルゴリズムは、ネットワークに注入されるデータの量を制御するためにエンドポイントで使用する必要があります. SCTPの輻輳制御は、個々のストリームではなく、アソシエーションに関して使用されます. 状況によっては、SCTP送信者がアルゴリズムで許可されているよりも保守的であることが有益な場合があります. ただし、SCTP送信者は、次のアルゴリズムで許可されているよりも積極的にはなりません. 

TCPと同様に、SCTPエンドポイントは次の3つの制御変数を使用して、その伝送速度を調整します. 

oレシーバーがアドバタイズするウィンドウサイズ（バイト単位のrwnd）. これは、受信パケットが使用できるバッファースペースに基づいてレシーバーによって設定されます. 

注：この変数は、association全体で保持されます. 

o輻輳制御ウィンドウ（バイト単位のcwnd）. これは、観測されたネットワーク状態に基づいて送信者によって調整されます. 

注：この変数は、宛先アドレスごとに維持されます. 

oSlow-Start Threshold（ssthresh、バイト単位）. これは、スロースタートと輻輳回避フェーズを区別するために送信者が使用します. 

注：この変数は、宛先アドレスごとに維持されます. 

SCTPには、追加の制御変数、partial_bytes_ackedも必要です. これは、輻輳回避フェーズ中に使用され、cwnd調整を容易にします. 

TCPとは異なり、SCTP送信者は、ピアの各宛先アドレス（ピアがマルチホームの場合）に対して、これらの制御変数cwnd、ssthresh、partial_bytes_ackedのセットを保持する必要があります. アソシエーション全体で保持されるrwndは1つだけです（ピアがマルチホームであるか、単一のアドレスを持つかは関係ありません）. 

7.2.1. スロースタート
不明な条件でネットワークへのデータ送信を開始する場合、または十分に長いアイドル期間の後に、SCTPがネットワークをプローブして使用可能な容量を判断する必要があります. スロースタートアルゴリズムは、転送の開始時、または再送信タイマーによって検出された損失を修復した後に、この目的で使用されます. 

o DATA送信前または十分に長いアイドル期間後の初期cwndは、min（4 * MTU、max（2 * MTU、4380バイト））に設定する必要があります. 

o再送信タイムアウト後の最初のcwndは、1 * MTU以下でなければなりません. 

o ssthreshの初期値は任意に高くてもかまいません（たとえば、実装はレシーバがアドバタイズしたウィンドウのサイズを使用してもかまいません）. 

o cwndがゼロより大きい場合は常に、エンドポイントはそのトランスポートアドレスで未処理のデータのcwndバイトを持つことができます. 

o cwndがssthresh以下の場合、SCTPエンドポイントは、現在のCongestion windowが完全に利用されており、受信SACKが累積TSN Ackポイントを進め、データ送信者が高速リカバリではありません. これらの3つの条件が満たされた場合にのみ、cwndを増やすことができます. それ以外の場合、cwndを増やしてはなりません（MUST）. これらの条件が満たされている場合、cwndは、最大で、1）確認済みの以前の未処理のDATA Chunksの合計サイズ、および2）宛先のパスMTUの小さい方だけ増やす必要があります. この上限は、[SAVAGE99]で概説されているACKスプリット攻撃から保護します. 

ピアエンドポイントがマルチホームである場合、エンドポイントが累積TSN Ackポイントを進めるSACKを受信すると、確認済みデータを送信した宛先アドレスに割り当てられたcwnd（またはcwnds）を更新する必要があります. ただし、受信したSACKが累積TSN Ackポイントを進めない場合、エンドポイントは宛先アドレスのcwndを調整してはなりません（MUST NOT）. 

エンドポイントのcwndは累積TSN Ackポイントにassociationられていないため、SACKが重複すると、累積TSN Ackポイントを進めなくても、エンドポイントはそれらを使用して新しいデータをクロックアウトできます. つまり、SACKによって新たに確認応答されたデータにより、現在処理中のデータの量がcwnd未満に減少するため、現在の変更されていないcwndの値で新しいデータを送信できるようになります. 一方、cwndの増加は、上で指定したように、累積TSN Ackポイントアドバンスにassociationられている必要があります. そうしないと、重複するSACKは新しいデータをクロックアウトするだけでなく、輻輳の可能性があるときに、ネットワークを離れたばかりのデータよりも多くの新しいデータを逆にクロックアウトします. 

oエンドポイントが特定のトランスポートアドレスでデータを送信しない場合、トランスポートアドレスのcwndをRTOごとにmax（cwnd / 2、4 * MTU）に調整する必要があります. 

7.2.2. 混雑回避
cwndがssthreshよりも大きい場合、送信者が対応するトランスポートアドレスに対して未処理のデータのcwnd以上のバイトを持っている場合、RTNごとに1 * MTUだけcwndを増やす必要があります. 

実際には、実装は次の方法でこの目標を達成できます. 

o partial_bytes_ackedは0に初期化されます. 

o cwndがssthreshより大きい場合は常に、累積TSN Ackポイントを進める各SACKの到着時に、新しい累積TSN AckおよびギャップACKブロックによって確認されたチャンクを含む、そのSACKで確認されたすべての新しいチャンクの合計バイト数によって、partial_bytes_ackedを増やします.  . 

o partial_bytes_ackedがcwnd以上で、SACKの到着前に送信者が未処理のデータのcwnd以上のバイトを持っていた場合（つまり、SACKの到着前に、flightsizeがcwnd以上であった場合）、MTUによってcwndを増やします.  、partial_bytes_ackedを（partial_bytes_acked-cwnd）にリセットします. 

oスロースタートと同様に、送信者が特定のトランスポートアドレスでDATAを送信しない場合、トランスポートアドレスのcwndをRTOごとにmax（cwnd / 2、4 * MTU）に調整する必要があります. 

o送信者によって送信されたすべてのデータが受信者によって確認されたとき、partial_bytes_ackedは0に初期化されます. 

7.2.3. 輻輳制御
SACKからのパケット損失を検出すると（セクション7.2.4を参照）、エンドポイントは以下を実行する必要があります. 

      ssthresh = max（cwnd / 2、4 * MTU）
      cwnd = ssthresh
      partial_bytes_acked = 0
        
基本的に、パケット損失によりcwndが半分にカットされます. 

T3-rtxタイマーがアドレスで期限切れになると、SCTPは次のよ​​うにスロースタートを実行する必要があります. 

      ssthresh = max（cwnd / 2、4 * MTU）
      cwnd = 1 * MTU
        
また、エンドポイントがそのアドレスへのデータの配信が成功したことの確認を受信するまで、そのアドレスに対して1つ以上のSCTPパケットが送信されないようにします. 

7.2.4. ギャップレポートでの高速再送信
データ損失がない場合、エンドポイントは確認応答の遅延を実行します. ただし、エンドポイントは、到着するTSNシーケンスのホールに気づいたときはいつでも、ホールが埋められるまで、データを運ぶパケットが到着するたびにSACKの送信を開始する必要があります（SHOULD）. 

エンドポイントは、一部のTSNが欠落していることを示すSACKを受信するたびに、高速再送信に関するアクションを実行する前に、同じTSNで（後続のSACKを介して、合計3つの欠落レポートがある）2つのミス表示を待つ必要があります. 

ミス表示は、HTNA（Highest TSN Newly Acknowledged）アルゴリズムに従う必要があります（SHOULD）. 着信SACKごとに、SACKで新たに確認応答された最高のTSNの前に、欠落したTSNについてのみ、ミス表示が増分されます. 新しく確認されたDATA Chunksは、以前にSACKで確認されていないものです. エンドポイントが高速復旧状態にあり、累積TSN Ackポイントを進めるSACKが到着した場合、SACKで欠落していると報告されたすべてのTSNについて、ミス表示が増分されます. 

TSNに対して3回目の連続したミス表示を受信した場合、データ送信者は次のことを行うものとします. 1）再送信するために、DATA Chunksに3つのミス表示をマークします. 

2）高速リカバリでない場合は、セクション7.2.3で説明されている式に従って、欠落しているDATA Chunksが最後に送信された宛先アドレスのssthreshおよびcwndを調整します. 

3）パケットの送信先である宛先トランスポートアドレスのパスMTUの制約に従って、再送信のマークが付けられた最も早い（つまり、最も低いTSN）DATA Chunksが1つのパケットに適合する数を決定します. この値をKと呼びます. これらのK個のDATA Chunksを1つのパケットで再送信します. 高速再送信が実行されている場合、送信者はcwndの値を無視する必要があり（SHOULD）、この単一パケットの再送信を遅延してはなりません（SHOULD NOT）. 

4）最後のSACKがそのアドレスに送信された最小の未解決のTSN番号を確認した場合、またはエンドポイントがそのアドレスに送信された最初の未処理のDATA Chunksを再送信している場合にのみ、T3-rtxタイマーを再起動します. 

5）DATA Chunksを高速再送信としてマークし、後続の高速再送信の対象外にします. 高速再送信アルゴリズムが原因で再送信のマークが付けられたTSNは、K個の他のTSNを伝送する送信データグラムに適合しなかったため、後続の高速再送信の対象外としてマークされます. ただし、再送信のマークが付けられているため、cwndが許可するとすぐに再送信されます. 

6）高速リカバリーでない場合は、高速リカバリーに入り、最高の未解決のTSNを高速リカバリー出口点としてマークします. SACKがこの出口ポイントまでのすべてのTSNを確認すると、高速リカバリが終了します. 高速復旧中は、ssthreshとcwndは、後続の高速復旧イベントのために、どの宛先でも変更すべきではありません（つまり、後続の高速再送信により、cwndをさらに削減すべきではありません）. 

注：上記の調整の前に、受信したSACKが新しいDATA Chunksも確認し、累積TSN Ackポイントを進める場合、セクション7.2.1およびセクション7.2.2で定義されたcwnd調整ルールを最初に適用する必要があります. 

上記の簡単な実装は、SACKによって報告された各TSNホールのカウンターを保持します. TSNホールを報告する連続するSACKごとにカウンターが増分します. 3に達し、Fast-Retransmit手順を開始すると、カウンターは0にリセットされます. 

SCTPのcwndは未解決のTSNの数を間接的に制限するため、輻輳制御ウィンドウサイズを調整せずに、TCP高速復旧の効果が自動的に実現されます. 

7.3. パスMTUディスカバリー
[RFC4821]、[RFC1981]、および[RFC1191]は、「パケット化レイヤーパスMTUディスカバリー」を指定します. これにより、エンドポイントは、特定のインターネットパスに沿った最大伝送ユニット（MTU）の見積もりを維持し、超過するパケットをそのパスに沿って送信しないようにします.  MTU（パスMTU（PMTU）の変更をプローブするための不定期の試行を除く）. [RFC4821]は、現在のエンドツーエンドのMTU設定を決定し、この値の変化を検出するためのMTU発見メカニズムと戦略についての議論を徹底しています. 

エンドポイントはこれらの手法を適用する必要があり（SHOULD）、宛先アドレスごとに適用する必要があります（SHOULD）. 

パスMTUディスカバリーに関して、2つの重要なSCTP固有のポイントがあります. 

1）SCTPアソシエーションは複数のアドレスにまたがることができます. エンドポイントは、ピアの宛先アドレスごとに個別のMTU見積もりを維持する必要があります. 

2）送信者は、ピアのすべての宛先アドレスに対して検出された最小のPMTUであるアソシエーションPMTUを追跡する必要があります. メッセージを複数の部分にフラグメント化する場合、このassociationPMTUを使用して、各フラグメントのサイズを計算する必要があります. これにより、IP断片化に遭遇することなく、再送信をシームレスに代替アドレスに送信できます. 

8.障害管理
8.1. エンドポイント障害検出
エンドポイントは、未確認のHEARTBEATチャンクを含む、ピアへの連続する再送信の総数（マルチホームの場合、ピアのすべての宛先トランスポートアドレスへの再送信を含む）のカウンターを保持します. このカウンターの値がプロトコルパラメーター 'Association.Max.Retrans'で示された制限を超える場合、エンドポイントはピアエンドポイントに到達できないと見なし、それ以上のデータの送信を停止します（したがって、associationはCLOSED状態になります）. さらに、エンドポイントは上位層に障害を報告し、オプションで、アウトバウンドキューに残っているすべての未処理のユーザーデータを報告する場合があります. ピアエンドポイントが到達不能になると、associationは自動的に閉じられます. 

カウンターは、そのピアエンドポイントに送信されたDATA Chunksが（SACKの受信によって）確認されるか、ピアエンドポイントからHEARTBEAT ACKが受信されるたびにリセットされます. 

8.2. パス障害検出
ピアエンドポイントがマルチホームの場合、エンドポイントは、ピアエンドポイントの宛先トランスポートアドレスごとにエラーカウンターを保持する必要があります. 

T3-rtxタイマーがいずれかのアドレスで期限切れになるたび、またはアイドルアドレスに送信されたHEARTBEATがRTO内で確認応答されない場合、その宛先アドレスのエラーカウンターがインクリメントされます. エラーカウンターの値がその宛先アドレスのプロトコルパラメーター 'Path.Max.Retrans'を超えると、エンドポイントは宛先トランスポートアドレスを非アクティブとしてマークし、通知を上位層に送信する必要があります（SHOULD）. 

未解決のTSNが確認されるか、そのアドレスに送信されたHEARTBEATがHEARTBEAT ACKで確認されると、エンドポイントは、DATA Chunksが最後に送信された（またはHEARTBEATが送信された）宛先トランスポートアドレスのエラーカウンターをクリアします. ピアエンドポイントがマルチホームであり、最後に送信されたチャンクが代替アドレスへの再送信であった場合、最後に送信されたチャンクのアドレスに確認応答を送信する必要があるかどうかについてあいまいさが存在します. ただし、このあいまいさがSCTPの動作に重大な影響を与えることはないようです. このあいまいさが望ましくない場合、送信された最後のチャンクが再送信であった場合、トランスミッタはエラーカウンタをクリアしないことを選択できます. 

注：SCTPエンドポイントを構成するとき、ユーザーは、 'Association.Max.Retrans'の値が、リモートエンドポイントのすべての宛先アドレスの 'Path.Max.Retrans'の合計よりも大きくなるのを避ける必要があります. そうでない場合、エンドポイントがピアエンドポイントに到達可能と見なしている間、すべての宛先アドレスが非アクティブになる可能性があります. この状態が発生した場合、SCTPが機能する方法を選択する方法は、実装によって異なります. 

プライマリパスが非アクティブとマークされている場合（過度の再送信などにより）、送信者は、新しい宛先パケットが存在し、アクティブである場合、自動的に代替宛先アドレスに送信できます（MAY）. プライマリパスが非アクティブとしてマークされているときに複数の代替アドレスがアクティブである場合、1つのトランスポートアドレスのみを選択して、新しい宛先トランスポートアドレスとして使用する必要があります. 

8.3. パスハートビート
デフォルトでは、SCTPエンドポイントは、HEARTBEATチャンクを定期的に宛先トランスポートアドレスに送信することにより、ピアのアイドル宛先トランスポートアドレスの到達可能性を監視する必要があります（SHOULD）. HEARTBEAT送信は、ESTABLISHED状態に達したときに開始される場合があり、SHUTDOWNまたはSHUTDOWN-ACKのいずれかを送信した後に中止されます. HEARTBEATの受信者は、COOKIE-ECHOED状態（INIT送信側）またはESTABLISHED状態（INIT受信側）に入った後、SHUTDOWN-SENT状態（SHUTDOWN送信側）またはSHUTDOWNに到達するまで、HEARTBEAT-ACKでHEARTBEATに応答する必要があります.  -ACK-SENT状態（SHUTDOWNレシーバー）. 

パスRTTの更新に使用できる新しいチャンク（通常、最初の送信DATA、INIT、COOKIE ECHO、HEARTBEATなどを含む）がなく、現在のハートビート内にHEARTBEATが送信されていない場合、宛先トランスポートアドレスは「アイドル」と見なされます. そのアドレスの期間. これは、アクティブと非アクティブの両方の宛先アドレスに適用されます. 

上位層はオプションで次の機能を開始できます. 

A）特定のassociationの特定の宛先トランスポートアドレスでハートビートを無効にします. 

B）HB.intervalを変更し、

C）特定のassociationの特定の宛先トランスポートアドレスでハートビートを再度有効にします. 

D）特定のassociationの特定の宛先トランスポートアドレスでオンデマンドのHEARTBEATを要求します. 

エンドポイントは、HEARTBEATがそのアドレスに送信され、1つのRTO内で確認応答されないたびに、宛先トランスポートアドレスのそれぞれのエラーカウンターをインクリメントする必要があります. 

このカウンターの値がプロトコルパラメーター 'Path.Max.Retrans'に到達すると、エンドポイントは、対応する宛先アドレスが非アクティブである場合は非アクティブとしてマークし、必要に応じてこの到達可能性の変化を上位層に報告することもできます. 宛先アドレス. この後、エンドポイントはこの宛先アドレスでハートビートを続行しますが、カウンターの増加を停止する必要があります. 

HEARTBEATチャンクの送信者は、パケットが送信される現在の時刻と、パケットの送信先の宛先アドレスを、チャンクのハートビート情報フィールドに含める必要があります. 

実装上の注意：ハートビートメカニズムの代替実装として、HEARTBEATが宛先に送信されるたびにエラーカウンター変数をインクリメントすることができます. HEARTBEAT ACKが到着するたびに、送信者はHEARTBEATが送信された宛先のエラーカウンターをクリアする必要があります（SHOULD）. これにより、以前にストロークされたエラー（およびその他のエラーカウント）が実質的にクリアされます. 

HEARTBEATの受信者は、ハートビート情報TLVと、受信したHEARTBEATチャンクから変更されずにコピーされた他の受信TLVを含むHEARTBEAT ACKですぐに応答する必要があります. 

HEARTBEAT ACKを受信すると、HEARTBEATの送信者は、HEARTBEATが送信された宛先トランスポートアドレスのエラーカウンターをクリアし、マークされていない場合は宛先トランスポートアドレスをアクティブとしてマークする必要があります. 最新のHEARTBEAT ACKを受信したために非アクティブな宛先アドレスがアクティブとしてマークされている場合、エンドポイントはオプションで上位層に報告する場合があります. HEARTBEAT ACKの受信者は、アソシエーション全体のエラーカウントもクリアする必要があります（セクション8.1で定義）. 

HEARTBEAT ACKの受信側は、HEARTBEAT ACKチャンクで伝送される時間値を使用して、その宛先トランスポートアドレスのRTT測定も実行する必要があります. 

ハートビートが許可されているアイドル宛先アドレスでは、その宛先アドレスのRTOごとに1回、プロトコルパラメーター 'HB.interval'を1回送信して、RTO値の+/- 50％のジッターでHEARTBEATチャンクを送信することをお勧めします. 以前のハートビートが未回答の場合は、RTOの指数バックオフ. 

SCTPユーザーがプリミティブを使用して、HB.intervalを変更し、特定の宛先アドレスでハートビートをオンまたはオフにすることができます. SCTPユーザーが設定したハートビート間隔は、その宛先のRTOに追加されます（指数バックオフを含む）. ハートビートタイマーが期限切れになるたびに1つのハートビートのみを送信する必要があります（複数の宛先がアイドル状態の場合）. これは、ハートビートの対象となるアイドル宛先の候補を選択する方法に関する実装の決定です（複数の宛先がアイドルの場合）. 

注：ハートビート間隔を調整するときは、考慮すべき副作用があります. この値を大きくすると、つまりHEARTBEATの時間が長くなると、失われたABORTメッセージの検出にも時間がかかります. ピアエンドポイントが何らかの理由でassociationをABORTし、ABORTチャンクが失われた場合、ローカルエンドポイントは、DATA ChunksまたはHEARTBEATチャンクを送信することによって失われたABORTのみを検出します（したがって、ピアは別のABORTを送信します）. これは、ハートビートタイマーを調整するときに考慮する必要があります. HEARTBEATが無効になっている場合、associationにDATAを送信するだけで、ピアから失われたABORTが検出されます. 

8.4. 「Out of the Blue」パケットの処理
SCTPパケットは、正しく形成されている場合（つまり、レシーバーのCRC32cチェックに合格した場合、セクション6.8を参照）、「out of the blue」（OOTB）パケットと呼ばれますが、レシーバーはこのパケットが属するアソシエーションを識別できません.  . 

OOTBパケットの受信者は、以下を実行する必要があります. 

1）OOTBパケットが非ユニキャストアドレスとの間で送受信される場合、受信者はパケットをサイレントに破棄する必要があります（SHOULD）. さもないと、

2）OOTBパケットにABORTチャンクが含まれている場合、受信者はOOTBパケットを静かに破棄し、それ以上のアクションを実行してはなりません（MUST）. さもないと、

3）パケットにVerification Tagが「0」に設定されたINITチャンクが含まれている場合は、セクション5.1の説明に従って処理します. 何らかの理由でINITを正常に処理できず、ABORTを応答として送信する必要がある場合、ABORTチャンクを含むパケットのVerification Tagは、受信したINITチャンクの開始タグと、ABORTのTビットでなければなりません. チャンクは0に設定する必要があり、Verification Tagが反映されないことを示します. 

4）パケットの最初のチャンクにCOOKIE ECHOが含まれている場合は、セクション5.1の説明に従って処理します. さもないと、

5）パケットにSHUTDOWN ACKチャンクが含まれている場合、受信者はOOTBパケットの送信者にSHUTDOWN COMPLETEで応答する必要があります. SHUTDOWN COMPLETEを送信する場合、OOTBパケットの受信者は、送信パケットのVerification TagフィールドにSHUTDOWN ACKで受信したVerification Tagを入力し、チャンクフラグのTビットを設定して、Verification Tagが反映されていることを示す必要があります. さもないと、

6）パケットにSHUTDOWN COMPLETEチャンクが含まれている場合、受信側は黙ってパケットを破棄し、それ以上のアクションを実行しないでください. さもないと、

7）パケットに「Stale Cookie」エラーまたはCOOKIE A​​CKが含まれている場合、SCTPパケットは通知なく破棄されます. さもないと、

8）受信者は、OOTBパケットの送信者にABORTで応答する必要があります. ABORTを送信するとき、OOTBパケットの受信者は、送信パケットのVerification TagフィールドにOOTBパケットのVerification Tagフィールドにある値を入力し、チャンクフラグのTビットを設定して、Verification Tagが反射してる. このABORTを送信した後、OOTBパケットの受信者はOOTBパケットを破棄し、それ以上のアクションは行いません. 

8.5. Verification Tag
このセクションで定義されているVerification Tagルールは、INIT、SHUTDOWN COMPLETE、COOKIE ECHO（セクション5.1を参照）、ABORT、またはSHUTDOWN ACKチャンクを含まないSCTPパケットを送受信するときに適用されます. これらのチャンクタイプの1つを含むSCTPパケットの送受信のルールについては、8.5.1項で個別に説明します. 

SCTPパケットを送信するとき、エンドポイントは、発信パケットのVerification Tagフィールドに、ピアから受信したINITまたはINIT ACKのInitiate Tagパラメータのタグ値を入力する必要があります. 

SCTPパケットを受信するとき、エンドポイントは、受信したSCTPパケットのVerification Tagフィールドの値が自身のタグと一致することを確認する必要があります. 受信したVerification Tag値が受信者自身のタグ値と一致しない場合、受信者はパケットを黙って破棄し、以下のセクション8.5.1にリストされている場合を除いてそれ以上処理しないものとします. 

8.5.1. Verification Tagルールの例外
A）INITを運ぶパケットの規則：

-送信者は、パケットのVerification Tagを0に設定する必要があります. 

-エンドポイントは、Verification Tagが0に設定されたSCTPパケットを受信すると、パケットにINITチャンクのみが含まれていることを確認する必要があります. それ以外の場合、受信者はパケットを黙って破棄する必要があります. 

B）ABORTを運ぶパケットのルール：

-エンドポイントは、既知の場合、送信パケットのVerification Tagフィールドに宛先エンドポイントのタグ値を常に入力する必要があります. 

-ABORTがOOTBパケットに応答して送信される場合、エンドポイントはセクション8.4で説明されている手順に従う必要があります. 

-パケットのVerification Tagフィールドが自身のタグと一致し、Tビットが設定されていない場合、またはピアのタグに設定されており、Tビットがチャンクフラグに設定されている場合、ABORTの受信者はパケットを受け入れる必要があります. それ以外の場合、受信者はパケットを黙って破棄し、それ以上のアクションを行わない必要があります. 

C）シャットダウンを完了するパケットのルール：

-SHUTDOWN COMPLETEを送信するとき、SHUTDOWN ACKの受信側にTCBがある場合、宛先エンドポイントのタグを使用する必要があり、Tビットを設定してはなりません（MUST NOT）. TCBが存在しない場合にのみ、送信者はSHUTDOWN ACKからのVerification Tagを使用し、Tビットを設定する必要があります. 

-SHUTDOWN COMPLETEの受信者は、パケットのVerification Tagフィールドが自身のタグと一致し、Tビットが設定されていない場合、またはピアのタグに設定されており、Tビットがチャンクフラグに設定されている場合、パケットを受け入れます. それ以外の場合、受信者はパケットを黙って破棄し、それ以上のアクションを実行してはなりません（MUST）. エンドポイントがSHUTDOWN-ACK-SENT状態でない場合、エンドポイントはSHUTDOWN COMPLETEを無視する必要があります. 

D）COOKIE ECHOを運ぶパケットのルール

-COOKIE ECHOを送信する場合、エンドポイントはINIT ACKで受信した開始タグの値を使用する必要があります. 

-COOKIE ECHOの受信者は、セクション5の手順に従います. 

E）SHUTDOWN ACKを運ぶパケットのルール

-受信機がCOOKIE-ECHOEDまたはCOOKIE-WAIT状態にある場合は、セクション8.4の手順に従う必要があります. 言い換えれば、それはOut of the Blueパケットとして扱われるべきです. 

9.Associationの終了
エンドポイントは、サービスを終了するときにそのassociationを終了する必要があります. アソシエーションは、中止またはシャットダウンのいずれかによって終了できます. アソシエーションのアボートは、アソシエーションの両端で保留中のデータが破棄され、ピアに配信されないという意味で、アボートです. アソシエーションのシャットダウンは、いずれかのエンドポイントによってキュー内のすべてのデータがそれぞれのピアに配信される適切なクローズと見なされます. ただし、シャットダウンの場合、SCTPはハーフオープン状態（TCPなど）をサポートしません. 一方の側では、もう一方の端が閉じている間もデータの送信を継続できます. いずれかのエンドポイントがシャットダウンを実行すると、各ピアのassociationはユーザーからの新しいデータの受け入れを停止し、SHUTDOWNチャンクの送信または受信時にキュー内のデータのみを配信します. 

9.1. アソシエーションの中止
エンドポイントが既存のassociationを中止することを決定した場合、そのエンドポイントはABORTチャンクを送信する必要があります. 送信者は、発信パケットのピアのVerification Tagを入力する必要があり、データチャンクをABORTにバンドルしないでください. 上位層の要求によりassociationが中止された場合、ユーザーが開始した中止エラーの原因（3.3.10.12を参照）は、ABORTチャンクに存在する必要があります（SHOULD）. 

エンドポイントは、ABORTチャンクを含む受信パケットに応答してはなりません（MUST 8.4も参照）. 

ABORTを受信するエンドポイントは、セクション8.5.1で説明されている特別なVerification Tagチェックルールを適用する必要があります. 

Verification Tagをチェックした後、受信側エンドポイントはそのassociationをそのレコードから削除しなければならず、その上位層に終了を報告する必要があります（SHOULD）. ユーザーが開始した中止エラーの原因がABORTチャンクに存在する場合、上位層の中止理由は、上位層で利用可能にする必要があります（SHOULD）. 

9.2. アソシエーションのシャットダウン
SHUTDOWNプリミティブ（セクション10.1を参照）を使用すると、アソシエーションのエンドポイントの上位層でアソシエーションを適切に閉じることができます. これにより、associationが終了する前に、シャットダウンイニシエーターのピアからのすべての未処理のDATA Chunksを配信できます. 

上位層からSHUTDOWNプリミティブを受信すると、エンドポイントはSHUTDOWN-PENDING状態になり、すべての未処理のデータがピアによって確認されるまでそこに留まります. エンドポイントは上位層から新しいデータを受け入れませんが、ギャップを埋めるために必要な場合は、データを遠端に再送信します. 

すべての未処理のデータが確認されると、エンドポイントはピアからSHUTDOWNチャンクを送信し、ピアから受信した最後の順次TSNを累積TSN Ackフィールドに含めます. 次に、T2シャットダウンタイマーを開始し、SHUTDOWN-SENT状態に入ります. タイマーの期限が切れた場合、エンドポイントは、ピアから受信した更新された最後の順次TSNを使用してSHUTDOWNを再送信する必要があります. 

T2-shutdownの適切なタイマー値を決定するには、セクション6.3のルールに従う必要があります. TSNのギャップを示すために、エンドポイントは同じSCTPパケットでSHUTDOWNチャンクとSACKをバンドルすることもできます. 

エンドポイントは、SHUTDOWNチャンクの再送信の数をプロトコルパラメーター 'Association.Max.Retrans'に制限する必要があります. このしきい値を超える場合、エンドポイントはTCBを破棄し、到達できないピアエンドポイントを上位層に報告する必要があります（したがって、associationはCLOSED状態になります）. ピアからのパケットの受信（つまり、ピアがキューに入れられたDATA Chunksをすべて送信するとき）は、エンドポイントの再送信カウントをクリアしてT2シャットダウンタイマーを再起動し、ピアがキューに入れられたすべてのDATA Chunksを送信する十分な機会を与えますまだ送信されていません. 

SHUTDOWNを受信すると、ピアエンドポイントは、

-SHUTDOWN-RECEIVED状態に入ります. 

-SCTPユーザーからの新しいデータの受け入れを停止します. 

-チャンクの累積TSN Ackフィールドをチェックして、そのすべての未処理のDATA ChunksがSHUTDOWN送信側によって受信されたことを確認します. 

エンドポイントがSHUTDOWN-RECEIVED状態に到達すると、ULP要求への応答としてSHUTDOWNを送信してはならず（MUST NOT）、後続のSHUTDOWNチャンクを破棄する必要があります. 

まだ未処理のDATA Chunksが残っている場合、SHUTDOWNレシーバーは、すべての未処理のDATA Chunksが確認されるまで、セクション6で定義された通常のデータ送信手順に従う必要があります. ただし、SHUTDOWNレシーバーは、SCTPユーザーからの新しいデータを受け入れてはなりません（MUST NOT）. 

SHUTDOWN-SENT状態の間、SHUTDOWN送信側は、1つ以上のDATA Chunksを含む各受信パケットにSHUTDOWNチャンクで即座に応答し、T2シャットダウンタイマーを再起動する必要があります. SHUTDOWNチャンク自体が受信したDATA Chunksのすべてを確認できない場合（つまり、確認できるTSNが累積TSNより大きく、したがってTSNシーケンスにギャップがある場合）、または重複したTSNが受信された場合、次に、SACKチャンクも送信する必要があります. 

SHUTDOWNの送信側は、全体的なガードタイマー「T5-shutdown-guard」を開始して、シャットダウンシーケンスの全体的な時間を制限する場合があります. このタイマーの満了時に、送信者はABORTチャンクを送信することでassociationを中止する必要があります（SHOULD）. 「T5-shutdown-guard」タイマーを使用する場合は、「RTO.Max」の5倍の推奨値に設定する必要があります. 

SHUTDOWNのレシーバーに未処理のDATA Chunksがなくなった場合、SHUTDOWNレシーバーはSHUTDOWN ACKを送信し、独自のT2シャットダウンタイマーを開始して、SHUTDOWN-ACK-SENT状態に入る必要があります. タイマーの期限が切れた場合、エンドポイントはSHUTDOWN ACKを再送信する必要があります. 

SHUTDOWN ACKの送信者は、SHUTDOWN ACKチャンクの再送信数をプロトコルパラメータ「Association.Max.Retrans」に制限する必要があります. このしきい値を超えると、エンドポイントはTCBを破棄し、到達できないピアエンドポイントを上位層に報告する可能性があります（したがって、associationはCLOSED状態になります）. 

SHUTDOWN ACKを受信すると、SHUTDOWN送信側はT2-shutdownタイマーを停止し、SHUTDOWN COMPLETEチャンクをピアに送信し、associationのすべてのレコードを削除します. 

エンドポイントは、SHUTDOWN COMPLETEチャンクを受信すると、それがSHUTDOWN-ACK-SENT状態であることを確認します. そうでない場合は、チャンクを破棄する必要があります. エンドポイントがSHUTDOWN-ACK-SENT状態にある場合、エンドポイントはT2シャットダウンタイマーを停止し、associationに関するすべての情報を削除する必要があります（したがって、associationはCLOSED状態になります）. 

エンドポイントは、シャットダウン手順を開始する前に、すべての未処理のDATA Chunksが確認されていることを確認する必要があります（SHOULD）. 

エンドポイントは、SHUTDOWN-PENDING、SHUTDOWN-SENT、SHUTDOWN-RECEIVED、またはSHUTDOWN-ACK-SENT状態の場合、上位層からの新しいデータ要求を拒否する必要があります. 

エンドポイントがSHUTDOWN-ACK-SENT状態にあり、このassociationに属するソースおよび宛先トランスポートアドレス（IPアドレスまたはINITチャンクのいずれか）を含むINITチャンクを受信した場合（たとえば、SHUTDOWN COMPLETEが失われた場合） 、INITチャンクを破棄し、SHUTDOWN ACKチャンクを再送信する必要があります. 

注：送信元と宛先のIPアドレスがエンドポイントに割り当てられたトランスポートアドレスと同じで、ポート番号が異なるINITを受信すると、別のassociationが初期化されたことを示します. 

INITまたはCOOKIE ECHOの送信者は、SCTPパケットのスタンドアロンSHUTDOWN COMPLETEでSHUTDOWN ACKの受信に応答する必要があります. その共通ヘッダーのVerification Tagフィールドは、SHUTDOWN ACKパケットで受信されたのと同じタグに設定されています.  . これは、セクション8.4で定義されているOut of the Blueパケットと見なされます. INITの送信側はT1-initを実行し続け、COOKIE-WAITまたはCOOKIE-ECHOED状態を維持します. 通常のT1-initタイマーの期限切れにより、INITまたはCOOKIEチャンクが再送信され、新しいassociationが開始されます. 

SHUTDOWNがCOOKIE-WAITまたはCOOKIE ECHOED状態で受信された場合、SHUTDOWNチャンクは通知なく破棄されるべきです（SHOULD）. 

エンドポイントがSHUTDOWN-SENT状態にあり、ピアからSHUTDOWNチャンクを受信した場合、エンドポイントはピアにSHUTDOWN ACKで即座に応答し、SHUTDOWN-ACK-SENT状態に移行してT2シャットダウンタイマーを再開します. 

エンドポイントがSHUTDOWN-ACK-SENT状態にあり、SHUTDOWN ACKを受信した場合、エンドポイントはT2シャットダウンタイマーを停止し、SHUTDOWN COMPLETEチャンクをピアに送信し、associationのすべてのレコードを削除します. 

10.上位層とのインターフェース
上位層プロトコル（ULP）は、SCTPにプリミティブを渡すことによってサービスを要求し、さまざまなイベントの通知をSCTPから受信します. 

このセクションで説明するプリミティブと通知は、SCTPを実装するためのガイドラインとして使用する必要があります. 以下のULPインターフェイスプリミティブの機能説明は、説明のために示しています. SCTPの実装が異なれば、ULPインターフェースも異なります. ただし、すべてのSCTP実装が同じプロトコル階層をサポートできることを保証するために、すべてのSCTPは特定の最小サービスセットを提供する必要があります. 

10.1 ULP-to-SCTP
以下のセクションでは、ULP / SCTPインターフェイスを機能的に特徴付けます. 使用される表記法は、高水準言語でのほとんどのプロシージャーまたは関数呼び出しに似ています. 

以下で説明するULPプリミティブは、プロセス間通信をサポートするためにSCTPが実行する必要がある基本機能を指定します. 個々の実装は、独自の正確な形式を定義する必要があり、単一の呼び出しで基本関数の組み合わせまたはサブセットを提供する場合があります. 

A）初期化

形式：INITIALIZE（[ローカルポート]、[ローカル適格アドレスリスト]）->ローカルSCTPインスタンス名

このプリミティブにより、SCTPは内部データ構造を初期化し、その動作環境をセットアップするために必要なリソースを割り当てることができます. SCTPが初期化されると、ULPはこのプリミティブを再度呼び出すことなく、他のエンドポイントと直接通信できます. 

SCTPはローカルSCTPインスタンス名をULPに返します. 

必須の属性：

なし. 

オプションの属性：

次のタイプの属性をプリミティブとともに渡すことができます. 

oローカルポート-ULPで指定する場合は、SCTPポート番号. 

oローカル適格アドレスリスト-ローカルSCTPエンドポイントがバインドする必要があるアドレスリスト. デフォルトでは、アドレスリストが含まれていない場合、ホストに割り当てられているすべてのIPアドレスをローカルエンドポイントで使用する必要があります. 

実装に関する注：このオプションの属性が実装によってサポートされている場合、このエンドポイントによって送信されるSCTPパケットのIP送信元アドレスフィールドに、ローカルの適格アドレスに示されているIPアドレスの1つが含まれるように強制するのは、実装の責任です. リスト. 

B）アソシエイト

形式：ASSOCIATE（ローカルSCTPインスタンス名、宛先トランスポートアドレス、送信ストリーム数）->アソシエーションID [、宛先トランスポートアドレスリスト] [、送信ストリーム数]

このプリミティブにより、上位層は特定のピアエンドポイントへのassociationを開始できます. 

ピアエンドポイントは、エンドポイントを定義するトランスポートアドレスの1つによって指定されます（セクション1.3を参照）. ローカルSCTPインスタンスが初期化されていない場合、ASSOCIATEはエラーと見なされます. 

アソシエーションの確立に成功すると、SCTPアソシエーションへのローカルハンドルであるアソシエーションIDが返されます. SCTPがピアエンドポイントとのSCTPアソシエーションを開くことができない場合、エラーが返されます. 

ピアの完全な宛先トランスポートアドレスやローカルエンドポイントのアウトバウンドストリーム数など、他のassociationパラメーターが返される場合があります. 返された宛先アドレスからのトランスポートアドレスの1つは、ローカルエンドポイントによって、このピアにSCTPパケットを送信するためのデフォルトのプライマリパスとして選択されます. 返された「宛先トランスポートアドレスリスト」は、ULPがデフォルトのプライマリパスを変更したり、特定のトランスポートアドレスにパケットを強制的に送信したりするために使用できます. 

実装上の注意：ASSOCIATEプリミティブがブロッキング関数呼び出しとして実装されている場合、ASSOCIATEプリミティブは、正常に確立されると、associationIDに加えてassociationパラメーターを返すことができます. ASSOCIATEプリミティブが非ブロッキング呼び出しとして実装されている場合、associationIDのみが返され、associationパラメータはCOMMUNICATION UP通知を使用して渡されます. 

必須の属性：

oローカルSCTPインスタンス名-INITIALIZE操作から取得されます. 

o宛先トランスポートアドレス-associationが確立されるピアエンドポイントのトランスポートアドレスの1つとして指定されます. 

oアウトバウンドストリーム数-ULPがこのピアエンドポイントに向けてオープンするアウトバウンドストリームの数. 

オプションの属性：

なし. 

C）シャットダウン

      形式：SHUTDOWN（associationID）
      ->結果
        
associationを正常に閉じます. ローカルでキューに入れられたユーザーデータはすべてピアに配信されます. アソシエーションは、ピアが送信されたすべてのSCTPパケットを確認した後でのみ終了します. associationが正常に終了すると、成功コードが返されます. アソシエーションを終了しようとすると失敗した場合は、エラーコードが返されます. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

オプションの属性：

なし. 

D）中止

      形式：ABORT（associationID [、上位層中止理由]）->
      結果
        
associationを不適切に閉じます. ローカルでキューに入れられたユーザーデータはすべて破棄され、ABORTチャンクがピアに送信されます. associationが正常に中止されると、成功コードが返されます. associationを中止しようとして失敗した場合は、エラーコードが返されます. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

オプションの属性：

o上位層の中止理由-中止がピアに渡される理由. 

なし. 

E）送信

形式：SEND（associationID、バッファアドレス、バイトカウント[、コンテキスト] [、ストリームID] [、ライフタイム] [、宛先トランスポートアドレス] [、順序付けられていないフラグ] [、バンドルなしフラグ] [、ペイロードプロトコルID ]）->結果

これは、SCTPを介してユーザーデータを送信する主な方法です. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

oバッファアドレス-送信されるUser messageが格納される場所. 

oバイト数-バイト数で表したユーザーデータのサイズ. 

オプションの属性：

o context-オプションの32ビット整数. このUser messageの転送が失敗した場合、ULPへの失敗通知の送信に含まれます. 

oストリームID-データを送信するストリームを示します. 指定しない場合、ストリーム0が使用されます. 

oライフタイム-ユーザーデータのライフタイムを指定します. 有効期限が切れると、ユーザーデータはSCTPによって送信されません. このパラメーターを使用すると、古いUser messageを送信する手間を省くことができます. SCTPは、ライフタイム変数内でデータの転送を開始できない（SCTPの送信プリミティブを介して宛先に送信できない）場合、ULPに通知します. ただし、有効期限が切れる前にSCTPがチャンクを送信しようとした場合、ユーザーデータは送信されます. 

実装上の注意：データライフタイムオプションをより適切にサポートするために、送信機は、送信DATA ChunksへのTSN番号の割り当てを最後まで保留する場合があります. また、実装を簡単にするために、TSN番号が割り当てられると、送信者はこのDATA Chunksの送信をコミット済みと見なし、DATA Chunksに添付されているライフタイムオプションを上書きする必要があります. 

o宛先トランスポートアドレス-このパケットの送信先となるピアエンドポイントの宛先トランスポートアドレスの1つとして指定されます. SCTPは、可能な限り、現在のプライマリパスではなく、この宛先トランスポートアドレスを使用してパケットを送信する必要があります. 

o unorderedフラグ-このフラグは、存在する場合、ユーザーがデータを無秩序な方法でピアに配信することを望んでいることを示します（つまり、このメッセージを運ぶすべてのDATA ChunksでUフラグが1に設定されます）. 

o no-bundleフラグ-このユーザーデータを他の送信DATA ChunksにバンドルしないようにSCTPに指示します. SCTPは、このフラグが存在する場合でも、ネットワークの輻輳に直面した場合にバンドルされる場合があります. 

o payload protocol-id-送信されるペイロードプロトコルデータのタイプを示す、ピアに渡される32ビットの符号なし整数. この値は、SCTPによって不透明なデータとして渡されます. 

F）プライマリを設定

形式：SETPRIMARY（associationID、宛先トランスポートアドレス、[ソーストランスポートアドレス]）->結果

パケットを送信するためのプライマリパスとして、指定された宛先トランスポートアドレスを使用するようにローカルSCTPに指示します. 

この操作を試みた結果が返されます. 指定された宛先トランスポートアドレスが、先にassociationられたコマンドまたは通信アップ通知で返された「宛先トランスポートアドレスリスト」に存在しない場合、エラーが返されます. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

o宛先トランスポートアドレス-ピアエンドポイントのトランスポートアドレスの1つとして指定されます. これは、パケットを送信するためのプライマリアドレスとして使用する必要があります. これは、ローカルSCTPエンドポイントによって維持されている現在のプライマリアドレス情報を上書きします. 

オプションの属性：

oソーストランスポートアドレス-オプションで、一部の実装では、すべての発信IPデータグラムに配置されるデフォルトのソースアドレスを設定できます. 

G）受け取る

形式：RECEIVE（アソシエーションID、バッファアドレス、バッファサイズ[、ストリームID]）->バイトカウント[、トランスポートアドレス] [、ストリームID] [、Stream Sequence Number] [、部分フラグ] [、配信番号] [、ペイロードプロトコルID]

このプリミティブは、SCTPインキューの最初のUser messageをULPで指定されたバッファーに読み込みます（利用可能な場合）. 読み込まれたメッセージのサイズ（バイト単位）が返されます. 特定の実装によっては、送信者のアドレス、受信したストリームID、取得できるメッセージがまだあるかどうかなど、他の情報も返すことがあります. Ordered Messageの場合、Stream Sequence Numberも戻ってきた. 

実装によっては、メッセージが利用できないときにこのプリミティブが呼び出される場合、実装はこの状態を示すか、データが利用可能になるまで呼び出しプロセスをブロックする必要があります. 

必須の属性：

oアソシエーションID-SCTPアソシエーションへのローカルハンドル

oバッファアドレス-受信したメッセージを保存するためにULPによって示されるメモリ位置. 

oバッファサイズ-受信するデータの最大サイズ（バイト単位）. 

オプションの属性：

oストリームID-データを受信するストリームを示します. 

oStream Sequence Number-送信SCTPピアによって割り当てられたStream Sequence Number. 

o部分フラグ-この返されたフラグが1に設定されている場合、この受信にはメッセージ全体の部分配信が含まれます. このフラグが設定されている場合、ストリームIDとStream Sequence Numberがこの受信に伴う必要があります. このフラグが0に設定されている場合、このStream Sequence Numberの配信がこれ以上受信されないことを示します. 

o payload protocol-id-ピアから受信した32ビットの符号なし整数. 受信したデータのペイロードプロトコルのタイプを示します. この値は、SCTPによって不透明なデータとして渡されます. 

H）ステータス

      形式：STATUS（associationID）
      ->ステータスデータ
        
このプリミティブは、次の情報を含むデータブロックを返す必要があります. 

アソシエーション接続状態、宛先トランスポートアドレスリスト、宛先トランスポートアドレス到達可能性状態、現在の受信側ウィンドウサイズ、現在のCongestion windowサイズ、未確認のDATA Chunksの数、受信保留中のDATA Chunksの数、プライマリパス、プライマリパス上の最新のSRTT、RTOオンプライマリパス、他の宛先アドレスのSRTTおよびRTOなど

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

オプションの属性：

なし. 

I）ハートビートを変更する

形式：CHANGE HEARTBEAT（associationID、宛先トランスポートアドレス、新しい状態[、間隔]）->結果

指定された宛先トランスポートアドレスでハートビートを有効または無効にするようにローカルエンドポイントに指示します. 

この操作を試みた結果が返されます. 

注：有効にした場合でも、宛先トランスポートアドレスがアイドルでない場合、ハートビートは実行されません. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

o宛先トランスポートアドレス-ピアエンドポイントのトランスポートアドレスの1つとして指定されます. 

o新しい状態-この宛先トランスポートアドレスのハートビートの新しい状態（有効または無効）. 

オプションの属性：

o interval-存在する場合、これが宛先トランスポートアドレスでハートビートを有効にする場合のハートビートの頻度を示します. この値は、宛先トランスポートアドレスのRTOに追加されます. この値が存在する場合、すべての宛先に影響します. 

J）HeartBeatのリクエスト

形式：REQUESTHEARTBEAT（associationID、宛先トランスポートアドレス）->結果

特定のassociationの指定された宛先トランスポートアドレスでハートビートを実行するようにローカルエンドポイントに指示します. 返された結果は、宛先アドレスへのHEARTBEATチャンクの送信が成功したかどうかを示す必要があります. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

o宛先トランスポートアドレス-ハートビートが発行されるアソシエーションのトランスポートアドレス. 

K）SRTTレポートを取得する

形式：GETSRTTREPORT（associationID、宛先トランスポートアドレス）-> srtt結果

特定のアソシエーションの特定の宛先トランスポートアドレスに関する現在のSRTT測定を報告するようにローカルSCTPに指示します. 返される結果は、最新のSRTTをミリ秒単位で含む整数になります. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

o宛先トランスポートアドレス-SRTT測定が報告されるアソシエーションのトランスポートアドレス. 

L）障害しきい値を設定する

形式：SETFAILURETHRESHOLD（associationID、宛先トランスポートアドレス、障害しきい値）

->結果

このプリミティブにより、ローカルSCTPは、指定された宛先アドレスの到達可能性障害検出しきい値「Path.Max.Retrans」をカスタマイズできます. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

o宛先トランスポートアドレス-障害検出しきい値を設定するassociationのトランスポートアドレス. 

o障害しきい値-宛先アドレスの「Path.Max.Retrans」の新しい値. 

M）プロトコルパラメータの設定

形式：SETPROTOCOLPARAMETERS（associationID、[、宛先トランスポートアドレス、]プロトコルパラメータリスト）->結果

このプリミティブにより、ローカルSCTPはプロトコルパラメータをカスタマイズできます. 

必須の属性：

oassociationID-SCTPassociationへのローカルハンドル. 

oプロトコルパラメータリスト-SCTPユーザーがカスタマイズするプロトコルパラメータの特定の名前と値（Association.Max.Retrans、セクション15を参照）. 

オプションの属性：

o宛先トランスポートアドレス-一部のプロトコルパラメータは、宛先トランスポートアドレスごとに設定できます. 

N）未送信メッセージを受信

形式：RECEIVE_UNSENT（データ取得ID、バッファアドレス、バッファサイズ[、ストリームID] [、Stream Sequence Number] [、部分的なフラグ] [、ペイロードプロトコルID]）

oデータ取得ID-障害通知でULPに渡されるID. 

oバッファアドレス-受信したメッセージを保存するためにULPによって示されるメモリ位置. 

oバッファサイズ-受信するデータの最大サイズ（バイト単位）. 

オプションの属性：

oストリームID-これは、データの送信先のストリームを示すために設定される戻り値です. 

oStream Sequence Number-この値は、メッセージにassociationられたStream Sequence Numberを示して返されます. 

o部分フラグ-この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分配信です. このフラグが設定されている場合、ストリームIDとStream Sequence Numberがこの受信に伴う必要があります. このフラグが0に設定されている場合、このStream Sequence Numberの配信がこれ以上受信されないことを示します. 

o payload protocol-id-ピアに送信するために送信された32ビットの符号なし整数. 受信したデータのペイロードプロトコルのタイプを示します. 

o未確認のメッセージを受信する

形式：RECEIVE_UNACKED（データ取得ID、バッファアドレス、バッファサイズ、[、ストリームID] [、Stream Sequence Number] [、部分的なフラグ] [、ペイロードプロトコルID]）

oデータ取得ID-障害通知でULPに渡されるID. 

oバッファアドレス-受信したメッセージを保存するためにULPによって示されるメモリ位置. 

oバッファサイズ-受信するデータの最大サイズ（バイト単位）. 

オプションの属性：

oストリームID-これは、データの送信先のストリームを示すために設定される戻り値です. 

oStream Sequence Number-この値は、メッセージにassociationられたStream Sequence Numberを示して返されます. 

o部分フラグ-この返されたフラグが1に設定されている場合、このメッセージはメッセージ全体の部分配信です. このフラグが設定されている場合、ストリームIDとStream Sequence Numberがこの受信に伴う必要があります. このフラグが0に設定されている場合、このStream Sequence Numberの配信がこれ以上受信されないことを示します. 

o payload protocol-id-受信したデータのペイロードプロトコルのタイプを示す、ピアに送信された32ビットの符号なし整数. 

P）SCTPインスタンスを破棄する

      形式：DESTROY（ローカルSCTPインスタンス名）
        
oローカルSCTPインスタンス名-これは、初期化プリミティブでアプリケーションに渡された値で、破棄するSCTPインスタンスを示します. 

10.2 SCTP-to-ULP
オペレーティングシステムまたはアプリケーション環境は、SCTPがULPプロセスに非同期に信号を送るための手段を提供すると想定されています. SCTPがULPプロセスを通知する場合、特定の情報がULPに渡されます. 

実装上の注意：場合によっては、これは別のソケットまたはエラーチャネルを介して行われることがあります. 

A）データ到着通知

SCTPは、User messageが正常に受信され、取得の準備ができたときに、ULPでこの通知を呼び出します. 

オプションで、通知とともに以下を渡すことができます. 

oassociationID-SCTPassociationへのローカルハンドル. 

oストリームID-データが受信されるストリームを示します. 

B）SEND FAILURE通知

メッセージを配信できない場合、SCTPはULPでこの通知を呼び出します. 

オプションで、通知とともに以下を渡すことができます. 

oassociationID-SCTPassociationへのローカルハンドル. 

oデータ取得ID-未送信および未確認のデータを取得するために使用されるID. 

o原因コード-失敗の理由を示します（サイズが大きすぎる、メッセージの有効期間の期限切れなど）. 

oコンテキスト-このメッセージに関連するオプション情報（セクション10.1のDを参照）. 

C）ネットワークステータス変更通知

宛先トランスポートアドレスが非アクティブとしてマークされる（SCTPが障害を検出するなど）、またはアクティブとしてマークされる（SCTPが回復を検出するなど）と、SCTPはULPでこの通知を呼び出します. 

次のものは通知とともに渡されます. 

oassociationID-SCTPassociationへのローカルハンドル. 

o宛先トランスポートアドレス-これは、変更の影響を受けるピアエンドポイントの宛先トランスポートアドレスを示します. 

o new-status-これは新しいステータスを示します. 

D）通信アップ通知

この通知は、SCTPがUser messageを送受信できるようになったとき、またはエンドポイントとの通信が失われたときに復元されます. 

実装上の注意：ASSOCIATEプリミティブがブロッキング関数呼び出しとして実装されている場合、associationパラメーターはASSOCIATEプリミティブ自体の結果として返されます. その場合、アソシエーションの開始者側でのCOMMUNICATION UP通知はオプションです. 

次のものは通知とともに渡されます. 

oassociationID-SCTPassociationへのローカルハンドル. 

o status-これは、発生したイベントのタイプを示します. 

o宛先トランスポートアドレスリスト-ピアのトランスポートアドレスの完全なセット. 

oアウトバウンドストリーム数-ULPがこのassociationで使用できるストリームの最大数. 

oインバウンドストリーム数-ピアエンドポイントがこのassociationで要求したストリームの数（これは、「アウトバウンドストリーム数」と同じ数ではない場合があります）. 

E）COMMUNICATION LOST通知

SCTPがエンドポイントとの通信を完全に（ハートビートなどを介して）失うか、エンドポイントが中止操作を実行したことを検出すると、ULPでこの通知を呼び出します. 

次のものは通知とともに渡されます. 

oassociationID-SCTPassociationへのローカルハンドル. 

o status-発生したイベントのタイプを示します. ステータスは、障害または正常終了イベントがシャットダウンまたは中止要求に応答して発生したことを示している場合があります. 

通知では以下が渡される場合があります. 

oデータ取得ID-未送信および未確認のデータを取得するために使用されるID. 

o last-acked-そのピアエンドポイントによって最後に確認されたTSN. 

o最終送信-そのピアエンドポイントに最後に送信されたTSN. 

o上位層の中止理由-ユーザーが開始した中止の場合に指定された中止理由. 

F）通信エラー通知

SCTPは、ピアからERRORチャンクを受信し、ULPに通知することを決定すると、ULPでこの通知を呼び出すことができます. 

以下は通知で渡すことができます：

oassociationID-SCTPassociationへのローカルハンドル. 

oエラー情報-これはエラーのタイプを示し、オプションでERRORチャンクを介して受信したいくつかの追加情報を示します. 

G）RESTART通知

SCTPは、ピアが再起動したことを検出すると、この通知をULPに送信します. 

以下は通知で渡すことができます：

oassociationID-SCTPassociationへのローカルハンドル. 

H）シャットダウン完了通知

SCTPがシャットダウン手順（セクション9.2）を完了すると、この通知は上位層に渡されます. 

以下は通知で渡すことができます：

oassociationID-SCTPassociationへのローカルハンドル. 

11.セキュリティに関する考慮事項
11.1 セキュリティの目的
ネットワークに接続された2つのエンドポイント間で、テレフォニーサービスの課金メッセージやシグナリングメッセージなどの時間依存のUser messageを確実に伝送するように設計された一般的なトランスポートプロトコルとして、SCTPには次のセキュリティ目標があります. 

-信頼性が高くタイムリーなデータ転送サービスの可用性

-SCTPによって運ばれるユーザー間の情報の整合性

11.2 潜在的な脅威に対するSCTPの対応
SCTPは、さまざまなリスク状況で使用される可能性があります. SCTPを実行しているシステムのオペレーターは、特定の状況を分析し、適切な対策を決定することが重要です. 

SCTPを実行しているシステムの運用者は、サイトを保護するためのガイダンスについて[RFC2196]を参照する必要があります. 

11.2.1. インサイダー攻撃への対抗
[RFC2196]の原則を適用して、内部者による情報の盗難や妨害のリスクを最小限に抑える必要があります. このような手順には、セキュリティポリシーの公開、物理レベル、ソフトウェアレベル、ネットワークレベルでのアクセス制御、およびサービスの分離が含まれます. 

11.2.2. ネットワークでのデータ破損からの保護
下位層のトランスポートサービスによって配信されるデータグラムの未検出エラーのリスクが高すぎると考えられる場合は、追加の整合性保護が必要です. この追加の保護がアプリケーション層で提供されている場合、SCTPヘッダーは意図的な整合性攻撃に対して脆弱なままです. パケットリプレイを検出するための既存のSCTPメカニズムは通常の運用には十分であると考えられていますが、運用環境に高度な攻撃者からの意図的な攻撃の重大なリスクがある場合、SCTPを保護するにはより強力な保護が必要です. 

SCTP認証拡張SCTP-AUTH [RFC4895]は、脅威環境がより強力な完全性保護を必要とするが、機密性は必要としない場合に使用できます. 

11.2.3. 機密性の保護
ほとんどの場合、機密性の侵害のリスクは、SCTPまたは下位層のプロトコルオーバーヘッドではなく、シグナリングデータペイロードに適用されます. これが当てはまる場合は、SCTPユーザーデータの暗号化のみが考慮される場合があります. 補足チェックサムサービスと同様に、ユーザーデータの暗号化はSCTPユーザーアプリケーションによって実行される場合があります. 代わりに、ユーザーアプリケーションは、実装固有のAPIを使用して、IPカプセル化セキュリティペイロード（ESP）[RFC4303]を使用して機密性と整合性を提供することを要求できます（MAY）. 

特にモバイルユーザーの場合、機密性の要件には、IPアドレスとポートのマスキングが含まれる場合があります. この場合、アプリケーションレベルの機密性の代わりにESPを使用する必要があります（SHOULD）. ESPを使用してSCTPトラフィックの機密性を保護する場合は、暗号化の整合性保護を含むESP暗号化トランスフォームを使用する必要があります. これは、機密性の脅威がある場合、強力な整合性の脅威も存在するためです. 

ESPが使用されている場合は常に、アプリケーションレベルの暗号化は通常必要ありません. 

機密性が提供される場所に関係なく、インターネットキー交換プロトコルバージョン2（IKEv2）[RFC4306]はキー管理に使用する必要があります（SHOULD）. 

事業者は、インターネットプロトコルレイヤーで、およびそのすぐ上で利用可能なセキュリティサービスの詳細について、[RFC4301]を参照する必要があります. 

11.2.4. ブラインドサービス拒否攻撃からの保護
ブラインド攻撃とは、攻撃者が標的のSCTPノードとの間でやり取りされるデータフローの内容を傍受または他の方法で確認できない攻撃です. ブラインドサービス拒否攻撃は、フラッディング、なりすまし、またはサービスの不適切な独占の形をとる場合があります. 

11.2.4.1. 洪水
フラッディングの目的は、リソースの枯渇、正当なトランザクションへの干渉、およびバッファ関連のソフトウェアバグの悪用を通じて、ターゲットシステムでサービスの損失と不正な動作を引き起こすことです. フラッディングは、SCTPノードか、介在するIPアクセスリンクまたはインターネットのリソースのいずれかに向けられます. 後者のエンティティがターゲットである場合、フラッディングは、ファイアウォールの違反など、ネットワークサービスの損失として現れます. 

一般に、洪水に対する保護は機器の設計レベルから始まり、次のような対策が含まれます. 

-サービスの要求が正当であると判断する前に、限られたリソースのコミットメントを回避します. 

-新しい作業の受け入れよりも進行中の処理の完了を優先します. 

-重複または古いキューに入れられたサービス要求の識別と削除. 

-非ユニキャストアドレスに送信された予期しないパケットに応答しない. 

ネットワーク機器は、疑わしいトラフィックの増加が発生した場合、アラームを生成してログに記録できる必要があります. ログには、使用される着信リンクのIDや送信元アドレスなどの情報が含まれている必要があります. これは、ネットワークまたはSCTPシステムのオペレーターが保護対策を講じるのに役立ちます. 悪用の明確なパターンが発生した場合に、オペレーターがそのようなアラームに対処するための手順を用意する必要があります. 

SCTPの設計は、特に4方向の起動ハンドシェイクの使用、ハンドシェイクが完了するまで応答するSCTPノードでのリソースのコミットメントを延期するためのCookieの使用、およびVerification Tagの使用において、フラッディング攻撃に耐性があります. 確立されたアソシエーションのフローへの無関係なパケットの挿入を防ぐため. 

IP認証ヘッダーとカプセル化セキュリティペイロードは、特定の種類のサービス拒否攻撃のリスクを軽減するのに役立ちます. 

INITチャンクのホスト名機能を使用すると、ターゲットDNSサーバーをフラッディングする可能性があります. INITチャンクで受け取ったホスト名をIPアドレスに解決するDNSクエリの大量のバックログは、特定のドメインの複数のホストにINITを送信することで実現できます. さらに、攻撃者は、ターゲットのホスト名を含むランダムなホストに大量のINITを送信することにより、第三者への間接攻撃でホスト名機能を使用する可能性があります. DNSリソースへの負担に加えて、ターゲットに送信されるINIT ACKが大量になる可能性もあります. このタイプの攻撃から保護する1つの方法は、DNSから受信したIPアドレスに元のINITのソースIPアドレスが含まれていることを確認することです. DNSから受信したIPアドレスのリストにINITのソースIPアドレスが含まれていない場合、エンドポイントはINITを黙って破棄してもよい（MAY）. この最後のオプションは、DNSに対する攻撃から保護しません. 

11.2.4.2. ブラインドマスカレード
マスカレードは、いくつかの方法でサービスを拒否するために使用できます. 

-偽装ノードがアクセスを制限されているターゲットSCTPノードでリソースを拘束する. たとえば、ターゲットノードはポリシーにより、なりすましSCTPノードとの最大1つのSCTPアソシエーションを許可する場合があります. なりすましの攻撃者は、なりすましのノードから来たとするアソシエーションを確立しようと試みる可能性があります. 

-意図的になりすましを検出できるようにすることで、偽装ノードがターゲットSCTPノードからロックアウトされる原因となる対策を引き起こします. 

-SHUTDOWNリクエストなどの無関係なコンテンツを挿入して、確立されたassociationを妨害する. 

SCTPは、4ウェイスタートアップハンドシェイクを使用することにより、IPスプーフィングによるブラインドマスカレード攻撃のリスクを軽減します. 最初の交換ではメモリがなくなるため、ブラインドマスカレード攻撃によってロックアウトメカニズムがトリガーされることはありません. さらに、状態Cookieを含むINIT ACKは、INITを受け取ったIPアドレスに送信されます. したがって、攻撃者は状態Cookieを含むINIT ACKを受信しません. SCTPは、Verification Tagを使用して、確立されたassociationのフローに無関係なパケットが挿入されるのを防ぎます. 

受信したINIT要求と予期しないINIT ACKなどの異常のロギングは、悪意のあるアクティビティのパターンを検出する方法と見なされる場合があります. ただし、そのようなロギングの潜在的な有用性は、それが意味するSCTP起動処理の増加と比較検討する必要があり、SCTPノードをフラッディング攻撃に対してより脆弱にします. 日常的にログを確認および分析するための操作手順を確立しなければ、ロギングは無意味です. 

11.2.4.3. サービスの不適切な独占
この見出しの下の攻撃は、攻撃者によって公然と正当に行われます. それらは、ターゲットSCTPノードまたは攻撃者とターゲットノード間の共有リソースの仲間のユーザーに対して向けられます. 可能性のある攻撃には、攻撃者のノードとターゲット間の多数のassociationのオープン、または正当に確立されたassociation内の大量の情報の転送が含まれます. 

ポリシー制限は、隣接するSCTPノードごとのアソシエーションの数に設定する必要があります. SCTPユーザーアプリケーションは、ローカルポリシーに基づいて、特定のアソシエーション内の大量の不正または「no-op」メッセージを検出し、結果としてアソシエーションをログに記録または終了できる必要があります. 

11.3. ファイアウォールとSCTPの相互作用
一部のファイアウォールは、断片化されたSCTPパケットの最初のフラグメントのみを検査し、それがINITチャンクに対応するかどうかを明確に判断できる場合に役立ちます（詳細については、[RFC1858]を参照してください）. したがって、セクション3.1で述べた（1）INITチャンクをバンドルしてはならないという要件を強調します. 

パケット内の他のチャンク、および（2）INITチャンクを含むパケットはゼロVerification Tagを持っている必要があります. さらに、INITチャンクの受信者は、他のチャンクにバンドルされているか、ゼロ以外のVerification Tagがあり、INITチャンクを含むINITチャンクを持つ到着パケットをサイレントに破棄することにより、これらのルールを適用する必要があります. 

11.4. SCTP非対応ホストの保護
SCTP非対応ホストに、SCTP対応ホストと同じレベルの攻撃に対する保護を提供するには、すべてのSCTPスタックが、付録Cで説明されているICMP処理を実装する必要があります. 

SCTPスタックが複数の制御またはDATA Chunksを含むパケットを受信し、そのパケットの処理で応答として複数のチャンクを送信する必要がある場合、応答チャンクの送信者は複数のパケットを送信してはなりません（MUST NOT）. Bundlingがサポートされている場合、単一のパケットに収まる複数の応答チャンクは、1つの単一の応答パケットに一緒にバンドルされる場合があります. Bundlingがサポートされていない場合、送信者は複数の応答チャンクを送信してはならず（MUST NOT）、他のすべての応答を破棄しなければなりません（MUST）. SACKチャンクはそれ自体がDATAへの応答であり、SACKは追加のDATAの応答を必要としないため、このルールはSACKチャンクには適用されないことに注意してください. 

SCTP実装は、送信されていないTSNを確認するSACKを受信した場合、associationを中止する必要があります（SHOULD）. 

応答に大きなパケットを必要とするINITを受信するSCTP実装は、複数のERRORパラメータを含めることにより、その裁量により、一部またはすべてのERRORパラメータを省略してINIT ACKのサイズを減らすことができます. COOKIEパラメータのサイズと、INITの受信者がピアに示すアドレスの数の組み合わせにより、INIT ACKが元のINITよりも大きくなる可能性があります. SCTPの実装では、バイト増幅攻撃の可能性を減らすために、INIT ACKをできるだけ小さくする必要があります（SHOULD）. 

12.ネットワーク管理の考慮事項
[RFC3873]で定義されているSCTPのMIBモジュールは、このドキュメントで指定されているプロトコルのバージョンに適用されます. 

13.推奨されるトランスミッションコントロールブロック（TCB）パラメータ
このセクションでは、実装のためにTCB内に含める必要がある推奨されるパラメーターのセットについて詳しく説明します. このセクションは例示を目的としたものであり、実装の要件として、またはSCTP TCB内のすべてのパラメーターの完全なリストとして見なしてはなりません. 各実装には、最適化のために独自の追加パラメーターが必要な場合があります. 

13.1. SCTPインスタンスに必要なパラメータ
association：現在のassociationのリストと、各associationのデータコンシューマーへのマッピング. これは、ハッシュテーブルまたは他の実装に依存する構造の形式にすることができます. データコンシューマは、SCTPの実装方法に応じて、ファイル記述子、名前付きパイプポインタ、テーブルポインタなどのプロセス識別情報になる場合があります. 

秘密鍵：このエンドポイントがMACを計算するために使用する秘密鍵. これは十分な長さの暗号品質の乱数である必要があります. RFC 4086での議論は、キーの選択に役立ちます. 

アドレスリスト：このインスタンスがバインドしたIPアドレスのリスト. この情報は、INITおよびINIT ACKチャンクでピアに渡されます. 

SCTP P ort：エンドポイントがバインドされているローカルSCTPポート番号. 

13.2. アソシエーションごとに必要なパラメーター（つまり、TCB）
ピア：すべてのパケットで送信され、受信されるタグ値検証：INITまたはINIT ACKチャンク. 鬼ごっこ ：

My：すべてのインバウンドパケットで予期され、検証で送信されるタグ：INITまたはINIT ACKチャンク. 鬼ごっこ ：

状態：associationの状態を示す状態変数：COOKIE-WAIT、COOKIE-ECHOED、ESTABLISHED 、: SHUTDOWN-PENDING、SHUTDOWN-SENT、SHUTDOWN-RECEIVED 、: SHUTDOWN-ACK-SENT. 

注：associationが「クローズ」されている場合、そのTCBを削除する必要があるため、「クローズ」状態は示されていません. 

ピア：ピアTransport：がバインドされているSCTPトランスポートアドレスのリスト. この情報はINITまたはAddress：INIT ACKから取得され、インバウンドパケットList：を特定のassociationにassociationるために使用されます. 通常、この情報は：TCBの迅速な検索とアクセスのためにハッシュまたはキー化されます. 

Primary：これは現在のプライマリ宛先トランスポートです. Path：ピアエンドポイントのアドレス. また、このエンドポイントのソーストランスポートアドレスを指定することもできます. 

全体：全体的なassociationエラーの数. エラー数：

全体：このassociationのしきい値. 全体的なエラー：エラー数に達すると、このassociationはしきい値：破棄されます. 

Peer Rwnd：ピアのrwndの現在の計算値. 

次のTSN：新しいDATA Chunksに割り当てられる次のTSN番号. ：これはINITまたはINIT ACKチャンクでピアに送信され、DATA ChunksがTSNに割り当てられるたびにインクリメントされます. 

Last Rcvd：これは順番に受信された最後のTSNです. この値TSNは、ピアの初期TSNを取得することによって最初に設定され、：INITまたはINIT ACKチャンクで受信され、：そこから1を減算します. 

マッピング：どの配列外の：順序のTSNが受信されたかを示すビットまたはバイトの配列（相対：：最終受信TSN）. ギャップが存在しない場合、つまり、順不同のパケットが受信されていない場合、この配列はすべてゼロに設定されます. この構造は、循環バッファーまたはビット配列の形式にすることができます. 

Ack State：このフラグは、次の受信パケットがSACKで応答されるかどうかを示します. これは、0に初期化されます. パケットが受信されると、増分されます. ：この値が2以上になると、SACKが送信され、値が0にリセットされます. 注：これは、DATA Chunksが順不同で受信されない場合にのみ使用されます. DATA：チャンクの順序が正しくない場合、SACKは遅延されません（セクション6を参照）. 

インバウンド：インバウンドストリームを追跡するための構造体の配列、ストリーム：通常は次のシーケンス番号を含みます：おそらくストリーム番号. 

Outbound：アウトバウンドストリームを追跡するための構造の配列、Streams：通常は次のシーケンス番号を含み、：ストリームで送信されます. 

Reasm Queue：再構成キュー. 

ローカル：このトランスポートにassociationられているローカルIPアドレスのリスト：association. 住所：リスト：

association：すべてのPMTUで検出された最小のPMTU：ピアのトランスポートアドレス. 

13.3. トランスポートアドレスごとのデータ
INITまたはINIT ACKチャンクから派生したピアのアドレスリスト内の各宛先トランスポートアドレスについて、以下を含む多くのデータ要素を維持する必要があります. 

エラー数：この送り先の現在のエラー数. 

Error：この送り先の現在のエラーしきい値. つまり、Threshold：エラーカウント：この値に達した場合に送り先をマークする値. 

cwnd：現在のCongestion window. 

ssthresh：現在のssthresh値. 

RTO：現在の再送信タイムアウト値. 

SRTT：現在の平滑化された往復時間. 

RTTVAR：現在のRTTバリエーション. 

partial：ACKされたバイト数でのcwndの増加の追跡方法：輻輳回避モード（セクション7.2.2を参照）. 

state：この宛先の現在の状態. つまり、DOWN、UP、：ALLOW-HB、NO-HEARTBEATなど. 

PMTU：現在既知のパスMTU. 

Per：各宛先で使用されるタイマー. 宛先：タイマー：

RTO-Pending：送信されたDATA Chunksの1つであるかどうかを追跡するために使用されるフラグ：このアドレスが現在RTTの計算に使用されている：このフラグが0の場合、次のDATA Chunksが送信されます. この宛先はRTTの計算に使用され、このフラグが設定されます. RTT：計算が完了するたびに（つまり、DATA ChunksがSACKされる）、このフラグをクリアします. 

last-time：この宛先が最後に送信された時刻. ：これは、ハートビートが必要かどうかを判断するために使用できます. 

13.4. 必要な一般的なパラメータ
Out Queue：アウトバウンドDATA Chunksのキュー. 

In Queue：インバウンドDATA Chunksのキュー. 

14. IANAに関する考慮事項
SCTPは、IANAが維持する3つのレジストリを定義しています. 

-追加のチャンクタイプの定義による-追加のパラメータータイプの定義による-またはERRORチャンク内の追加の原因コードの定義による

SCTPでは、SCTPポート登録のためにIANAポート番号レジストリを開く必要があります. 14.5節でその方法を説明します. IESGが任命したExpert Reviewerは、SCTPポート割り当て要求の評価においてIANAをサポートします. 

14.1. IETF定義のチャンク拡張
新しいチャンクパラメータタイプコードの割り当ては、[RFC2434]で定義されているIETFコンセンサスアクションを通じて行われます. チャンクパラメータのドキュメントには、次の情報が含まれている必要があります. 

a）新しいチャンクタイプの長い名前と短い名前. 

b）チャンクの構造の詳細な説明. セクション3.2で定義された基本構造に準拠する必要があります. 

c）チャンク内の各フィールドの使用目的の詳細な定義と説明（チャンクフラグがある場合はそれを含む）. 

d）プロトコルの操作内での新しいチャンクタイプの使用に関する詳細な手順の説明. 

最後のチャンクタイプ（255）は、必要に応じて将来の拡張のために予約されています. 

14.2. IETF定義のチャンクパラメータ拡張
新しいチャンクパラメータタイプコードの割り当ては、[RFC2434]で定義されているIETFコンセンサスアクションを通じて行われます. チャンクパラメータのドキュメントには、次の情報が含まれている必要があります. 

a）パラメータタイプの名前. 

b）パラメータフィールドの構造の詳細な説明. この構造は、セクション3.2.1で説明されている一般的なType-Length-Value形式に準拠する必要があります. 

c）パラメータ値の各コンポーネントの詳細な定義. 

d）このパラメータタイプの使用目的の詳細な説明、およびこのチャンク内にこのパラメータタイプの複数のインスタンスが見つかるかどうか、またどのような状況で見つかるかの指示. 

e）各パラメータタイプは、すべてのチャンクで一意である必要があります. 

14.3. IETF定義の追加エラー原因
追加の原因コードは、[RFC2434]で定義されている仕様が必要なアクションを介して11〜65535の範囲で割り当てることができます. 提供されるドキュメントには、次の情報が含まれている必要があります. 

a）エラー条件の名前. 

b）SCTPエンドポイントがこの原因コードでERROR（またはABORT）を発行する条件の詳細な説明. 

c）この原因コードを含むERROR（またはABORT）チャンクを受信するSCTPエンドポイントによる予期されるアクション. 

d）この原因コードに伴うデータフィールドの構造と内容の詳細な説明. 

原因コードパラメータの最初のワード（32ビット）は、セクション3.3.10に示す形式に準拠する必要があります. 

-最初の2バイトには原因コードの値が含まれています-最後の2バイトには原因パラメーターの長さが含まれています. 

14.4. ペイロードプロトコル識別子
DATA Chunks内の未指定のペイロードプロトコル識別子を示すためにSCTPによって予約されている値0を除いて、SCTPはペイロードプロトコル識別子の標準化または検証を担当しません. SCTPは単に上位層から識別子を受信し、対応するペイロードデータと一緒にそれを運びます. 

上位層、つまりSCTPユーザーは、必要に応じて、特定のプロトコル識別子をIANAで標準化する必要があります（SHOULD）. 特定のペイロードプロトコル識別子の使用は、SCTPの範囲外です. 

14.5 ポート番号レジストリ
SCTPサービスは、コンタクトポート番号を使用して、TCPやUDPのように、不明な発信​​者にサービスを提供できます. したがって、IANAは、次のルールを使用して、SCTPの既存のポート番号レジストリを開くように要求されます. これは、既存のポート番号登録手順とうまく一致する予定です. IESGが任命したExpert Reviewerは、[RFC2434]で定義された手順に従って、SCTPポート割り当て要求を評価する際にIANAをサポートします. 

ポート番号は3つの範囲に分けられます. Well Knownポートは0〜1023のポートであり、Registeredポートは1024〜49151のポートであり、Dynamicおよび/またはPrivateポートは49152〜65535のポートです. WellKnownポートおよびRegisteredポートは、サーバーアプリケーションでの使用を目的としています. システムのデフォルトの連絡先. ほとんどのシステムでは、既知のポートはシステム（またはルート）プロセスまたは特権ユーザーが実行するプログラムでのみ使用できますが、登録済みポートは通常のユーザープロセスまたは通常のユーザーが実行するプログラムで使用できます. 動的および/またはプライベートポートは、クライアント側ポート、アウトオブバンドネゴシエーションポート、専用ポートの登録前のアプリケーションテストなど、一時的な使用を目的としています. 登録してはなりません. 

ポート番号レジストリは、Well Known PortsおよびRegistered Ports範囲のSCTPポートの登録を受け入れる必要があります. 既知の登録済みのポートは、登録なしで使用してはなりません. アプリケーションをTCPからSCTPに移植する場合など、場合によっては、登録が完了する前にSCTPポートを使用するのが自然に思えるかもしれませんが、IANAは特定の既知の登録済みポートの登録を保証しないことを強調します. 登録はできるだけ早くリクエストする必要があります. 

各ポート登録には、次の情報が含まれている必要があります. 

o完全に文字（AZとaz）、数字（0-9）、および「-_ +. / *」からの句読文字（引用符は含まない）で構成される短いポート名. 

o登録を要求されたポート番号. 

o港の目的を説明する短い英語のフレーズ. 

o登録を実行する人またはエンティティの名前と連絡先情報、および場合によってはポートの使用を定義するドキュメントへの参照. IETFワーキンググループからの登録では、ワーキンググループに名前を付けるだけで済みますが、連絡先を示すことをお勧めします. 

登録者は、登録を送信する際にこれらのガイドラインに従うことをお勧めします. 

oポート名は、複数のSCTPポート番号に登録してはなりません（SHOULD NOT）. 

o TCPに登録されたポート名は、SCTPにも登録される場合があります. このような登録では、既存のTCP登録と同じポート番号を使用する必要があります（SHOULD）. 

oポートを使用する具体的な意図は、ポート登録の前にすべきです（SHOULD）. たとえば、既存のTCPポートは、SCTPにそれらのポートを使用する意図よりも前に登録してはなりません（SHOULD NOT）. 

このドキュメントでは、次のポートを登録しています. （これらの登録は、今後の割り当て要求に準拠するためのモデルと見なす必要があります. ）

         discard 9 / sctp Discard＃IETF TSVWG
                                     ＃Randall Stewart <rrs@cisco.com>
                                     ＃[RFC4960]
        
ポート9でSCTP接続を受け入れる破棄サービスは、すべての着信アプリケーションデータを破棄し、応答としてデータを送信しません. したがって、SCTPの破棄ポートはTCPの破棄ポートに類似しており、SCTPスタックの状態をチェックするために使用される場合があります. 

         ftp-data 20 / sctp FTP＃IETF TSVWG
                                     ＃Randall Stewart <rrs@cisco.com>
                                     ＃[RFC4960]
        
         ftp 21 / sctp FTP＃IETF TSVWG
                                     ＃Randall Stewart <rrs@cisco.com>
                                     ＃[RFC4960]
        
ファイル転送プロトコル（FTP）データ（20）および制御ポート（21）. 

         ssh 22 / sctp SSH＃IETF TSVWG
                                     ＃Randall Stewart <rrs@cisco.com>
                                     ＃[RFC4960]
        
セキュアシェル（SSH）リモートログインサービス. ホストへのセキュアシェルログインを可能にします. 

         http 80 / sctp HTTP＃IETF TSVWG
                                     ＃Randall Stewart <rrs@cisco.com>
                                     ＃[RFC4960]
        
SCTP上のWorld Wide Web HTTP. 

         bgp 179 / sctp BGP＃IETF TSVWG
                                     ＃Randall Stewart <rrs@cisco.com>
                                     ＃[RFC4960]
        
SCTP上のボーダーゲートウェイプロトコル. 

         https 443 / sctp HTTPS＃IETF TSVWG
                                     ＃Randall Stewart <rrs@cisco.com>
                                     ＃[RFC4960]
        
SCTP上のTLS / SSL上のWorld Wide Web HTTP. 

15.推奨されるSCTPプロトコルパラメータ値
次のプロトコルパラメータを推奨します. 

      RTO.Initial-3秒
      RTO.Min-1秒
      RTO.Max-60秒
      最大バースト-4
      RTO.Alpha-1/8
      RTO.Beta-1/4
      Valid.Cookie.Life-60秒
      Association.Max.Retrans-10回の試行Path.Max.Retrans-5回の試行（宛先アドレスごと）
      Max.Init.Retransmits-8回の試行
      HB.interval-30秒
      HB.Max.Burst-1
        
実装上の注意：SCTPの実装により、ULPはこれらのプロトコルパラメータの一部をカスタマイズできます（セクション10を参照）. 

注：RTO.Minは上記の推奨値に設定する必要があります. 

16.謝辞
この更新されたドキュメントによって表される取り組みは、小さな偉業ではなく、RFC 2960の最初の著者の要約を表します. カラ、L. チャン、V. パクソン. 

それに加えて、元のRFCに貢献したすべての人からのコメント：

マークオールマン、RJアトキンソン、リチャードバンド、スコットブラドナー、スティーブベロビン、ピーターバトラー、ラムダントゥ、R. エジルパヴァイ、マイクフィスク、サリーフロイド、福本淳、マットホールドリージ、ヘンリーハウ、クリスチャンウイテマ、ゲイリーレヘッカ、ジョナサンリー、デビッドリーマン、ジョン・ラフニー、ダニエル・ルアン、バリー・ナーゲルバーグ、トーマス・ナーテン、エリック・ノードマーク、リンドン・オン、シャマル・プラサード、ケルビン・ポーター、ハインツ・プラントナー、ヤルノ・ラジャハルム、レイモンド・E・リーブス、レニー・レヴィス、イヴァン・アリアス・ロドリゲス、A. サンカー、グレッグ・サイドボトム、ブライアンワイルド、ラモンテヤロール、その他多くの貴重なコメント. 

次に、SCTP実装者ガイドの作成者であるI. Arias-Rodriguez、K. Poon、A. Caro、およびM. Tuexenを追加します. 

次に、後続の7つのSCTP相互運用性テストすべてと、その承認に示されているようにRFC 4460についてコメントしたテストの取り組みを追加します. 

バリー・ズッカーマン、ラ・モンテ・ヤロール、チャオビン・シェ、ワン・シャオペン、ジョナサン・ウッド、ジェフ・ワスコウ、マイク・ターナー、ジョン・タウンゼンド、サビナ・トレンテ、クリフ・トーマス、鈴木雄二、マノジ・ソランキ、スヴェル・スロット、キール・シャー、ジャン・ロビンス、ベン・ロビンソン、レニーレヴィス、イアンペリアム、RCモニー、サンジャイラオ、スミスラダクリシュナン、ハインツプラント、バイレンパテル、ナタリームエリク、ミッチマイアーズ、バーンワードメイクネヒト、スタンマクレラン、オリバーマヨール、トマスオルティマーティン、サンディープマハジャン、デビッドリーマン、ジョナサンリー、フィリップ、カール・ナットソン、ジョー・ケラー、ガレス・キーリー、アンドレアス・ジュングマイヤー、ジャナルダン・アイエンガー、ムツヤ・イリー、ジョン・ヒーバート、カウザー・ハッサン、フレッド・ハスル、ダン・ハリソン、ジョン・グリム、ローレント・グロード、スティーブン・ファーニス、福本淳、藤田健、スティーブ・ディミグ、トーマスカラン、セルカンシル、メリッサキャンベル、ピーターバトラー、ロブブレナン、ハーシュボンドウェ、ブライアンビデュロック、ケイトリンベストラー、ジョンバーガー、Robby Benedyk、Stephen Baucke、Sandeep Balani、Ronnie Sellar. 

Mark Allmanに特に感謝します. MarkAllmanは、実際にはmax-burstに関する彼の研究の共著者である必要がありますが、専門性のためになんとか揺れ動きました. また、Lyndon OngとPhil Conradの貴重な意見と多くの貢献に謝意を表します. 

そして最後に、あなたはこのドキュメントを持っています、そしてアルフレッド・ホーネスとロニー・セラーズを含むそれにコメントした人々があります. 

このドキュメントのコーディング、テスト、および更新のプロセスに参加したすべての人に、感謝の気持ちを十分に表すことはできません. 私が言えることは、ありがとうございます！

Randall Stewart-エディター

付録A.明示的な輻輳通知
ECN [RFC3168]は、IPへの提案された拡張機能について説明しており、データグラム損失の外で輻輳を認識できるようにする方法を詳しく説明しています. これは、実装がSCTPに追加することを選択できるオプション機能です. この付録では、実装者がこの機能を実装することを選択した場合に知っておく必要がある小さな違いについて詳しく説明します. 一般に、[RFC3168]は以下の例外を除いて従うべきです. 

ネゴシエーション：

[RFC3168]は、TCP接続のSYNおよびSYN-ACKステージ中のECNのネゴシエーションについて詳しく説明しています. SYNの送信側はTCPフラグに2ビットを設定し、SYN-ACKの送信側は1ビットのみを設定します. この背後にある理由は、両側が本当にECN対応であることを保証することです. SCTPの場合、これは必要ありません. エンドポイントがECN対応であることを示すために、エンドポイントはECN用に予約されたTLVをINITまたはINIT ACKチャンクに追加する必要があります（SHOULD）. このTLVにはパラメーターが含まれていないため、次の形式になります. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | パラメータタイプ= 32768 | パラメータの長さ= 4 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
ECN-Echo：

[RFC3168]は、ネットワークから到着したCongestion Experienced（CE）ビットを送信者に通知するために、TCP確認応答で受信者が送り返す特定のビットの詳細を示しています. SCTPの場合、ECNEチャンクを含めることでこれと同じ指示が行われます. このチャンクには1つのデータ要素、つまり、CEビットでマークされたIPデータグラムにassociationられた最小のTSNが含まれ、次のようになります. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | チャンクタイプ= 12 | Flags = 00000000 | チャンク長= 8 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 最小のTSN番号|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
注：ECNEは制御チャンクと見なされます. 

CWR：

[RFC3168]は、次の発信TCPセグメントのヘッダーで送信者が送信する特定のビットの詳細を示し、Congestion windowが減少したことをピアに示します. これはCWRビットと呼ばれます. SCTPの場合、CWRチャンクを含めることによって同じ指示が行われます. このチャンクには、1つのデータ要素、つまりECNEチャンクで送信されたTSN番号が含まれています. この要素は、最初にCEビットでマークされたデータグラムの最小TSN番号を表します. 

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | チャンクタイプ= 13 | Flags = 00000000 | チャンク長= 8 |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
       | 最小のTSN番号|
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
注：CWRは制御チャンクと見なされます. 

付録B. CRC32cチェックサムの計算
「反映された値」を、マシンの通常のビット順序とは逆の値として定義します. 32ビットCRC（巡回冗長検査）はCRC32cの説明に従って計算され、多項式コード0x11EDC6F41（Castagnoli93）またはx ^ 32 + x ^ 28 + x ^ 27 + x ^ 26 + x ^ 25 + x ^ 23 +を使用しますx ^ 22 + x ^ 20 + x ^ 19 + x ^ 18 + x ^ 14 + x ^ 13 + x ^ 11 + x ^ 10 + x ^ 9 + x ^ 8 + x ^ 6 + x ^ 0. CRCは、ETHERNET CRC [ITU32]と同様の手順を使用して計算され、トランスポートレベルの使用を反映するように変更されます. 

CRC計算は多項式除算を使用します. メッセージのビット文字列Mは多項式M（X）に変換され、CRは多項式演算を使用してM（X）から計算されます. 

CRCがリンク層で使用される場合、多項式はオンザワイヤーのビット順序から導出されます. 「ワイヤー上の」最初のビットは高次係数です. SCTPはトランスポートレベルのプロトコルであるため、実際のシリアルメディアのビット順序を知ることはできません. さらに、SCTPエンドポイント間のパスの異なるリンクは、異なるリンクレベルのビットオーダーを使用する場合があります. 

したがって、CRC計算のためにSCTPトランスポートメッセージを多項式にマッピングするための規則を確立する必要があります. SCTPメッセージを多項式にマッピングするためのビットの順序付けでは、バイトが最初に最上位に取られますが、各バイト内ではビットが最下位に取られます. メッセージの最初のバイトは、8つの最高係数を提供します. 各バイト内で、最下位のSCTPビットはそのバイト内の最上位の多項式係数を提供し、最上位のSCTPビットはそのバイト内の最下位の多項式係数です. （このビット順序は、「ミラーリング」または「反射」と呼ばれることもあります. [WILLIAMS93]）CRC多項式は、一貫したマッピングを使用して、SCTPトランスポートレベルのバイト値に変換されます. 

SCTPトランスポートレベルのCRC値は、次のように計算する必要があります. 

-CRC入力データは、0からN-1までの番号が付けられたバイトストリームに割り当てられます. 

-トランスポートレベルのバイトストリームは、多項式値にマップされます. 0からN-1までの番号が付けられたjバイトのNバイトPDUは、次数8N-1の多項式M（x）の係数と見なされます. バイトjのビット0は係数x ^（8（Nj）-8）です. バイトjのビット7は係数x ^（8（Nj）-1）です. 

-CRC剰余レジスタはすべて1で初期化され、CRCはx ^ 32を同時に乗算してCRC多項式で除算するアルゴリズムで計算されます. 

-多項式はx ^ 32で乗算され、生成多項式G（x）で除算され、31以下の次数の剰余R（x）を生成します. 

-R（x）の係数は32ビットシーケンスと見なされます. 

-ビットシーケンスが補完されます. 結果はCRC多項式です. 

-CRC多項式はSCTPトランスポートレベルのバイトにマップされます. 係数x ^ 31はSCTPバイト0のビット7の値を与え、x ^ 24の係数はバイト0のビット0の値を与えます. x^ 7の係数はバイト3のビット7を与え、係数x ^ 0のバイト3のビット0が得られます. 結果の4バイトのトランスポートレベルシーケンスは、32ビットのSCTPチェックサム値です. 

実装に関する注：CRCに関する標準文書、教科書、ベンダーの資料は、多くの場合、代替の定式化に従います. この場合、長分割アルゴリズムの残りの部分を保持するために使用されるレジスタは、すべて1ではなくゼロに初期化され、代わりに最初の32ビットが初期化されます. メッセージの補足されます. この定式化で使用される長除算アルゴリズムは、2 ^ 32による初期乗算と長除算が1つの同時演算に結合されるように指定されています. このようなアルゴリズム、および64ビットより長いメッセージの場合、2つの仕様はまったく同じです. この同等性は、このドキュメントの目的です. 

SCTPの実装者は、両方の仕様が文献に記載されており、場合によっては長分割アルゴリズムに制限がないことを警告しています. このドキュメントでの公式の選択は、SCTP以外の使用を許可することです. この場合、同じCRCアルゴリズムを使用して、64ビットより短いメッセージを保護できます. 

チェックサムを実行する前に、Verification Tagに対してアソシエーションを検証することには、計算上の利点があります. 無効なタグは、ほとんどの場合、不正なチェックサムと同じアクションになるためです. この手法の例外は、INITといくつかのSHUTDOWN-COMPLETE交換、および古いCOOKIE ECHOです. これらの特別な場合の交換は小さなパケットを表す必要があり、チェックサム計算の影響を最小限に抑えます. 

付録C. ICMP処理
ICMPメッセージがSCTPエンドポイントによって受信されるときはいつでも、レイヤー3によって提供されている情報の適切な利用を確実にするために、次の手順に従う必要があります. 

ICMP1）実装は、typeフィールドが "Destination Unreachable"に設定されていないすべてのICMPv4メッセージを無視してもよい（MAY）. 

ICMP2）実装は、typeフィールドが「Destination Unreachable」、「Parameter Problem」、または「Packet Too Big」ではないすべてのICMPv6メッセージを無視してもよい（MAY）. 

ICMP3）コードが「Protocol Unreachable」または「Fragmentation Needed」を示さない場合、実装はICMPv4メッセージを無視してもよい（MAY）. 

ICMP4）コードが「Unrecognized Next Header Type Encountered」でない場合、実装はタイプ「Parameter Problem」のすべてのICMPv6メッセージを無視してもよい（MAY）. 

ICMP5）実装では、ICMPメッセージ（v4またはv6）のペイロードを使用して、ICMPが応答しているメッセージを送信したassociationを特定する必要があります. associationが見つからない場合、実装はICMPメッセージを無視する必要があります（SHOULD）. 

ICMP6）実装は、ICMPメッセージに含まれるVerification TagがピアのVerification Tagと一致することを検証する必要があります. Verification Tagが0ではなく、一致しない場合は、ICMPメッセージを破棄します. 0であり、ICMPメッセージに十分なバイトが含まれている場合は、チャンクタイプがINITチャンクであり、開始タグがピアのタグと一致することを確認するには、ICMP7に進みます. ICMPメッセージが短すぎるか、チャンクのタイプまたは開始タグが一致しない場合は、暗黙的にパケットを破棄します. 

ICMP7）ICMPメッセージがv6 "Packet Too Big"またはv4 "Fragmentation Needed"のいずれかである場合、実装は、PATH MTUディスカバリー用に定義されているようにこの情報を処理できます（MAY）. 

ICMP8）ICMPコードが「Unrecognized Next Header Type Encountered」または「Protocol Unreachable」の場合、INITチャンクが含まれていない場合、実装はこのメッセージをTビットが設定されたアボートとして扱う必要があります. INITチャンクが含まれていて、associationがCOOKIE-WAIT状態にある場合は、ICMPメッセージをABORTのように処理します. 

ICMP9）ICMPv6コードが "Destination Unreachable"の場合、実装は宛先を到達不能状態にマークするか、パスエラーカウンターをインクリメントできます（MAY）. 

これらの手順は[RFC1122]とは異なり、ポート到達不能メッセージの処理の要件や、実装が「プロトコル到達不能」メッセージに応答してassociationを中止しなければならない（MUST）要件とは異なることに注意してください. 実装はポート到達不能ではなくABORTを送信するため、ポート到達不能メッセージは処理されません. 「プロトコル到達不能」メッセージのより厳密な処理は、SCTPをサポートしていないホストのセキュリティ上の問題によるものです. 

次の非規範的なサンプルコードは、「ミラーリング」技術を使用して、それぞれ32ビット幅の256エントリのSCTP CRC32cのルックアップテーブルを生成するオープンソースCRCジェネレータ[WILLIAMS93]から取得されます. ソフトウェアテーブルルックアップCRCが進むにつれて、特に低速でも高速でもありませんが、同じ（ホスト順）ルックアップテーブルを使用し、定義済みのntohlのみを使用して、ビッグエンディアンとリトルエンディアンの両方のCPUで作業できるという利点があります.  （）およびhtonl（）操作. コードは[WILLIAMS93]から多少変更され、ビッグエンディアンとリトルエンディアンのアーキテクチャ間の移植性を確保しています. （ターゲットアーキテクチャのバイトエンディアンがリトルエンディアンであることがわかっている場合は、最終的なビット反転とバイト反転のステップを1つの操作にまとめることができます. ）

   / ************************************************* ************ /
   / *ロスウィリアムステーブルジェネレーターのメモ定義は* /
   / *する：TB_WIDTH = 4、TB_POLLY = 0x1EDC6F41、TB_REVER = TRUE * /
   / *ウィリアムズ氏の直接計算コードの場合、設定を使用します* /
   / * cm_width = 32、cm_poly = 0x1EDC6F41、cm_init = 0xFFFFFFFF、* /
   / * cm_refin = TRUE、cm_refot = TRUE、cm_xorort = 0x00000000 * /
   / ************************************************* ************ /
        
   / * crcテーブルファイルの例* /
   #ifndef __crc32cr_table_h__
   #define __crc32cr_table_h__
        
   #define CRC32C_POLY 0x1EDC6F41
   #define CRC32C（c、d）（c =（c >> 8）^ crc_c [（c ^（d））＆0xFF]）
        
unsigned long型crc_c [256] = {0x00000000L、0xF26B8303L、0xE13B70F7L、0x1350F3F4L、0xC79A971FL、0x35F1141CL、0x26A1E7E8L、0xD4CA64EBL、0x8AD958CFL、0x78B2DBCCL、0x6BE22838L、0x9989AB3BL、0x4D43CFD0L、0xBF284CD3L、0xAC78BF27L、0x5E133C24L、0x105EC76FL、0xE235446CL、0xF165B798L、0x030E349BL、0xD7C45070L、 0x25AFD373L、0x36FF2087L、0xC494A384L、0x9A879FA0L、0x68EC1CA3L、0x7BBCEF57L、0x89D76C54L、0x5D1D08BFL、0xAF768BBCL、0xBC267848L、0x4E4DFB4BL、0x20BD8EDEL、0xD2D60DDDL、0xC186FE29L、0x33ED7D2AL、0xE72719C1L、0x154C9AC2L、0x061C6936L、0xF477EA35L、0xAA64D611L、0x580F5512L、0x4B5FA6E6L、0xB93425E5L、0x6DFE410EL、0x9F95C20DL、 0x8CC531F9L、0x7EAEB2FAL、0x30E349B1L、0xC288CAB2L、0xD1D83946L、0x23B3BA45L、

0xF779DEAEL、0x05125DADL、0x1642AE59L、0xE4292D5AL、0xBA3A117EL、0x4851927DL、0x5B016189L、0xA96AE28AL、0x7DA08661L、0x8FCB0562L、0x9C9BF696L、0x6EF07595L、0x417B1DBCL、0xB3109EBFL、0xA0406D4BL、0x522BEE48L、0x86E18AA3L、0x748A09A0L、0x67DAFA54L、0x95B17957L、0xCBA24573L、0x39C9C670L、0x2A993584L、0xD8F2B687L、0x0C38D26CL、 0xFE53516FL、0xED03A29BL、0x1F682198L、0x5125DAD3L、0xA34E59D0L、0xB01EAA24L、0x42752927L、0x96BF4DCCL、0x64D4CECFL、0x77843D3BL、0x85EFBE38L、0xDBFC821CL、0x2997011FL、0x3AC7F2EBL、0xC8AC71E8L、0x1C661503L、0xEE0D9600L、0xFD5D65F4L、0x0F36E6F7L、0x61C69362L、0x93AD1061L、0x80FDE395L、0x72966096L、0xA65C047DL、0x5437877EL、 0x4767748AL、0xB50CF789L、0xEB1FCBADL、0x197448AEL、0x0A24BB5AL、0xF84F3859L、0x2C855CB2L、0xDEEEDFB1L、0xCDBE2C45L、0x3FD5AF46L、0x7198540DL、0x83F6A0L64C0LC0A60C64A0L64C0C0L60A60C60A0L60A60C60L600x5739B3E5L、0xA55230E6L、0xFB410CC2L、0x092A8FC1L、0x1A7A7C35L、0xE811FF36L、0x3CDB9BDDL、0xCEB018DEL、0xDDE0EB2AL、0x2F8B6829L、0x82F63B78L、0x709DB87BL、0x63CD4B8FL、0x91A6C88CL、0x456CAC67L、0xB7072F64L、0xA457DC90L、0x563C5F93L、0x082F63B7L、0xFA44E0B4L、0xE9141340L、0x1B7F9043L、0xCFB5F4A8L、0x3DDE77ABL、0x2E8E845FL、 0xDCE5075CL、0x92A8FC17L、0x60C37F14L、0x73938CE0L、0x81F80FE3L、0x55326B08L、0xA759E80BL、0xB4091BFFL、0x466298FCL、0x1871A4D8L、0xEA1A27DBL、0xF94AD42FL、0x0B21572CL、0xDFEB33C7L、0x2D80B0C4L、0x3ED04330L、0xCCBBC033L、0xA24BB5A6L、0x502036A5L、0x4370C551L、0xB11B4652L、0x65D122B9L、0x97BAA1BAL、0x84EA524EL、0x7681D14DL、 0x2892ED69L、0xDAF96E6AL、0xC9A99D9EL、0x3BC21E9DL、0xEF087A76L、0x1D63F975L、0x0E330A81L、0xFC588982L、0xB21572C9L、0x407EL60L16L16L16L16L16L16L16L0L016160x38CC2A06L、0xCAA7A905L、0xD9F75AF1L、0x2B9CD9F2L、0xFF56BD19L、0x0D3D3E1AL、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、 0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、 0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、 0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、 0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x1E6DCDEEL、0xEC064EEDL、0xC38D26C4L、0x31E6A5C7L、0x22B65633L、0xD0DDD530L、0x0417B1DBL、0xF67C32D8L、0xE52CC12CL、0x1747422FL、0x49547E0BL、0xBB3FFD08L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、 0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、 0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、 0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0xA86F0EFCL、0x5A04​​8DFFL、0x8ECEE914L、0x7CA56A17L、0x6FF599E3L、0x9D9E1AE0L、0xD3D3E1ABL、0x21B862A8L、0x32E8915CL、0xC083125FL、0x144976B4L、0xE622F5B7L、0xF5720643L、0x07198540L、0x590AB964L、0xAB613A67L、0xB831C993L、0x4A5A4A90L、0x9E902E7BL、0x6CFBAD78L、0x7FAB5E8CL、0x8DC0DD8FL、0xE330A81AL、0x115B2B19L、0x020BD8EDL、 0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、0x020BD8EDL、0xF0605BEEL、0x24AA3F05L、0xD6C1BC06L、0xC5914FF2L、0x37FACCF1L、0x69E9F0D5L、0x9B8273D6L、0x88D28022L、0x7AB90321L、0xAE7367CAL、0x5C18E4C9L、0x4F48173DL、0xBD23943EL、0xF36E6F75L、0x0105EC76L、0x12551F82L、0xE03E9C81L、

0x34F4F86AL、0xC69F7B69L、0xD5CF889DL、0x27A40B9EL、0x79B737BAL、0x8BDCB4B9L、0x988C474DL、0x6AE7C44EL、0xBE2DA0A5L、0x4C4623A6L、0x5F16L5

#endif

    / *テーブル作成ルーチンの例* /
        
   #include <stdio.h>
   #include <stdlib.h>
        
   #define OUTPUT_FILE "crc32cr.h"
   #define CRC32C_POLY 0x1EDC6F41L
   ファイル* tf;
   署名なしlong
   Reflect_32（符号なしlong b）
   {
     int i;
     unsigned long rw = 0L;
        
     for（i = 0; i <32; i ++）{
         if（b＆1）
           rw | = 1 <<（31-i）;
        
         b >> = 1;
     }
     リターン（rw）;
   }
        
   署名なしlong
   build_crc_table（intインデックス）
   {
     int i;
     unsigned long rb;
        
     rb = Reflect_32（インデックス）;
        
     for（i = 0; i <8; i ++）{
         if（rb＆0x80000000L）
          rb =（rb << 1）^ CRC32C_POLY;
         そうしないと
          rb << = 1;
     }
     return（reflect_32（rb））;
   }
        
   メイン（）
   {
     int i;
        
     printf（ "\ nCRC-32cテーブルファイル<％s>を生成しています\ n"、
     OUTPUT_FILE）;
     if（（tf = fopen（OUTPUT_FILE、 "w"））== NULL）{
         printf（ "％sを開けません\ n"、OUTPUT_FILE）;
         出口（1）;
     }
     fprintf（tf、 "#ifndef __crc32cr_table_h __ \ n"）;
     fprintf（tf、 "#define __crc32cr_table_h __ \ n \ n"）;
     fprintf（tf、 "#define CRC32C_POLY 0x％08lX \ n"、
     CRC32C_POLY）;
     fprintf（tf、
     "#define CRC32C（c、d）（c =（c >> 8）^ crc_c [（c ^（d））＆0xFF]）\ n"）;
     fprintf（tf、 "\ nunsigned long crc_c [256] = \ n {\ n"）;
     for（i = 0; i <256; i ++）{
         fprintf（tf、 "0x％08lXL、"、build_crc_table（i））;
         if（（i＆3）== 3）
           fprintf（tf、 "\ n"）;
     }
     fprintf（tf、 "}; \ n \ n＃endif \ n"）;
        
     if（fclose（tf）！= 0）
       printf（ "<％s>を閉じることができません. " OUTPUT_FILE）;
        
     そうしないと
       printf（ "\ nCRC-32cテーブルが<％s>に書き込まれました. \ n"、
         OUTPUT_FILE）;
   }
        
   / * crc挿入の例* /
        
#include "crc32cr.h"

   署名なしlong
   generate_crc32c（unsigned char * buffer、unsigned int length）
   {
     unsigned int i;
     unsigned long crc32 =〜0L;
     符号なしの長い結果. 
     符号なしcharバイト0、バイト1、バイト2、バイト3;
        
     for（i = 0; i <長さ; i ++）{
         CRC32C（crc32、buffer [i]）;
     }
        
     結果=〜crc32;
        
     / *結果は否定された多項式剰余を保持するようになりました. 
      *テーブルとアルゴリズムが「反映」されているため[williams95]. 
      *つまり、結果はメッセージをマッピングした場合と同じ値になります
      *多項式へ、ホストビットオーダー多項式を計算
      *残り、最後の否定を実行し、その後エンドツーエンドを実行
      *ビット反転. 
      * 32ビットのビット反転は4つのインプレースと同じであることに注意してください
      * 8ビットの反転と、それに続くエンドツーエンドのバイトスワップ. 
      *言い換えると、各ビットのバイトは正しい順序にあり、
      *ただし、バイトはバイトスワップされています. したがって、明示的に
      *バイトスワップ. リトルエンディアンマシンでは、このバイトスワップと
      *最後のntohlはキャンセルされ、省略される可能性があります. 
      * /
        
     byte0 =結果＆0xff;
     byte1 =（result >> 8）＆0xff;
     byte2 =（result >> 16）＆0xff;
     byte3 =（result >> 24）＆0xff;
     crc32 =（（byte0 << 24）|
              （バイト1 << 16）|
              （バイト2 << 8）|
              バイト3）;
     return（crc32）;
   } int
   insert_crc32（unsigned char * buffer、unsigned int length）
   {
     SCTP_message * message;
     署名されていない長いcrc32;
     メッセージ=（SCTP_message *）バッファー;
     message-> common_header.checksum = 0L;
     crc32 = generate_crc32c（バッファ、長さ）;
     / *そしてそれをメッセージに挿入します* /
     message-> common_header.checksum = htonl（crc32）;
     1を返します. 
   }
        
   int
   validate_crc32（unsigned char * buffer、unsigned int length）
   {
     SCTP_message * message;
     unsigned int i;
     unsigned long original_crc32;
     unsigned long crc32 =〜0L;
        
     / *チェックサムを保存してゼロにする* /
     メッセージ=（SCTP_message *）バッファー;
     original_crc32 = ntohl（message-> common_header.checksum）;
     message-> common_header.checksum = 0L;
     crc32 = generate_crc32c（バッファ、長さ）;
     return（（ori​​ginal_crc32 == crc32）？1：-1）;
   }
        
参考文献

規範的な参考文献

[ITU32]「ITU-T勧告V.42、「非同期から同期への変換を使用したDCEのエラー修正手順」」、ITU-Tセクション8.1.1.6.2. 

[RFC0768] Postel、J. 、「User Datagram Protocol」、STD 6、RFC 768、1980年8月. 

[RFC0793] Postel、J. 、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月. 

[RFC1122] Braden、R. 、編、「インターネットホストの要件-通信層」、STD 3、RFC 1122、1989年10月. 

[RFC1123] Braden、R. 、編、「インターネットホストの要件-アプリケーションとサポート」、STD 3、RFC 1123、1989年10月. 

[RFC1191] Mogul、J. およびS. Deering、「Path MTU discovery」、RFC 1191、1990年11月. 

[RFC1981] McCann、J.、Deering、S. 、およびJ. Mogul、「Path MTU Discovery for IP version 6」、RFC 1981、1996年8月. 

[RFC1982] Elz、R. およびR. Bush、「Serial Number Arithmetic」、RFC 1982、1996年8月. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

[RFC2434] Narten、T. およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月. 

[RFC2460] Deering、S. およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月. 

[RFC2581] Allman、M.、Paxson、V. 、およびW. Stevens、「TCP Congestion Control」、RFC 2581、1999年4月. 

[RFC3873]牧師、J. およびM. Belinchon、「ストリーム制御伝送プロトコル（SCTP）管理情報ベース（MIB）」、RFC 3873、2004年9月. 

[RFC4291] Hinden、R. およびS. Deering、「IPバージョン6アドレッシングアーキテクチャ」、RFC 4291、2006年2月. 

[RFC4301] Kent、S. およびK. Seo、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、2005年12月. 

[RFC4303]ケントS. 、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、2005年12月. 

[RFC4306] Kaufman、C. 、編、「インターネットキーエクスチェンジ（IKEv2）プロトコル」、RFC 4306、2005年12月. 

[RFC4821] Mathis、M. およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、2007年3月. 

参考情報

[FALL96]秋、K. およびS.フロイド、「シミュレーションに基づくタホ、リノ、およびSACK TCPの比較」、SIGCOMM'99 V. 26 N. 3 pp 5- 21、1996年7月. 

[SAVAGE99] Savage、S.、Cardwell、N.、Wetherall、D. 、およびT. Anderson、「誤動作レシーバーによるTCP輻輳制御」、ACM Computer Communications Review 29（5）、1999年10月. 

[ALLMAN99] Allman、M.、V. Paxson、「On-Estimating End-to-End Network Path Properties」、SIGCOMM'99、1999. 

[WILLIAMS93]ウィリアムズ、R. 、「CRCエラー検出アルゴリズムの無痛ガイド」、インターネット出版、http：//www.geocities.com/SiliconValley/Pines/ 8659 / crc.htm、1993年8月. 

[RFC0813]クラークD. 、「TCPにおけるウィンドウと確認応答の戦略」、RFC 813、1982年7月. 

[RFC1858] Ziemba、G.、Reed、D. 、およびP. Traina、「IPフラグメントフィルタリングのセキュリティに関する考慮事項」、RFC 1858、1995年10月. 

[RFC2104] Krawczyk、H.、Bellare、M. 、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月. 

[RFC2196] Fraser、B. 、「Site Security Handbook」、FYI 8、RFC 2196、1997年9月. 

[RFC2522] Karn、P. およびW. Simpson、「Photuris：Session-Key Management Protocol」、RFC 2522、1999年3月. 

[RFC2960]スチュワート、R. 、シェ、Q. 、モーノー、K. 、シャープ、C. 、シュワルツバウアー、H. 、テイラー、T. 、リティナ、I. 、カラ、M. 、チャン、L.、V . Paxson、「Stream Control Transmission Protocol」、RFC 2960、2000年10月. 

[RFC3309] Stone、J.、Stewart、R. 、およびD. Otis、「Stream Control Transmission Protocol（SCTP）Checksum Change」、RFC 3309、2002年9月. 

[RFC3168]ラマクリシュナン、K. 、フロイド、S. 、およびD.ブラック、「IPへの明示的輻輳通知（ECN）の追加」、RFC 3168、2001年9月. 

[RFC4086] Eastlake、D.、3rd、Schiller、J. 、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月. 

[RFC4460] Stewart、R.、Arias-Rodriguez、I.、Poon、K.、Caro、A. 、およびM. Tuexen、「Stream Control Transmission Protocol（SCTP）Specification Errata and Issues」、RFC 4460、2006年4月. 

[RFC4895] Tuexen、M.、Stewart、R.、Lei、P. 、およびE. Rescorla、「Authenticated Chunks for Stream Control Transmission Protocol（SCTP）」、RFC 4895、2007年8月. 

編集者の住所

ランドールR.スチュワート4875フォレストドライブスイート200コロンビア、SC 29206 US

メール：rrs@cisco.com

完全な著作権表示

Copyright（C）IETF Trust（2007）. 

このドキュメントはBCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します. 

このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代表者、または（もしあれば）組織、インターネット社会、IETFトラスト、およびインターネットエンジニアリングタスクフォースはすべてを否認します. 明示または黙示を問わず、ここに含まれる情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを保証するものではありません. 

知的財産

IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるまたは適用されない範囲に関して、いかなる立場も取らない. 利用できる; また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません. RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています. 

IETF事務局に対して行われたIPR開示のコピー、および使用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによる一般ライセンスまたはそのような所有権の使用許可を得ようとした試みの結果を取得できます.  http://www.ietf.org/iprのIETFオンラインIPRリポジトリから. 

IETFは、この規格の実装に必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、利害関係者に呼びかけます. IEETのietf-ipr@ietf.orgに情報を送信してください. 