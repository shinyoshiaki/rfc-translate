RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
4585
RFC 4585-リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック（RTP / AVPF）日本語訳の拡張RTPプロファイル
URL : https://tools.ietf.org/html/rfc4585
タイトル : RFC 4585 - Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)
翻訳編集 : 自動生成
ネットワークワーキンググループJ.オット
コメントのリクエスト：4585ヘルシンキ工科大学
カテゴリ：標準化過程S.ウェンガー
                                                                   ノキア
                                                                 N. Sato
                                                                     Oki
                                                           C.バーマイスター
                                                                  J.レイ
                                                              Matsushita
                                                               2006年7月
        
リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック（RTP / AVPF）用の拡張RTPプロファイル

このメモのステータス

このドキュメントは、インターネットコミュニティのインターネット標準追跡プロトコルを指定し、改善のための議論と提案を要求します. このプロトコルの標準化の状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください. このメモの配布は無制限です. 

著作権表示

Copyright（C）The Internet Society（2006）. 

概要

RTPを使用するリアルタイムメディアストリームは、パケット損失に対してある程度回復力があります. 受信者は、リアルタイムトランスポートコントロールプロトコル（RTCP）の基本メカニズムを使用して、パケット受信統計を報告し、送信者が中期的に送信動作を適応できるようにすることができます. これは、フィードバックおよびフィードバックベースのエラー修復のための唯一の手段です（いくつかのコーデック固有のメカニズムを除く）. このドキュメントでは、視聴覚プロファイル（AVP）の拡張機能を定義します. これにより、受信者は統計的により迅速なフィードバックを送信者に提供できるため、短期間の適応と効率的なフィードバックベースの修復メカニズムを実装できます. この初期フィードバックプロファイル（AVPF）は、RTCPのAVP帯域幅の制約を維持し、大規模なグループへのスケーラビリティを維持します. 

目次

   1.はじめに.........................................................  ..... 3
      1.1. 定義................................................ 3
      1.2. 用語................................................ 5
   2.RTPおよびRTCPパケットフォーマットとプロトコルの動作............... 6
      2.1. RTP.................................................  ....... 6
      2.2. 基礎となるトランスポートプロトコル............................. 6
   3.RTCPフィードバックのルール......................................... 7
      3.1. 複合RTCPフィードバックパケット............................. 7
      3.2. アルゴリズムの概要.......................................... 8
      3.3. 動作モード......................................... 9
      3.4. 定義とアルゴリズムの概要........................ 11
      3.5. AVPFRTCPスケジューリングアルゴリズム............................ 14
           3.5.1. 初期化..................................... 15
           3.5.2. 早期フィードバック送信........................ 15
           3.5.3. 通常のRTCP送信.......................... 18
           3.5.4. その他の考慮事項............................... 19
      3.6. グループサイズに関する考慮事項.......................... 20
           3.6.1. ACKモード........................................... 20
           3.6.2. NACK Mode ..........................................20
      3.7. 決定ステップの要約................................. 22
           3.7.1. 一般的なヒント...................................... 22
           3.7.2. メディアセッション属性........................... 22
   4.SDPの定義..............................................  ..23
      4.1. プロファイルの識別.................................... 23
      4.2. RTCPフィードバック機能属性........................ 23
      4.3. RTCP帯域幅修飾子.................................. 27
      4.4. 例.................................................  .27
   5.AVPエンティティとAVPFエンティティの相互作用と共存.......... 29
   6.RTCPフィードバックメッセージのフォーマット............................... 31
      6.1. フィードバックメッセージの一般的なパケット形式................ 32
      6.2. Transport Layer Feedback Messages......................... 34
           6.2.1. Generic NACK ....................................... 34
      6.3. Payload-Specific Feedback Messages........................ 35
           6.3.1. 画像喪失表示（PLI）...................... 36
           6.3.2. スライス損失表示（SLI）........................ 37
           6.3.3. 参照画像選択表示（RPSI）...... 39
      6.4. アプリケーション層フィードバックメッセージ....................... 41
   7.早期フィードバックと輻輳制御.......................... 41
   8.セキュリティに関する考慮事項........................................ 42
   9.IANAの考慮事項............................................ 43
   10.謝辞.............................................. 47
   11.参考文献...............................................  ..... 48
      11.1. 規範的参考文献..................................... 48
      11.2. 有益な参考資料................................... 48
        
1.はじめに
RTPを使用するリアルタイムメディアストリームは、パケット損失に対してある程度回復力があります. RTP [1]は、受信者でメディアストリームを適切に再生するために、送信者に存在する順序とタイミングを復元するために必要なすべてのメカニズムを提供します. RTPはまた、すべての受信者からの全体的な受信品質に関する継続的なフィードバックを提供します. これにより、中期（数秒から数分程度）の送信者は、コーディングスキームと送信動作を観測されたネットワーク品質に適合させることができます. サービスの（QoS）. ただし、いくつかのペイロード固有のメカニズム[6]を除いて、RTPは、送信者がメディアストリームをすぐに修復できるようにするタイムリーなフィードバックを提供しません：再送信、遡及前方誤り訂正（FEC）制御、またはメディア固有のメカニズム一部のビデオコーデックの場合、

エラー回復力を改善するためにRTPで利用可能な現在のメカニズムには、オーディオ冗長コーディング[13]、ビデオ冗長コーディング[14]、RTPレベルFEC [11]、およびより堅牢なメディアストリーム送信に関する一般的な考慮事項[12]が含まれます. これらのメカニズムはプロアクティブに適用できます（これにより、特定のメディアストリームの帯域幅が増加します）. あるいは、ラウンドトリップ時間（RTT）が小さい十分に小さいグループでは、送信者は、上記のメカニズムおよび/またはメディアエンコーディング固有のアプローチを使用して、オンデマンドで修復を実行できます. 「小グループ」と「十分に小さいRTT」はどちらもアプリケーションに大きく依存することに注意してください. 

このドキュメントでは、2つの変更/追加によって[1]と[2]に基づいて最小限の制御で音声およびビデオ会議用に変更されたRTPプロファイルを指定します. まず、タイムリーなフィードバックを実現するために、初期RTCPメッセージの概念とアルゴリズムを許可します. 小さなマルチキャストグループでの低遅延フィードバック（および大きなマルチキャストグループでのフィードバックの内破を防ぐため）が導入されました. ポイントツーポイントのシナリオには特別な考慮が払われています. 次に、RTCPペイロードで送信するために、少数の汎用フィードバックメッセージと、コーデックおよびアプリケーション固有のフィードバック情報の形式が定義されています. 

1.1. 定義
RTP / RTCP [1]および「最小限の制御での音声およびビデオ会議のRTPプロファイル」[2]の定義が適用されます. さらに、このドキュメントでは次の定義が使用されています. 初期RTCPモード：メディアストリームの受信者が、関心のあるイベントを発生に近い送信者に報告できることが多い（常にではありません）動作モード. 初期RTCPモードでは、RTCPパケットは、このドキュメントで定義されているタイミングルールに従って送信されます. 

アーリーRTCPパケット：アーリーRTCPパケットは、[1]のスケジューリングアルゴリズムに従った場合に許可されるよりも早く送信されるパケットです. その理由は、受信者によって監視される「イベント」です. アーリーRTCPパケットは、イミディエイトフィードバックおよびアーリーRTCPモードで送信できます. このドキュメントでは、早期RTCPパケットの送信は、早期フィードバックの送信とも呼ばれます. 

イベント：送信者にとって（潜在的に）関心のあるメディアストリームの受信者によって行われた観測（パケット損失またはパケット受信、フレーム損失など）. したがって、送信者に報告するのに役立ちます. フィードバックメッセージによって. 

フィードバック（FB）メッセージ：このドキュメントで定義されているRTCPメッセージは、RTCPレシーバーレポート（RR）で伝送される長期のレシーバーステータス情報に加えて、レシーバーで観察されたイベントに関する情報をに戻すために使用されます. メディアストリームの送信者. わかりやすくするために、このドキュメントではフィードバックメッセージをFBメッセージと呼びます. 

フィードバック（FB）しきい値：FBしきい値は、即時フィードバックモードと早期RTCPモードの間の移行を示します. マルチパーティシナリオの場合、FBしきい値は、平均して、各受信者が各イベントを送信者にすぐに報告できる最大グループサイズを示します. つまり、EarlyRTCPパケットを使用して待機する必要はありません. 定期的にスケジュールされたRTCP間隔. このしきい値は、提供されるフィードバックのタイプ、ネットワークQoS（パケット損失の確率と分散など）、使用中のコーデックとパケット化スキーム、セッション帯域幅、およびアプリケーション要件に大きく依存します. アルゴリズムは、このしきい値の同じ値に同意するすべての送信者と受信者に依存しないことに注意してください. これは、アプリケーション設計者に概念的なガイダンスを提供することのみを目的としており、計算には使用されません. わかりやすくするために、このドキュメントでは、フィードバックしきい値という用語をFBしきい値と呼びます. 

即時フィードバックモード：メディアストリームの各受信者が、統計的に、関心のある各イベントをメディアストリームの送信者にすぐに報告できる操作モード. 即時フィードバックモードでは、RTCPFBメッセージはこのドキュメントで定義されているタイミングルールに従って送信されます. 

メディアパケット：メディアパケットはRTPパケットです. 

通常のRTCPモード：FBメッセージの優先送信が許可されていない動作モード. 代わりに、RTCPメッセージは[1]のルールに従って送信されます. それでも、このようなRTCPメッセージには、このドキュメントで定義されているフィードバック情報が含まれている場合があります. 

通常のRTCPパケット：初期RTCPパケットとして送信されないRTCPパケット. 

RTP送信者：RTP送信者は、メディアパケットとRTCPパケットを送信し、通常のRTCPパケットと初期のRTCP（フィードバック）パケットを受信するRTPエンティティです. RTP送信者は論理的な役割であり、同じRTPエンティティが同時にRTP受信者として機能する場合があることに注意してください. 

RTPレシーバー：RTPレシーバーは、メディアパケットとRTCPパケットを受信し、通常のRTCPパケットと初期のRTCP（フィードバック）パケットを送信するRTPエンティティです. RTP受信者は論理的な役割であり、同じRTPエンティティが同時にRTP送信者として機能する場合があることに注意してください. 

1.2. 用語
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです.  RFC 2119 [5]で説明されているように解釈されます. 

2.RTPおよびRTCPパケットフォーマットとプロトコルの動作
2.1. RTP
[2]で定義されているルールは、以下に記載されているルールを除いて、このプロファイルにも適用されます. 

RTCPパケットタイプ：2つの追加のRTCPパケットタイプが登録され、フィードバック情報を伝達するための対応するFBメッセージがこのメモのセクション6で定義されています. 

RTCPレポート間隔：このドキュメントでは、RTCPレポート間隔に影響を与える3つの操作モードについて説明します（このメモのセクション3.2を参照）. 通常のRTCPモードでは、同じRTPエンティティからの2つのRTCPレポート間の推奨される最小間隔である5秒を除いて、[1]のすべてのルールが適用されます. 即時フィードバックモードと初期RTCPモードの両方で、2つのRTCPレポート間の最小間隔5秒が削除され、さらに、FBメッセージを含むRTCPパケット（このメモのセクション4で定義）の場合、このメモのセクション3で指定されたルールが適用されます. 送信されます. 

[1]に記載されているルールは、さまざまなパラメータを指定するセッションの説明によって上書きされる場合があります（たとえば、送信者と受信者のRTCPにそれぞれ割り当てられた帯域幅の共有）. セッション記述プロトコル（SDP）[3]を使用して定義されたセッションには、[4]のルールが適用されます. 

輻輳制御：[2]で詳述されているのと同じ基本ルールが適用されます. これに加えて、セクション7では、フィードバックの影響とFBメッセージに対する送信者の反応についてさらに検討します. 

2.2. 基礎となるトランスポートプロトコル
RTPは、UDPやDatagram Congestion Control Protocol（DCCP）などの信頼性の低いトランスポートプロトコルの上で使用することを目的としています. このセクションでは、このメモで指定されているRTCPフィードバックによって導入されたプレーンRTP操作以外の詳細について簡単に説明します. 

UDP：UDPは、ポイントツーポイントおよびマルチキャスト通信用のデータグラムのベストエフォート配信を提供します. UDPは、輻輳制御またはエラー修復をサポートしていません. このメモで定義されているRTCPベースのフィードバックは、限定的なエラー修復の最小限のサポートを提供できます. RTCPフィードバックは十分に小さいタイムスケール（RTTのオーダー）で動作することが保証されていないため、RTCPフィードバックは輻輳制御をサポートするのに適していません. このメモは、ユニキャストとマルチキャストの両方の操作に対応しています. 

DCCP：DCCP [19]は、ユニキャスト通信用の輻輳制御されているが信頼性の低いデータグラムフローを提供します. TCPフレンドリーレートコントロール（TFRC）ベースの[20]輻輳制御（CCID 3）により、DCCPはオーディオおよびビデオ通信に特に適しています. DCCPの確認メッセージは、受信および欠落したデータグラム（したがって、輻輳）に関する詳細なフィードバックレポートを提供する場合があります. 

RTP over DCCPを実行する場合、輻輳制御はDCCP層で実行され、RTP層で追加のメカニズムは必要ありません. さらに、RTCPフィードバック対応の送信者は、より頻繁なDCCPベースのフィードバックを活用できるため、受信者は、必要に応じて（追加の）汎用フィードバックメッセージの使用を控えることができます. 

3.RTCPフィードバックのルール
3.1. 複合RTCPフィードバックパケット
このドキュメントで説明されているように、2つのコンポーネントがRTCPベースのフィードバックを構成します. 

oステータスレポートは、送信者レポート（SR）/受信レポート（RR）パケットに含まれ、複合RTCPパケット（ソース記述（SDES）および場合によっては他のメッセージも含む）の一部として定期的に送信されます. これらのステータスレポートは、メディアストリームの最近の受信品質の全体的な指標を提供します. 

oメディアストリームの特定の部分の損失または受信を示す（または受信したデータに関する他の形式のかなり即時のフィードバックを提供する）、このドキュメントで定義されているFBメッセージ. FBメッセージの送信規則は、このドキュメントで新たに導入されました. 

RTCP FBメッセージは、単なる別のRTCPパケットタイプです（セクション4を参照）. したがって、複数のFBメッセージを単一の複合RTCPパケットに結合することができ、それらは他のRTCPパケットと結合して送信することもできます. 

このドキュメントで定義されているFBメッセージを含む複合RTCPパケットには、[1]で定義されている順序でRTCPパケットが含まれている必要があります. 

o [1]のセクション9.1に従ってRTCPパケットを暗号化する場合に存在しなければならないオプションの暗号化プレフィックス. o必須のSRまたはRR. 

o必須SDES. CNAMEアイテムを含める必要があります. 他のすべてのSDESアイテムはオプションです. o1つ以上のFBメッセージ. 

FBメッセージは、[1]で定義されているRRおよびSDESRTCPパケットの後に複合パケットに配置する必要があります. 他のRTCP拡張に関する順序は定義されていません. 

このドキュメントでは、フィードバックパケットを伝送する2種類の複合RTCPパケットを使用しています. 

a）最小限の複合RTCPフィードバックパケット

最小限の複合RTCPフィードバックパケットには、上記の必須情報のみが含まれている必要があります. 必要に応じて暗号化プレフィックス、正確に1つのRRまたはSR、CNAMEアイテムのみが存在する正確に1つのSDES、およびFBメッセージ. これは、フィードバックを伝達するために送信されるRTCPパケットのサイズを最小化し、RTCP帯域幅の制限を遵守しながらフィードバックを提供できる頻度を最大化するためです. 

このパケット形式は、RTCPFBメッセージがEarlyRTCPパケットの一部として送信される場合は常に使用する必要があります. このドキュメントでは、このパケットタイプを最小複合RTCPパケットと呼びます. 

b）（完全な）複合RTCPフィードバックパケット

（完全な）複合RTCPフィードバックパケットには、追加の数のRTCPパケット（追加のRR、追加のSDESアイテムなど）が含まれる場合があります. 上記の注文規則を順守する必要があります. 

このパケット形式は、RTCPFBメッセージが通常のRTCPパケットの一部としてまたは通常のRTCPモードで送信される場合は常に使用する必要があります. また、即時フィードバックまたは早期RTCPモードでRTCPFBメッセージを送信するために使用される場合があります. このドキュメントでは、このパケットタイプを完全な複合RTCPパケットと呼びます. 

FBメッセージを含まないRTCPパケットは、非FBRTCPパケットと呼ばれます. このようなパケットは、[1]のフォーマット規則に従わなければなりません. 

3.2. アルゴリズムの概要
FBメッセージはRTCP制御ストリームの一部であるため、RTCP帯域幅の制約を受けます. これは、特に、受信者で観察されたイベントを送信者にすぐに報告できない可能性があることを意味します. ただし、送信者に提供されるフィードバックの価値は、通常、時間の経過とともに減少します. つまり、受信側でユーザーが認識するメディア品質や、メディアストリームの修復を実現するために必要なコストの観点からです. 

RTP [1]および一般的に使用されるRTPプロファイル[2]は、複合RTCPパケットを送信するタイミングのルールを指定します. このドキュメントでは、アプリケーションがイベント（RTPパケットの損失または受信など）をタイムリーに報告できるようにし、FBメッセージを使用するアルゴリズムに対応できるように、これらのルールを変更します. 

変更されたRTCP送信アルゴリズムの概要は次のとおりです. FBメッセージを送信する必要がない限り、複合RTCPパケットはRTPのルール[1]に従って送信されます. ただし、RTCPレポート間の5秒の最小間隔は施行. したがって、RTCPレポート間の間隔は、平均RTCPパケットサイズとRTP / RTCPエンティティで使用可能なRTCP帯域幅共有からのみ導出されます. オプションで、通常のRTCPパケット間の最小間隔を適用できます. 

受信者がFBメッセージを送信する必要性を検出した場合、次の通常のRTCPレポート間隔（上記の通常のRTCPアルゴリズムに従ってスケジュールされます）よりも早く送信する場合があります. フィードバック抑制は、マルチパーティセッションでのフィードバックの内破を回避するために使用されます. 受信者は、（短い）ランダムディザリング間隔を待機して、同じイベントを報告する他の受信者からの対応するFBメッセージを確認します. ポイントツーポイントセッションの場合、そのような遅延はないことに注意してください. 別のメンバーから対応するFBメッセージが受信された場合、この受信者はFBメッセージの送信を控え、通常のRTCP送信スケジュールに従い続けます. 受信者が他のメンバーからの対応するFBメッセージをまだ見ていない場合、受信者は早期フィードバックの送信が許可されているかどうかを確認します. 早期フィードバックの送信が許可されている場合、受信者は最小の複合RTCPパケットの一部としてFBメッセージを送信します. アーリーフィードバックを送信する許可は、このレシーバーによって送信された以前のRTCPパケットのタイプと、以前のアーリーフィードバックメッセージが送信された時刻によって異なります. 

FBメッセージは、完全な複合RTCPパケットの一部として送信することもできます. これらのパケットは、[1]（5秒の下限を除く）に従って定期的に送信されます. 

3.3. 動作モード
RTCPベースのフィードバックは、以下に説明する3つのモード（図1）のいずれかで動作します. 動作モードは、受信者が平均してすべてのイベントを送信者にタイムリーに報告できるかどうかを示すだけです. このモードは、FBメッセージの送信をスケジュールするために使用されるアルゴリズムには影響しません. 

また、受信品質とRTPセッションのローカルで監視されている状態によっては、個々の受信者が現在の動作モードに関する共通の認識に同意しない場合があります（同意する必要はありません）. 

a）即時フィードバックモード：このモードでは、グループサイズがFBしきい値を下回っています. これにより、各受信側は、意図した目的でRTCPフィードバックパケットを送信するのに十分な帯域幅を得ることができます. これは、各受信者に対して、事実上「即時の」RTCPフィードバックパケットを使用して各イベントを報告するのに十分な帯域幅があることを意味します. 

グループサイズのしきい値は、使用されるフィードバックのタイプ（ACKとNACKなど）、帯域幅、パケットレート、パケット損失の確率と分布、メディアタイプ、コーデックなど、さまざまなパラメータの関数です（必ずしもこれらに限定されません）.  、および報告するイベントの（最悪の場合または観察された）頻度（たとえば、フレームの受信、パケットの損失）. 

大まかな見積もりとして、Nを受信者が間隔Tごとに報告するイベントの平均数、Bをこの特定の受信者のRTCP帯域幅の割合、Rを平均RTCPパケットサイズとすると、受信者は次のように即時フィードバックモードで動作します.  N <= B * T / Rである限り. 

b）初期RTCPモード：このモードでは、グループサイズおよびその他のパラメーターにより、各レシーバーがレポートする価値のある（またはレポートが必要な）各イベントに反応できなくなります. ただし、フィードバックは十分な頻度で提供できるため、送信者はそれに応じてメディアストリームの送信を調整し、それによって全体的なメディア再生品質を向上させることができます. 

上記の表記法を使用すると、初期RTCPモードは、N> B * T / Rを「下限」として大まかに特徴付けることができます. 上限の見積もりはより困難です. N = 1に設定すると、特定のRとBについて、報告されるイベント間の平均間隔として間隔T = R / Bが得られます. この情報は、RTCPパケットの早期送信が有用かどうかを判断するためのヒントとして使用できます. 

c）通常のRTCPモード：一部のグループサイズ以上では、受信者からの個々のイベントにフィードバックを提供することはまったく役に立ちません-フィードバックを提供できる時間スケールのため、および/または大規模なグループでは送信者のため（s）個々のフィードバックに反応する機会はもうありません. 

このモードを開始する正確なグループサイズのしきい値を指定することはできませんが、明らかに、この境界は上記の項目b）で指定された早期RTCPモードの上限と一致します. 

このドキュメントで説明されているフィードバックアルゴリズムはスムーズにスケーリングされるため、グループ内のそれぞれのFBしきい値の正確な値について参加者間で合意する必要はありません. したがって、これらすべてのモード間の境界はソフトです. 

     ALAS
   フィードバック
     V
     ：<-------- NACKフィードバック--------> //
     :
     ：即時||
     ：フィードバックモード||初期RTCPモード通常のRTCPモード
     ：<=============> || <=============> // <============== ===>
     :               ||
    -+ --------------- || --------------- // -------------- ---->グループサイズ
     2               ||
      アプリケーション固有のFBしきい値
         = f（データレート、パケット損失、コーデック、...）
        
図1：動作モード

前に述べたように、それぞれのFBしきい値は、いくつかの技術パラメーター（コーデック、トランスポート、使用されるフィードバックのタイプなど）だけでなく、それぞれのアプリケーションシナリオにも依存します. セクション3.6は、これらのしきい値を推定する際のいくつかの有用なヒントを提供します（ただし、正確な計算はありません）. 

3.4. 定義とアルゴリズムの概要
以下の状態情報は、受信者ごとに維持する必要があります（主に[1]から取得）. すべての変数（以下の項目hを除く）は、各レシーバーで個別に計算されることに注意してください. したがって、それらのローカル値は任意の時点で異なる可能性があります. 

a）「送信者」をRTPセッションのアクティブな送信者の数とします. 

b）「メンバー」をRTPセッションの受信者数の現在の見積もりとします. 

c）tnとtpを、タイマーの再検討の前に計算された、次に（最後に）スケジュールされたRTCPRR送信の時間とします. 

d）[1]に従って、TminをRTCPパケット間の最小間隔とします. [1]とは異なり、最初のRTCPパケットを送信する前にグループサイズのサンプリングを可能にするために、最初のTminは1秒に設定されています. 最初のRTCPパケットが送信された後、Tminは0に設定されます. 

e）T_rrを、定期的にスケジュールされたRTCPパケットを送信した直後に、受信者が次の通常のRTCPパケットの送信をスケジュールする間隔とします. この値は、[1]のルールに従って取得されますが、このドキュメントで定義されているTminを使用します. T_rr= T（[1]で定義されている「計算された間隔」）、tn = tp +T. T_rrは常に最後の値を参照します. 計算されたTの（再検討またはtnを決定するため）. このドキュメントでは、T_rrは通常のRTCP間隔とも呼ばれます. 

f）t0を、報告されるイベントが受信者によって検出される時間とします. 

g）T_dither_maxを、マルチパーティセッションでの爆縮を防ぐためにRTCPフィードバックパケットをさらに遅延させることができる最大間隔とします. T_dither_maxの値は、T_rrに基づいて動的に計算されます（または、将来指定されるすべてのRTPレシーバーに共通の別のメカニズムを使用して導出される場合があります）. ポイントツーポイントセッション（つまり、ユニキャストストリーミングセッションなど、グループサイズに変更がない、メンバーが2つだけのセッション）の場合、T_dither_maxは0に設定されます. 

h）T_max_fb_delayを上限とし、イベントへのフィードバックを送信者に報告する必要があります. この値はアプリケーション固有であり、このドキュメントでは値は定義されていません. 

i）teをフィードバックパケットがスケジュールされる時間とします. 

j）T_fdを、時刻t0のイベントに応答するFBメッセージの送信の実際の（ランダム化された）遅延とします. 

k）allow_earlyを、次の定期的にスケジュールされたRTCP間隔tnの前に受信者が現在FBメッセージを送信できるかどうかを示すブール変数とします. この変数は、単一の受信機から送信されるフィードバックを調整するために使用されます. allow_earlyは、早期フィードバック送信後にFALSEに設定され、次の通常のRTCP送信が行われるとすぐにTRUEに設定されます. 

l）avg_rtcp_sizeを、[1]で定義されているRTCPパケットサイズの移動平均とします. 

m）T_rr_intervalを、通常のRTCPパケット間で使用されるオプションの最小間隔とします. T_rr_interval == 0の場合、この変数はRTCPフィードバックアルゴリズムの全体的な動作に影響を与えません. T_rr_interval！= 0の場合、次の通常のRTCPパケットは、最後の通常のRTCP送信後（つまり、tp + T_rr）にT_rrでスケジュールされません. 代わりに、次の通常のRTCPパケットは、最後の通常のRTCP送信後少なくともT_rr_intervalまで遅延されます. つまり、tp + T_rr_interval以降にスケジュールされます. T_rr_intervalはT_rrとtpの計算に影響を与えないことに注意してください. 代わりに、tp + T_rr_intervalの前に送信がスケジュールされている通常のRTCPパケットは、たとえばFBメッセージが含まれていない場合に抑制されます. 

注：T_rr_intervalを独立変数として提供することは、アプリケーションの必要に応じて通常のRTCPフィードバック（したがって帯域幅の消費）を最小限に抑えると同時に、より頻繁な初期RTCPパケットを使用してタイムリーなフィードバックを提供できるようにすることを目的としています. RTCP帯域幅の削減は早期フィードバックの頻度にも影響を与えるため、この目標はRTCP帯域幅全体を削減することでは達成できませんでした. 

n）t_rr_lastを、最後の通常のRTCPパケットがスケジュールされて送信された時点、つまりT_rr_intervalのために抑制されていない時点とします. 

o）T_retentionを、過去のFBメッセージがAVPFエンティティによって保存される時間枠とします. これは、フィードバックイベント自体に気付く前に、他のエンティティからFBメッセージを受信したエンティティに対してもフィードバック抑制が機能するようにするためです. T_retentionは少なくとも2秒に設定する必要があります. 

p）M * Tdを、（[1]で定義されているように）非アクティブと見なされるレシーバーのタイムアウト値とします. 

受信者で報告するイベントのフィードバック状況を以下の図2に示します. 時間ｔ０で、そのようなイベント（例えば、パケット損失）が受信機で検出される. 受信者は、現在の帯域幅、グループサイズ、およびその他のアプリケーション固有のパラメータに基づいて、FBメッセージを送信者に送り返す必要があると判断します. 

マルチパーティセッションでのフィードバックパケットの内破を回避するために、受信者はRTCPフィードバックパケットの送信をランダムな時間T_fd（[0、T_dither_max]の間隔で乱数が均等に分散される）だけ遅延させる必要があります. 次に、複合RTCPパケットの送信をte = t0 + T_fdにスケジュールする必要があります. 

T_dither_maxパラメーターは、通常のRTCP間隔T_rrから派生します. これは、グループサイズに基づいています. 将来のドキュメントでは、すべてのRTPレシーバーがT_dither_maxの計算に同じメカニズムを使用することが保証できる場合、T_dither_maxの他の計算（たとえば、RTTに基づく）も指定する可能性があります. 

特定のアプリケーションシナリオでは、受信者はFBメッセージの許容可能なローカル遅延の上限T_max_fb_delayを決定する場合があります. 事前推定またはT_dither_maxの実際の計算により、この上限に違反する可能性があることが示された場合（たとえば、T_dither_max> T_max_fb_delayのため）、達成可能なゲインが不十分であると見なされるため、受信者はフィードバックをまったく送信しないことを決定できます. 

アーリーRTCPパケットがスケジュールされている場合、次の通常のRTCPパケットのタイムスロットをそれに応じて更新して、後で新しいtn（tn = tp + 2 * T_rr）と新しいtp（tp = tp + T_rr）を設定する必要があります. これは、早期フィードバックで使用される短期平均RTCP帯域幅が、早期フィードバックなしで使用される帯域幅を超えないようにするためです. 

             イベントへ
             報告書
             検出されました
                |
                | RTCPフィードバック範囲
                | （T_max_fb_delay）
                vXXXXXXXXXXXXXXXXXXXXXXXXXXX））
   | --- + -------- + ------------- + ----- + ------------ | | -------- + --->
       |        |             |     |            ( (        |
       | t0 te |
       tp tn
                 \_______  ________/
                         \/
                   T_dither_max
        
図2：初期RTCPスケジューリングのイベントレポートとパラメーター

3.5. AVPFRTCPスケジューリングアルゴリズム
S0を（S個の送信者のうち）アクティブな送信者とし、Nを受信者の数とし、Rをこれらの受信者の1つとします. 

Rが、フィードバックメカニズムの使用が現在のコンステレーションで妥当であることを確認したと仮定します（これはアプリケーション固有であるため、このドキュメントでは指定されていません）. 

さらに、通常のRTCPパケット間の最小間隔を適用しない場合、またはT_rr_intervalがアプリケーションによって指定された意味のある値に設定されている場合は、T_rr_intervalが0であると想定します. この値は、通常のRTCPパケット間の最小間隔を示します. 

これにより、受信者Rは、1つ以上のFBメッセージを最小または完全な複合RTCPパケットとして送信するために、次のルールを使用する必要があります. 

3.5.1. 初期化
最初に、Rはallow_early = TRUEおよびt_rr_last = NaN（Not-a-Number、つまり、有効な時間と区別できる無効な値）を設定する必要があります. 

さらに、Tminの初期値を除いて、[1]によるRTCP変数の初期化が適用されます. ポイントツーポイントセッションの場合、初期Tminは0に設定されます. マルチパーティセッションの場合、Tminは1.0秒に初期化されます. 

3.5.2. 早期フィードバック送信
Rが最後の通常のRTCPRRパケットをtpで送信するようにスケジュールし（そしてこのパケットをtpで送信または抑制し）、tn = tp + T_rrの次の送信（[1]による再検討を含む）をスケジュールしたと仮定します. また、最後の通常のRTCPパケット送信がt_rr_lastで発生したと想定します. 

アーリーフィードバックアルゴリズムは、次の手順で構成されます. 

1.時刻t0で、Rは1つ以上のFBメッセージを送信する必要性を検出します. たとえば、メディアの「ユニット」をACKまたはNACKする必要があるため、フィードバック情報を提供することが送信者にとって潜在的に役立つことを発見します. 

2. Rは最初に、送信がスケジュールされた1つ以上のFBメッセージを含む複合RTCPパケットがすでに存在するかどうかを確認します（早期または通常のRTCPパケットとして）. 

2a）その場合、新しいFBメッセージをスケジュールされたパケットに含める必要があります. 待機中の複合RTCPパケットのスケジューリングは変更しないでおく必要があります. その際、利用可能なフィードバック情報をマージして、FBメッセージをできるだけ少なくする必要があります. これで、すぐに実行するアクションのコースが完了します. 

2b）複合RTCPパケットの送信がまだスケジュールされていない場合は、新しい（最小または完全な）複合RTCPパケットを作成する必要があり、T_dither_maxの最小間隔を次のように選択する必要があります. 

i）セッションがポイントツーポイントセッションの場合、

T_dither_max = 0. 

ii）セッションがマルチパーティセッションの場合、

T_dither_max = l * T_rr

l = 0.5の場合. 

T_dither_maxの値は、異なる方法で計算される場合があります（たとえば、RTTに基づいて）. これは、将来のドキュメントで指定する必要があります. このような将来の仕様では、すべてのRTPレシーバーが同じメカニズムを使用してT_dither_maxを計算する必要があります. 

上記のT_dither_maxの値は、最小値です. アプリケーション固有のフィードバックを考慮すると、T_dither_maxをこの値を超えて増やす価値がある場合があります. これは、実装者の裁量に任されています. 

3.次に、Rは、次の通常のRTCPパケットがt0でトリガーされた初期RTCPパケットの時間範囲内にあるかどうか、つまりt0 + T_dither_max> tnであるかどうかを確認する必要があります. 

3a）その場合、早期RTCPパケットをスケジュールしてはなりません. 代わりに、FBメッセージは、tnにスケジュールされた通常のRTCPパケットに含まれるように保存する必要があります. これで、すぐに実行するアクションのコースが完了します. 

3b）それ以外の場合は、次の手順が実行されます. 

4. Rは、Early RTCPパケットの送信が許可されているかどうか、つまりallow_early == TRUEかどうかを確認する必要があります. 

4a）allow_early == FALSEの場合、Rは次にスケジュールされた通常のRTCPパケットの時間をチェックする必要があります. 

1. tn --t0 <T_max_fb_delayの場合、レポートが遅れても、フィードバックは送信者にとって引き続き役立つ可能性があります. したがって、Rは、tnで送信するために通常のRTCPパケットに含まれるRTCPFBメッセージを作成してもよい[MAY]. 

2.それ以外の場合、RはRTCPFBメッセージを破棄する必要があります. 

これで、実行するアクションの即時コースが完了します. 

4b）allow_early == TRUEの場合、Rはte = t0 + RND * T_dither_maxの早期RTCPパケットをスケジュールする必要があります. RNDは、0と1の間で均等に分散される疑似ランダム関数です. 

5. Rは、RTPセッションの他のメンバーから受信したFBメッセージとRが送信したいFBメッセージの重複を検出する必要があります. したがって、RTPセッションのメンバーである間、Rは（最小の）複合RTCPパケットの到着を継続的に監視し、これらのRTCPパケットに含まれる各FBメッセージを少なくともT_retentionの間保存する必要があります. 上記のステップ1から4に従って独自のFBメッセージの送信をスケジュールする場合、Rは、間隔[t0 --T_retention; te]そして次のように行動します：

5a）Rが受信したFBメッセージのセマンティクスを理解し、メッセージの内容がRが送信したいフィードバックのスーパーセットである場合、Rは自身のFBメッセージを破棄し、tnの次の通常のRTCPパケット送信を再スケジュールする必要があります（前に計算したとおり） ）. 

5b）Rが受信したFBメッセージのセマンティクスを理解し、メッセージの内容がRが送信したいフィードバックのスーパーセットではない場合、Rはスケジュールどおりに独自のFBメッセージを送信する必要があります. 送信するフィードバック情報と受信したフィードバック情報の間に重複がある場合、送信されるフィードバックの量は最大Rです. RMはフィードバック情報を変更せずに送信することができます. RMは、自身のフィードバックとの間の冗長性を排除することもできます. 他のセッションメンバーからこれまでに受け取ったフィードバック. 

5c）Rが受信したFBメッセージのセマンティクスを理解しない場合、Rは自身のFBメッセージを早期RTCPパケットとしてスケジュールしたままにするか、Rは次の通常のRTCPパケット送信をtn（前に計算）に再スケジュールし、現在定期的にスケジュールされているRTCPメッセージへのFBメッセージ. 

注：5c）では、不明なFBメッセージを受信して​​も、特定の受信者でフィードバックが抑制されない場合があります. 結果として、特定のイベントにより、M個の異なるタイプのFBメッセージ（すべて適切であるが相互に理解されていない）がスケジュールされる可能性があり、その結果、「大きな」受信者グループは最大M個のグループに効果的に分割されます. これらのMグループのそれぞれのメンバー間で、フィードバック抑制は5aおよび5bの後に発生しますが、グループ間で抑制は発生しません. その結果、送信者はO（M）RTCPFBメッセージを受信する可能性があります. したがって、非常に限られたフィードバック爆縮の可能性があります. ただし、送信者とすべての受信者が同じRTPセッションで同じ（セットの）コーデックを使用して同じアプリケーションを構成するため、FBメッセージのセマンティクスの相違はほとんどないと安全に想定できます. 

さらに、O（M）FBメッセージがT_dither_maxの時間間隔でランダムに配信されることを考えると、結果として生じる限られた数の追加の複合RTCPパケットは、（a）送信者を圧倒しないと想定され、（b）次のように伝達される必要があります. すべてに補足的な情報が含まれています. 

6. RのFBメッセージが5のように他の受信者FBメッセージによって抑制されなかった場合、teに達すると、RはそのFBメッセージを含む（最小の）複合RTCPパケットを送信する必要があります. 次に、Rはallow_early = FALSEを設定し、tn = tp + 2 * T_rrを再計算し、tpを前のtnに設定する必要があります. 新しく計算されたtnに達するとすぐに、Rが次の通常のRTCPパケットを送信するか、T_rr_intervalのためにそれを抑制するかに関係なく、allow_early = TRUEを再度設定する必要があります. 

3.5.3. 通常のRTCP送信
完全な複合RTCPパケットは、定期的に送信する必要があります. これらのパケットには、1つ以上のFBメッセージも含まれる場合があります. 通常のRTCPパケットの送信は次のようにスケジュールされます. 

T_rr_interval == 0の場合、送信はこのドキュメントのセクション3.2および3.4​​で指定されているルールに従う必要があり、セクション3.5.2で指定されているtnの調整に準拠する必要があります（つまり、早期RTCPパケット送信の場合は通常の送信を1回スキップする必要があります発生しました）. [1]に従って、tnに達するとタイマーの再検討が行われます. 通常のRTCPパケットは、タイマーの再検討後に送信されます. 通常のRTCPパケットが送信または抑制されるときはいつでも、allow_earlyをTRUEに設定し、tp、tnを[1]に従って更新する必要があります. 通常のRTCPパケットの最初の送信後、Tminを0に設定する必要があります. 

T_rr_interval！= 0の場合、送信時間の計算は、このドキュメントのセクション3.2および3.4​​で指定されているルールに従い、セクション3.5.2で指定されているtnの調整に準拠する必要があります（つまり、初期のRTCP送信が発生しました）. [1]に従って、tnに達するとタイマーの再検討が行われます. タイマーの再検討後、次のアクションが実行されます. 

1.以前に通常のRTCPパケットが送信されたことがない場合（つまり、t_rr_last == NaNの場合）、通常のRTCPパケットをスケジュールする必要があります. 保存されたFBメッセージは、通常のRTCPパケットに含まれる場合があります. スケジュールされたパケットが送信された後、t_rr_lastをtnに設定する必要があります. Tminは0に設定する必要があります. 

2.それ以外の場合、一時値T_rr_current_intervalは次のように計算されます. 

T_rr_current_interval = RND * T_rr_interval

RNDは、0.5から1.5の間で均等に分散された疑似ランダム関数です. このディザリングされた値は、次の選択肢のいずれかを決定するために使用されます. 

2a）t_rr_last + T_rr_current_interval <= tnの場合、通常のRTCPパケットをスケジュールする必要があります. 保存されたRTCPFBメッセージは、通常のRTCPパケットに含まれる場合があります. スケジュールされたパケットが送信された後、t_rr_lastをtnに設定する必要があります. 

2b）t_rr_last + T_rr_current_interval> tnおよびRTCPFBメッセージが保存され、送信を待機している場合、RTCPパケットはtnで送信するようにスケジュールする必要があります. このRTCPパケットは、最小または通常のRTCPパケット（実装者の裁量による）である可能性があり、複合RTCPパケットには、保存されたRTCPFBメッセージが含まれている必要があります. t_rr_lastは変更しないでください. 

2c）それ以外の場合（t_rr_last + T_rr_current_interval> tnであるが、保存されたRTCP FBメッセージが送信を待機していない場合）、複合RTCPパケットを抑制しなければなりません（つまり、スケジュールしてはいけません）. t_rr_lastは変更しないでください. 

上記の4つのケース（1、2a、2b、および2c）のすべてで、allow_earlyをTRUEに設定する必要があり（通常のRTCPパケットを送信した後）、tpとtnを[1]のルールに従って更新する必要があります（5つを除く）.  2番目の最小値. 

3.5.4. その他の考慮事項
T_rr_interval！= 0の場合、RTP / AVPFエンティティのタイムアウト計算（[1]のセクション6.3.5）は、Tdの計算にTminの代わりにT_rr_intervalを使用し、RTPエンティティのタイムアウトにM * Tdを使用するように変更する必要があります. 

複合RTCPパケットが送信または受信されるたびに（最小または完全複合、早期または通常）、avg_rtcp_size変数はそれに応じて更新する必要があり（[1]を参照）、tnの後続の計算では新しいavg_rtcp_sizeを使用する必要があります. 

3.6. グループサイズに関する考慮事項
このセクションでは、さまざまなフィードバックモードを使用できるグループサイズに関するガイドラインをいくつか示します. 

3.6.1. ACKモード
RTPセッションには正確に2つのメンバーが必要であり、このグループサイズは拡大してはなりません. つまり、ポイントツーポイント通信である必要があります. ユニキャストアドレスは、セッションの説明で使用する必要があります. 

2者間の単方向および双方向通信の場合、RTPセッション帯域幅の2.5％が、フィードバックを含む受信者からのRTCPトラフィックに使用できます. 64 kbit / sストリームの場合、これによりRTCPで1,600ビット/ sが生成されます. RTCPパケットあたり平均96バイト（= 768ビット）と仮定すると、受信者は1秒あたり2つのイベントを送信者に報告できます. 各FBメッセージで10個のイベントの確認応答が収集される場合、1秒あたり20個のイベントを確認応答できます. 256 kbit / sでは、1秒あたり8つのイベントが報告されます. したがって、ACKはより細かい粒度で送信できます（たとえば、FBメッセージごとに3つのACKのみを組み合わせる）. 

1 Mbit / s以上では、受信者は30 fpsのビデオストリーム内の個々のフレーム（パケットではありません！）を確認できます. 

これらの帯域幅制限で適切に機能するように、ACK戦略を定義する必要があります. セッションでACKが許可されているかどうか、許可されている場合はどのACK戦略を使用するかを示す指標は、SDPを使用したセッション記述のメディア固有の属性など、帯域外メカニズムによって伝達される場合があります. 

3.6.2. NACK Mode
否定的な確認応答（および同様のレポート特性を示す他のタイプのフィードバック）は、グループサイズが2より大きくなる可能性があるすべてのセッションに使用する必要があります. もちろん、NACKはポイントツーポイント通信にも使用できます. 

初期RTCPパケットの使用を検討する必要があるかどうかは、セッション帯域幅、コーデック、特殊なタイプのフィードバック、送信者と受信者の数など、いくつかのパラメーターによって異なります. 

動作モードを決定する際の最も重要なパラメータは、2つの複合RTCPパケット間の許容最小間隔（T_rr）と、時間間隔ごとにレポートする必要があると思われるイベントの平均数（およびもちろん時間の経過に伴う分布）です. 最小間隔は、使用可能なRTCP帯域幅とRTCPパケットの予想される平均サイズから導き出すことができます. 報告するイベントの数（たとえば、1秒あたり）は、パケット損失率と送信者のパケット送信率から導き出すことができます. これらの2つの値から、即時フィードバックモードの許容グループサイズを計算できます. 

セクション3.3で述べたように：

Nを受信者が間隔Tごとに報告するイベントの平均数、Bをこの特定の受信者のRTCP帯域幅の割合、Rを平均RTCPパケットサイズとすると、受信者はN <=である限り即時フィードバックモードで動作します.  B * T / R. 

その場合、早期RTCPモードの上限は、許容可能な品質低下、つまり、時間間隔ごとに報告されない可能性のあるイベントの数にのみ依存します. 

セクション3.3で述べたように：

上記の表記法を使用すると、初期RTCPモードは、N> B * T / Rを「下限」として大まかに特徴付けることができます. 上限の見積もりはより困難です. N = 1に設定すると、特定のRとBについて、報告されるイベント間の平均間隔として間隔T = R / Bが得られます. この情報は、RTCPパケットの早期送信が有用かどうかを判断するためのヒントとして使用できます. 

例：30fpsの256kbit / sビデオが約1,500バイトのMTUサイズのネットワークを介して送信される場合、ほとんどの場合、各フレームは1つのパケットに収まり、1パケットあたり30パケットのパケットレートになります.  2番目. ネットワークで5％のパケット損失が発生した場合（均等に分散され、受信者間の相互依存性がない場合）、各受信者は平均して2秒ごとに3つのパケット損失を報告する必要があります. 単一の送信者と3つ以上の受信者を想定すると、これにより、受信者に割り当てられたRTCP帯域幅の3.75％、つまり9.6 kbit / sが得られます. さらに、平均的な複合RTCPパケットのサイズを120バイトとすると、1秒あたり10個のRTCPパケット、または2秒で20個のRTCPパケットを送信できます. すべての受信者が2秒ごとに3つの失われたパケットを報告する必要がある場合、これにより、すべての損失イベントが報告された場合、最大グループサイズは6〜7レシーバーになります. 初期のRTCPパケットの送信に関するルールは、このレポートのほとんどがタイムリーに発生するための十分な柔軟性を提供する必要があります. 

この例を拡張してEarlyRTCPモードの上限を決定すると、次の考慮事項が生じる可能性があります. 基盤となるコーディングスキームとアプリケーション（および許容ユーザー）が、2秒ごとに修復せずに1回の損失を許容すると仮定します. したがって、各受信者によって報告されるパケットの数は2秒に2つに減少し、グループサイズは10に増加します. さらにいくつかのパケット損失が相関していると仮定すると、フィードバックトラフィックはさらに減少し、グループサイズは約12〜16になります.  （おそらく20でも）初期RTCPモードを使用してかなりよくサポートできます. これらの考慮事項はすべて統計に基づいており、場合によっては当てはまらないことに注意してください. 

3.7. 決定ステップの要約
3.7.1. 一般的なヒント
RTCPフィードバック情報を送信するかどうかを検討する前に、アプリケーションはこのメカニズムが適用可能かどうかを判断する必要があります. 

1）アプリケーションは、関連する（アプリケーション固有の）最大フィードバック遅延と現在観測されているラウンドトリップ時間（利用可能な場合）を含むパケットレートの現在の比率に対して、フィードバックメカニズムを適用できるかどうかを判断する必要があります. 

この決定は、RTCP受信統計および帯域外メカニズムに基づく（およびそれに続いて動的に改訂される）場合があります. 

2）アプリケーションは、特定の観測されたエラーレート、割り当てられた帯域幅、フレーム/パケットレート、およびグループサイズについて、フィードバックメカニズムを適用できるかどうか（および適用できるかどうか）を決定する必要があります. 

定期的なRTCP受信統計も、このステップに貴重な情報を提供します. 

3）アプリケーションがフィードバックを送信することを決定した場合、アプリケーションは、FBメッセージを含む早期RTCPパケットまたは通常のRTCPパケットを送信するためのルールに従う必要があります. 

4）送信されるRTCPフィードバックのタイプは、下位層のトランスポートプロトコルから送信者が利用できる情報と重複してはなりません. つまり、トランスポートプロトコルがパケット受信（DCCPなど）について否定的または肯定的な確認応答を提供する場合、受信者はRTCP層で同じ情報を繰り返さないようにする必要があります（つまり、汎用NACKの送信を控えます）. 

3.7.2. メディアセッション属性
メディアセッションは通常、送信者と受信者の間でトランスポートアドレス、コーデック情報などを伝達するために帯域外メカニズムを使用して記述されます. このようなメカニズムは2つあります. メディアセッションを記述するために使用される形式と、この記述を転送するための別のメカニズムです. 

IETFでは、現在、セッション記述プロトコル（SDP）を使用してメディアセッションを記述し、SIP、セッションアナウンスプロトコル（SAP）、リアルタイムストリーミングプロトコル（RTSP）、HTTP（とりわけ）などのプロトコルを使用して説明. 

メディアセッション記述形式には、RTCPフィードバックメカニズムがこのセッションでサポートされていること、およびどのフィードバックメカニズムを適用できるかを示すパラメータが含まれている場合があります. 

そのためには、「AVP」の代わりにプロファイル「AVPF」を指定する必要があります. サポートされているフィードバックのタイプを示すために、さらに属性を定義できます. 

セクション4には、SDPでのRTCPフィードバックをサポートするための構文仕様が含まれています. 他のメディアセッション記述形式の同様の仕様は、このドキュメントの範囲外です. 

4.SDPの定義
このセクションでは、セッションの説明に使用されるいくつかの追加のSDPパラメーターを定義します. これらはすべて、メディアレベルの属性として定義されています. 

4.1. プロファイルの識別
[4]で定義されているAVプロファイルは、たとえばSession Description Protocol（SDP）[3]のコンテキストでは、「AVP」と呼ばれます. このドキュメントで指定されているプロファイルは、「AVPF」と呼ばれます. 

このドキュメントで指定されている変更されたタイミングルールに従ったフィードバック情報は、このセッションの説明が「AVPF」プロファイルの使用を（排他的または他のAVプロファイルと共同で）示していない限り、特定のメディアセッションに送信してはなりません. 

4.2. RTCPフィードバック機能属性
このドキュメントで指定されているRTCPフィードバックを使用する機能を示すために、新しいペイロード形式固有のSDP属性が定義されています： "a = rtcp-fb". 「rtcp-fb」属性は、SDPメディア属性としてのみ使用する必要があり、セッションレベルで提供してはなりません. 「rtcp-fb」属性は、「AVPF」が指定されているメディアセッションでのみ使用する必要があります. 

「rtcp-fb」属性は、指定されたペイロードタイプに対してこのメ​​ディアセッションで使用できるRTCPFBメッセージを示すために使用する必要があります. ワイルドカードペイロードタイプ（ "*"）は、RTCPフィードバック属性がすべてのペイロードタイプに適用されることを示すために使用できます. 複数のタイプのフィードバックがサポートされている場合、および/またはペイロードタイプのサブセットに同じフィードバックを指定する必要がある場合は、複数の「a = rtcp-fb」行を使用する必要があります. 

「rtcp-fb」属性が指定されていない場合、RTP受信者は、それぞれのメディアタイプに定義されている他の適切なRTCPフィードバックパケットを使用してフィードバックを送信できます（MAY）. RTP受信者は、FBメッセージのいずれかに反応するRTP送信者に依存してはなりません（MUSTNOT）. RTP送信者は、一部のフィードバックメッセージを無視することを選択できます（MAY）. 

1つ以上の「rtcp-fb」属性がメディアセッションの説明に存在する場合、「rtcp-fb」を含むメディアセッションのRTCPレシーバー

oセマンティクスを完全に理解していない（つまり、「a = rtcp-fb」行のすべての値の意味を理解していない）すべての「rtcp-fb」属性を無視する必要があります. 

oこのメディアセッションの「rtcp-fb」属性の1つで指定されているRTCPフィードバックパケットのいずれかを使用して、このドキュメントで指定されているフィードバック情報を提供する必要があります. そして

o「rtcp-fb」属性行の1つにリストされているもの以外のFBメッセージを使用してはなりません（MUSTNOT）. 

オファー/アンサーモデル[8]と組み合わせて使用​​する場合、オファー提供者はこれらのAVPF属性のセットをピアに提示してもよい[MAY]. 回答者は、理解できないすべての属性と、一般的にサポートされていない属性、またはこの特定のメディアセッションで使用したくない属性をすべて削除する必要があります. 回答者は、メディアの説明にフィードバックパラメータを追加してはならず、そのようなパラメータの値を変更してはなりません. 答えはメディアセッションを拘束するものであり、提供者と回答者の両方がこの方法でネゴシエートされたフィードバックメカニズムのみを使用する必要があります. 提供者と回答者の両方が、ネゴシエートされたフィードバックメカニズムのサブセットのみのRTCP FBメッセージを送信することを個別に決定できますが、受信時にすべてのタイプのネゴシエートされたFBメッセージに適切に反応する必要があります. 

RTP送信者は、あらゆる種類のRTCP FBメッセージを受信する準備をしなければならず、理解できないすべてのRTCPFBメッセージをサイレントに破棄しなければなりません. 

「rtcp-fb」属性の構文は次のとおりです（フィードバックタイプとオプションのパラメーターはすべて大文字と小文字が区別されます）. 

（以下のABNFでは、fmt、SP、およびCRLFが[3]で定義されているように使用されます. ）

      rtcp-fb-syntax = "a = rtcp-fb：" rtcp-fb-pt SP rtcp-fb-val CRLF
        
      rtcp-fb-pt = "*"; ワイルドカード：すべての形式に適用
                         / fmt; SDP仕様で定義されているとおり
        
rtcp-fb-val = "ack" rtcp-fb-ack-param / "nack" rtcp-fb-nack-param / "trr-int" SP 1 * DIGIT / rtcp-fb-id rtcp-fb-param

      rtcp-fb-id = 1 *（英数字/ "-" / "_"）
        
rtcp-fb-param = SP "app" [SPバイト文字列] / SPトークン[SPバイト文字列] /; 空の

rtcp-fb-ack-param = SP "rpsi" / SP "app" [SPバイト文字列] / SPトークン[SPバイト文字列] /; 空の

rtcp-fb-nack-param = SP "pli" / SP "sli" / SP "rpsi" / SP "app" [SPバイト文字列] / SPトークン[SPバイト文字列] /; 空の

上記の文法のリテラルには、次のセマンティクスがあります. 

フィードバックタイプ「ack」：

このフィードバックタイプは、フィードバックに対する肯定的な確認応答がサポートされていることを示します. 

フィードバックタイプ「ack」は、メディアセッションがセクション3.6.1で定義されているACKモードでの動作を許可されている場合にのみ使用する必要があります. 

さまざまなタイプの肯定応答フィードバックをさらに区別するために、パラメーターを提供する必要があります. 

パラメータ「rpsi」は、セクション6.3.3で定義されている参照画像選択表示フィードバックの使用を示します. 

パラメータ「app」が指定されている場合、これはアプリケーション層フィードバックの使用を示します. この場合、「app」に続く追加のパラメーターを使用して、さまざまなタイプのアプリケーション層フィードバックをさらに区別することができます. このドキュメントでは、「アプリ」に固有のパラメータは定義されていません. 

「ack」のその他のパラメータは、他のドキュメントで定義されている場合があります. 

フィードバックタイプ「ナック」：

このフィードバックタイプは、フィードバックに対する否定的な確認応答がサポートされていることを示します. 

パラメータなしのフィードバックタイプ「nack」は、セクション6.2.1で定義されている汎用NACKフィードバック形式の使用を示します. 

このドキュメントでは、メディアタイプ「video」と組み合わせて「nack」で使用するために、次の3つのパラメータが定義されています. 

o「pli」は、セクション6.3.1で定義されているPicture LossIndicationフィードバックの使用を示します. 

o「sli」は、セクション6.3.2で定義されているスライス損失表示フィードバックの使用を示します. 

o「rpsi」は、セクション6.3.3で定義されている参照画像選択表示フィードバックの使用を示します. 

「アプリ」は、アプリケーション層フィードバックの使用を示します. 「アプリ」の後に追加のパラメーターを指定して、さまざまなタイプのアプリケーション層フィードバックを区別することができます. このドキュメントでは、「アプリ」に固有のパラメータは定義されていません. 

「nack」のその他のパラメータは、他のドキュメントで定義されている場合があります. 

その他のフィードバックタイプ<rtcp-fb-id>：

他の文書は、追加のタイプのフィードバックを定義する場合があります. これらの場合に文法を拡張可能に保つために、rtcp-fb-idがプレースホルダーとして導入されています. 新しいフィードバックスキーム名は一意である必要があります（したがって、IANAに登録する必要があります）. 新しい名前に加えて、そのセマンティクス、パケット形式（必要な場合）、およびその操作のルールを指定する必要があります. 

通常のRTCP最小間隔 "trr-int"：

属性「trr-int」は、このメディアセッションの2つの通常の（完全な複合）RTCPパケット間の最小間隔T_rr_intervalをミリ秒単位で指定するために使用されます. 「trr-int」が指定されていない場合、デフォルト値は0と見なされます. 

（セクション6.4で定義されている）アプリケーション層のフィードバックに関するより具体的な情報は、他の場所で定義されているフィードバックの種類とパラメーターとして伝達されると想定されていることに注意してください. したがって、このドキュメントでは、タイプとパラメータについてこれ以上の規定はありません. 

さらなるタイプのフィードバックおよびさらなるパラメータは、他の文書で定義され得る. 

フィードバック情報を送信するかどうかは受信者次第であり、提供されたフィードバックを利用するかどうかは送信者（方法）次第です. 

4.3. RTCP帯域幅修飾子
[1]および[2]で定義されている標準のRTCP帯域幅の割り当ては、最大RTCP帯域幅を明示的に定義する帯域幅修飾子によって上書きされる場合があります. SDPで使用する場合、このような修飾子は[4]で指定されます. 「b = RS：<bw>」および「b = RR：<bw>」を使用して、RTPに異なる帯域幅（ビット/秒で測定）を割り当てることができます. それぞれ送信者と受信者. [4]の優先順位規則は、送信者と受信者が使用する実際の帯域幅を決定するために適用されます. 

高度に非対称なリンク（衛星リンクなど）で意図的に動作するアプリケーションは、このメカニズムを使用して高帯域幅ストリームのフィードバックレートを下げ、フィードバックパスの確定的な輻輳を防ぐ必要があります. 

4.4. 例
例1：次のセッションの説明は、DTMFストリームが汎用NACKを使用するポイントツーポイント通信用のオーディオとDTMF [18]で構成されるセッションを示しています. このセッションの説明は、送信者が送信するDTMFストリームのフィードバックを受信できること、および受信する意思があることを示すために、SIP INVITE、200 OK、またはACKメッセージに含めることができます. 

      v = 0
      o=alice 3203093520 3203093520 IN IP4 host.example.com
      s =フィードバックのあるメディア
      t = 0 0 c = IN IP4 host.example.com
      m =オーディオ49170RTP / AVPF 0 96
      a = rtpmap：0 PCMU / 8000
      a = rtpmap：96電話イベント/ 8000
      a = fmtp：96 0-16
      a = rtcp-fb：96ナック
        
これにより、送信者と受信者は、オーディオセッションでDTMFイベントの信頼性の高い送信を提供できます. 1つのレシーバーで64kbit / sのオーディオストリームを想定すると、レシーバーには、負の確認応答ストリームに使用できる2.5％のRTCP帯域幅があります. つまり、毎秒250バイト、または毎秒2つのRTCPフィードバックメッセージです. したがって、受信機は、1秒あたり最大2つの欠落しているDTMFオーディオパケットを個別に通信できます. 

例2：次のセッションの説明は、ビデオソースがコーデックの汎用NACKとH.263の参照画像選択の両方を受け入れるマルチキャストビデオのみのセッション（H.261またはH.263 +のいずれかを使用）を示しています. このような説明は、Session Announcement Protocol（SAP）を使用して伝達された可能性があります. 

      v = 0
      o=alice 3203093520 3203093520 IN IP4 host.example.com
      s =フィードバック付きのマルチキャストビデオ
      t = 3203130148 3203137348
      m = audio 49170 RTP / AVP 0
      c = IN IP4 224.2.1.183
      a = rtpmap：0 PCMU / 8000
      m =ビデオ51372RTP / AVPF 98 99
      c = IN IP4 224.2.1.184
      a = rtpmap：98 H263-1998 / 90000
      a = rtpmap：99 H261 / 90000
      a = rtcp-fb：*ナック
      a = rtcp-fb：98 nack rpsi
        
送信者は、着信Generic NACKをヒントとして使用して、新しいイントラフレームをできるだけ早く送信できます（輻輳制御が許可されている場合）. 参照画像選択表示（RPSI）メッセージを受信すると、送信者は大きなフレーム内送信を回避できます. 代わりに、フレーム間を送信し続ける場合がありますが、指定されたフレームを新しいエンコーディング参照として選択します. 

例3：次のセッションの説明では、例2と同じメディアセッションを定義していますが、AVPおよびAVPF RTPエンティティの混合モード操作が可能です（次のセクションも参照）. 両方のメディアの説明で同じアドレスが使用されていることに注意してください. ただし、適用可能な両方のRTPプロファイルに関する情報を伝達するには、2つのm =行が必要です. 

      v = 0
      o=alice 3203093520 3203093520 IN IP4 host.example.com
      s =フィードバック付きのマルチキャストビデオ
      t = 3203130148 3203137348
      m = audio 49170 RTP / AVP 0
      c = IN IP4 224.2.1.183
      a = rtpmap：0 PCMU / 8000
      m =ビデオ51372RTP / AVP 98 99
      c = IN IP4 224.2.1.184
      a = rtpmap：98 H263-1998 / 90000
      a = rtpmap：99 H261 / 90000
      m =ビデオ51372RTP / AVPF 98 99
      c = IN IP4 224.2.1.184
      a = rtpmap：98 H263-1998 / 90000
      a = rtpmap：99 H261 / 90000
      a = rtcp-fb：*ナック
      a = rtcp-fb：98 nack rpsi
        
これらの2つのm =行は、両方が実際に同じ内容を伝達する代替手段であることを示すために、適切なメカニズムによってグループ化する必要があることに注意してください. これを実現できるサンプルフレームワークは[10]で定義されています. 

この例では、RTCPフィードバック対応の受信者は、イベントを送信者に早く報告するという利点があります（これはグループ全体に利益をもたらす可能性があります）. ただし、平均して、すべてのRTP受信機は同じ量のフィードバックを提供します. AVPエンティティとAVPFエンティティ間の相互作用については、次のセクションで詳しく説明します. 

5.AVPエンティティとAVPFエンティティの相互作用と共存
このドキュメントで定義されているAVPFプロファイルは、[2]で定義されているAVPプロファイルの拡張です. 両方のプロファイルは同じ基本ルールに従います（RTCPの帯域幅の上限、および送信者と受信者への帯域幅の割り当てを含む）. したがって、2つのプロファイルのいずれかを使用する送信者と受信者を1つのセッションに混在させることができます（セクション4.5の例3を参照）. 

AVPとAVPFは、堅牢性の観点から、RTPエンティティがそれぞれの他のプロファイルのエンティティを認識する必要がないように定義されています. これらは互いの機能を妨げません. ただし、提示されるメディアの品質が低下する可能性があります. 

複合セッションで使用する場合、次の考慮事項が送信者と受信者に適用されます. 

o AVPエンティティ（送信者と受信者）

AVP送信者は、AVPF受信者からRTCPフィードバックパケットを受信し、これらのパケットを無視します. AVPFエンティティによるRTCPメッセージの間隔がときどき狭くなります（たとえば、5秒ルールに違反します）. 全体的な帯域幅の制約は両方のタイプのエンティティによって順守されているため、RTCP帯域幅のシェアを引き続き取得します. ただし、AVPエンティティは5秒ルールに拘束されますが、グループサイズとセッション帯域幅によっては、AVPFエンティティがAVPよりも頻繁にRTCPレポートを提供する場合があります. また、AVPFエンティティがより大きな複合RTCPパケットを送信する可能性があるため（余分なRTCPパケットのため）、全体的なレポートがわずかに減少する可能性があります. 

T_rr_intervalが通常のRTCPパケット間の下限として使用され、T_rr_intervalが十分に大きく（たとえば、[1]のセクション6.3.5によるT_rr_interval> M * Td）、初期RTCPパケットがAVPFエンティティによって送信されない場合、AVPエンティティはこれらのAVPFグループメンバーを誤ってタイムアウトしたため、グループサイズを過小評価しています. したがって、AVPエンティティがメディアセッションに関与している可能性がある場合、T_rr_intervalは5秒を超えてはなりません（SHOULDNOT）. 

o AVPFエンティティ（送信者と受信者）

動的に計算されたT_rrが十分に小さい場合（たとえば、1秒未満）、AVPFエンティティが誤ってAVPグループメンバーをタイムアウトし、グループサイズを過小評価する可能性があります. したがって、AVPエンティティがメディアセッションに関与している可能性がある場合は、T_rr_intervalを使用する必要があり、5秒に設定する必要があります. 

結論として、AVPエンティティがメディアセッションに関与している可能性があり、T_rr_intervalを使用する場合は、T_rr_intervalを5秒に設定する必要があります. 

またはAVPF送信者

AVPF送信者は、AVPF受信者からのみフィードバック情報を受信します. ターゲットメディアの品質を提供するためにフィードバックに依存している場合、AVPレシーバーで達成される品質は最適ではない可能性があります. 

oAVPFレシーバー

AVPF受信者は、メディアセッション内のすべての送信エンティティがAVPFをサポートしている場合にのみ、早期RTCPフィードバックパケットを送信する必要があります. AVPF受信機は、以下のタイミングルールに従って定期的にスケジュールされた複合RTCPパケットの一部としてフィードバック情報を送信できます. 

[1]と[2]は、混合モードで動作するメディアセッションでも使用されます. ただし、フィードバックを提供する受信者は、フィードバックに反応する送信者にまったく依存してはなりません. 

6.RTCPフィードバックメッセージのフォーマット
このセクションでは、low-delay RTCPフィードバックメッセージの形式を定義します. これらのメッセージは、次の3つのカテゴリに分類されます. 

- Transport layer FB messages
- Payload-specific FB messages 
- Application layer FB messages

Transport layer FB messagesは、汎用のフィードバック情報、つまり特定のコーデックや使用中のアプリケーションに依存しない情報を送信することを目的としています. 情報は、トランスポート/ RTP層で生成および処理されることが期待されています. 現在、一般的な否定応答（NACK）メッセージのみが定義されています. 

Payload-specific FB messagesは、特定のペイロードタイプに固有の情報を転送し、コーデックの「レイヤー」で生成および処理されます. このドキュメントでは、すべてのPayload-specific FB messagesと組み合わせて使用​​される共通ヘッダーを定義します. 特定のメッセージの定義は、RTPペイロード形式の仕様または追加のフィードバック形式のドキュメントに委ねられています. 

Application layer FB messagesは、受信者から送信者のアプリケーションにフィードバックを透過的に伝達する手段を提供します. このようなメッセージに含まれる情報は、トランスポート/ RTPまたはコーデック層で処理されることは期待されていません. 2つのアプリケーションインスタンス間で交換されるデータは、通常、アプリケーションプロトコル仕様で定義されているため、アプリケーションで識別できるため、追加の外部情報は必要ありません. したがって、このドキュメントでは、すべてのApplication layer FB messagesとともに使用される共通のヘッダーのみを定義しています. プロトコルの観点からは、Application layer FB messagesは、Payload-specific FB messagesの特殊なケースとして扱われます. 

注：メディア送信者側で一部のFBメッセージを適切に処理するには、送信者がFBメッセージが参照しているペイロードタイプを知っている必要がある場合があります. ほとんどの場合、この知識は、単一のペイロードタイプのみを使用するメディアストリームから取得できる可能性があります. ただし、複数のコーデックが同時に使用されている場合（たとえば、オーディオとDTMFで）、またはコーデックの変更が発生した場合、ペイロードタイプ情報をFBメッセージの一部として明示的に伝達する必要がある場合があります. これは、すべてのペイロード固有のメッセージとApplication layer FB messagesに適用されます. ペイロードタイプ情報の送信方法を定義するのは、FBメッセージの仕様次第です. 

このドキュメントでは、2つのトランスポート層と3つの（ビデオ）Payload-specific FB messages、およびApplication layer FB messages用の単一のコンテナーを定義します. 追加のトランスポート層およびPayload-specific FB messagesは、他のドキュメントで定義されている場合があり、IANAを介して登録する必要があります（セクション9「IANAの考慮事項」を参照）. 

上記のRTCPFBメッセージタイプの一般的な構文とセマンティクスについては、次のサブセクションで説明します. 

6.1. フィードバックメッセージの一般的なパケット形式
すべてのFBメッセージは、図3に示されている共通のパケット形式を使用する必要があります. 

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=2|P|   FMT   |       PT      |          length               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  SSRC of packet sender                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  SSRC of media source                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   :            Feedback Control Information (FCI)                 :
   :                                                               :
        
図3：フィードバックメッセージの一般的なパケット形式

フィールドV、P、SSRC、および長さは、RTP仕様[2]で定義されており、それぞれの意味を以下に要約します. 

バージョン（V）：2ビットこのフィールドはRTPバージョンを識別します. 現在のバージョンは2です. 

パディング（P）：1ビットパディングビットは、設定されている場合、パケットの最後に、制御情報の一部ではないが長さフィールドに含まれる追加のパディングオクテットが含まれていることを示します. 

フィードバックメッセージタイプ（FMT）：5ビットこのフィールドは、FBメッセージのタイプを識別し、タイプ（トランスポート層、ペイロード固有、またはアプリケーション層のフィードバック）に関連して解釈されます. 3つのフィードバックタイプのそれぞれの値は、以下のそれぞれのセクションで定義されています. 

ペイロードタイプ（PT）：8ビットこれは、パケットがRTCPFBメッセージであることを識別するRTCPパケットタイプです. IANAでは2つの値が定義されています. 

            Name   | Value | Brief Description
         ----------+-------+------------------------------------
            RTPFB  |  205  | Transport layer FB message
            PSFB   |  206  | Payload-specific FB message
        
長さ：16ビットこのパケットの長さ（32ビットワードから1を引いたもの）. ヘッダーとパディングを含みます. これは、RTCP送信者および受信者レポートで使用される長さフィールドの定義と一致しています[3]. 

パケット送信者のSSRC：32ビットこのパケットの発信者の同期ソース識別子. 

メディアソースのSSRC：32ビットこのフィードバック情報が関連するメディアソースの同期ソース識別子. 

フィードバック制御情報（FCI）：可変長次の3つのセクションでは、トランスポート層、ペイロード固有、またはアプリケーション層のフィードバックの各タイプのフィードバックのFBメッセージに含めることができる追加情報を定義します. 追加のFCIコンテンツは、追加のドキュメントで指定される場合があることに注意してください. 

各RTCPフィードバックパケットには、FCIフィールドに少なくとも1つのFBメッセージが含まれている必要があります. セクション6.2および6.3は、複数のFBメッセージを単一のFCIフィールドに圧縮できるかどうかを、FCIタイプごとに定義します. この場合、それらは同じタイプ、つまり同じFMTでなければなりません. 複数のタイプのフィードバックメッセージ、つまり複数のFMTを伝達する必要がある場合は、複数のRTCP FBメッセージを生成する必要があり、同じ複合RTCPパケットに連結する必要があります. 

6.2. Transport Layer Feedback Messages
Transport layer FB messagesは、値RTPFBによってRTCPメッセージタイプとして識別されます. 

このドキュメントでは、単一の汎用トランスポート層FBメッセージであるGenericNACKが定義されています. これは、FMTパラメーターによって次のように識別されます. 

0：未割り当て
1：汎用NACK 
2-30：未割り当て
31：識別子番号スペースの将来の拡張用に予約済み

次のサブセクションでは、このタイプのFBメッセージのFCIフィールドの形式を定義します. さらに一般的なフィードバックメッセージが将来定義される可能性があります. 

6.2.1. Generic NACK
Generic NACKメッセージは、PT = RTPFBおよびFMT = 1によって識別されます. 

FCIフィールドには少なくとも1つが含まれている必要があり、複数のGenericNACKが含まれている場合があります. 

Generic NACKは、1つ以上のRTPパケットの損失を示すために使用されます. 失われたパケットは、パケット識別子とビットマスクによって識別されます. 

基盤となるトランスポートプロトコルが送信者に同様のフィードバック情報を提供できる場合は、汎用NACKフィードバックを使用しないでください（たとえば、DCCPの場合など）. 

フィードバック制御情報（FCI）フィールドには、次の構文があります（図4）. 

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            PID                |             BLP               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図4：汎用NACKメッセージの構文

パケットID（PID）：16ビットPIDフィールドは、失われたパケットを指定するために使用されます. PIDフィールドは、失われたパケットのRTPシーケンス番号を参照します. 

次の失われたパケットのビットマスク（BLP）：16ビットBLPでは、PIDで示されたRTPパケットの直後にある16個のRTPパケットのいずれかの損失を報告できます. BLPの定義は、[6]で与えられているものと同じです. BLPの最下位ビットをビット1、最上位ビットをビット16として示すと、受信者がRTPパケット番号（PID + i）を受信して​​いない場合、ビットマスクのビットiは1に設定されます（モジュロ2 ^ 16）このパケットが失われたことを示します. それ以外の場合、ビットiは0に設定されます. 送信者は、ビットマスクが0に設定されているため、受信者がパケットを受信したと想定してはならないことに注意してください. たとえば、PIDに対応するパケットと次のパケットが次の場合、BLPの最下位ビットは1に設定されます. 失われました. しかしながら、送信者は、BLPのビット2から15が0であるという理由だけで、パケットPID +2からPID + 16が受信されたことを推測できません. 送信者が知っているのは、受信者が現時点でそれらを紛失したと報告していないことだけです. 

FBメッセージの長さは2+ nに設定する必要があり、nはFCIフィールドに含まれる汎用NACKの数です. 

Generic NACKメッセージは、シーケンス番号を介してペイロードタイプを暗黙的に参照します. 

6.3. Payload-Specific Feedback Messages
Payload-specific FB messagesは、RTCPメッセージタイプとして値PT = PSFBによって識別されます. 

これまでに、3つのPayload-specific FB messagesと、Application layer FB messagesが定義されています. これらは、FMTパラメーターによって次のように識別されます. 

      0：未割り当て
      1：画像損失表示（PLI）
      2：スライス損失表示（SLI）
      3：参照画像選択表示（RPSI）
      4-14：未割り当て
      15：アプリケーション層FB（AFB）メッセージ
      16-30：未割り当て
      31：シーケンス番号スペースの将来の拡張のために予約済み
        
次のサブセクションでは、Payload-specific FB messagesのFCI形式を定義し、セクション6.4では、Application layer FB messagesのFCI形式を定義します. 

6.3.1. 画像喪失表示（PLI）
PLI FBメッセージは、PT = PSFBおよびFMT = 1によって識別されます. 

FCIフィールドにはPLIが1つだけ含まれている必要があります. 

6.3.1.1. セマンティクス
Picture Loss Indicationメッセージを使用して、デコーダは、1つまたは複数の画像に属する未定義の量のコード化されたビデオデータの損失についてエンコーダに通知します. 画像間予測に基づくビデオコーディングスキームと組み合わせて使用​​すると、PLIを受信するエンコーダは、予測チェーンが壊れている可能性があることを認識します. 送信者は、画像内を送信して再同期を実現することにより、PLIに反応してもよい（[6]で定義されているFIRメッセージと実質的に同様のメッセージにする）. ただし、送信者は、セクション7で概説されているように、輻輳制御を考慮する必要があります. これにより、フレーム内を送信する機能が制限される場合があります. 

RFC 2032 [6]などの他のRTPペイロード仕様では、特定のコーデックの一部のフィードバックメカニズムがすでに定義されています. 両方のスキームをサポートするアプリケーションは、フィードバックを送信するときに、この仕様で定義されているフィードバックメカニズムを使用する必要があります. 下位互換性の理由から、このようなアプリケーションは、それぞれのRTPペイロード形式で必要な場合、それぞれのRTPペイロード形式で定義されたフィードバックスキームを受信して​​応答できる必要があります. 

6.3.1.2. メッセージフォーマット
PLIはパラメータを必要としません. したがって、長さフィールドは2でなければならず、フィードバック制御情報があってはなりません. 

このFBメッセージのセマンティクスは、ペイロードタイプに依存しません. 

6.3.1.3. タイミングルール
タイミングはセクション3で概説されているルールに従います. PLIと他のタイプのフィードバックの両方を使用するシステムでは、PLIは他のFBタイプほど遅延が重要ではないため、PLIの通常のRTCPRRタイミングルールに従うことをお勧めします. 

6.3.1.4. 備考
PLIメッセージは通常、完全なイントラ画像の送信をトリガーします. イントラ画像は、予測された（インター）画像よりも数倍大きくなります. それらのサイズは、それらが生成される時間とは無関係です. ほとんどの環境では、特に帯域幅が制限されたリンクを使用する場合、画像内の使用は、通常のフレーム期間のかなりの数である許容遅延を意味します. 例：送信フレームレートが10 fpsで、画像内が画像間より10倍大きいと想定される場合、1秒の遅延を受け入れる必要があります. このような環境では、FBメッセージの送信に特別な短い遅延は必要ありません. したがって、[2]に従ってTmin = 0でRTCPタイミングルールによって許可される次の可能なタイムスロットを待機しても、システムパフォーマンスに悪影響はありません. 

6.3.2. スライス損失表示（SLI）
SLI FBメッセージは、PT = PSFBおよびFMT = 2で識別されます. 

FCIフィールドには少なくとも1つが含まれている必要があり、複数のSLIが含まれている場合があります. 

6.3.2.1. セマンティクス
Slice Loss Indicationを使用すると、デコーダーは、スキャン順序で1つまたは複数の連続するマクロブロックの損失または破損を検出したことをエンコーダーに通知できます（以下を参照）. このFBメッセージは、Annex Qが有効になっているH.263など、不均一で動的に変更可能なマクロブロックサイズのビデオコーデックには使用しないでください. このような場合、エンコーダは破損した空間領域を常に識別できるとは限りません. 

6.3.2.2. フォーマット
Slice Loss Indicationは1つの追加のFCIフィールドを使用し、その内容を図6に示します. FBメッセージの長さは2 + nに設定する必要があります. nはFCIフィールドに含まれるSLIの数です. 

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 最初| 番号| PictureID |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図6：スライス損失表示（SLI）の構文

最初：13ビット最初に失われたマクロブロックのマクロブロック（MB）アドレス. MBの番号付けは、画像の左上隅にあるマクロブロックがマクロブロック番号1と見なされ、各マクロブロックの番号がラスタースキャンの順序で左から右に、次に上から下に増加するように行われます（画像内の合計N個のマクロブロック. 右下のマクロブロックはマクロブロック番号Nと見なされます. 

数：13ビット上記のスキャン順で失われたマクロブロックの数. 

PictureID：6ビットマクロブロックの損失が発生した画像を参照するために使用されるコーデック固有の識別子の最下位6ビット. 多くのビデオコーデックでは、PictureIDはTemporalReferenceと同じです. 

このFBメッセージの適用範囲は、ビデオコーデックの小さなセットに限定されています. したがって、明示的なペイロードタイプ情報は提供されません. 

6.3.2.3. タイミングルール
スライス損失表示を使用するアルゴリズムの効率は、表示がタイムリーに送信されない場合に大幅に低下します. 動き補償は、破損していると報告されていない破損したピクセルを伝播します. したがって、セクション3で説明したアルゴリズムの使用を強くお勧めします. 

6.3.2.4. 備考
スライスという用語は、ここではMPEG-1の意味で定義および使用されています. スキャン順の連続した数のマクロブロックです. 最近のビデオコーディング標準では、スライスという用語の理解が異なる場合があります. たとえば、H.263（1998）には、「長方形スライス」と呼ばれる概念があります. 1つの長方形スライスが失われると、失われた/損傷したMBの領域を正確に識別するために、複数のSLIを送信する必要が生じる可能性があります. 

FCIの最初のフィールドは、画像の最初のマクロブロックを1として定義し、疑うことができるように0として定義しません. これは、この仕様をITU-TRecで利用可能な同等のメカニズムに合わせるために行われました. H.245 [24]. 画像内のマクロブロックの最大数（2 ** 13または8192）は、ほとんどのITU-TおよびISO / IECビデオコーデックの最大画像サイズに対応します. 将来のビデオコーデックがより大きな画像サイズおよび/またはより小さなマクロブロックサイズを提供する場合は、追加のFBメッセージを定義する必要があります. 時間参照フィールドの最下位6ビットは、損失が発生した画像を示すのに十分であると見なされます. 

SLIへの反応は、この仕様の一部ではありません. SLIに反応する典型的な方法の1つは、影響を受ける空間領域にイントラリフレッシュを使用することです. 

FBのタイミングに関係なく、これらすべての領域へのイントラマクロブロックの送信を可能にするために、動き補償の影響を受ける領域を追跡するアルゴリズムが報告されました（H.263（2000）付録I [17]および[15]）. これらのアルゴリズムを使用する場合、FBのタイミングは使用しない場合よりも重要ではありませんが、これらのアルゴリズムは画像の大部分を修正するため、FBが遅延した場合ははるかに大量のデータを送信する必要があることに注意する必要があります.  . 

6.3.3. 参照画像選択表示（RPSI）
RPSI FBメッセージは、PT = PSFBおよびFMT = 3によって識別されます. 

FCIフィールドにはRPSIが1つだけ含まれている必要があります. 

6.3.3.1. セマンティクス
MPEG-4ビジュアルバージョン2 [16]やH.263バージョン2 [17]などの最新のビデオコーディング標準では、予測コーディングに最新のものよりも古い参照画像を使用できます. 通常、参照画像の先入れ先出しキューが維持されます. エンコーダーがエンコーダーとデコーダーの同期性の喪失について学習した場合は、正しいことがわかっている参照画像を使用できます. この参照画像は通常よりも時間的に離れているため、結果として予測的にコード化された画像はより多くのビットを使用します. 

MPEG-4とH.263はどちらも、破損した画像の一時IDや破損した領域のサイズなどの情報を含むRPSIメッセージの「ペイロード」のバイナリ形式を定義しています. このビット文字列は通常、小さく（数十ビット）、可変長であり、自己完結型です. つまり、参照画像の選択を実行するために必要なすべての情報が含まれています. 

MPEG-4とH.263はどちらも、正のフィードバック情報とともにRPSIを使用できます. つまり、エラーなしでデコードされた画像（またはスライス）が報告されます. マルチパーティセッションでは、いかなる形式の正のフィードバックも使用してはならないことに注意してください（RTCP間隔で個々の参照画像に関する正のフィードバックを報告することは、とにかくあまり役​​に立たないと予想されます）. 

6.3.3.2. フォーマット
RPSIメッセージのFCIは、図7に示されている形式に従います. 

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | PB | 0 | ペイロードタイプ| ネイティブRPSIビット文字列|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | コーデックごとに定義... | パディング（0）|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図7：参照画像選択表示（RPSI）の構文

PB：8ビットRPSIメッセージの長さを32ビットの倍数にパディングするために必要な未使用ビットの数. 

0：1ビットは送信時にゼロに設定し、受信時に無視する必要があります. 

ペイロードタイプ：7ビットネイティブRPSIビット文字列を解釈する必要があるコンテキストでのRTPペイロードタイプを示します. 

ネイティブRPSIビット文字列：可変長ビデオコーデックによってネイティブに定義されたRPSI情報. 

パディング：#PBビットRPSIメッセージの内容を次の32ビット境界まで埋めるためにゼロに設定されたビット数. パディングビットの数は、PBフィールドで指定する必要があります. 

6.3.3.3. タイミングルール
RPSIは、SLIを使用するアルゴリズムよりも遅延にとってさらに重要です. これは、RPSIメッセージが古いほど、エンコーダーとデコーダーの同期を再確立するためにエンコーダーが費やす必要のあるビット数が増えるためです. 特定のビットレート/フレームレート/損失レートのシナリオでのRPSIのオーバーヘッドに関する情報については、[15]を参照してください. 

したがって、RPSIメッセージは通常、セクション3のアルゴリズムを使用して、できるだけ早く送信する必要があります. 

6.4. アプリケーション層フィードバックメッセージ
Application layer FB messagesは、ペイロード固有のメッセージの特殊なケースであり、PT = PSFBおよびFMT = 15で識別されます. Application layer FB messages構造自体がスタッキングを許可しない限り（たとえば、固定サイズまたは明示的な長さのインジケーターによって）、FCIフィールドに含まれるApplication layer FB messagesは1つだけでなければなりません. 

これらのメッセージは、アプリケーション定義のデータを受信者のアプリケーションから送信者のアプリケーションに直接転送するために使用されます. 転送されるデータは、FBメッセージによって識別されません. したがって、アプリケーションはメッセージペイロードを識別できなければなりません. 

通常、アプリケーションは独自のメッセージセットを定義します. たとえば、MPEG-4 [16]のNEWPREDメッセージ（RFC 3016 [23]に従ってRTPパケットで伝送）またはH.263 / Annex N、U [17]のFBメッセージ（17]（ RFC 2429 [14]に従ってパケット化されます）. これらのメッセージには、RTCPメッセージからの追加情報は必要ありません. したがって、アプリケーションメッセージは次のようにFCIフィールドに配置され、それに応じて長さフィールドが設定されます. 

アプリケーションメッセージ（FCI）：可変長このフィールドには、受信者から送信元に転送する必要のある元のアプリケーションメッセージが含まれます. 形式はアプリケーションによって異なります. このフィールドの長さは可変です. アプリケーションデータが32ビットアラインメントされていない場合、32ビットアラインメントを実現するには、パディングビットとバイトを追加する必要があります. パディングの識別はアプリケーション層次第であり、この仕様では定義されていません. 

Application layer FB messages仕様では、メッセージを特定のコーデック（RTPペイロードタイプで識別）のコンテキストで具体的に解釈する必要があるかどうかを定義する必要があります. 適切な処理のためにペイロードタイプへの参照が必要な場合、Application layer FB messages仕様は、Application layer FB messages自体の一部としてペイロードタイプ情報を通信する方法を定義する必要があります. 

7.早期フィードバックと輻輳制御
前のセクションでは、FBメッセージと、これらのメッセージを送信するタイミングルールを定義しました. 受信したフィードバックに対応する方法は、フィードバックメカニズムを使用するアプリケーションによって異なるため、このドキュメントの範囲を超えています. 

ただし、すべてのアプリケーションで、ベストエフォートネットワーク環境で動作する場合、[1]および[2]で定義されているように、メディアストリームでの（TCP対応の）輻輳制御に対する共通の要件があります. 

RTCPフィードバック自体は、他のトランスポート層フィードバックメカニズム（通常はRTTの順序で動作する）よりもはるかに遅いタイムスケールで動作する可能性があるため、輻輳制御の目的には不十分であることに注意してください. したがって、適切な輻輳制御を実行するには、追加のメカニズムが必要です. 

利用可能な帯域幅を競合するTCP接続と合理的に公平に共有する輻輳制御アルゴリズム（TFRC [7]など）を使用して、RTP送信者とメディアセッションの機能（RTPの場合）の範囲内でメディアストリームのデータレートを決定する必要があります.  / AVPFセッションは、ベストエフォート環境で送信されます. 

8.セキュリティに関する考慮事項
提案されたペイロード形式で情報を転送するRTPパケットは、RTP仕様[1]およびRTP / AVPプロファイル仕様[2]で説明されているセキュリティの考慮事項の対象となります. このプロファイルは、追加のセキュリティサービスを指定していません. 

このプロファイルは、RTCPのタイミング動作を変更し、5秒の最小RTCP間隔を排除し、受信者がより早いフィードバックを提供できるようにします. 関連するRTPセッションのグループメンバー（おそらく多数のエンティティを表すふりをしている）は、多数のRTCPパケットを送信することにより、RTCPの動作を妨害し、それによって通常のRTCPレポートおよび早期FBメッセージに使用できるRTCP帯域幅を減らす可能性があります. （これらの影響を引き起こすために、エンティティがマルチキャストグループのメンバーである必要はないことに注意してください. ）同様に、悪意のあるメンバーが非常に大きなRTCPメッセージを送信する可能性があるため、avg_rtcp_size変数が増加し、有効なRTCP帯域幅が減少します. 

不明なRTCPフィードバックパケットを受信すると、フィードバック情報が抑制される場合があります. これにより、悪意のあるグループメンバーが、受信者（フィードバックを抑制する）または送信者（修復アクションが実行されない）によって認識されないランダムなコンテンツを含むペイロード固有のRTCPフィードバックパケットを送信するだけで、早期フィードバックを減らすリスクが発生します.  ）. 

悪意のあるグループメンバーは、フィードバック情報で任意の高い損失率を報告して、送信者にデータ送信を抑制させ、冗長性情報の量を増やしたり、偽のパケット損失に対処するための他のアクションを実行したりすることもできます（たとえば、送信するフレーム数を減らしたり、音声を減らしたりします/ビデオ品質）. これにより、再生されるメディアストリームの品質が低下する可能性があります. 

最後に、悪意のあるグループメンバーは、多数のグループメンバーとして機能し、それによって、アーリーフィードバック帯域幅の人為的に大きなシェアを取得し、他のグループメンバーの反応性を低下させる可能性があり、場合によっては、イミディエイトまたはアーリーで動作しなくなることさえあります. フィードバックモードであるため、このプロファイルの目的全体が損なわれます. 

送信者と受信者は、奇妙な報告行動を観察するときは保守的に行動する必要があります. 1つまたは少数の受信者からの過度の障害報告の場合、送信者は、メディアストリームの送信動作を適応させるときに、このフィードバックを考慮しないことを決定できます（MAY）. いずれの場合も、送信者と受信者は引き続き最大RTCP帯域幅を順守する必要がありますが、少なくとも定期的にスケジュールされたRTCPパケットを送信できることを確認してください. 送信者は、奇妙なレポート動作に遭遇したときに、送信帯域幅を調整する方法を慎重に検討する必要があります. 疑わしいフィードバックを無視しても、送信帯域幅を増やしてはなりません. 

すべてのRTCPメッセージを認証することにより、偽のRTCPパケット（通常のパケットと初期のパケット）を使用した攻撃を回避できます. これは、[22]で定義されているセキュアRTPプロファイルと一緒にAVPFプロファイルを使用することで実現できます. 前提条件として、これら2つのプロファイルの適切な組み合わせ（「SAVPF」）が指定されています[21]. （ソース認証ではなく）グループ認証を使用する場合、前述の攻撃は、適切なキー情報を所有している悪意のある、または誤動作しているグループメンバーによって実行される可能性があることに注意してください. 

9.IANAの考慮事項
以下の連絡先情報は、ここに含まれるすべての登録に使用されます. 

     連絡先：Joerg Ott
                   mailto:jo@acm.org
                   電話：+ 358-9-451-2460
        
最小限の制御で視聴覚会議のプロファイルの拡張としてのフィードバックプロファイルが、セッション記述プロトコル（具体的には「プロト」タイプ）に登録されています：「RTP / AVPF」. 

SDPプロトコル（「プロト」）：

名前：RTP / AVPF長い形式：RTCPベースのフィードバックを使用した拡張RTPプロファイル名前のタイプ：proto属性のタイプ：メディアレベルのみ目的：RFC 4585参照：RFC 4585

SDP属性（ "att-field"）：

属性名：rtcp-fb長い形式：RTCPフィードバックパラメーター名前のタイプ：att-field属性のタイプ：メディアレベルのみ文字セットの対象：いいえ目的：RFC 4585参照：RFC 4585値：このドキュメントと以下の登録を参照してください

「rtcp-fb」属性用に新しいレジストリが設定され、最初に次の登録が作成されました：このドキュメントで定義されている「ack」、「nack」、「trr-int」、および「app」. 

属性「rtcp-fb」の初期値登録

値名：ack長い名前：肯定応答参照：RFC4585. 

値の名前：nack長い名前：Negative Acknowledgement Reference：RFC4585. 

値の名前：trr-int長い名前：最小の受信者レポート間隔参照：RFC4585. 

値の名前：app長い名前：アプリケーション定義のパラメーター参照：RFC4585. 

それ以上のエントリーは先着順で登録できます. 新しい登録ごとに、パラメーター名と可能な追加引数の構文を示す必要があります. 新規登録ごとに、登録されたパラメーターのセマンティクス、パラメーターの構文とセマンティクス、および対応するフィードバックパケット形式（必要な場合）を指定する、永続的で安定した、公的にアクセス可能なドキュメントが存在することが必須です. [3]の一般的な登録手順が適用されます. 

「ack」と「nack」の両方で使用するために、最初に次の値を登録する共同サブレジストリが設定されています. 

属性値「ack」および「nack」の初期値登録：

値名：sli長い名前：スライス損失表示使用可能：nack参照：RFC4585. 

値の名前：pli長い名前：Picture Loss Indication使用可能：nack参照：RFC4585. 

値名：rpsi長い名前：参照画像選択表示使用可能：ack、nack参照：RFC4585. 

値の名前：app長い名前：アプリケーション層のフィードバック使用可能：ack、nack参照：RFC4585. 

それ以上のエントリーは先着順で登録できます. 各登録では、パラメーター名、可能な追加引数の構文、およびパラメーターが「ack」または「nack」フィードバック、あるいはその両方、またはいくつかの異なる「rtcp-fb」属性パラメーターに適用可能かどうかを示す必要があります. 新規登録ごとに、登録されたパラメーターのセマンティクス、パラメーターの構文とセマンティクス、および対応するフィードバックパケット形式（必要な場合）を指定する、永続的で安定した、公的にアクセス可能なドキュメントが存在することが必須です. [3]の一般的な登録手順が適用されます. 

2つのRTCP制御パケットタイプ：Transport layer FB messagesのクラス（「RTPFB」）とPayload-specific FB messagesのクラス（「PSFB」）用. セクション6に従って、RTPFB = 205およびPSFB = 206がRTCPレジストリに追加されました. 

RTP RTCP制御パケットタイプ（PT）：

名前：RTPFB長い名前：汎用RTPフィードバック値：205参照：RFC4585. 

名前：PSFB長い名前：ペイロード固有の値：206参照：RFC4585. 

AVPFが追加のRTCPペイロードタイプを定義するため、対応する「予約済み」RTPペイロードタイプスペース（[2]で定義されている72-76）がそれに応じて拡張されました. 

RTPFBペイロードタイプとPSFBペイロードタイプの両方のFMT値に対して新しいサブレジストリが設定され、最初に次の登録が作成されました. 

RTPFBの範囲内で、次の2つのフォーマット（FMT）値が最初に登録されます. 

名前：汎用NACK長い名前：汎用否定確認値：1参照：RFC4585. 

名前：拡張子長い名前：将来の拡張子のために予約されています値：31参照：RFC4585. 

PSFB範囲内で、次の5つのフォーマット（FMT）値が最初に登録されます. 

名前：PLI長い名前：画像損失表示値：1参照：RFC4585. 

名前：SLI長い名前：スライス損失表示値：2参照：RFC4585. 

名前：RPSI長い名前：参照画像選択表示値：3参照：RFC4585. 

名前：AFB長い名前：アプリケーション層フィードバック値：15参照：RFC4585. 

名前：拡張子長い名前：将来の拡張子のために予約されています. 値：31参照：RFC4585. 

RFC 2434 [9]で定義されている「仕様が必要」のルールに従って、さらにエントリを登録できます. 各登録では、FMT値、FCIフィールドに入力する特定のFBメッセージがあるかどうか、および複数のFBメッセージを単一のFCIフィールドにスタックできるかどうかを示す必要があります. 新規登録ごとに、登録されたパラメーターのセマンティクス、および関連するFBメッセージ（存在する場合）の構文とセマンティクスを指定する、永続的で安定した、公的にアクセス可能なドキュメントが存在することが必須です. [3]の一般的な登録手順が適用されます. 

10.謝辞
このドキュメントは、IETFのオーディオビジュアルトランスポート（AVT）ワーキンググループの製品です. 著者は、SteveCasnerとColinPerkinsのコメントと提案、および多数の質問への対応に感謝します. また、著者は、Magnus Westerlundのレビューと貴重な提案、およびFBメッセージの形式とセマンティクスへの貢献について福永茂に特に感謝します. 

また、Andreas Bueschingとパナソニックの人々のシミュレーションとフィードバックプロファイルの最初の独立した実装に感謝します. 

11.参考文献
11.1. 規範的参考文献
[1] Schulzrinne、H.、Casner、S.、Frederick、R. 、およびV. Jacobson、「RTP：リアルタイムアプリケーションのトランスポートプロトコル」、STD 64、RFC 3550、2003年7月. 

[2] Schulzrinne、H. およびS. Casner、「最小限の制御による音声およびビデオ会議のRTPプロファイル」、STD 65、RFC 3551、2003年7月. 

[3] Handley、M.、Jacobson、V. 、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、2006年7月. 

[4] Casner、S. 、「RTP制御プロトコル（RTCP）帯域幅のセッション記述プロトコル（SDP）帯域幅修飾子」、RFC 3556、2003年7月. 

[5] Bradner、S. 、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月. 

[6] Turletti、T. およびC. Huitema、「H.261ビデオストリームのRTPペイロード形式」、RFC 2032、1996年10月. 

[7] Handley、M.、Floyd、S.、Padhye、J. 、およびJ. Widmer、「TCP Friendly Rate Control（TFRC）：Protocol Specification」、RFC 3448、2003年1月. 

[8] Rosenberg、J. およびH. Schulzrinne、「Session Description Protocol（SDP）を使用したオファー/アンサーモデル」、RFC 3264、2002年6月. 

[9] Narten、T. およびH. Alvestrand、「RFCでIANA考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月. 

11.2. 有益な参考文献
[10] Camarillo、G.、Eriksson、G.、Holler、J. 、およびH. Schulzrinne、「Session Description Protocol（SDP）におけるメディアラインのグループ化」、RFC 3388、2002年12月. 

[11] Perkins、C. およびO. Hodson、「ストリーミングメディアの修復のオプション」、RFC 2354、1998年6月. 

[12] Rosenberg、J. およびH. Schulzrinne、「一般的な前方誤り訂正のためのRTPペイロード形式」、RFC 2733、1999年12月. 

[13] Perkins、C.、Kouvelas、I.、Hodson、O.、Hardman、V.、Handley、M.、Bolot、J.、Vega-Garcia、A.、and S. Fosse-Parisis、 "RTP Payload冗長オーディオデータ用」、RFC 2198、1997年9月. 

[14] Bormann、C.、Cline、L.、Deisher、G.、Gardos、T.、Maciocco、C.、Newell、D.、Ott、J.、Sullivan、G.、Wenger、S.、and C .Zhu、「1998年版のITU-TRec. H.263ビデオ（H.263 +）のRTPペイロード形式」、RFC 2429、1998年10月. 

[15] B. Girod、N. Faerber、「モバイルビデオ伝送のためのフィードバックベースのエラー制御」、Proceedings IEEE、Vol. 87、No. 10、pp.1707-1723、1999年10月. 

[16] ISO / IEC 14496-2：2001 / Amd.1：2002、「情報技術-視聴覚オブジェクトのコーディング-パート2：ビジュアル」、2001年. 

[17] ITU-T勧告H.263、「低ビットレート通信のためのビデオコーディング」、2000年11月. 

[18] Schulzrinne、H. およびS. Petrack、「DTMFディジット、テレフォニートーン、およびテレフォニー信号のRTPペイロード」、RFC 2833、2000年5月. 

[19] Kohler、E.、Handley、M. 、およびS. Floyd、「Datagram Congestion Control Protocol（DCCP）」、RFC 4340、2006年3月. 

[20] Handley、M.、Floyd、S.、Padhye、J. 、およびJ. Widmer、「TCP Friendly Rate Control（TFRC）：Protocol Specification」、RFC 3448、2003年1月. 

[21] Ott、J. およびE. Carrara、「RTCPベースのフィードバック用の拡張セキュアRTPプロファイル（RTP / SAVPF）」、作業中、2005年12月. 

[22] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E. 、およびK. Norrman、「The Secure Real-time Transport Protocol（SRTP）」、RFC 3711、2004年3月. 

[23]菊池恭子、野村徹、福永聡、松井恭子、木俣博、「MPEG-4オーディオ/ビジュアルストリームのRTPペイロードフォーマット」、RFC 3016、2000年11月. 

[24] ITU-T勧告H.245、「マルチメディア通信の制御プロトコル」、2006年5月. 

著者の住所

Joerg Ott Helsinki工科大学（TKK）ネットワーキングラボラトリーPO Box 3000 FIN-02015TKKフィンランド

Eメール：jo@acm.org

ステファンウェンガーノキアリサーチセンター私書箱10033721タンペレフィンランド

Eメール：stewe@stewe.org

Noriyuki Sato Oki Electric Industry Co., Ltd. 1-16-8 Chuo, Warabi-city, Saitama 335-8510 Japan

   電話番号：+81 48 431 5932
   ファックス：+81 48 431 9115
   Eメール：sato652@oki.com
        
Carsten Burmeister Panasonic R＆D Center Germany GmbH

Eメール：carsten.burmeister@eu.panasonic.com

Jose Rey Panasonic R＆D Center Germany GmbHMonzastr. 4c D-63225ランゲン、ドイツ

Eメール：jose.rey@eu.panasonic.com

完全な著作権声明

Copyright（C）The Internet Society（2006）. 

このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、作成者はすべての権利を保持します. 

このドキュメントおよびここに含まれる情報は「現状有姿」で提供され、寄稿者、組織の代表者、またはスポンサー（存在する場合）、インターネットソサエティおよびインターネットエンジニアリングタスクフォースは、明示的または明示的を問わず、すべての保証を否認します. ここに記載されている情報の使用が、商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを含むがこれに限定されない、黙示の保証. 

知的財産

IETFは、本書に記載されている技術の実装または使用に関連すると主張される可能性のある知的財産権またはその他の権利の有効性または範囲、あるいはそのような権利に基づくライセンスが可能性がある場合とそうでない場合がある範囲に関して、いかなる立場も取りません. 利用可能である; また、そのような権利を特定するために独自の努力をしたことを表すものでもありません. RFC文書の権利に関する手順に関する情報は、BCP78およびBCP79に記載されています. 

IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような所有権の使用に関する一般的なライセンスまたは許可を取得しようとした結果を取得できます.  http://www.ietf.org/iprのIETFオンラインIPRリポジトリから. 

IETFは、この標準の実装に必要となる可能性のあるテクノロジを対象とする可能性のある著作権、特許、特許出願、またはその他の所有権に関心を持ってもらうよう、関係者に呼びかけています. 情報をIETF（ietf-ipr@ietf.org）に送信してください. 

了承

RFC Editor機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます. 