RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
3711
RFC 3711-セキュアリアルタイムトランスポートプロトコル（SRTP）
URL：https://tools.ietf.org/html/rfc3711
タイトル：RFC 3711-Secure Real-time Transport Protocol（SRTP）
翻訳編集：自動生成
ネットワークワーキンググループM.バウアー
コメントのリクエスト：3711 D. McGrew
カテゴリ：規格追跡Cisco Systems、Inc.
                                                              ナスルンド
                                                              E.カララ
                                                              K.ノーマン
                                                       エリクソンリサーチ
                                                              2004年3月
        
セキュアリアルタイムトランスポートプロトコル（SRTP）

このメモのステータス

このドキュメントは、インターネットコミュニティ用のインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します. このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください. このメモの配布は無制限です. 

著作権表示

Copyright（C）The Internet Society（2004）. 全著作権所有. 

概要

このドキュメントでは、RTPトラフィックとRTPの制御トラフィックに機密性、メッセージ認証、および再生保護を提供できるリアルタイムトランスポートプロトコル（RTP）のプロファイルであるセキュアリアルタイムトランスポートプロトコル（SRTP）について説明します. リアルタイム転送制御プロトコル（RTCP）. 

目次

   1.はじめに. . . . . . . . . . . . . . . . . . . . . . . . . ３
       1.1. 表記規約. . . . . . . . . . . . . . . . . ３
   2.目標と機能. . . . . . . . . . . . . . . . . . . . . . 4
       2.1. 特徴 . . . . . . . . . . . . . . . . . . . . . . . . 5
   3. SRTPフレームワーク. . . . . . . . . . . . . . . . . . . . . . . . 5
       3.1. セキュアRTP. . . . . . . . . . . . . . . . . . . . . . . 6
       3.2. SRTP暗号化コンテキスト. . . . . . . . . . . . . . . 7
             3.2.1. 変換に依存しないパラメーター. . . . . . . . 8
             3.2.2. 変換に依存するパラメータ. . . . . . . . . 10
             3.2.3. SRTPパケットの暗号化コンテキストへのマッピング. 10
       3.3. SRTPパケット処理. . . . . . . . . . . . . . . . . 11
             3.3.1. パケットインデックスの決定、およびROC、s_lの更新. 13
             3.3.2. リプレイ保護. . . . . . . . . . . . . . . . 15
      3.4. セキュアRTCP. . . . . . . . . . . . . . . . . . . . . . . 15
        
   4.事前定義された暗号変換. . . . . . . . . . . . . 19
       4.1. 暗号化. . . . . . . . . . . . . . . . . . . . . . . 19
             4.1.1. カウンターモードのAES. . . . . . . . . . . . . . . 21
             4.1.2. f8モードのAES. . . . . . . . . . . . . . . . . 22
             4.1.3. NULL暗号. . . . . . . . . . . . . . . . . . . 25
       4.2. メッセージの認証と完全性. . . . . . . . . . 25
             4.2.1. HMAC-SHA1. . . . . . . . . . . . . . . . . . . . 25
       4.3. 鍵の導出. . . . . . . . . . . . . . . . . . . . . 26日
             4.3.1. 鍵導出アルゴリズム. . . . . . . . . . . . 26日
             4.3.2. SRTCP鍵導出. . . . . . . . . . . . . . 28
             4.3.3. AES-CM PRF. . . . . . . . . . . . . . . . . . . 28
   5.デフォルトおよび必須から実装への変換. . . . . . . . . 28
       5.1. 暗号化：AES-CMおよびNULL. . . . . . . . . . . . . . . 29日
       5.2. メッセージ認証/完全性：HMAC-SHA1. . . . . . . 29日
       5.3. 鍵の導出：AES-CM PRF. . . . . . . . . . . . . . . 29日
   6. SRTP変換の追加. . . . . . . . . . . . . . . . . . . . 29日
   7.根拠. . . . . . . . . . . . . . . . . . . . . . . . . . . 30
       7.1. キーの導出. . . . . . . . . . . . . . . . . . . . . 30
       7.2. ソルトキー. . . . . . . . . . . . . . . . . . . . . . . 30
       7.3. Universal Hashingからのメッセージ整合性. . . . . . . . 31
       7.4. データ発信元認証に関する考慮事項. . . . . . . . 31
       7.5. 短い長さゼロのメッセージ認証. . . . . . 32
   8.重要な管理上の考慮事項. . . . . . . . . . . . . . . . . 33
       8.1. キーを再入力します. . . . . . . . . . . . . . . . . . . . . . . 34
             8.1.1. 再入力のための<From、To>の使用. . . . . . . 34
       8.2. キー管理パラメーター. . . . . . . . . . . . . . . . 35
   9.セキュリティに関する考慮事項. . . . . . . . . . . . . . . . . . . . 37
       9.1. SSRCコリジョンと2タイムパッド. . . . . . . . . . . . . 37
       9.2. キーの用途. . . . . . . . . . . . . . . . . . . . . . . . 38
       9.3. RTPペイロードの機密性. . . . . . . . . . . 39
       9.4. RTPヘッダーの機密性. . . . . . . . . . . . 40
       9.5. RTPペイロードとヘッダーの整合性. . . . . . . . . 40
             9.5.1. 弱いまたはNullメッセージ認証のリスク. . . 42
             9.5.2. 暗黙的なヘッダー認証. . . . . . . . . 43
   10. Forward Error Correctionメカニズムとの相互作用. . . . . 43
   11.シナリオ. . . . . . . . . . . . . . . . . . . . . . . . . . 43
       11.1 ユニキャスト. . . . . . . . . . . . . . . . . . . . . . . . . 43
       11.2 マルチキャスト（1人の送信者）. . . . . . . . . . . . . . . . . 44
       11.3. 鍵の再生成とアクセス制御. . . . . . . . . . . . . . 45
       11.4. 基本的なシナリオの要約. . . . . . . . . . . . . . . 46
   12. IANAに関する考慮事項. . . . . . . . . . . . . . . . . . . . . . 46
   13.謝辞. . . . . . . . . . . . . . . . . . . . . . . 47
   14.参考文献. . . . . . . . . . . . . . . . . . . . . . . . . . 47
       14.1. 規範的な参照. . . . . . . . . . . . . . . . . . 47
       14.2. 有益な参照. . . . . . . . . . . . . . . . . 48
   付録A：インデックスを決定するための擬似コード. . . . . . . . . . 51
   付録B：テストベクトル. . . . . . . . . . . . . . . . . . . . . 51
       B.1. AES-f8テストベクトル. . . . . . . . . . . . . . . . . . . 51
        
       B.2. AES-CMテストベクトル. . . . . . . . . . . . . . . . . . . 52
       B.3. 鍵導出テストベクトル. . . . . . . . . . . . . . . 53
   著者のアドレス. . . . . . . . . . . . . . . . . . . . . . . . 55
   完全な著作権声明. . . . . . . . . . . . . . . . . . . . . 56
        
1.はじめに
このドキュメントでは、RTPトラフィックとRTPの制御トラフィックに機密性、メッセージ認証、および再生保護を提供できるリアルタイムトランスポートプロトコル（RTP）のプロファイルであるセキュアリアルタイムトランスポートプロトコル（SRTP）について説明します.  RTCP（リアルタイム転送制御プロトコル）[RFC3350]. 

SRTPは、RTPおよびRTCPストリームの暗号化とメッセージ認証のためのフレームワークを提供します（セクション3）. SRTPはデフォルトの暗号化トランスフォームのセットを定義し（セクション4および5）、将来新しいトランスフォームを導入できるようにします（セクション6）. 適切なキー管理（セクション7および8）により、SRTPはユニキャストおよびマルチキャストRTPアプリケーション（セクション11）に対して安全です（セクション9）. 

SRTPは、高スループットと低パケット拡張を実現できます. SRTPは、異種環境（有線ネットワークと無線ネットワークの混合）に適した保護であることが証明されています. そのような機能を取得するために、暗号化のための追加ストリーム暗号、メッセージ認証のためのキー付きハッシュベースの関数、およびSRTPのRTPシーケンス番号とインデックスに基づくシーケンス/同期の「暗黙の」インデックスに基づいて、デフォルトの変換が説明されていますセキュアRTCP（SRTCP）の番号. 

1.1. 表記規則
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます. 用語は、以下の例外を除いて[RFC2828]に準拠しています. 簡単にするために、ドキュメント全体で「ランダム」という用語を使用して、ランダムまたは疑似ランダムに生成された値を示します. 大量のランダムビットを取得するのは困難な場合があり、SRTPのセキュリティのために、擬似ランダム性で十分です[RFC1750]. 

慣例により、採用された表現はネットワークのバイト順です. つまり、左端のビット（オクテット）が最も重要なものです. XORとは、バイナリ文字列の2を法とするビット単位の加算を意味し、|| 連結を示します. つまり、C = A ||の場合 Bの場合、Cの最上位ビットはAのビットであり、Cの最下位ビットはBのビットと同じです. 16進数には0xがプレフィックスとして付加されます. 

「暗号化」という言葉には、NULLアルゴリズムの使用も含まれます（実際にはデータがクリアなままになります）. 

表記法を少し乱用して、「メッセージ認証」および「認証タグ」という用語を一般的な慣習として使用します. ただし、グループ通信などの一部の状況では、提供されるサービスは完全性保護のみであり、データ発信元認証ではありません. 

2.目標と機能
SRTPのセキュリティ目標は、以下を保証することです. 

* RTPおよびRTCPペイロードの機密性、および

* RTPおよびRTCPパケット全体の整合性と、再生されたパケットに対する保護. 

これらのセキュリティサービスはオプションであり、SRTCP整合性保護が必須であることを除いて、互いに独立しています（RTCPメッセージの悪意のあるまたは誤った変更は、RTPストリームの処理を妨害する可能性があります）. 

プロトコルのその他の機能的目標は次のとおりです. 

*新しい暗号化トランスフォームでアップグレードできるフレームワーク、

*低帯域幅コスト、つまり、RTPヘッダー圧縮効率を維持するフレームワーク

そして、事前定義された変換によってアサートされます：

*低い計算コスト、

*フットプリントが小さい（つまり、キーイング情報とリプレイリスト用のコードサイズとデータメモリが小さい）、

*帯域幅エコノミーの目標をサポートするための限定的なパケット拡張、

* RTPが使用する基礎となるトランスポート、ネットワーク、および物理層からの独立性、特にパケット損失と並べ替えに対する高い耐性. 

これらの特性により、SRTPは、有線シナリオと無線シナリオの両方でRTP / RTCPに適した保護スキームになります. 

2.1. 特徴
上記の直接的な目標に加えて、SRTPはいくつかの追加機能を提供します. 鍵管理の負担を軽減し、セキュリティをさらに高めるために導入されました. 以下が含まれます：

*単一の「マスターキー」は、SRTPストリームと対応するSRTCPストリームの両方について、機密性と完全性を保護するためのキー情報を提供できます. これは、鍵導出関数（セクション4.3を参照）によって実現され、マスター鍵から安全に導出された、それぞれのセキュリティプリミティブに「セッション鍵」を提供します. 

*さらに、キーの導出は、セッションキーを定期的に更新するように構成できます. これにより、固定キーによって生成される暗号文の量が制限され、攻撃者が暗号化して分析できます. 

*「ソルティングキー」は、事前計算および時間メモリのトレードオフ攻撃から保護するために使用されます[MF00] [BS00]. 

これらの機能の詳細な根拠はセクション7にあります. 

3. SRTPフレームワーク
RTPはReal-time Transport Protocol [RFC3550]です. SRTPをRTPのプロファイルとして定義します. このプロファイルは、RTPオーディオ/ビデオプロファイル[RFC3551]の拡張機能です. 明示的に言及されている場合を除き、SRTPセキュリティ機能が追加されたそのプロファイルのすべての側面が適用されます. 概念的には、SRTPは、RTPアプリケーションとトランスポート層の間に存在する「スタック内のバンプ」実装であると考えています. SRTPはRTPパケットをインターセプトし、送信側で同等のSRTPパケットを転送し、SRTPパケットをインターセプトして、同等のRTPパケットを受信側のスタックに渡します. 

Secure RTCP（SRTCP）は、SRTPがRTPに対して行うのと同じセキュリティサービスをRTCPに提供します. SRTCPメッセージ認証は必須であり、RTCPフィールドを保護してメンバーシップを追跡し、RTP送信者にフィードバックを提供するか、パケットシーケンスカウンターを維持します. SRTCPについては、セクション3.4で説明します. 

3.1. 安全なRTP
SRTPパケットのフォーマットを図1に示します. 

        0 1 2 3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ <+
     | V = 2 | P | X | CC | M | PT | シーケンス番号| |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
     | タイムスタンプ| |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
     | 同期ソース（SSRC）識別子| |
     + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |
     | 寄稿ソース（CSRC）識別子| |
     | .... | |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
     | RTP拡張（オプション）| |
   +> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+ |
   | | ペイロード... | |
   | | + ------------------------------- + |
   | | | RTPパディング| RTPパッド数| |
   +> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+-+ <+
   | 〜SRTP MKI（オプション）〜|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | ：認証タグ（推奨）：|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | |
   +-暗号化された部分*認証された部分--- +
        
図1. SRTPパケットのフォーマット. *暗号化された部分は、セクション4の定義済み変換のプレーンテキストと同じサイズです. 

SRTPパケットの「暗号化部分」は、同等のRTPパケットのRTPペイロード（存在する場合はRTPパディングを含む）の暗号化で構成されます. 暗号化された部分は、プレーンテキストの正確なサイズである場合と、大きい場合があります. 図1は、RTPの可能なパディングを含むRTPペイロードを示しています[RFC3550]. 

事前定義された暗号化トランスフォームはパディングを使用しません. これらの場合、RTPとSRTPのペイロードサイズは正確に一致します. SRTPに追加された新しい変換（セクション6に続く）は、パディングを必要とする場合があり、したがって、より大きなペイロードを生成する場合があります. RTPは独自のパディングフォーマットを提供します（図1を参照）. RTPヘッダーのパディングインジケーターにより、プレフィックスフリーコードを使用したパディングと比較してコンパクトさの点でメリットがあります. このRTPパディングは、パディングを必要とする変換のデフォルトの方法である必要があります. 変換は、他のパディング方法を指定してもよい（MAY）、次にパディングの量、形式、および処理を指定しなければならない（MUST）. パディングを使用する暗号化変換は、特にメッセージ認証が使用されない場合、微妙な攻撃に対して脆弱であることに注意することが重要です[V02]. 新しい暗号化トランスフォームの各仕様では、使用するパディングのセキュリティへの影響を慎重に検討して説明する必要があります. メッセージ認証コードは独自のパディングを定義するため、このデフォルトは認証トランスフォームには適用されません. 

OPTIONAL MKIおよびRECOMMENDED認証タグは、SRTPによって定義され、RTPにない唯一のフィールドです. 8ビットのアライメントのみが想定されます. 

MKI（マスターキー識別子）：構成可能な長さ、オプション. MKIは、キー管理によって定義、通知、および使用されます. MKIは、特定のパケットを認証および/または暗号化するセッションキーが導出されたマスターキーを識別します. MKIは、セクション3.2.3に従って識別されるSRTP暗号コンテキストを識別しないことに注意してください. MKIは、再キーイング、暗号化コンテキスト内の特定のマスターキーの識別（セクション3.2.1）の目的でキー管理によって使用される場合があります. 

認証タグ：構成可能な長さ、推奨. 認証タグは、メッセージ認証データを運ぶために使用されます. SRTPパケットの認証済み部分は、RTPヘッダーと、それに続くSRTPパケットの暗号化部分で構成されます. したがって、暗号化と認証の両方が適用される場合、暗号化は送信側で認証の前に適用され、受信側で逆に適用される必要があります. 認証タグはRTPヘッダーとペイロードの認証を提供し、シーケンス番号を認証することで間接的に再生保護を提供します. これは追加の保護を提供しないため、MKIは整合性保護されていないことに注意してください. 

3.2. SRTP暗号コンテキスト
各SRTPストリームでは、暗号化状態情報を維持するために送信側と受信側が必要です. この情報は「暗号化コンテキスト」と呼ばれます. 

SRTPは、セッションキーとマスターキーの2種類のキーを使用します. 「セッションキー」とは、暗号化変換（暗号化やメッセージ認証など）で直接使用されるキーを意味し、「マスターキー」とは、（キー管理プロトコルによって与えられる）ランダムなビット文字列を意味します. 暗号化された安全な方法でセッションキーが導出されます. 暗号化コンテキストのマスターキーとその他のパラメーターは、SRTPの外部にあるキー管理メカニズムによって提供されます. セクション8を参照してください. 

3.2.1. 変換に依存しないパラメーター
変換に依存しないパラメーターは、使用される特定の暗号化または認証変換とは無関係に、暗号化コンテキストに存在します. SRTPの暗号化コンテキストの変換に依存しないパラメーターは、次のもので構成されます. 

* 32ビットの符号なしロールオーバーカウンター（ROC）. これは、16ビットのRTPシーケンス番号が65,535を通過した後にゼロにリセットされた回数を記録します. SRTPがRTPパケットヘッダーから抽出するシーケンス番号（SEQ）とは異なり、ROCはSRTPによって維持されます（3.3.1項を参照）. 

所定のROCおよびRTPシーケンス番号に対応するSRTPパケットのインデックスを48ビット量として定義します

i = 2 ^ 16 * ROC + SEQ. 

*受信側のみ、16ビットのシーケンス番号s_l. これは、受信した最高のRTPシーケンス番号と見なすことができ（その処理についてはセクション3.3.1を参照）、メッセージ認証が推奨されているため、認証する必要があります. 

*暗号化アルゴリズムの識別子、つまり暗号とその動作モード、

*メッセージ認証アルゴリズムの識別子

*受信者のみが保持する再生リスト（認証と再生保護が提供されている場合）. 最近受信および認証されたSRTPパケットのインデックスが含まれます. 

* MKIがSRTPおよびSRTCPパケットに存在するかどうかに関するMKIインジケーター（0/1）、

* MKIインジケーターが1に設定されている場合、MKIフィールドの長さ（オクテット単位）、および（送信者にとって）現在アクティブなMKIの実際の値（MKIインジケーターの値と長さは、コンテキストの存続期間）、

*ランダムで秘密にしておかなければならないマスターキー

*マスターキーごとに、そのマスターキーで処理（送信）されたSRTPパケットの数のカウンターがあります（セキュリティに不可欠、セクション3.3.1および9を参照）. 

*非負の整数n_eおよびn_a. 暗号化およびメッセージ認証のためのセッションキーの長さを決定します. 

さらに、マスターキーごとに、SRTPストリームは次の関連する値を使用できます. 

*セッションキーのキー派生で使用されるマスターソルト. この値を使用する場合、ランダムにする必要がありますが、パブリックにすることもできます（MAY）. マスターソルトの使用を強くお勧めします. セクション9.2を参照してください. 「NULL」ソルトは00 ... 0として扱われます. 

*セット{1,2,4、...、2 ^ 24}の整数、「key_derivation_rate」. ここで、指定されていない値はゼロとして扱われます. 2のべき乗という制約は、セッションキーの導出の実装を簡略化します. セクション4.3を参照してください. 

* MKI値

* <From、To>値. マスターキーの有効期間を指定します. 範囲（範囲のエンドポイントを含む）内のマスターキーが有効である2つの48ビットインデックス値で表されます. <From、To>の使用については、セクション8.1.1を参照してください. <From、To>はMKIの代替であり、マスターキーが<From、To>範囲が定義されているSRTPセッションキーと1対1で対応していることを前提としています. 

SRTCPはデフォルトで、以下を除いてSRTPと暗号コンテキストを共有します. 

* RTCPインデックスは各SRTCPパケットで明示的に伝送されるため、ロールオーバーカウンターとs_l-valueを維持する必要はありません. 

*個別のリプレイリストが保持されます（リプレイ保護が提供されている場合）. 

* SRTCPは、そのキーで処理されたSRTCPパケットの数のカウントを維持するための手段として、マスターキー（SRTPのマスターキーと同じであっても、以下を参照）の個別のカウンターを維持します. 

特に、事前定義された変換（キーの派生を含む）が使用されているが、セッションキーはそのように共有してはならない場合、マスターキーはSRTPと対応するSRTCPの間で共有できることに注意してください. 

さらに、同期ソース（SSRC、RTPヘッダーの一部）で識別される、指定されたRTPセッション内のいくつかのSRTPストリームが、ほとんどの暗号コンテキストパラメーター（以下を含む）を共有する場合があります（セクション8および9.1を参照）. おそらくマスターキーとセッションキー）. このような場合、上記の通常のSRTP / SRTCPパラメータ共有と同様に、各ストリーム（SSRC）の個別のリプレイリストとパケットカウンタは引き続き維持する必要があります. また、個別のSRTPインデックスを維持する必要があります. 

上記のパラメーター（およびその他のSRTPパラメーター）のパラメーター、事前定義された変換、およびデフォルト値の概要は、セクション5および8.2にあります. 

3.2.2. 変換に依存するパラメーター
すべての暗号化、認証/整合性、および鍵導出パラメーターは、変換セクション（セクション4）で定義されます. そのようなパラメーターの典型的な例は、暗号のブロックサイズ、セッションキー、初期化ベクトル（IV）形成用のデータなどです. 将来のSRTP変換仕様には、その変換に追加の暗号化コンテキストのパラメーターがある場合は、それをリストするセクションを含める必要があります. 

3.2.3. SRTPパケットの暗号化コンテキストへのマッピング
各参加者のRTPセッションは、宛先トランスポートアドレスのペア（1つのネットワークアドレスとRTPおよびRTCPのポートペア）によって定義され[RFC3550]、マルチメディアセッションはRTPセッションのコレクションとして定義されることを思い出してください. たとえば、特定のマルチメディアセッションには、オーディオRTPセッション、ビデオRTPセッション、およびテキストRTPセッションを含めることができます. 

暗号化コンテキストは、トリプレットコンテキスト識別子によって一意に識別される必要があります. 

コンテキストID = <SSRC、宛先ネットワークアドレス、宛先トランスポートポート番号>

ここで、宛先ネットワークアドレスと宛先トランスポートポートは、SRTPパケット内のものです. この情報が提示されると、セクション3.2で説明されているように、キー管理は情報を含むコンテキストを返すと想定されます. 

上記のように、SRTPとSRTCPはデフォルトで暗号化コンテキストのパラメータの大部分を共有します. したがって、実際にSRTCPストリームの暗号コンテキストパラメータを取得することは、対応するSRTP暗号コンテキストへのバインディングを意味する場合があります. RTCPポートはRTPポートのみから直接推定できないため、このようなバインディングを保証するのは実装次第です. あるいは、鍵管理は、共通のパラメーター（マスター鍵など）を複製して、個別のSRTPコンテキストとSRTCPコンテキストを提供することを選択できます. 後者のアプローチでは、SRTPおよびSRTCPで、必要に応じて、たとえば個別の変換を使用することもできます. 1つの単一のRTPセッションの一部を形成する複数のSRTPストリームがキーやその他のパラメーターを共有する場合も、同様の考慮事項が発生します. 

特定のコンテキスト識別子に対応するパケットに対して有効なコンテキストが見つからない場合、そのパケットは破棄されなければなりません（MUST）. 

3.3. SRTPパケット処理
以下はSRTPに適用されます. SRTCPについては、セクション3.4で説明します. 

暗号化コンテキストの初期化がキー管理を介して行われたと想定すると、送信者はSRTPパケットを構築するために次のことを行う必要があります（SHALL）. 

1.セクション3.2.3の説明に従って、使用する暗号化コンテキストを決定します. 

2.セクション3.3.1で説明されているように、ロールオーバーカウンター、暗号化コンテキストの最大シーケンス番号、およびRTPパケットのシーケンス番号を使用して、SRTPパケットのインデックスを決定します. 

3.マスターキーとマスターソルトを決定します. これは、セクション8.1に従って、前のステップで決定されたインデックスまたは暗号化コンテキストの現在のMKIを使用して行われます. 

4.セクション4.3で説明されているように、セッションキーとセッションソルトを決定します（トランスフォームで使用されている場合）. ステップ2で決定されたインデックスを使用した暗号化コンテキストでマスターキー、マスターソルト、key_derivation_rate、およびセッションキー長を使用します. および3. 

5. RTPペイロードを暗号化して、パケットの暗号化部分を生成します（定義されている暗号については、セクション4.1を参照）. このステップでは、暗号化コンテキストで示されている暗号化アルゴリズム、セッション暗号化キー、およびステップ4で見つかったセッションソルト（使用されている場合）と、ステップ2で見つかったインデックスを使用します. 

6. MKIインジケーターが1に設定されている場合は、MKIをパケットに追加します. 

7.メッセージ認証の場合は、セクション4.2で説明されているように、パケットの認証済み部分の認証タグを計算します. この手順では、現在のロールオーバーカウンター、暗号化コンテキストで示される認証アルゴリズム、および手順4で見つかったセッション認証キーを使用します. 認証タグをパケットに追加します. 

8.必要に応じて、ステップ2で決定したパケットインデックスを使用して、セクション3.3.1のようにROCを更新します. 

SRTPパケットを認証および復号化するには、受信者は次のことを行う必要があります. 

1.セクション3.2.3の説明に従って、使用する暗号化コンテキストを決定します. 

2.セクション3.3.1のアルゴリズムを実行して、SRTPパケットのインデックスを取得します. セクション3.3.1で説明されているように、アルゴリズムは、ロールオーバーカウンターとSRTPパケットのシーケンス番号を持つ暗号化コンテキストの最大シーケンス番号を使用します. 

3.マスターキーとマスターソルトを決定します. コンテキストのMKIインジケーターが1に設定されている場合は、SRTPパケットでMKIを使用します. それ以外の場合は、セクション8.1に従って、前の手順のインデックスを使用します. 

4.セクション2と3で決定されたインデックス付きの暗号化コンテキストでマスターキー、マスターソルト、key_derivation_rate、およびセッションキーの長さを使用して、セクション4.3で説明されているように、セッションキーとセッションソルト（トランスフォームで使用される場合）を決定します.  . 

5.メッセージ認証とリプレイ保護については、まずステップ2で決定したリプレイリストとインデックスを使用して、パケットがリプレイされているかどうかを確認します（セクション3.3.2）. パケットがリプレイされていると判断された場合、パケットは破棄し、イベントをログに記録する必要があります. 

次に、ステップ2のロールオーバーカウンター、暗号化コンテキストに示されている認証アルゴリズム、およびステップ4のセッション認証キーを使用して、認証タグの検証を実行します. 結果が「認証失敗」の場合（セクション4.2を参照）、パケットは以降の処理から破棄されなければならず、イベントはログに記録されるべきです（SHOULD）. 

6.暗号化コンテキストで示されている復号化アルゴリズム、ステップ4で見つかったセッション暗号化キー、ソルト（使用されている場合）、ステップ2のインデックスを使用して、パケットの暗号化部分を復号化します（定義されている暗号については、セクション4.1を参照）.  . 

7.ステップ2で推定されたパケットインデックスを使用して、セクション3.3.1のように暗号化コンテキストでロールオーバーカウンターと最大シーケンス番号s_lを更新します. リプレイ保護が提供されている場合は、セクション3.3の説明に従ってリプレイリストも更新します.  2. 

8.存在する場合、パケットからMKIおよび認証タグフィールドを削除します. 

3.3.1. パケットインデックスの決定、およびROC、s_lの更新
SRTPの実装では、シーケンスに「暗黙の」パケットインデックスを使用します. つまり、すべてのインデックスがSRTPパケットで明示的に伝達されるわけではありません. 事前定義された変換の場合、インデックスiは、再生保護（セクション3.3.2）、暗号化（セクション4.1）、メッセージ認証（セクション4.2）、および鍵の派生（セクション4.3）で使用されます. 

セッションが開始すると、送信側はロールオーバーカウンターROCをゼロに設定する必要があります. RTPシーケンス番号SEQが2 ^ 16を法としてラップするたびに、送信側はROCを2 ^ 32を法として1ずつ増分する必要があります（以下のセキュリティの側面を参照）. 送信者のパケットインデックスは次のように定義されます. 

i = 2 ^ 16 * ROC + SEQ. 

受信側の実装では、RTPシーケンス番号を使用して、すべてのSRTPパケットのシーケンスにおけるパケットの場所であるパケットの正しいインデックスを決定します. ロールオーバーカウンターを適切に使用するための堅牢なアプローチでは、その取り扱いと使用法を明確に定義する必要があります. 特に、シーケンス番号が2 ^ 16またはゼロに近い順不同のRTPパケットは、適切に処理する必要があります. 

インデックスの推定値は、受信者がローカルに保持しているROCとs_lの値に基づいています. セッションのセットアップ時に、ROCをゼロに設定する必要があります. 進行中のセッションに参加する受信者には、鍵管理シグナリングなどの帯域外シグナリングを使用して、現在のROC値を指定する必要があります. さらに、受信者は最初の観測されたSRTPパケットのRTPシーケンス番号（SEQ）にs_lを初期化する必要があります（キー管理などの帯域外シグナリングによって初期値が提供されている場合を除く）. 

連続したSRTPパケットでは、受信者はインデックスをi = 2 ^ 16 * v + SEQとして推定する必要があります（SHOULD）. 

ここで、vは、セット{ROC-1、ROC、ROC + 1}（モジュロ2 ^ 32）から選択され、iが値2 ^ 16 * ROC + s_l（付録を参照）に最も近くなります. 疑似コード）. 

パケットが処理および認証された後（セッションのSRTPパケットに対して有効になっている場合）、受信者はvを使用して、次のようにs_lおよびROC変数を条件付きで更新する必要があります. v =（ROC-1）mod 2 ^ 32の場合、s_lまたはROCは更新されません. v = ROCの場合、SEQが現在のs_lより大きい場合に限り、s_lがSEQに設定されます. ROCに変更はありません. v =（ROC + 1）mod 2 ^ 32の場合、s_lはSEQに設定され、ROCはvに設定されます. 

キーの再生成が発生した後（新しいマスターキーに変更）、ロールオーバーカウンターは常に値のシーケンスを維持します. つまり、ゼロにリセットしてはなりません（MUST NOT）. 

ロールオーバーカウンターは32ビット長で、シーケンス番号は16ビット長なので、同じキーで保護できる特定のSRTPストリームに属するパケットの最大数は、事前定義された変換を使用して2 ^ 48です. その数のSRTPパケットが特定の（マスターまたはセッション）キーで送信された後、送信者はそのキーでこれ以上パケットを送信してはなりません（MUST NOT）. （SRTCPにも同様の制限があり、実際にはより制限的かもしれません. セクション9.2を参照してください. ）この制限は、暗号化キーが変更される前に通過できるトラフィック量に上限を設けることにより、セキュリティ上の利点を強化します. 鍵の再発行（セクション8.1を参照）は、この量のトラフィックの前にトリガーする必要があり、たとえば、セキュリティの向上とメディアへのアクセス制御のために、より早くトリガーする必要があります. 

受信側では、s_lとROCの更新に注意が必要です. メッセージ認証が存在しない場合、s_lの初期化もROC更新も完全に堅牢にすることはできません. 受信者の「暗黙のインデックス」アプローチは、パケットの並べ替えと損失が大きすぎず、ビットエラーが不幸な方法で発生しない限り、事前定義された変換に対して機能します. 特に、同期が失われる前に、2 ^ 15パケットが失われるか、パケットがシーケンスから2 ^ 15パケット外れている必要があります. このような大幅な損失または並べ替えは、RTPアプリケーション自体を混乱させる可能性があります. 

インデックス推定とROC更新のアルゴリズムは実装の問題であり、環境（たとえば、パケット損失率）と、同期が失われる可能性がある場合（初期シーケンス番号（ランダムに選択された場合）など）を考慮に入れる必要があります.  RTPによる）は事前にわかっていません（キー管理プロトコルでは送信されません）が、2 ^ 16を法としてラップする可能性があります. 

上記よりも精巧で堅牢な方式は、RTP独自の「ロールオーバーカウンター」の処理です. [RFC3550]の付録A.1を参照してください. 

3.3.2. リプレイ保護
安全な再生保護は、整合性保護が存在する場合にのみ可能です. 整合性保護だけではリプレイ攻撃に対するセキュリティを保証できないため、RTPとRTCPの両方にリプレイ保護を使用することをお勧めします. 

パケットは、敵対者によって格納されたときに「リプレイ」され、ネットワークに再注入されます. メッセージ認証が提供されると、SRTPは再生リストを介してそのような攻撃から保護します. 各SRTPレシーバーは、受信および認証されたすべてのパケットのインデックスを概念的に含むリプレイリストを維持します. 実際には、リストは「スライディングウィンドウ」アプローチを使用できるため、再生保護には一定量のストレージで十分です. SRTP-WINDOW-SIZEを超えてコンテキスト内のパケットインデックスよりも遅れているパケットインデックスが受信されたと見なすことができます. SRTP-WINDOW-SIZEは受信側の実装依存のパラメーターであり、少なくとも64でなければなりません. しかし、どちらをより高い値に設定してもかまいません. 

受信者は、着信パケットのインデックスをリプレイリストとウィンドウに対してチェックします. ウィンドウの前、またはウィンドウの内側にあるがまだ受信されていないインデックスを持つパケットのみが受け入れられます. 

パケットが認証された後（必要な場合は最初にウィンドウが先に移動されます）、再生リストは新しいインデックスで更新される必要があります（SHALL）. 

リプレイリストは、IPのセキュリティアーキテクチャ[RFC2401]で説明されているように、ビットマップを使用して受信されたパケットを表すことで効率的に実装できます. 

3.4. 安全なRTCP
セキュアRTCPは、セキュアRTPの定義に従います. SRTCPは、3つの必須の新しいフィールド（SRTCPインデックス、「暗号化フラグ」、および認証タグ）と1つのオプションフィールド（MKI）をRTCPパケット定義に追加します. 同等のSRTCPパケットを形成するために、3つの必須フィールドをRTCPパケットに追加する必要があります. 追加されたフィールドは、他のプロファイル固有の拡張に従います. 

[RFC3550]のセクション6.1によると、複合パケットにはREQUIREDパケット形式があります. SRTCPには、最初の部分が送信者レポートまたは受信者レポートである必要があるという意味で、その要件に従ってパケットを与える必要があります. ただし、そのセクションで指定されているRTCP暗号化プレフィックス（ランダムな32ビット量）は、そこに記載されているように、[RFC3550]で指定されている暗号化方法にのみ適用され、暗号化メカニズムでは必要ないため、使用しないでください.  SRTPで使用されます. 

      0 1 2 3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ <+
     | V = 2 | P | RC | PT = SRまたはRR | 長さ| |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
     | 送信者のSSRC | |
   +> + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |
   | 〜送信者情報〜|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | 〜レポートブロック1〜|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | 〜レポートブロック2〜|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | 〜...〜|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | | V = 2 | P | SC | PT = SDES = 202 | 長さ| |
   | + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |
   | | SSRC / CSRC_1 | |
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | 〜SDESアイテム〜|
   | + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |
   | 〜...〜|
   +> + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + |
   | | E | SRTCPインデックス| |
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ <+
   | 〜SRTCP MKI（オプション）〜|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | ：認証タグ：|
   | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+ |
   | |
   +-暗号化された部分認証された部分----- +
        
図2.セキュアなRTCPパケットのフォーマットの例. 送信者レポートとSDESパケットを含む、基盤となるRTCP複合パケットで構成されています. 

SRTCPパケットの暗号化部分は、最初のRTCPパケットから、つまり、9番目の（9）オクテットから複合パケットの終わりまで、同等の複合RTCPパケットのRTCPペイロードの暗号化（セクション4.1）で構成されます. SRTCPパケットの認証部分は、同等の（最終的には複合の）RTCPパケット、Eフラグ、およびSRTCPインデックス（暗号化がペイロードに適用された後）で構成されます. 

追加されたフィールドは次のとおりです. 

Eフラグ：1ビット、必須Eフラグは、現在のSRTCPパケットが暗号化されているか、暗号化されていないかを示します. [RFC3550]のセクション9.1では、複合RTCPパケットを2つの下位層パケットに分割できます. 1つは暗号化され、もう1つはクリアテキストで送信されます. 「1」に設定されたEビットは暗号化されたパケットを示し、「0」は非暗号化パケットを示します. 

SRTCPインデックス：31ビット、必須SRTCPインデックスは、SRTCPパケットの31ビットカウンターです. SRTPで使用される「暗黙の」インデックスアプローチとは対照的に、インデックスは各パケットに明示的に含まれます. SRTCPインデックスは、最初のSRTCPパケットが送信される前にゼロに設定されなければならず（MUST）、各SRTCPパケットが送信された後に2 ^ 31を法として1ずつ増加しなければなりません（MUST）. 特に、鍵の再生成後、SRTCPインデックスを再びゼロにリセットしてはなりません（MUST NOT）. 

認証タグ：構成可能な長さ、必須認証タグは、メッセージ認証データを運ぶために使用されます. 

MKI：構成可能な長さ、オプションMKIはマスターキーインジケータであり、セクション3のMKI定義に従って機能します. 

SRTCPは、デフォルトでSRTPの暗号化コンテキストパラメータとパケット処理を使用しますが、次の変更点があります. 

*インデックスはパケットで明示的に通知されるため、受信者はインデックスを「推定」する必要はありません. 

*事前定義されたSRTCP暗号化はセクション4.1で指定されているとおりですが、このセクションで提供されているSRTCP暗号化部分の定義を使用し、SRTCPインデックスをインデックスiとして使用します. 暗号化トランスフォームと関連パラメータは、デフォルトでは、関連付けられているSRTPストリームの保護のために選択されたものと同じである必要があります（SHALL）. 一方、NULLアルゴリズムは、暗号化されないRTCPパケットに適用されるものとします（SHALL）. SRTCPは、対応するSRTPで使用されるものとは異なる暗号化トランスフォームを持つ場合があります. この機能の予想される使用法は、前者にNULL暗号化があり、後者に非NULL暗号化がある場合です. 

Eフラグには、パケットが暗号化されているかどうかに応じて、送信者によって値が割り当てられます. 

* SRTCP復号化はセクション4と同様に実行されますが、Eフラグが1に等しい場合のみです. そうであれば、SRTCPインデックスをインデックスiとして使用して、暗号化部分が復号化されます. Eフラグが0の場合、ペイロードは変更されません. 

* SRTCPリプレイ保護はセクション3.3.2で定義されているとおりですが、SRTCPインデックスをインデックスiとして使用し、SRTCPに固有の個別のリプレイリストを使用します. 

*事前定義されたSRTCP認証タグはセクション4.2で指定されていますが、このセクションで指定されているSRTCPパケットの認証済み部分（インデックスを含む）を使用しています. 認証変換と関連パラメータ（たとえば、キーサイズ）は、デフォルトでは、関連するSRTPストリームの保護のために選択されたものと同じである必要があります. 

*処理の最後のステップでは、送信者だけが2 ^ 31を法としてインクリメントしてSRTCPインデックスの値を更新する必要があり、セキュリティ上の理由から、送信者は処理されたSRTCPパケットの数もチェックする必要があります. セクション9.2を参照してください. 

RTCPのメッセージ認証は、RTPの制御プロトコル（BYEパケットがあるなど）であるため、必須です. 

SRTCPでのパケット拡張（追加されたフィールドによる）が原因でSRTCPメッセージがRTCP帯域幅の共有を超えて使用しないように注意する必要があります. これを回避するには、次の2つの対策を講じる必要があります. 

1. [RFC3550]の6.3章で定義されているRTCP変数「avg_rtcp_size」を初期化する場合、SRTCPによって追加されるフィールドのサイズを含める必要があります（インデックス、Eビット、認証タグ、および存在する場合はMKI）.  . 

2.変数「packet_size」（[RFC3550]のセクション6.3.3）を使用して「avg_rtcp_size」を更新する場合、「packet_size」の値にはSRTCPによって追加された追加フィールドのサイズを含める必要があります. 

これらの対策を講じると、SRTCPメッセージは割り当てられた帯域幅を超えて使用することはありません. 追加されたフィールドのサイズがSRTCPトラフィックに及ぼす影響は、メッセージがより長いパケット間隔で送信されることです. 間隔の増加は、追加されたフィールドのサイズに正比例します. 事前定義された変換の場合、追加されるフィールドのサイズは少なくとも14オクテットであり、MKIおよび認証タグのサイズに応じて上限があります. 

4.事前定義された暗号化変換
SRTPで使用できる暗号化およびメッセージ認証アルゴリズムは多数ありますが、以下では、アルゴリズムとパラメーター識別子のシグナリングのエンコードを指定する複雑さを回避するために、デフォルトのアルゴリズムを定義します. 定義されたアルゴリズムは、セクション2にリストされている目標を達成するために選択されました. 新しい変換でSRTPを拡張する方法に関する推奨事項は、セクション6に記載されています. 

4.1. 暗号化
以下のパラメーターは、このセクションで指定されている、事前定義されたNULL以外の暗号化トランスフォームに共通です. 

* BLOCK_CIPHER-MODEは、使用されるブロック暗号とその動作モードを示します* n_bはブロック暗号のブロックのビットサイズです* k_eはセッション暗号化キーです* n_eはk_eのビット長です* k_sはセッションソルティングですkey * n_sはk_s * SRTP_PREFIX_LENGTHのビット長で、キーストリームプレフィックスのオクテット長であり、使用中のメッセージ認証コードで指定された負でない整数です. 

SRTP / SRTCPの個別のセッションキーとソルトは、セクション4.3で指定されているようにデフォルトで導出されます. 

SRTPで定義された暗号化トランスフォームは、SRTPパケットインデックスと秘密鍵を擬似ランダムキーストリームセグメントにマッピングします. 各キーストリームセグメントは、単一のRTPパケットを暗号化します. パケットを暗号化するプロセスは、パケットに対応するキーストリームセグメントを生成し、そのキーストリームセグメントをRTPパケットのペイロードにビット単位で排他的論理和演算して、SRTPパケットの暗号化部分を生成することで構成されます. ペイロードサイズがn_bビットの整数倍でない場合、キーストリームの超過（最下位）ビットは単に破棄されます. 復号化も同じ方法で行われますが、平文と暗号文の役割を入れ替えます. 

   + ---- + + ------------------ + ------------------------ --------- +
   | KG |-> | キーストリームプレフィックス| キーストリームサフィックス| --- +
   + ---- + + ------------------ + ------------------------ --------- + |
                                                                     |
                               + --------------------------------- + v
                               | RTPパケットのペイロード|->（*）
                               + --------------------------------- + |
                                                                     |
                               + --------------------------------- + |
                               | SRTPパケットの暗号化された部分| <-+
                               + --------------------------------- +
        
図3：デフォルトのSRTP暗号化処理. ここで、KGはキーストリームジェネレーターを示し、（*）はビット単位の排他的論理和を示します. 

インデックスが与えられた場合のキーストリームの生成方法の定義は、暗号とその動作モードによって異なります. 以下では、そのような2つのキーストリームジェネレータが定義されています. NULL暗号も定義されており、RTPの暗号化が不要な場合に使用されます. 

キーストリームのSRTP定義を図3に示します. 各キーストリームセグメントの最初のオクテットは、メッセージ認証コードで使用するために予約される場合があります. その場合、暗号化に使用されるキーストリームは、最後に予約されたオクテットの直後から始まります. 最初に予約されたオクテットは「キーストリームプレフィックス」（[RFC3550、セクション6.1]の「暗号化プレフィックス」と混同しないでください）と呼ばれ、残りのオクテットは「キーストリームサフィックス」と呼ばれます. キーストリームプレフィックスは暗号化に使用してはなりません（MUST NOT）. このプロセスを図3に示します. 

キーストリームプレフィックスのオクテット数はSRTP_PREFIX_LENGTHとして示されます. キーストリームプレフィックスは、SRTP_PREFIX_LENGTHのゼロ以外の正の値で示されます. つまり、機密性を提供しない場合でも、パケット認証のためにキーストリームジェネレーターの出力を計算する必要がある場合があります. その場合、デフォルトのキーストリームジェネレーター（モード）を使用する必要があります. 

デフォルトの暗号はAdvanced Encryption Standard（AES）[AES]であり、AESを実行する2つのモード、（1）セグメント化整数カウンターモードAESおよび（2）f8モードのAESを定義します. このセクションの残りの部分では、E（k、x）をキーkと入力ブロックxに適用されるAESとします. 

4.1.1. カウンターモードのAES
概念的には、カウンターモード[AES-CTR]は、連続する整数の暗号化で構成されます. 整数シーケンスの開始点をランダム化するために、実際の定義は少し複雑です. 各パケットは、個別のキーストリームセグメントで暗号化されます. セグメントは次のように計算する必要があります. 

キーストリームセグメントは、ブロックインデックスが昇順であるキーk = k_eを使用して、AES暗号の128ビット出力ブロックを暗号化方向に連結したものである必要があります（SHALL）. 象徴的には、各キーストリームセグメントは次のようになります. 

E（k、IV）|| E（k、IV + 1 mod 2 ^ 128）|| E（k、IV + 2 mod 2 ^ 128）...

128ビット整数値IVは、以下のように、SSRC、SRTPパケットインデックスi、およびSRTPセッションソルティングキーk_sで定義する必要があります. 

      IV =（k_s * 2 ^ 16）XOR（SSRC * 2 ^ 64）XOR（i * 2 ^ 16）
        
上記のXOR合計の3つの項のそれぞれには、操作を明確にするために必要な数の先行ゼロが埋め込まれ、128ビット値と見なされます. 

SSRCを含めると、同じキーを使用して、同じRTPセッション内の個別のSRTPストリームを保護できます. セクション9.1のセキュリティに関する警告を参照してください. 

SRTCPの場合、複合パケットの最初のヘッダーのSSRCを使用する必要があります. iは31ビットSRTCPインデックスである必要があり、k_e、k_sはSRTCP暗号化セッションキーとソルトで置き換える必要があります. 

初期値IVはパケットごとに固定され、カウンタの目的で最下位ビットの16個のゼロを「予約」することによって形成されることに注意してください. IVの固定値に対して生成されたキーストリームのブロック数は、キーストリームの再利用を避けるために2 ^ 16を超えてはなりません. 以下を参照してください. AESのブロックサイズは128ビットなので、最大のRTPパケットを暗号化するために必要なキーストリームの2 ^ 23ビットを生成するには2 ^ 16出力ブロックで十分です（IPv6の「ジャンボグラム」[RFC2675]を除く）.  RTPベースのマルチメディアトラフィックに使用されます）. 暗号化できるパケットの最大ビットサイズに対するこの制限は、確率的攻撃の効果を制限することによって暗号化方法のセキュリティを確保します[BDJR]. 

特定のカウンターモードキーの場合、入力として使用される各IV値は、2回のパッド状況（セクション9.1）のセキュリティ上の露出を回避するために、区別する必要があります. この制約を満たすために、実装はROCのSRTPパケットインデックスの組み合わせを保証する必要があります|| SEQ、およびIVの構築に使用されるSSRCは、特定のキーに対して異なります. この一意性を保証できないことは、Secure RTPにとって致命的となる可能性があります. これは、RTP自体の状況とは対照的です. RTP自体は、そのような障害を許容できる可能性があります. 専用のセキュリティモジュールが存在する場合は、RTPシーケンス番号とSSRCがそのモジュールによって生成またはチェックされることをお勧めします（つまり、SRTPシステムでのシーケンス番号とSSRC処理はキーと同様に保護する必要があります）.  . 

4.1.2. f8モードのAES
UMTS（3Gネットワ​​ークとしてのユニバーサルモバイルテレコミュニケーションシステム）データを暗号化するために、f8-アルゴリズムとして知られるソリューション（[f8-a] [f8-b]を参照）が開発されました. 高レベルでは、提案された方式は出力フィードバックモード（OFB）[HAC]の変形であり、より複雑な初期化とフィードバック機能を備えています. 通常のOFBと同様に、コアはブロック暗号で構成されます. ここでは、AESの使用を、「f8モードの操作」RTP暗号化と呼ばれるもので使用されるブロック暗号として定義します. AES f8モードは、セッションキーとソルトにAESカウンターモードと同じデフォルトサイズを使用する必要があります（SHALL）. 

図4は、f8モードで実行されるブロック暗号Eの構造を示しています. 

                    IV
                    |
                    v
                + ------ +
                | |
           + ---> | E |
           | + ------ +
           | |
     m->（*）+ ----------- + ------------- +-... ------ +
           | IV '| | | |
           | | j = 1->（*）j = 2->（*）... j = L-1->（*）
           | | | | |
           | | +->（*）+->（*）... +->（*）
           | | | | | | | |
           | v | v | v | v
           | + ------ + | + ------ + | + ------ + | + ------ +
    k_e --- + ---> | E | | | E | | | E | | | E |
                | | | | | | | | | | |
                + ------ + | + ------ + | + ------ + | + ------ +
                    | | | | | | |
                    + ------ + + -------- + +-... ---- + |
                    | | | |
                    vvvv
                   S（0）S（1）S（2）. . . S（L-1）
        
図4. f8モードの動作（アスタリスク（*）、ビット単位のXORを表す）. この図は、AES-f8を使用した場合の図3のKGを表しています. 

4.1.2.1. f8キーストリームの生成
初期化ベクトル（IV）は、セクション4.1.2.2（およびセクションSRSRTCPの場合はセクション4.1.2.3）の説明に従って決定する必要があります（SHALL）. 

   IV '、S（j）、およびmがn_bビットブロックを表すとします. キーストリーム、
   S（0）|| ... || S（L-1）、Nビットメッセージの場合、
   IV '= E（k_e XOR m、IV）、およびS（-1）= 00..0を設定します. ために
   j = 0,1、..、L-1ここで、L = N / n_b（それが最も近い整数に切り上げられる）
   まだ整数ではありません）計算
        
            S（j）= E（k_e、IV 'XOR j XOR S（j-1））
        
IVは直接使用されないことに注意してください. 代わりに、別のキーの下でEを介して供給され、内部の「マスクされた」値（IV 'と表示）を生成して、攻撃者が既知の入力/出力ペアを取得するのを防ぎます. 

内部カウンターjの役割は、短いキーストリームサイクルを防ぐことです. キーマスクの値mは

m = k_s || 0x555..5、

つまり、セッションソルティングキー. バイナリパターン0101 ..によって追加され、希望するキーサイズn_e全体を埋めます. 

送信者は、2 ^ 32ビットを超えるブロックを生成するべきではありません. これは、2 ^ 39ビットのキーストリームを生成するのに十分です. カウンターモードとは異なり、f8が安全でない（安全である）ことが保証されている絶対的なしきい値の上（下）はありません. 上記の制限は、十分なセキュリティマージンを確保して、f8キーストリーム生成における縮退動作の確率を制限するために選択されています. 

4.1.2.2. f8 SRTP IVフォーメーション
次のIV形成の目的は、暗黙ヘッダー認証（IHA）と呼ばれる機能を提供することです. セクション9.5を参照してください. 

128ビットブロックAES-f8のSRTP IVは、次の方法で形成する必要があります. 

IV = 0x00 || M || PT || シーケンス|| TS || SSRC || ROC

M、PT、SEQ、TS、SSRCは、RTPヘッダーから取得する必要があります. ROCは暗号化コンテキストからのものです. 

IVの一部としてSSRCが存在することにより、同じRTPセッション内の複数のストリーム間でマスターキーが共有されている場合にAES-f8を使用できます. セクション9.1を参照してください. 

4.1.2.3. f8 SRTCP IVフォーメーション
128ビットブロックAES-f8のSRTCP IVは、次の方法で形成する必要があります. 

IV = 0..0 || E || SRTCPインデックス|| V || P || RC || PT || 長さ|| SSRC

ここで、V、P、RC、PT、長さ、SSRCは、RTCP複合パケットの最初のヘッダーから取得する必要があります. EおよびSRTCPインデックスは、パケットに追加される1ビットおよび31ビットのフィールドです. 

4.1.3. NULL暗号
NULL暗号は、RTP / RTCPの機密性が要求されない場合に使用されます. キーストリームは「000..0」と考えることができます. つまり、暗号化はプレーンテキスト入力を暗号テキスト出力に単にコピーする必要があります. 

4.2. メッセージ認証と完全性
このセクション全体で、Mは整合性保護されるデータを示します. SRTPの場合、Mは、ROCと連結されたパケットの認証済み部分（図1で指定）で構成されている必要があります. M=認証済み部分|| ROC; SRTCPの場合、Mは認証された部分（図2で指定）のみで構成される必要があります（SHALL）. 

共通パラメーター：

* AUTH_ALGは認証アルゴリズムです* k_aはセッションメッセージ認証キーです* n_aは認証キーのビット長です* n_tagは出力認証タグのビット長です* SRTP_PREFIX_LENGTHは上記で定義したキーストリームプレフィックスのオクテット長です、AUTH_ALGのパラメーター

SRTP / SRTCPの個別のセッション認証キーは、セクション4.3で指定されているようにデフォルトで導出されます. 

n_a、n_tag、およびSRTP_PREFIX_LENGTHの値は、キーの特定の固定値に対して固定する必要があります. 

認証タグの計算プロセスを以下に説明します. 送信者はMのタグを計算し、それをパケットに追加します. SRTPレシーバーは、選択したアルゴリズムとキーを使用してMで新しい認証タグを計算することによりメッセージ/認証タグのペアを検証し、受信したメッセージに関連付けられているタグと比較します. 2つのタグが等しい場合、メッセージ/タグのペアは有効です. それ以外の場合は無効であり、エラー監査メッセージ「AUTHENTICATION FAILURE」を返す必要があります. 

4.2.1. HMAC-SHA1
SRTPの事前定義された認証変換はHMAC-SHA1 [RFC2104]です. HMAC-SHA1の場合、SRTP_PREFIX_LENGTH（図3）は0でなければなりません. SRTP（またはSRTCP）の場合、HMACはセッション認証キーと上記で指定されたMに適用される必要があります（HMAC（k_a、M））. 次に、HMAC出力は、n_tagの左端のビットに切り捨てられる必要があります（SHALL）. 

4.3. 鍵導出
4.3.1. 鍵導出アルゴリズム
採用されている暗号化またはメッセージ認証変換（SRTP定義済み変換、またはセクション6に従って新しく導入されたもの）に関係なく、相互運用可能なSRTP実装は、SRTP鍵導出を使用してセッション鍵を生成する必要があります. セッションの開始時に鍵導出レートが適切に通知されると、SRTP鍵導出を使用する当事者間で追加の通信を行う必要はありません. 

                         パケットインデックス--- +
                                         |
                                         v
               + ----------- +マスター+ -------- +セッションencr_key
               | ext | キー| | ---------->
               | キー管理| --------> | キー| セッションauth_key
               | （オプション| |派生| ---------->
               | rekey）| --------> | | セッションsalt_key
               | | マスター| | ---------->
               + ----------- +塩+ -------- +
        
図5：SRTPキーの派生. 

少なくとも1つの初期キーの導出はSRTPによって実行される必要があります. つまり、最初のキーの導出が必要です. 暗号化コンテキストの「key_derivation_rate」値に従って、鍵導出のさらなるアプリケーションが実行される場合があります. 鍵導出関数は最初のパケットの前に最初に呼び出されなければならず（SHALL）、次にr> 0の場合、インデックスmod rがゼロに等しいときはいつでも鍵導出が実行されます. これは、セッションキーの「更新」と考えることができます. 「key_derivation_rate」の値は、関連付けられたマスターキーの有効期間中、固定しておく必要があります. 

相互運用可能なSRTP実装は、事前に定義された両方の変換で行われるように、暗号化変換のセッションソルティングキーを導出することもできます（MAY）. 

mとnを正の整数とします. 疑似ランダム関数ファミリーは、キー付き関数のセット{PRF_n（k、x）}であり、（秘密の）ランダムキーkに対して、mビットxが与えられた場合、PRF_n（k、x）はnビット文字列です. 計算上、ランダムなnビット文字列と区別できません. [HAC]を参照してください. SRTPでの鍵導出の目的のために、m = 128（またはそれ以上）の安全なPRFを使用する必要があり、デフォルトのPRF変換はセクション4.3.3で定義されています. 

「a DIV t」は、tによる整数の除算を示し、切り捨てられ、すべてのaについて「a DIV 0 = 0」という規則に従います. また、「a DIV t」をaと同じ長さのビット文字列として扱うという慣例を採用しているため、「a DIV t」は一般に先行ゼロを持ちます. 

鍵の導出は、暗号コンテキストで決定される<label>、8ビット定数（下記参照）、master_saltおよびkey_derivation_rateの観点から次のように定義する必要があります（SHALL）.  | SRTPのSEQ）：

* r =インデックスDIV key_derivation_rateとします（上記で定義したDIVを使用）. 

* key_id = <label> ||とします r. 

* x = key_id XOR master_saltとします. key_idとmaster_saltは、最下位ビットが一致するように整列されます（右揃え）. 

<label>は、派生するキーのタイプごとに一意である必要があります. 現在<label> 0x00〜0x05（下記参照）を定義しており、将来の拡張では、他の目的のために0x06〜0xffの範囲の新しい値を指定する場合があります. このパケットのnビットSRTPキー（またはソルト）は、次のようにマスターキーk_masterから派生する必要があります. 

PRF_n（k_master、x）. 

（PRFは、xの追加のフォーマットとパディングを内部的に指定する場合があります. たとえば、デフォルトのPRFについてはセクション4.3.3を参照してください. ）

セッションキーとソルトは以下を使用して派生する必要があります. 

-k_e（SRTP暗号化）：<ラベル> = 0x00、n = n_e. 

-k_a（SRTPメッセージ認証）：<ラベル> = 0x01、n = n_a. 

-k_s（SRTPソルト化キー）：<label> = 0x02、n = n_s. 

ここで、n_e、n_s、およびn_aは暗号化コンテキストからのものです. 

マスターキーとマスターソルトはランダムである必要がありますが、マスターソルトは公開される場合があります. 

key_derivation_rateが0の場合、キーの派生の適用は1回だけ行われる必要があることに注意してください. 

上記のDIVの定義は、純粋に表記上の便宜のためです. 許可された鍵導出率のセットの中で非ゼロのtの場合、「a DIV t」は、tの2を底とする対数による右シフトとして実装できます. レートが256の累乗になるように選択されている場合、導出操作はさらに容易になりますが、その粒度は粗すぎて、この仕様の要件にはならないと考えられていました. 

同じマスターキー（セクション9.2を参照）を使用して保護できるパケット数の上限は、キーの派生とは無関係です. 

4.3.2. SRTCPキーの派生
SRTCPはデフォルトでSRTPと同じマスターキー（およびマスターソルト）を使用する必要があります. これを安全に行うには、SRTCPにセッションキーの派生を適用するときに、セクション4.3.1の定義に次の変更を加える必要があります. 

SRTPインデックスを32ビット量に置き換えます：0 || SRTCPインデックス（つまり、Eビットを除外し、固定の0ビットで置き換えます）. SRTCP暗号化キーには<label> = 0x03、SRTCP認証キーには<label> = 0x04、および<label> = 0x05、SRTCPソルティングキー. 

4.3.3. AES-CM PRF
現在定義されているPRFは、128、192、または256ビットのマスターキーでキー設定され、入力ブロックサイズがm = 128であり、nが最大2 ^ 23のnビット出力を生成できます. PRF_n（k_master、x）は、セクション4.1.1で説明されているように、カウンターモードでAESである必要があり、キーk_masterに適用され、IVが（x * 2 ^ 16）に等しく、出力キーストリームが最初にnに切り捨てられます（左ほとんど）ビット. （n / 128、切り上げ、AESの適用が必要です. ）

5.デフォルトおよび必須から実装への変換
デフォルトのトランスフォームは、SRTPの必須から実装へのトランスフォームでもあります. もちろん、「実施義務」は「使用義務」を意味するものではありません. 表1は、事前定義された変換を要約したものです. 以下のデフォルト値は、事前定義された変換に有効です. 

必須から実装へ. オプションのデフォルト

暗号化AES-CM、NULL AES-f8 AES-CMメッセージ整合性HMAC-SHA1-HMAC-SHA1鍵導出（PRF）AES-CM-AES-CM

表1：SRTPおよびSRTCPでの必須から実装、オプション、およびデフォルトの変換. 

5.1. 暗号化：AES-CMおよびNULL
セグメント化整数カウンターモードで実行されているAESは、セクション4.1.1で定義されているように、デフォルトの暗号化アルゴリズムである必要があります. デフォルトのキーの長さは、セッション暗号化キー（n_e）の128ビットである必要があります（SHALL）. デフォルトのセッションソルトキーの長さ（n_s）は112ビットである必要があります. 

NULL暗号は、実装に必須である必要があります（SHALL）. 

5.2. メッセージ認証/完全性：HMAC-SHA1
セクション4.2.1で定義されているHMAC-SHA1は、デフォルトのメッセージ認証コードである必要があります. HMAC-SHA1の場合、デフォルトのセッション認証キーの長さ（n_a）は160ビットである必要があり、デフォルトの認証タグの長さ（n_tag）は80ビットである必要があり、SRTP_PREFIX_LENGTHはゼロである必要があります. さらに、SRTCPの場合、事前定義されたHMAC-SHA1は、これらのデフォルトよりも小さいn_tagまたはn_aの値で適用してはなりません（MUST NOT）. SRTPの場合、小さい値は推奨されませんが、セクション7.5および9.5の問題を慎重に検討した後で使用できます（MAY）. 

5.3. 鍵の導出：AES-CM PRF
セクション4.3.1から4.3.3で定義された128ビットのマスターキーを使用したAESカウンターモードベースのキーの導出とPRFは、セッションキーを生成するためのデフォルトの方法です. デフォルトのマスターソルト長は112ビットである必要があり、デフォルトの鍵導出率はゼロである必要があります. 

6. SRTP変換の追加
セクション4では、変換の定義に必要な詳細レベルの例を示します. 新しいトランスフォームをSRTPに追加する場合は常に、新しいトランスフォームをSRTP（およびSRTCP）でどのように使用できるかを正確に定義するために、対応する標準トラックRFCを記述する必要があります. このようなコンパニオンRFCは、SRTPプロトコルドキュメントとの重複を回避する必要があります（SHOULD）. ただし、SRTPまたはSRTCP暗号化コンテキスト定義を新しいパラメーター（固定値またはデフォルト値を含む）で拡張したり、パケット処理にステップを追加したり、SRTP / SRTCPパケットにフィールドを追加したりする必要がある場合があります. コンパニオンRFCは、変換とSRTPの他の側面との間の相互作用に関する既知の問題について説明する必要があります（SHALL）. 

新しい変換ドキュメントはそれぞれ、そのキー属性を指定する必要があります. たとえば、キーのサイズ（最小、最大、推奨）、キーの形式、入力キーイングマテリアルの推奨/必須処理、キーの有効期間に関する要件/推奨事項、キーの再生成とキーの派生、 SRTPとSRTCPの間での鍵の共有が許可されているかどうかなど. 

追加されたメッセージ整合性変換は、SRTCPの最小許容キー/タグサイズを定義する必要があります. これは、セクション5.2で定義されている最小値と同等の強度です. 

7.根拠
このセクションでは、SRTPのいくつかの重要な機能の背後にある根拠について説明します. 

7.1. キーの導出
鍵導出は、鍵確立の負担を軽減します. 暗号化コンテキストごとに最大6つの異なるキー（SRTPおよびSRTCP暗号化キーとソルト、SRTPおよびSRTCP認証キー）が必要ですが、これらは単一のマスターキーから暗号的に安全な方法で導出されます. したがって、鍵管理プロトコルは1つのマスター鍵（および必要に応じてマスターソルト）のみを交換する必要があり、SRTP自体が必要なすべてのセッション鍵を（鍵導出関数の最初の必須アプリケーションを介して）導出します. 

キー導出関数の複数のアプリケーションはオプションですが、有効にするとセキュリティ上の利点が得られます. それらは、攻撃者が単一の固定セッションキーによって生成された大量の暗号文を取得することを防ぎます. 攻撃者が特定のセッションキーの大量の暗号文を収集できた場合、攻撃者は特定の攻撃を仕掛ける手助けとなる可能性があります. 

鍵導出機能の複数のアプリケーションは、侵害されたセッション鍵が同じマスター鍵から派生した他のセッション鍵を侵害し​​ないという意味で、後方および前方のセキュリティを提供します. つまり、特定のセッションキーを回復できる攻撃者は、とにかく（同じマスターキーから派生した）前および後のセッションキーで保護されたメッセージにアクセスすることができません. （もちろん、リークされたマスターキーは、そこから派生したすべてのセッションキーを明らかにします. ）

特に大規模なマルチキャスト設定では、高頻度のキー更新に注意が必要です. セクション11を参照してください. 

7.2. ソルティングキー
マスターソルトは、キーの派生に対するオフラインのキー衝突攻撃に対するセキュリティを保証します. そうしないと、有効なキーサイズ[MF00]が減少する可能性があります. 

暗号化で使用される派生セッションソルティングキーは、追加ストリーム暗号に対するいくつかの攻撃から保護するために導入されました. セクション9.2を参照してください. EXP IV中の塩の合法封入方法は、ハードウェアの実装を容易にするために選択されています. 

7.3. ユニバーサルハッシュによるメッセージの整合性
セクション4.1（キーストリームプレフィックス）で与えられるキーストリームの特定の定義は、Wegman-Carterパラダイム[WC81]でのメッセージ認証に適した特定のユニバーサルハッシュ関数を提供することです. このような機能は、安全性が高く、シンプルで、迅速であり、特に、デジタル信号プロセッサや、高速乗算演算を行うその他のプロセッサに適しています. 

SRMACでは、HMAC-SHA1以外の認証変換は現在提供されていません. 上記のユニバーサルハッシュ関数のような将来の変換は、セクション6のガイドラインに従って追加される場合があります. 

7.4. データ発信元認証の考慮事項
ペアワイズ通信では、整合性とデータ発信元認証が一緒に提供されることに注意してください. ただし、キーがメンバー間で共有されるグループシナリオでは、MACタグは、グループのメンバーがパケットを送信したことを証明するだけで、メンバーが別のユーザーになりすますことを防ぎません. マルチキャストおよびグループRTPセッションのデータ発信元認証（DOA）は、解決策を必要とする難しい問題です. いくつかの有望な提案が調査されていますが[PCST1] [PCST2]、これらの技術を厳密に指定するにはさらに作業が必要です. したがって、グループでのSRTPデータ送信元認証は、今後の検討課題です. 

それ以外の場合、署名を使用してDOAを実行できます. ただし、これは帯域幅と処理時間の点で大きな影響を与えるため、事前定義されたパケット整合性変換ではこの形式の認証を提供していません. 

RTPペイロードやRTPヘッダーが操作された場合、ミキサーとトランスレーターが存在するため、データ発信元認証は許可されません. これらのタイプの中間エンティティは、エンドツーエンドの機密性も破壊することに注意してください（IVの形成は、たとえばRTPヘッダーの保持に依存するため）. 特定の信頼モデルは、ミキサー/トランスレーターを信頼してメディアを復号化/再暗号化することを選択する場合があります（これは、エンドツーエンドのセキュリティを破壊することを意味し、関連するセキュリティ上の影響を伴います）. 

7.5. 短い長さゼロのメッセージ認証
図1に示すように、認証タグはSRTPで推奨されています. 完全な80ビットの認証タグを使用する必要があります（SHOULD）が、次の2つのアプリケーション環境のいずれかをサポートするために、特定の条件下では短いタグまたは長さゼロのタグ（つまり、メッセージ認証なし）を使用できます. 

1.帯域幅の確保が不可欠な環境では、強力な認証は非現実的です. 重要な特殊なケースは、ワイヤレス通信システムで、帯域幅は希少で高価なリソースです. 調査によると、特定のアプリケーションとリンクテクノロジーでは、バイトを追加すると、スペクトル効率が大幅に低下する可能性があります[SWO]. スペクトル効率を改善するためにIPヘッダー圧縮技術を設計するためにかなりの努力がなされてきました[RFC3095]. 一般的な音声アプリケーションは20バイトのサンプルを生成し、RTP、UDP、およびIPヘッダーは、許容できる無線帯域幅の経済性を実現するために、平均で1バイトまたは2バイトにまとめて圧縮する必要があります[RFC3095]. この場合、強力な認証では50％近くのオーバーヘッドが発生します. 

2.認証は、認証タグが原因で拡張に対応できない固定幅フィールドを持つデータリンクを使用するアプリケーションでは実用的ではありません. これは、いくつかの重要な既存のワイヤレスチャネルの場合です. たとえば、ゼロバイトヘッダー圧縮は、EVRC / SMV音声をCDMA2000 VoIPサービスのレガシーIS-95ベアラーチャネルに適合させるために使用されます. 単一の追加オクテットをデータに追加できないことが判明したため、ROHC [RFC3242]のゼロバイトプロファイルの作成が動機付けられました. 

短いタグは、制限された一連のアプリケーションに対して安全です. たとえば、32ビットのメッセージ認証タグで保護された20ミリ秒のパケット化間隔を持つG.729オーディオコーデックなどの音声テレフォニーアプリケーションについて考えてみます. 特定のパケットが正常に偽造される可能性は2 ^ 32に1つだけです. したがって、攻撃者が制御できるオーディオ出力は、平均して、994日間で20ミリ秒です. 対照的に、アプリケーションがステートフルの場合、単一の偽造パケットの影響ははるかに大きくなる可能性があります. パケット間で相対的または予測的な圧縮を使用するコーデックは、悪意を持って生成された状態を伝播し、出力の持続時間を長くします. 

確かに、すべてのSRTPまたはテレフォニーアプリケーションが、短いまたは長さがゼロの認証タグの基準を満たしているわけではありません. セクション9.5.1は、メッセージ認証が弱い、またはまったくない場合のリスクについて説明し、セクション9.5は、それが受け入れられる場合と受け入れられない場合の状況について説明しています. 

8.重要な管理上の考慮事項
SRTP暗号化コンテキスト（SRTPマスターキーなど）を確立するための新しいキー管理標準[MIKEY] [KEYMGT] [SDMS]があります. 独自仕様のオープン管理キー管理方法も、テレフォニーアプリケーション[MIKEY] [KINK]およびマルチキャストアプリケーション[GDOI]で使用される可能性があります. このセクションでは、SRTPセッションを処理するキー管理システムのガイダンスを提供します. 

初期化の場合、相互運用可能なSRTP実装には、SSRCを指定する必要があり（SHOULD）、キー管理によってRTPストリームの初期RTPシーケンス番号を指定できます（したがって、キー管理はRTP操作パラメーターに依存します）. キー管理でのRTPシーケンス番号の送信は、たとえば、初期シーケンス番号がラッピングに近い場合（同期の問題を回避するため）、および現在のシーケンス番号を参加エンドポイントに通知する場合（再生リストを適切に初期化する場合）に役立ちます. 

事前定義された変換が使用される場合、SRTPにより、同じRTPセッションに属するSRTP / SRTCPストリーム間で同じマスターキーを共有できます. 

まず、同じRTPセッションに属するSRTPストリーム間での共有は、同期メカニズム、つまりIVの設計がキーストリームの再利用を回避する場合に安全です（2タイムパッド、セクション9.1）. これは、RTPが同じRTPセッションに属するストリームに固有のSSRCを提供するという事実によって処理されます. 詳細については、セクション9.1を参照してください. 

第二に、SRTPと対応するSRTCPの間の共有は安全です. SRTPストリームとそれに関連するSRTCPストリームの両方が同じSSRCを伝送するという事実は、キーの派生により、2タイムパッドの問題を構成しません. したがって、1つのRTPセッションに対応するSRTPとSRTCPは、（デフォルトでそうであるように）マスター鍵を共有する場合があります. 

メッセージ認証は、キーストリームの再利用の問題とは関係のないSSRCの一意性にも依存していることに注意してください. 同じキーで認証されたSRTPストリームは、メッセージの送信者を識別するために別個のSSRCを持つ必要があります. SSRCは異なるSRTPストリームを区別するために使用される暗号的に認証されたフィールドであるため、この要件が必要です. 2つのストリームが同じSSRC値を使用していた場合、攻撃者は1つのストリームから別のストリームにメッセージを検出せずに置き換えることができます. 

SRTP / SRTCPは、上記以外の状況、つまりSRTPと対応するSRTCPの間、および同じRTPセッションに属するストリーム間でマスターキーを共有してはなりません（MUST NOT）. 

8.1. 再入力
特定のキー管理システムがSRTP内でキーの再生成を提供するための推奨される方法は、暗号化コンテキストのマスターキーをMKIに関連付けることです. 

これにより、マスターキーを簡単に取得できますが（セクション11のシナリオを参照）、各パケットにビットを追加するという欠点があります. セクション7.5で述べたように、一部のワイヤレスリンクは追加されたビットに対応しないため、SRTPは<From、To>の使用を介してキー更新をトリガーするより経済的な方法も定義し、特定の単純なシナリオで機能します（セクションを参照） 8.1.1）. 

SRTP送信者は、マスターキーに使用されているSRTPおよびSRTCPトラフィックの量をカウントし、必要に応じてキー管理を呼び出してキーを再生成する必要があります（セクション9.2）. これらの相互作用は、SRTPへのキー管理インターフェースによって定義され、このプロトコル仕様では定義されていません. 

8.1.1. 再入力のための<From、To>の使用
SRTPは、MKIの使用に加えて、マスターキーを取得するための別のオプションのメカニズムである<From、To>を定義します. <From、To>は、SRTPインデックスの範囲（シーケンス番号とROCのペア）を指定します. この範囲内で、特定のマスターキーが有効であり、（使用される場合は）暗号コンテキストの一部です. 現在のSRTPパケットの48ビットSRTPインデックスを調べると、どのFrom-To間隔に属しているかを判別することで、対応するマスターキーを見つけることができます. SRTCPには、SRTCPが独自の（31ビット）インデックスを持っている場合でも（暗号化コンテキストから取得できる）、最後に観測/使用されたSRTPインデックス（暗号化コンテキストから取得できます）がこの目的で使用されます（以下の警告を参照）. 

この方法には、MKIと比較して、各パケットにビットを追加することなく、マスターキーを識別し、その寿命を定義できるという利点があります. これは、すでに述べたように、追加されたビットに対応していない一部のワイヤレスリンクで役立ちます. ただし、その使用は特定の非常に単純なシナリオに限定する必要があります（SHOULD）. RTPセッションが単純な単方向または双方向ストリームである場合は、その使用を制限することをお勧めします. これは、複数のストリームの場合、単一のRTPストリームの<From、To>に基づいて鍵の再生成をトリガーすることが難しいためです. たとえば、複数のストリームがマスターキーを共有している場合、特定のストリームのインデックスシーケンススペースと、<From、To>値の基になるインデックスシーケンススペースとの間に単純な1対1の対応はありません. その結果、マスターキーがストリーム間で共有されると、これらのストリームの1つは、インデックス管理が再キーイングポイントを定義するストリームとして、キー管理によって指定される必要があります. また、SRTCPでの再キートリガーは、対応するSRTPストリームに基づいています. つまり、SRTPストリームがマスターキーを変更するときは、対応するSRTCPも変更します. これは明らかに複数のストリームでますます複雑になります. 

<From、To>のデフォルト値は、「最初に観測されたパケットから」および「さらに通知されるまで」です. ただし、それぞれのマスター/セッションキー（セクション9.2）の下で送信されるSRTP / SRTCPパケットの最大制限を超えてはなりません. 

<From、To>がキーの取得として使用される場合、MKIはパケットに挿入されません（暗号化コンテキストのインジケーターはゼロです）. ただし、MKIを使用しても、<From、To>キーの有効期間を同時に使用することは除外されません. これは、たとえば、MKIがアクティブになる時点で送信側で信号を送るのに役立ちます. 

8.2. 主要な管理パラメーター
以下の表は、キー管理が提供できるすべてのSRTPパラメータを示しています. 参考として、セクション5で説明されているSRTP実装のデフォルト値とサポートに必須の値の概要も示します. 

   サポートが必要なデフォルトパラメータ
   --------- -------------------- -------
        
SRTPおよびSRTCP encr transf. AES_CM、NULL AES_CM（その他の可能な値：AES_f8）

SRTPおよびSRTCP auth transf. HMAC-SHA1 HMAC-SHA1

SRTPおよびSRTCP認証パラメーター：n_tag（タグの長さ）80 80 SRTP prefix_length 0 0

鍵導出PRF AES_CM AES_CM

鍵素材パラメーター（マスターキーごと）：マスターキーの長さ128128 n_e（encrセッションキーの長さ）128128 n_a（認証セッションキーの長さ）160160マスターソルトのマスターソルトキーの長さ112112 n_s（セッションソルトキーの長さ） 112112鍵導出率0 0

キーの有効期間SRTP-packets-max-lifetime 2 ^ 48 2 ^ 48 SRTCP-packets-max-lifetime 2 ^ 31 2 ^ 31 from-to-lifetime <From、To> MKIインジケーター0 0 MKIの長さ0 0の値MKI

暗号コンテキストインデックスパラメータ：SSRC値ROC SEQ SRTCPインデックストランスポートアドレスポート番号

他のRTPプロファイルとの関係：FECとSRTPの間の送信者の順序FEC-SRTP FEC-SRTP（セクション10を参照）

9.セキュリティに関する考慮事項
9.1. SSRCコリジョンと2タイムパッド
同じキーとインデックスから生成された固定キーストリーム出力は、一度だけ暗号化するために使用する必要があります. そのようなキーストリームを再利用すると（暗号学者によって冗談で「2タイムパッド」システムと呼ばれます）、セキュリティが著しく損なわれる可能性があります. NSAのVENONAプロジェクト[C99]は、そのような妥協の歴史的な例を提供しています. SRTPおよびSRTCPキー情報を確立および維持するために自動キー管理を使用する必要があります. この要件は、手動のキー管理で発生する可能性が高いキーストリームの再利用を回避するためです. さらに、SRTPでは、RTP / RTCPストリームおよびパケットごとに一意であるキーまたは暗号化の重要性の他のパラメーターを要求することにより、「2タイムパッド」が回避されます. 

事前定義された変換（AES-CMおよびAES-f8）では、IVにSSRCを含めることにより、同じRTPセッションに属するストリーム間でマスターキーを共有できます. マスターキーは、異なるRTPセッション間で共有してはなりません. 

したがって、SSRCは、同じマスターキーを共有する同じRTPセッション内のすべてのRTPストリーム間で一意である必要があります. RTP自体は、同じRTPセッション内のSSRC衝突を検出するためのアルゴリズムを提供します. したがって、一時的な衝突は一時的な2タイムパッドにつながる可能性があります. 不幸なことに、SSRCがストリームのシーケンス番号も同じである（ほぼ2 ^（-48）の確率で発生する）時点で衝突するという不幸なイベントです. したがって、鍵管理は、セッションで使用されるSSRCをネゴシエーションパラメーターとして含めることで、そのようなSSRCの衝突を回避し、その一意性を積極的に保証する必要があります（SHOULD）. これは、たとえば、SSRCの衝突がRTPレベルで検出される前に、同時に送信を開始できる複数の送信者がいるシナリオでの強力な要件です. 

また、SSRCが異なる場合でも、同じキーを広範囲に使用すると、確率的衝突と時間メモリトレードオフ攻撃が成功する可能性が高まる可能性があります. 

説明したように、マスターキーは同じRTPセッションに属するストリーム間で共有できますが、各SSRCが独自のマスターキーを持っていることが推奨されます. マスターキーがSSRC参加者間で共有され、SSRCが上記で推奨されているようにキー管理モジュールによって管理されている場合、SSRC衝突エラーの推奨ポリシーは、それが誤動作の兆候であるため、参加者がSRTPセッションを離れることです. 

9.2. 主な用途
有効なキーのサイズは、マスターキーのサイズと、暗号化の場合はソルティングキーのサイズによって決まります（上限）. 付加的なストリーム暗号は、プレーンテキストソースに関する統計的知識を使用して、キーの衝突と時間とメモリのトレードオフ攻撃[MF00] [H80] [BS00]を可能にする攻撃に対して脆弱です. これらの攻撃は平文間の共通性を利用し、暗号分析者が多くのキーまたは出力の多くのバイトにわたって復号化の計算作業を償却する方法を提供するため、暗号の有効なキーサイズを削減します. これらの攻撃とインターネットトラフィックの暗号化への適用性の詳細な分析は、[MF00]で提供されています. 要約すると、m個の異なるキーが使用されるセキュリティシステムで使用される場合のSRTPの有効なキーサイズ、は、mの対数（2を底とする）を引いた暗号のキーサイズに等しくなります. このような攻撃に対する保護は、使用するキーのサイズを増やすだけで提供できます. これは、ソルティングキーを使用することで実現できます. ソルティングキーはランダムである必要がありますが、公開される場合があります. （推奨）サイズ112ビットのソルトサイズは、最大で2 ^ 112のキーが使用されているシナリオでの攻撃から保護します. これはすべての実用的な目的に十分です. 

実装では、可能な限り大きいキーを使用する必要があります. 多くの場合、暗号のキーサイズを増やしても、その暗号のスループットには影響しません. 

事前定義されたトランスフォームでSRTPおよびSRTCPインデックスを使用すると、同じキーで保護できるパケットの最大数が修正されます. SRTPとSRTCPが独立して考慮される場合、この制限はSRTPストリームの2 ^ 48 SRTPパケットと2 ^ 31 SRTCPパケットに固定されます. たとえば再キーイングにより、この制限に達すると、インデックスのラッピングと一致する場合と一致しない場合があるため、送信者はパケット数を維持する必要があります. ただし、関連するSRTPおよびSRTCPストリームのセッションキーが同じマスターキーから派生している場合（デフォルトの動作、セクション4.3）、考慮しなければならない上限は、実際には2つの量の最小値です. つまり、2 ^ 48 SRTPパケットまたは2 ^ 31 SRTCPパケットが同じキー（以前に発生した方）で保護されている場合、新しいマスターキーを提供するためにキー管理を呼び出す必要があります（以前に保存して使用したキーを再度使用してはなりません）. または、セッションを終了する必要があります. RTCPの送信者が、SRTP（またはSRTCP）の送信者が、同じSRTP（SRTCP）ストリームに属する2 ^ 48 SRTP（または2 ^ 31 SRTCP）パケットを送信する前にマスターキーまたはセッションキーを更新していないことを発見した場合、 RTCP送信者のセキュリティポリシーに応じて、RTCP BYEパケットを送信するかどうか、イベントをログに記録するかどうかなど、動作方法. 

注：ほとんどの一般的なアプリケーション（128,000 RTPパケットごとに少なくとも1つのRTCPパケットを想定）では、最初に上限に達するのはSRTCPインデックスですが、これが発生するまでの時間は非常に長く、200 SRTCPパケット/秒でも、SRTCPの2 ​​^ 31インデックススペースは、約4か月の通信を確保するのに十分です. 

マスターキーが同じRTPセッション（セクション9.1）内のSRTPストリーム間で共有される場合、上記の境界はストリームごと（つまり、SSRCごと）に基づいていますが、送信者は、シーケンス番号スペースが最初に枯渇するストリーム. 

キーの導出は、固定セッションキーで暗号化され、分析のために攻撃者が利用できるプレーンテキストの量を制限しますが、キーの導出はマスターキーの寿命を延ばしません. これを確認するには、2タイムパッドを回避するための要件を検討してください. 2つの異なるパケットは、個別のIVまたは個別のセッションキーで処理する必要があり、IVとセッションキーの両方の個別性は（事前定義済みの場合）変換）パケットインデックスの違いに依存します. 

キーの導出では、導出されたセッションキーがかなり長くても、有効なキーのサイズは最大でもマスターキーのサイズであることに注意してください. 事前定義された認証変換では、セッション認証キーは160ビットですが、デフォルトのマスターキーは128ビットのみです. この設計の選択は、既存のHMAC実装をSRTPに問題なくプラグインできるように、[RFC2104]の特定の推奨事項に準拠するように行われました. デフォルトのタグサイズは80ビットであるため、アプリケーションにとっては、セキュリティの観点からも許容範囲と見なされます. これについて懸念があるユーザーは、代わりにキーの派生に192ビットのマスターキーを使用することをお勧めします. しかし、鍵派生で使用される既存のAES実装は、128ビット以外の鍵長を常にサポートするとは限らないため、192ビット鍵を必須としないことを選択しました. AESは160ビットキーでの使用について定義されていない（または適切に分析されていない）ため、短いキーを192または256ビットに埋め込むためにアドホックキーパディングスキームを使用することはお勧めしません. 

9.3. RTPペイロードの機密性
SRTPの事前定義された暗号は「シーク可能な」ストリーム暗号です. つまり、キーストリーム内の任意の場所を効率的にシークできる暗号です（そのため、1つのパケットの暗号化または復号化は、先行するパケットに依存しません）. シーク可能なストリーム暗号を使用することにより、SRTPは、このプロパティを持たないストリーム暗号で起こり得るサービス拒否攻撃を回避します. ストリーム暗号と同様に、ペイロードの正確な長さは暗号化によって明らかになることに注意することが重要です. これは、コーデックの出力の長さが特定のパラメータ設定などによって変わる可能性があるため、ペイロードの特定の「フォーマットビット」を推定できる可能性があることを意味します. これは、キーストリームの対応するビットを推定できることを意味します. しかしながら、ストリーム暗号が安全である場合（カウンターモードとf8は、特定の仮定[BDJR] [KSYH] [IK]で確実に安全です）、キーストリームの数ビットの知識は、攻撃者が後続のキーストリームビットを予測するのに役立ちません. したがって、ペイロードの長さ（およびこれから推定できる情報）はリークしますが、それ以外は何もリークしません. 

一部のRTPパケットには非常に予測可能なデータ（SIDなど）が含まれる可能性があるため、既知のプレーンテキスト攻撃（現在の慣行）に対抗するように設計された暗号を使用することが重要です. 

9.4. RTPヘッダーの機密性
SRTPでは、RTPヘッダーは平文で送信され、ヘッダー圧縮が可能になります. これは、盗聴者がペイロードタイプ、同期ソース識別子、タイムスタンプなどのデータを利用できることを意味します. さらに、RTPはヘッダーの将来の拡張を可能にするため、どのような機密情報が「漏洩」される可能性があるかを予測できません. 

SRTPは低コストの方法で、ヘッダー圧縮により帯域幅を削減できます. 使用するセキュリティプロトコルを決定するのは、エンドポイントのポリシーです. 本当にヘッダーを保護する必要があり、周囲の環境によって保護することが許可されている場合は、IPsec [RFC2401]などの代替手段も検討する必要があります. 

9.5. RTPペイロードとヘッダーの完全性
SRTPメッセージは、その整合性とソースIDに対する攻撃の対象となります. これらのリスクについては、セクション9.5.1で説明します. これらの攻撃から保護するために、各SRTPストリームは、80ビットの出力タグと160ビットのキーを備えたHMAC-SHA1 [RFC2104]、または同等の強度のメッセージ認証コードで保護する必要があります（SHOULD）. Secure RTPは、このセクションで説明されている状況を除き、メッセージ認証なしで使用してはなりません（SHOULD NOT）. AES Counter Modeやf8を含む暗号化アルゴリズムはメッセージ認証を提供しないことに注意することが重要です. SRTCPは、弱い（またはNULL）認証で使用してはなりません（MUST NOT）. 

SRTPは、弱い認証（32ビット認証タグなど）または認証なし（NULL認証アルゴリズム）で使用できます（MAY）. これらのオプションにより、SRTPを使用して、

*弱い認証またはnull認証は許容可能なセキュリティリスクであり、*強力なメッセージ認証を提供することは現実的ではありません. 

これらの条件については、以下とセクション7.5で説明します. 弱い認証またはnull認証が使用されるためには、両方の条件が保持されなければならないことに注意してください. 弱い認証オプションまたはnull認証オプションの行使に関連するリスクは、リスクが与えられた特定のアプリケーションまたは環境で使用する前に、セキュリティ監査で検討する必要があります. これについては、セクション9.5.1で説明します. 

RTPアプリケーションが成功した偽造のごく一部の影響が無視できるようなものである場合、弱い認証は許容されます. アプリケーションがステートレスの場合、単一の偽造されたRTPパケットの影響は、その特定のパケットのデコードに限定されます. この条件下で、認証タグのサイズは、SRTPレシーバーによってRTPアプリケーションに渡されたパケットのごくわずかな部分だけが偽造できることを保証しなければなりません（MUST）. 偽造されたパケットの制御を与えられた場合、敵がRTPアプリケーションの出力に大きな影響を与えることができない場合、この割合は無視できます（セクション7.5の例を参照）. 

攻撃者が暗号文を変更して解読して判読可能な値になる可能性が低い場合は、弱い認証またはnull認証が許容される場合があります. 多くのコーデックでは、入力信号を知らない攻撃者が制御された方法で出力信号を操作できないため、攻撃者がRTP平文データを取得することが困難な場合が1つの重要なケースです. 多くの場合、攻撃者が平文の実際の値を決定するのは難しいかもしれません. たとえば、ライブのオーディオまたはビデオ信号を知るために、非表示のスヌーピングデバイスが必要になる場合があります. 攻撃者は、攻撃対象の信号と同等以上の品質を持つ必要があります. それ以外の場合、攻撃者は、被害者が使用するコーデックでその信号をエンコードするのに十分な情報を持っていないためです. 

RTPアプリケーションがRTPデータに基づいてデータ転送またはアクセス制御の決定を行う場合は、弱い認証またはnull認証を使用してはなりません（MUST NOT）. このような場合、攻撃者は受信者にデータを攻撃者に転送させることにより、機密性を破壊することができます. そのような攻撃の実際の例については、[B96]のセクション3を参照してください. 

攻撃者がパケットを格納し、セッションの後半でそれらを再生する再生攻撃が受信機に無視できない影響を与える可能性がある場合は、null認証を使用してはなりません（MUST NOT）. 成功したリプレイ攻撃の例は、一定期間監視カメラの出力を保存し、その後、監視を回避するために監視ステーションにその出力を注入することです. 暗号化はこの攻撃から保護しません. これを無効にするには、null以外の認証が必要です. 

存在するメッセージ偽造が問題である場合、つまり、受信したデータの精度が無視できないほど重要である場合、null認証を使用してはなりません（MUST NOT）. 

9.5.1. 弱いまたはNullメッセージ認証のリスク
弱い認証またはnull認証の使用を考慮したセキュリティ監査中に、メッセージ認証アルゴリズムが使用されていない場合に発生する可能性がある次の攻撃に留意することが重要です. 

平文を予測できない攻撃者は、送信者と受信者の間で送信されるメッセージを常に変更して、ランダムな平文値に復号化したり、ランダムな平文値に復号化する偽のパケットのストリームを受信者に送信したりできます.  . この攻撃は本質的にサービス拒否攻撃ですが、メッセージ認証がない場合、RTPアプリケーションには、真の値とビットごとに相関する入力があります. 一部のマルチメディアコーデックと一般的なオペレーティングシステムは、そのようなデータが有効なビデオデータとして受け入れられるとクラッシュします. このサービス拒否攻撃は、攻撃者によるパケットのドロップ、遅延、または並べ替えによるものよりもはるかに大きな脅威になる可能性があります. 

平文を予測できない攻撃者は、受信者がそれを確実に受け入れる前のメッセージを再生できます. ステートレスコーデックを備えたアプリケーションは、このタイプの攻撃に対して堅牢である可能性がありますが、他のより複雑なアプリケーションでは、これらの攻撃ははるかに深刻になる可能性があります. 

平文を予測できる攻撃者は、暗号文を変更して、選択した任意の値に復号化できます. 付加的なストリーム暗号を使用すると、攻撃者は常に個々のビットを変更できます. 

暗号化されているが認証されていない平文に対してデータ転送またはアクセス制御の決定が行われると、認証の欠如により、攻撃者は機密性を破壊する可能性があります. これは、受信者がだまされて攻撃者にデータを転送し、間接的に機密を侵害する可能性があるためです（[B96]のセクション3を参照）. これは、データ転送の決定が復号化された平文に対して行われるためです. プレーンテキストの情報は、プレーンテキストがESP [RFC2401]トンネルモード（それぞれ、トランスポートモード）で転送されるサブネット（またはプロセス）を決定します. Secure RTPがメッセージ認証なしで使用される場合、アプリケーションが復号化された平文に基づいてデータ転送またはアクセス制御の決定を行わないことを確認する必要があります. 

埋め込みを必要とする一部の暗号化操作モード（標準の暗号化ブロックチェーン（CBC）など）は、整合性がない状態で特定の埋め込みタイプを使用すると、機密性に対する攻撃に非常に敏感です. 攻撃[V02]は、図1を参照して説明したように、CBCモードと一緒に使用すると、これが標準のRTPパディングの場合に実際に当てはまることを示しています. したがって、後でSRTPにトランスフォームを追加する場合は、適切な整合性保護なしでこのパディングを使用するリスクを慎重に検討する必要があります. 

9.5.2. 暗黙的なヘッダー認証
f8モードのIV形成により、メッセージ認証が使用されない場合でも、RTPヘッダーの暗黙の認証（IHA）が提供されます. IHAが使用されている場合、RTPヘッダーの値を変更する攻撃者は、受信側の復号化プロセスにランダムな平文値を生成させます. この保護はメッセージ認証と同等ではありませんが、アプリケーションによっては役立つ場合があります. 

10.前方誤り訂正メカニズムとの相互作用
SRTP SHALLでForward Error Correction（RFC 2733など）処理を使用する場合のデフォルトの処理では、送信側でSRTP処理の前にFEC処理を実行し、受信側でFEC処理の前にSRTP処理を実行します. この順序の変更（それを逆にする、またはSRTP暗号化とSRTP認証の間にFECを配置する）は、帯域外に通知する必要があります. 

11.シナリオ
SRTPは、さまざまなシナリオでRTP / RTCPトラフィックのセキュリティプロトコルとして使用できます. SRTPには、特にキーの使用法に関する多数の構成オプションがあり、使用方法によってはアプリケーションの全体的なパフォーマンスに影響を与える可能性があります. したがって、SRTPの使用は、それが使用されるシナリオとアプリケーションの種類に依存します. 以下では、SRTPのいくつかの使用例を簡単に説明し、そのオプションの推奨設定に関するいくつかのガイドラインを示します. 

11.1 ユニキャスト
典型的な例は、音声通話またはビデオオンデマンドアプリケーションです. 

1つのRTPセッションとして、1つの双方向RTPストリームを検討してください. セクション9.1の原則に従って、2つのパーティが同じマスターキーを2つの方向で共有することが可能です. 鍵導出の最初のラウンドは、マスター鍵を以下のセッション鍵のいずれかまたはすべてに分割します（提供されているセキュリティー機能に従って）. 

SRTP_encr_key、SRTP_auth_key、SRTCP_encr_key、SRTCP_authキー. 

（簡単にするために、これも派生するソルトの説明は省略します. ）このシナリオでは、ほとんどの場合、デフォルトのライフタイムを持つ単一のマスターキーがあれば十分です. これにより、キーの有効期間が十分に長くなり、ほとんどの実用的な目的でキーの最小セットが配置されます. また、この場合、RTCP保護をスムーズに適用できます. これらの仮定の下では、MKIの使用を省略できます. 鍵導出と各方向のパケットレートの大きな差を組み合わせると、複数のセッション鍵を同時に格納する必要がある場合があるため、格納が問題になる場合は、低速鍵導出の使用をお勧めします. 

同じ考慮事項を、各セッションが個別のマスターキーを持つ複数のRTPセッションを使用するユニキャストシナリオに拡張できます. 

11.2 マルチキャスト（1人の送信者）
（保護されていない）RTPと同様に、送信者が処理する必要がある可能性のある非常に大量のSRTCP受信者レポートが原因で、大きなグループでスケーラビリティの問題が発生します. SRTPでは、送信者は各受信者の状態（暗号コンテキスト）を維持する必要があります. より正確には、受信者レポートの保護に使用されるSRTCPの状態を維持する必要があります. オーバーヘッドは、グループのサイズに比例して増加します. 特に、鍵の再生成には特別な配慮が必要です. 以下を参照してください. 

最初に、受信者の小さなグループについて考えてみましょう. レシーバー間でのマスターキーの配布には、いくつかの可能な設定があります. 単一のRTPセッションが与えられた場合、1つの可能性は、セクション9.1と同じマスターキーを共有して、それぞれのRTCPトラフィックをすべて保護することです. この共有マスターキーは、送信SRTPトラフィックを保護するために送信者が使用するものと同じにすることができます. または、レシーバー間でのみ共有され、SRTCPトラフィックにのみ使用されるマスターキーにすることもできます. どちらの方法でも、受信者は相互に信頼する必要があります. 

SRTCPとキーストレージを考慮して、送信者があまり多くのセッションキーを格納する必要がないように、低速（またはゼロ）のkey_derivation（必須の初期キーを除く）を使用することをお勧めします（各SRTCPストリームは別のセッションを持っている可能性があります） SRTCPソースが異なる時間に送信するため、特定の時点でのキー. したがって、SRTPの鍵導出が必要な場合は、SRTPの暗号コンテキストをSRTCP暗号コンテキストから分離しておくことができるため、SRTCPのkey_derivation_rateを0に、SRTPの値をゼロ以外にすることができます. 

鍵の再生成にMKIを使用することは、ほとんどのアプリケーションで推奨されています（セクション8.1を参照）. 

マスターキーを共有する複数のSRTP / SRTCPストリーム（同じRTPセッション内）がある場合、2 ^ 48 SRTPパケット/ 2 ^ 31 SRTCPパケットの上限は、ストリームの1つが最大数に達する前に、パケットの場合、再キーイングは、マスターキーを共有するすべてのストリームでトリガーする必要があります. （厳密なセキュリティの観点から、最大値に達したストリームのみを再キー化する必要がありますが、その後、ストリームはマスターキーを共有しなくなります. これは意図されています. ）送信側のローカルポリシーは、再キーイングを強制する必要があります. どのストリームでも最大パケット制限に達しないようにします. 鍵の再生成にMKIを使用することをお勧めします. 

送信者が1人の大規模マルチキャストでは、小グループマルチキャストホールドと同じ考慮事項. このシナリオでの最大の問題は、RTCP受信者レポートを送り返す各受信者に対して維持する必要がある状態（暗号化コンテキスト）により、送信者側に追加の負荷がかかることです. 少なくとも、各RTCPソースに対して再生ウィンドウを維持する必要があります. 

11.3. 鍵の再生成とアクセス制御
再キーイングは、アクセス制御（たとえば、マルチキャストRTPセッション中にメンバーが削除された場合）や、純粋な暗号化の理由（たとえば、キーがその寿命の終わりにある場合）が原因で発生する可能性があります. SRTPのデフォルトの変換を使用する場合、同じマスターキーで保護されたストリームのインデックススペースを使い果たす前に、マスターキーを置き換える必要があります. 

キー管理がSRTP実装のキーを再生成する方法は範囲外ですが、マルチキャストグループのキーを管理する簡単な方法があることは明らかです. たとえば、1送信者のマルチキャストでは、通常、新しいキーが必要になるタイミングを決定するのは送信者の責任です. 送信者は、最大数のパケットが送信されたときに追跡できる1つのエンティティです. 受信者はいつでもセッションに参加したりセッションから離脱したりできるため、パケットの損失や遅延などが発生する可能性があります. ワンセンダーマルチキャスト以外のシナリオでは、他の方法を使用できます. ここでは、1回の交換に数秒かかる、キー交換はコストのかかる操作になる可能性があることを考慮する必要があります. したがって、マスターキーが使い果たされる/期限切れになる少し前に、帯域外キー管理が開始され、レシーバーと共有される新しいマスターキーが生成されます. 

アクセス制御の目的で、<From、To>期間は、パケットレートに応じて、必要な粒度で設定されます. いくつかの大規模なグループのシナリオでは、SRTCPで高レートのキー再生成が問題になる可能性があります. 前述のように、マスターキーを決定するために、SRTCPインデックスではなくSRTPインデックスを使用することには潜在的な問題があります. 特に、マスターキーの切り替え中の短期間、SRTCPパケットが対応するSRTPの現在のマスターキーの下にない場合があります. そのため、このようなシナリオで鍵の再生成にMKIを使用すると、より良い結果が得られます. 

11.4. 基本的なシナリオの概要
これらのシナリオの説明では、主に鍵の再生成と大規模マルチキャストに関連するSRTPの使用に関するいくつかの推奨事項を強調しています. 

-<From、To>機能で高速キー再生成を使用しないでください. 特に、SRTCPパケットが再キーイング時間の近くに到着した場合、正しいSRTCPキーを取得する際に問題が発生する可能性があります. この場合、MKIを使用する必要があります（SHOULD）. 

-同じRTPセッション内の複数のSRTPストリームが同じマスターキーを共有する場合、中程度のレートの再キー化でも同じ問題が発生する可能性があり、MKIを使用する必要があります（SHOULD）. 

-セキュリティを強化しますが、複数のストリームで使用されるキーの数を最小限にしようとする場合、ゼロ以外のkey_derivation_rateは推奨されません. 

12. IANAに関する考慮事項
RTP仕様では、Session Description Protocol（SDP）などの上位レベルの制御プロトコルが使用するプロファイル名のレジストリを確立して、トランスポート方式を参照します. このプロファイルは、「RTP / SAVP」という名前を登録します. 

SRTPは、キー管理プロトコルが通知する暗号変換を使用します. 暗号トランスフォームまたはトランスフォームのスイートをIANAに登録するのは、特定の各キー管理プロトコルのタスクです. キー管理プロトコルはSRTPではなく、これらのプロトコル番号を伝達し、各キー管理プロトコルは、必要な番号付けスキームと構文を選択します. 

SRTPのキー管理プロトコルの仕様は、ここでは範囲外です. ただし、セクション8.2では、デフォルトのトランスフォームと必須のトランスフォームに対して定義する必要があるパラメーターについてのガイダンスを提供しています. 

13.謝辞
David Oran（Cisco）とRolf Blom（Ericsson）はこのドキュメントの共著者ですが、著者リストの長さを抑えるために、それらの貴重な貢献がここで認められています. 

著者はさらに、マグナス・ウェスターランド、ブライアン・ワイス、ギスライン・ペルティエ、モーガン・リンドクヴィスト、ロバート・フェアリー=カニングハム、エイドリアン・パーリグ、AVT WG、そして特に輸送および安全保障地域局長のコリン・パーキンスとスティーブン・キャスナーに感謝します.  Eric Rescorlaのレビューとサポート. 

14.参考文献
14.1. 規範的な参考文献
   [AES] NIST、「Advanced Encryption Standard（AES）」、FIPS PUB 197、
             http://www.nist.gov/aes/
        
[RFC2104] Krawczyk、H.、Bellare、M. 、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

[RFC2401]ケント、S. 、およびR.アトキンソン、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 2401、1998年11月. 

[RFC2828] Shirey、R. 、「インターネットセキュリティ用語集」、FYI 36、RFC 2828、2000年5月. 

[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R. およびV. Jacobson、「RTP：A Transport Protocol for Real-time Applications」、RFC 3550、2003年7月. 

[RFC3551] Schulzrinne、H. およびS. Casner、「最小制御のオーディオおよびビデオ会議のRTPプロファイル」、RFC 3551、2003年7月. 

14.2. 参考情報
   [AES-CTR] Lipmaa、H.、Rogaway、P. およびD. Wagner、「CTR-Mode
             暗号化」、NIST、http：//csrc.nist.gov/encryption/modes/
             workshop1 / papers / lipmaa-ctr.pdf
        
[B96] Bellovin、S. 、「Proceedings of the Sixth Usenix Unix Security Symposium、pp. 1-16、San Jose、CA、July 1996（http：//www.research.  att.com/~smb/papers/index.html）. 

[BDJR] Bellare、M.、Desai、A.、Jokipii、E. 、およびP. Rogaway、「対称暗号化の具体的な処理：DESの動作モードの分析」、Proceedings 38th IEEE FOCS、pp. 394-403、1997 . 

[BS00] Biryukov、A. およびA. Shamir、「ストリーム暗号の暗号化時間/メモリ/データのトレードオフ」、Proceedings、ASIACRYPT 2000、LNCS 1976、pp. 1-13、Springer Verlag. 

[C99]クローウェル、WP、「VENONAプロジェクトの概要」、http：//www.nsa.gov：8080 / docs / venona / index.html. 

[CTR] Dworkin、M.、NIST Special Publication 800-38A、「Recommendation for Block Cipher Modes of Operation：Methods and Techniques」、2001. http：//csrc.nist.gov/publications/nistpubs/800-38a/sp800 -38a.pdf. 

[f8-a] 3GPP TS 35.201 V4.1.0（2001-12）技術仕様第3世代パートナーシッププロジェクト. 技術仕様グループサービスとシステムの側面. 3Gセキュリティ; 3GPP機密性および整合性アルゴリズムの仕様. ドキュメント1：f8およびf9仕様（リリース4）. 

[f8-b] 3GPP TR 33.908 V4.0.0（2001-09）テクニカルレポート第3世代パートナーシッププロジェクト. 技術仕様グループサービスとシステムの側面. 3Gセキュリティ; 3GPP標準の機密性と整合性のアルゴリズムの設計、仕様、および評価に関する一般的なレポート（リリース4）. 

[GDOI]バウアーM.、ウェイスB.、ハードジョノT.、およびH.ハーニー、「The Group Domain of Interpretation、RFC 3547、2003年7月. 

[HAC] Menezes、A.、Van Oorschot、P. およびS. Vanstone、「応用暗号のハンドブック」、CRC Press、1997、ISBN 0-8493-8523-7. 

[H80] Hellman、ME、「A cryptanalytic time-memory trade-off」、IEEE Transactions on Information Theory、1980年7月、401-406ページ. 

[IK] T. IwataおよびT. Kohno： "3GPP Confidentiality and Integrity Algorithms for New Security Proofs for the 3GPP Confidentiality and Integrity Algorithms"、Proceedings of FSE 2004. 

[KINK] Thomas、M.、J. Vilhuber、「Kerberized Internet Negotiation of Keys（KINK）」、作業中. 

[KEYMGT] Arrko、J.他、「Session Description Protocol（SDP）およびReal Time Streaming Protocol（RTSP）のキー管理拡張機能」、作業中. 

[KSYH] Kang、JS、Shin、SU. 、Hong、D. およびO. Yi、「KASUMIおよび3GPP暗号化モードf8の証明可能なセキュリティ」、Proceedings Asiacrypt 2001、Springer Verlag LNCS 2248、pp. 255-271、2001 . 

[MIKEY] Arrko、J. 、他 al. 、「MIKEY：マルチメディアインターネットキーイング」、Work in Progress. 

[MF00] McGrew、D. およびS. Fluhrer、「冗長な平文の暗号化とインターネットセキュリティへの影響に関する攻撃」、暗号化の選択された領域に関する第7回年次ワークショップの議事録（SAC 2000）、Springer-Verlag. 

[PCST1] Perrig、A.、Canetti、R.、Tygar、D. およびD. Song、「マルチキャストのための効率的で安全なソース認証」、Proc. ネットワークと分散システムのセキュリティシンポジウムNDSS 2001、pp. 35-46、2001. 

[PCST2] Perrig、A.、Canetti、R.、Tygar、D. 、およびD. Song、「損失のあるチャネルを介したマルチキャストストリームの効率的な認証および署名」、Proc. IEEE Security and Privacy Symposium S＆P2000、pp. 56-73、2000

[RFC1750] Eastlake、D.、Crocker、S. およびJ. Schiller、「Randomness Recommendations for Security」、RFC 1750、1994年12月. 

[RFC2675] Borman、D.、Deering、S. およびR. Hinden、「IPv6 Jumbograms」、RFC 2675、1999年8月. 

[RFC3095] Bormann、C.、Burmeister、C.、Degermark、M.、Fukuhsima、H.、Hannu、H.、Jonsson、LE. 、Hakenberg、R.、Koren、T.、Le、K.、Liu、 Z.、Martensson、A. 、宮崎、A.、Svanbro、K.、Wiebke、T. 、吉村、T.、H. Zheng、「堅牢なヘッダー圧縮：フレームワークと4つのプロファイル：RTP、UDP、ESP、および非圧縮（ROHC）」、RFC 3095、2001年7月. 

[RFC3242]ジョンソン、LE. G.ペルティエ、「RObust Header Compression（ROHC）：A Link-Layer Assisted Profile for IP / UDP / RTP」、RFC 3242、2002年4月. 

[SDMS]アンドレアセン、F. 、バウアー、M. およびD.ウィング、「メディアストリームのセッション記述プロトコルセキュリティ記述」、作業中. 

[SWO] Svanbro、K.、Wiorek、J. およびB. Olin、「Voice-over-IP-over-wireless」、Proc. PIMRC 2000、ロンドン、2000年9月. 

[V02] Vaudenay、S. 、「CBCパディングによって引き起こされるセキュリティの欠陥-SSL、IPsec、WTLSへの適用...」、暗号学の進歩、EUROCRYPT'02、LNCS 2332、pp. 

[WC81]ウェグマン、ミネソタ、およびJLカーター、「新しいハッシュ関数と認証およびセットの等価性におけるそれらの使用」、JCSS 22、265-279、1981. 

付録A：インデックスを決定するための擬似コード
以下は、シーケンス番号SEQのSRTPパケットのインデックスiを決定するアルゴリズムの疑似コードの例です. 以下では、符号付き演算を想定しています. 

if（s_l <32,768）if（SEQ-s_l> 32,768）vを（ROC-1）mod 2 ^ 32に設定else vをROCに設定endif else if（s_l-32,768> SEQ）vを（ROC + 1）modに設定2 ^ 32それ以外の場合は、vをROCに設定しますendif endif return SEQ + v * 65,536

付録B：テストベクトル
すべての値は16進数です. 

B.1. AES-f8テストベクトル
SRTPプレフィックス長：0

RTPパケットヘッダー：806e5cba50681de55c621599

RTPパケットのペイロード：70736575646f72616e646f6d6e657373 20697320746865206e65787420626573 74207468696e67

   ROC：d462564a
   キー：234829008467be186c3de14aae72d62c
   ソルトキー：32f2870d
   キーマスク（m）：32f2870d555555555555555555555555
   key XOR key-mask：11baae0dd132eb4d3968b41ffb278379
        
   IV：006e5cba50681de55c621599d462564a
   IV '：595b699bbd3bc0df26062093c1ad8f73 j = 0
   IV 'xor j：595b699bbd3bc0df26062093c1ad8f73
   S（-1）：00000000000000000000000000000000
   IV 'xor S（-1）xor j：595b699bbd3bc0df26062093c1ad8f73
   S（0）：71ef82d70a172660240709c7fbb19d8e
   plaintext：70736575646f72616e646f6d6e657373
   ciphertext：019ce7a26e7854014a6366aa95d4eefd
        
   j = 1
   IV 'xor j：595b699bbd3bc0df26062093c1ad8f72
   S（0）：71ef82d70a172660240709c7fbb19d8e
   IV 'xor S（0）xor j：28b4eb4cb72ce6bf020129543a1c12fc
   S（1）：3abd640a60919fd43bd289a09649b5fc
   平文：20697320746865206e65787420626573
   ciphertext：1ad4172a14f9faf455b7f1d4b62bd08f
        
   j = 2
   IV 'xor j：595b699bbd3bc0df26062093c1ad8f71
   S（1）：3abd640a60919fd43bd289a09649b5fc
   IV 'xor S（1）xor j：63e60d91ddaa5f0b1dd4a93357e43a8d
   S（2）：220c7a8715266565b09ecc8a2a62b11b
   平文：74207468696e67
   暗号文：562c0eef7c4802
        
B.2. AES-CMテストベクトル
    キーストリームセグメントの長さ：1044512オクテット（65282 AESブロック）
    セッションキー：2B7E151628AED2A6ABF7158809CF4F3C
    ロールオーバーカウンター：00000000
    シーケンス番号：0000
    SSRC：00000000
    セッションソルト：F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000（シフト済み）
    オフセット：F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000
        
カウンターキーストリーム

    F0F1F2F3F4F5F6F7F8F9FAFBFCFD0000 E03EAD0935C95E80E166B16DD92B4EB4
    F0F1F2F3F4F5F6F7F8F9FAFBFCFD0001 D23513162B02D0F72A43A2FE4A5F97AB
    F0F1F2F3F4F5F6F7F8F9FAFBFCFD0002 41E95B3BB0A2E8DD477901E4FCA894C0
    ... ...
    F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF EC8CDF7398607CB0F2D21675EA9EA1E4
    F0F1F2F3F4F5F6F7F8F9FAFBFCFDFF00 362B7C3C6773516318A077D7FC5073AE
    F0F1F2F3F4F5F6F7F8F9FAFBFCFDFF01 6A2CC3787889374FBEB4C81B17BA6C44
        
Nota Bene：このテストケースは、キーストリームセグメントの後半が[CTR]のセクションF.5.1のテストケースと一致するように考案されています. 

B.3. 鍵導出テストベクトル
このセクションでは、カウンターモードでAES-128を使用するデフォルトの鍵導出関数のテストデータを提供します. 以下では、16オクテットのセッション暗号化キーと14オクテットのセッションソルトを必要とするAES-128カウンターモード暗号の初期キー導出と、94オクテットのセッション認証キーを必要とする認証機能について説明します. これらの値は、以下では暗号鍵、暗号ソルト、および認証鍵と呼ばれます. これは初期の鍵導出であり、鍵導出率はゼロに等しいため、（インデックスDIV key_derivation_rate）の値はゼロ（実際には、6オクテットのゼロのストリング）です. 以下では、key_derivation_rateをkdrに短縮します. 

キー導出関数への入力は、16オクテットのマスターキーと14オクテットのマスターソルトです. 

マスターキー：E1F97A0D3E018BE0D64FA32C06DE4139マスターソルト：0EC675AD498AFEEBB6960B3AABE6

まず、暗号鍵がどのように生成されるかを示します. AES-CMの入力ブロックは、暗号化キーラベル0x00と（インデックスDIV kdr）を連結してマスターソルトを排他的論理和した後、2つのヌルオクテットで右側をパディングします（2乗^ 16オペレーション. セクション4.3.3を参照）. 結果の値は、マスターキーを使用してAES-CM-で暗号化され、暗号キーが取得されます. 

      インデックスDIV kdr：000000000000
      ラベル：00
      マスターソルト：0EC675AD498AFEEBB6960B3AABE6
      -----------------------------------------------
      xor：0EC675AD498AFEEBB6960B3AABE6（x、PRF入力）
        
      x * 2 ^ 16：0EC675AD498AFEEBB6960B3AABE60000（AES-CM入力）
        
暗号キー：C61E7A93744F39EE10734AFE3FF7A087（AES-CM出力）

次に、暗号ソルトがどのように生成されるかを示します. AES-CMの入力ブロックは、マスターソルトと暗号化ソルトラベルの連結を排他的論理和することによって生成されます. その値は上記のように埋め込まれ、暗号化されます. 

インデックスDIV kdr：000000000000ラベル：02マスターソルト：0EC675AD498AFEEBB6960B3AABE6

      ----------------------------------------------
      xor：0EC675AD498AFEE9B6960B3AABE6（x、PRF入力）
        
      x * 2 ^ 16：0EC675AD498AFEE9B6960B3AABE60000（AES-CM入力）
        
30CBBC08863D8C85D49DB34A9AE17AC6（AES-CM ouptut）

暗号ソルト：30CBBC08863D8C85D49DB34A9AE1

次に、認証キーが生成される方法を示します. AES-CMの入力ブロックは上記のように生成されますが、認証キーラベルを使用します. 

      インデックスDIV kdr：000000000000
      ラベル：01
      マスターソルト：0EC675AD498AFEEBB6960B3AABE6
      -----------------------------------------------
      xor：0EC675AD498AFEEAB6960B3AABE6（x、PRF入力）
        
      x * 2 ^ 16：0EC675AD498AFEEAB6960B3AABE60000（AES-CM入力）
        
以下では、認証キーが左側に表示され、対応するAES入力ブロックが右側に表示されます. 

   認証キーのAES入力ブロック
   CEBE321F6FF7716B6FD4AB49AF256A15 0EC675AD498AFEEAB6960B3AABE60000
   6D38BAA48F0A0ACF3C34E2359E6CDBCE 0EC675AD498AFEEAB6960B3AABE60001
   E049646C43D9327AD175578EF7227098 0EC675AD498AFEEAB6960B3AABE60002
   6371C10C9A369AC2F94A8C5FBCDDDC25 0EC675AD498AFEEAB6960B3AABE60003
   6D6E919A48B610EF17C2041E47403576 0EC675AD498AFEEAB6960B3AABE60004
   6B68642C59BBFC2F34DB60DBDFB2 0EC675AD498AFEEAB6960B3AABE60005
        
著者のアドレス

質問とコメントは著者とavt@ietf.orgに送ってください：

Mark Ba​​ugher Cisco Systems、Inc. 5510 SW Orchid Street Portland、OR 97219 USA

   電話：+1 408-853-4418
   メール：mbaugher@cisco.com
        
Elisabetta Carrara Ericsson Research SE-16480ストックホルムスウェーデン

   電話：+46 8 50877040
   メール：elisabetta.carrara@ericsson.com
        
David A. McGrew Cisco Systems、Inc. San Jose、CA 95134-1706 USA

   電話：+1 301-349-5815
   メール：mcgrew@cisco.com
        
Mats Naslund Ericsson Research SE-16480ストックホルムスウェーデン

   電話：+46 8 58533739
   メール：mats.naslund@ericsson.com
        
Karl Norrman Ericsson Research SE-16480ストックホルムスウェーデン

   電話：+46 8 4044502
   メール：karl.norrman@ericsson.com
        
完全な著作権表示

Copyright（C）The Internet Society（2004）. このドキュメントは、BCP 78に含まれる権利、ライセンス、制限の対象であり、ここに記載されている場合を除き、著者はすべての権利を保持します. 

このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または組織（ある場合）、インターネットエンジニアリングおよびインターネットエンジニアリングタスクフォースはすべての保証を明示的または明示的に後援しますここに記載されている情報の使用により、商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害されないという保証を含みますが、これに限定されるものではありません. 

知的財産

IETFは、このドキュメントで説明されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません. 利用できる; また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません. RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります. 

IETF事務局に対して行われたIPR開示のコピー、および使用可能にされるライセンスの保証、またはこの仕様の実装者またはユーザーによる一般的なライセンスまたはそのような所有権の使用許可を得ようとした試みの結果を取得できます.  http://www.ietf.org/iprのIETFオンラインIPRリポジトリから. 

IETFは、この規格の実装に必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけています. IEETのietf-ipr@ietf.orgに情報を送信してください. 

了承

RFC Editor機能への資金提供は、現在Internet Societyから提供されています. 