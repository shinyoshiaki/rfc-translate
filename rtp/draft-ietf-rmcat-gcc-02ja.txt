RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
https://tools.ietf.org/html/draft-ietf-rmcat-gcc-02
draft-ietf-rmcat-gcc-02-リアルタイム通信のためのGoogle輻輳制御アルゴリズム日本語訳
URL : https://tools.ietf.org/html/rfchttps://tools.ietf.org/html/draft-ietf-rmcat-gcc-02
タイトル : draft-ietf-rmcat-gcc-02 - A Google Congestion Control Algorithm for Real-Time Communication
翻訳編集 : 自動生成
ネットワークワーキンググループS.ホルマー
インターネットドラフトH.ルンディン
対象ステータス：情報Google
有効期限：2017年1月9日G.Carlucci
                                                             L.デチッコ
                                                              S.マスコロ
                                                     バリのポリテクニック
                                                            2016年7月8日
        
リアルタイム通信用のGoogle輻輳制御アルゴリズムdraft-ietf-rmcat-gcc-02

概要

このドキュメントでは、ワールドワイドウェブ(RTCWEB)でリアルタイム通信を使用する場合の輻輳制御の2つの方法について説明します. 1つは遅延ベースでもう1つは損失ベースです. 

これは、メディアストリームの輻輳制御に関するRMCATワーキンググループへの入力ドキュメントとして公開されます. そのワーキンググループのメーリングリストはrmcat@ietf.orgです. 

要件言語

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです.  RFC 2119 [RFC2119]で説明されているように解釈されます. 

このメモのステータス

このインターネットドラフトは、BCP78およびBCP79の規定に完全に準拠して提出されます. 

インターネットドラフトは、インターネット技術特別調査委員会(IETF)の作業文書です. 他のグループも作業文書をインターネットドラフトとして配布する場合があることに注意してください. 現在のインターネットドラフトのリストはhttp://datatracker.ietf.org/drafts/current/にあります. 

インターネットドラフトは、最大6か月間有効なドラフト文書であり、いつでも他の文書によって更新、置換、または廃止される可能性があります. インターネットドラフトを参考資料として使用したり、「進行中の作業」として以外に引用したりすることは不適切です. 

このインターネットドラフトは2017年1月9日に期限切れになります. 

著作権表示

Copyright(c)2016 IETFTrustおよびドキュメントの作成者として特定された人物. 全著作権所有. 

このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定(http://trustee.ietf.org/license-info)の対象となります. これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます. 

目次

   1.はじめに. . . . . . . . . . . . . . . . . . . . . . . . 3
     1.1. 数学表記の規則. . . . . . . . . . . . 3
   2.システムモデル. . . . . . . . . . . . . . . . . . . . . . . . 4
   3.フィードバックと拡張機能. . . . . . . . . . . . . . . . . . . 4
   4.送信エンジン. . . . . . . . . . . . . . . . . . . . . . . 5
   5.遅延ベースの制御. . . . . . . . . . . . . . . . . . . . . 5
     5.1. 到着時モデル. . . . . . . . . . . . . . . . . . . 6
     5.2. 事前フィルタリング. . . . . . . . . . . . . . . . . . . . . . 7
     5.3. 到着時間フィルター. . . . . . . . . . . . . . . . . . . 7
     5.4. 過剰使用検出器. . . . . . . . . . . . . . . . . . . . 8
     5.5. レート制御. . . . . . . . . . . . . . . . . . . . . . 10
     5.6. パラメータ設定. . . . . . . . . . . . . . . . . . . 12
   6.損失ベースの制御. . . . . . . . . . . . . . . . . . . . . 13
   7.相互運用性に関する考慮事項. . . . . . . . . . . . . . . 14
   8.実装経験. . . . . . . . . . . . . . . . . . 14
   9.さらなる作業. . . . . . . . . . . . . . . . . . . . . . . . 15
   10.IANAの考慮事項. . . . . . . . . . . . . . . . . . . . . 15
   11.セキュリティに関する考慮事項. . . . . . . . . . . . . . . . . . . 15
   12.謝辞. . . . . . . . . . . . . . . . . . . . . . 15
   13.参照. . . . . . . . . . . . . . . . . . . . . . . . . 16
     13.1. 規範的参照. . . . . . . . . . . . . . . . . . 16
     13.2. 有益な参考資料. . . . . . . . . . . . . . . . . 16
   付録A.変更ログ. . . . . . . . . . . . . . . . . . . . . 16
     A.1. バージョン-00から-01. . . . . . . . . . . . . . . . . . . 16
     A.2. バージョン-01から-02. . . . . . . . . . . . . . . . . . . 17
     A.3. バージョン-02から-03. . . . . . . . . . . . . . . . . . . 17
     A.4. rtcweb-03からrmcat-00. . . . . . . . . . . . . . . . . . 17
     A.5. rmcat-00から-01. . . . . . . . . . . . . . . . . . . . 17
     A.6. rmcat-01から-02. . . . . . . . . . . . . . . . . . . . 17
     A.7. rmcat-02から-03. . . . . . . . . . . . . . . . . . . . 18
     A.8. ietf-rmcat-00からietf-rmcat-01. . . . . . . . . . . . 18
        
     A.9. ietf-rmcat-01からietf-rmcat-02. . . . . . . . . . . . 18
   著者のアドレス. . . . . . . . . . . . . . . . . . . . . . . 18
        
1.はじめに
輻輳制御は、インターネットリソースを共有するすべてのアプリケーションの要件です[RFC2914]. 

リアルタイムメディアの輻輳制御は、いくつかの理由で困難です. 

oメディアは通常、さまざまな帯域幅に対応するためにすばやく変更できない形式でエンコードされており、帯域幅の要件は、多くの場合、個別のかなり大きなステップでのみ変更できます. 

o参加者は、応答方法について特定の希望を持っている可能性があります. これは、輻輳が検出されたフローに必要な帯域幅を削減していない可能性があります. 

oエンコーディングは通常、パケット損失に敏感ですが、リアルタイムの要件により、再送信によるパケット損失の修復は不可能です. 

このメモでは、同じ輻輳制御を使用する他のビデオフローおよび同じリンクを共有するTCPフローと一緒に、優れたパフォーマンスと妥当な帯域幅共有を提供できる2つの輻輳制御アルゴリズムについて説明します. 

使用されるシグナリングは、[abs-send-time]、[ID.alvestrand-rmcat-remb]、および[ID.holmer-rmcat-transport-wide-ccで定義されている実験的なRTPヘッダー拡張とRTCPメッセージRFC 3550 [RFC3550]で構成されます.  -拡張機能]. 

1.1. 数学表記の規則
このドキュメントの数学は、より公式に適した形式から転記されています. 

次の表記規則が使用されます. 

X_hat変数Xの真の値の推定値-通常、変数名の上に曲折アクセント記号でマークされます. 

X(i)ベクトルXの「i」番目の値-通常は下付き文字iでマークされます. 

E {X}確率変数Xの期待値

2.システムモデル
次の要素がシステムにあります. 

oRTPパケット-メディアデータを含むRTPパケット. 

oパケットのグループ-グループの出発時間とグループの到着時間(絶対送信時間)[abs-send-time]によって一意に識別される送信者から送信されるRTPパケットのセット. これらは、ビデオパケット、オーディオパケット、またはオーディオパケットとビデオパケットの組み合わせである可能性があります. 

o着信メディアストリーム-RTPパケットで構成されるフレームのストリーム. 

oRTP送信者-ネットワークを介してRTPストリームをRTP受信者に送信します. RTPタイムスタンプとabs-send-timeヘッダー拡張を生成します

o RTPレシーバー-RTPストリームを受信し、到着時間をマークします. 

o RTP受信者のRTCP送信者-受信者レポート、REMBメッセージ、およびトランスポート全体のRTCPフィードバックメッセージを送信します. 

o RTP送信者のRTCP受信者-受信者レポートとREMBメッセージ、およびトランスポート全体のRTCPフィードバックメッセージを受信し、これらを送信者側のコントローラーに報告します. 

o RTPレシーバーのRTCPレシーバーは、送信者から送信者レポートを受信します. 

o損失ベースのコントローラー-損失率の測定、ラウンドトリップ時間の測定、およびREMBメッセージを取得し、ターゲット送信ビットレートを計算します. 

o遅延ベースのコントローラー-RTP受信機で、またはRTP送信者が受信したフィードバックからパケット到着情報を取得し、損失ベースのコントローラーに渡す最大ビットレートを計算します. 

一緒に、損失ベースのコントローラーと遅延ベースのコントローラーは、輻輳制御アルゴリズムを実装します. 

3.フィードバックと拡張機能
提案されたアルゴリズムを実装する方法は2つあります. 1つは両方のコントローラーが送信側で実行され、もう1つは遅延ベースのコントローラーが受信側で実行され、損失ベースのコントローラーが送信側で実行されます. 

最初のバージョンは、[ID.holmer-rmcat-transport-wide-cc-extensions]で説明されているパケットごとのフィードバックプロトコルを使用して実現できます. ここで、RTP受信者は、受信した各パケットの到着時間とトランスポート全体のシーケンス番号を記録します. これらは、トランスポート全体のフィードバックメッセージを使用して定期的に送信者に返送されます. 推奨されるフィードバック間隔は、受信したビデオフレームごとに1回、オーディオのみまたはマルチストリームの場合は少なくとも30ミリ秒ごとに1回です. フィードバックオーバーヘッドを制限する必要がある場合は、この間隔を100ミリ秒に増やすことができます. 

送信者は、受信した{シーケンス番号、到着時間}のペアを、フィードバックレポートの対象となる各パケットの送信時間にマッピングし、それらのタイムスタンプを遅延ベースのコントローラーにフィードします. また、フィードバックメッセージのシーケンス番号に基づいて損失率を計算します. 

2番目のバージョンは、受信側に遅延ベースのコントローラーを配置し、着信パケットの到着時間とサイズを監視および処理することで実現できます. 送信者は、abs-send-time RTPヘッダー拡張[abs-send-time]を使用して、受信者が群間遅延変動を計算できるようにする必要があります. 遅延ベースのコントローラーからの出力はビットレートになり、REMBフィードバックメッセージ[ID.alvestrand-rmcat-remb]を使用して送信者に返送されます. パケット損失率は、RTCPレシーバーレポートを介して返送されます. 送信者では、REMBメッセージのビットレートと失われたパケットの一部が損失ベースのコントローラーに送られ、最終的なターゲットビットレートが出力されます. 輻輳が検出されたらすぐに、または少なくとも1秒に1回、REMBメッセージを送信することをお勧めします. 

4.送信エンジン
Pacing は、コントローラーによって計算されたターゲットビットレートを作動させるために使用されます. 

メディアエンコーダーがデータを生成すると、これはPacerキューに送られます. Pacerは、burst_time間隔ごとにパケットのグループをネットワークに送信します. burst_timeの推奨値は5ミリ秒です. パケットのグループのサイズは、ターゲットビットレートとburst_timeの積として計算されます. 

5.遅延ベースの制御
遅延ベースの制御アルゴリズムは、さらに4つの部分に分解できます. 事前フィルタリング、到着時間フィルター、過剰使用検出器、およびレートコントローラーです. 

5.1. 到着時間モデル
このセクションでは、受信したパケットグループのタイミングに基づいてネットワークパラメータの推定値を継続的に更新する適応フィルタについて説明します. 

到着間隔時間 t(i) - t(i-1) を、2つのパケットグループの到着時間の差として定義します. 同様に、出発間時間 T(i) - T(i-1) は、パケットの2つのグループの出発時間の差として定義されます. 最後に、群間遅延変動 d(i) は、到着間時間と出発間時間の差として定義されます. または、グループiとグループi-1の遅延の違いとして解釈が異なります. 

     d(i) = t(i) - t(i-1) -(T(i) - T(i-1))
        
出発間時間は、連続するグループ間で T(i) - T(i-1) として計算されます. ここで、T(i) は、処理中の現在のパケットグループの最後のパケットの出発タイムスタンプです. 順不同で受信されたパケットは、到着時間モデルによって無視されます. 

各グループには、グループの最後のパケットが受信された時間に対応する受信時間 t(i) が割り当てられます. t(i) - t(i-1) > T(i) - T(i-1) の場合、つまり到着間隔が出発間隔よりも大きい場合、グループは前のグループに比べて遅延します. 

群間遅延変動は次のようにモデル化できます. 

     d(i) = w(i)
        
ここで、w(i) は確率過程Wからのサンプルであり、link容量、現在のcross traffic、および現在送信されているビットレートの関数です. Wをwhite Gaussian processとしてモデル化します. チャネルを使いすぎている場合、w(i)の平均が増加すると予想され、ネットワークパス上のキューが空になっている場合、w(i)の平均は減少します. それ以外の場合、w(i)の平均はゼロになります. 

   w(i) から平均 m(i) を分割して、プロセスをゼロ平均にします. 
   我々が得る
        
式1

     d(i) = m(i) + v(i)
        
ノイズ項v(i)は、モデルによってキャプチャされないネットワークジッタおよびその他の遅延効果を表します. 

5.2. 事前フィルタリング
事前フィルタリングは、チャネルの停止によって引き起こされる一時的な遅延を処理することを目的としています. 停止中、輻輳とは関係のない理由でネットワークバッファにキューイングされているパケットは、停止が終了するとバーストで配信されます. 

事前フィルタリングは、バーストで到着するパケットのグループをマージします. 次の2つの条件のいずれかが当てはまる場合、パケットは同じグループにマージされます. 

o  burst_time間隔内に送信される一連のパケットがグループを構成します. 

o  到着間時間がburst_time未満で、群間遅延変動 d(i) が0未満のパケットは、現在のパケットグループの一部と見なされます. 

5.3. 到着時間フィルター
パラメータd(i) は、パケットの各グループ i> 1ですぐに使用できます. m(i)を推定し、この推定値を使用して、ボトルネックリンクが過剰に使用されているかどうかを検出します. このパラメーターは、任意の適応フィルターで推定できます. カルマンフィルターを使用しています. 

m(i)を時間iでの推定値とします. 

時間iから時間i + 1までの状態の進化を次のようにモデル化します. 

     m(i + 1)= m(i)+ u(i)
        
ここで、u(i)は、平均と分散がゼロのガウス統計を使用して定常プロセスとしてモデル化する状態ノイズです. 

     q(i) = E{u(i)^2}
        
   q(i)は10 ^ -3に等しいことが推奨されます
        
式1が与えられると、

       d(i) = m(i)+ v(i)
        
   ここで、v(i)はゼロの平均白色ガウス測定ノイズです. 
   分散 var_v = E {v(i)^ 2}
        
カルマンフィルターは、推定値m_hat(i) を次のように再帰的に更新します. 

     z(i)= d(i) -m_hat(i-1)
        
     m_hat(i) = m_hat(i-1)+ z(i)* k(i)
        
                        e(i-1)+ q(i)
     k(i) = ----------------------------------------
                var_v_hat(i) +(e(i-1)+ q(i))
        
     e(i)=(1-k(i))*(e(i-1)+ q(i))
        
   分散var_v(i)= E {v(i)^ 2}は、指数関数を使用して推定されます
   平均化フィルター、可変サンプリングレート用に変更
        
     var_v_hat(i) = max(alpha * var_v_hat(i-1)+(1-alpha)* z(i)^ 2、1)
        
     alpha =(1-chi)^(30 /(1000 * f_max))
        
ここで、f_max = max {1 /(T(j)-T(j-1))} for j in i-K + 1、...、iは、最後のKパケットグループが受信された最高レートであり、 chiは、通常、区間[0.1、0.001]の数値として選択されるフィルター係数です. v(i)がゼロであるという仮定は、WGN(white gaussian noise)の精度が低い場合があることを意味するため、var_v_hatの更新の周りに追加の外れ値フィルターを導入しました. z(i)> 3 * sqrt(var_v_hat)の場合、フィルターはz(i)ではなく3 * sqrt(var_v_hat)で更新されます. たとえば、パケットがチャネル容量よりも高いレートで送信される状況では、v(i)は白になりません. その場合、パケットは互いにキューに入れられます. 

5.4. 過剰使用検出器
到着時間フィルターの出力として取得された群間遅延変動推定値m(i)は、しきい値del_var_th(i)と比較されます. しきい値を超える見積もりは、過剰使用の兆候と見なされます. このような表示は、検出器が過剰使用をレート制御サブシステムに通知するのに十分ではありません. 決定的な過剰使用は、少なくともoveruse_time_thミリ秒の間過剰使用が検出された場合にのみ通知されます. ただし、m(i)<m(i-1)の場合、上記のすべての条件が満たされていても、過剰使用は通知されません. 同様に、m(i)<-del_var_th(i)の場合、使用中の反対の状態が検出されます. 過剰使用も過少使用も検出されない場合、検出器は通常の状態になります. 

しきい値del_var_thは、アルゴリズムの全体的なダイナミクスとパフォーマンスに顕著な影響を与えます. 特に、静的しきい値del_var_thを使用すると、提案されたアルゴリズムによって制御されるフローが、同時TCPフローによって不足する可能性があることが示されています[Pv13]. この飢餓は、しきい値del_var_thを十分に大きな値に増やすことで回避できます. 

その理由は、del_var_thの値を大きくすると、より大きなキューイング遅延を許容できるのに対し、del_var_thが小さいと、過剰使用検出器は、オフセット推定値m(i)のわずかな増加にすばやく反応して、オーバーを生成するためです.  -利用可能な帯域幅A_hatの遅延ベースの推定値を減らす信号を使用します(セクション4.4を参照). したがって、損失ベースのフローと競合する場合など、最も一般的なシナリオで良好なパフォーマンスを得るには、しきい値del_var_thを動的に調整する必要があります. 

このため、次の動的方程式に従ってしきい値del_var_th(i)を変更することを提案します. 

del_var_th(i) =
         del_var_th(i-1) + (t(i)-t(i-1)) * K(i) * (|m(i)|-del_var_th(i-1))
        
|m(i)|の場合、K(i)= K_dの場合 <del_var_th(i-1)またはK(i)= K_uそれ以外の場合. 理論的根拠は、m(i)が範囲[-del_var_th(i-1)、del_var_th(i-1)]の外にある場合、del_var_th(i)を増やすことです. 一方、オフセット推定値m(i)は、範囲、del_var_thが減少します. このようにして、たとえばTCPフローが同じボトルネックに入ったためにm(i)が増加すると、del_var_th(i)が増加し、提案されたアルゴリズムによって制御されるフローの枯渇につながる可能性のある過剰使用信号の制御されない生成を回避します.  [Pv13]. さらに、この条件が当てはまる場合、del_var_th(i)を更新しないでください. 

     |m(i)| --del_var_th(i)> 15
        
del_var_th(i)が小さすぎると検出器の感度が高くなりすぎる可能性があるため、del_var_th(i)を[6、600]の範囲にクランプすることもお勧めします. 

一方、m(i)が[-del_var_th(i-1)、del_var_th(i-1)]の範囲に戻ると、しきい値del_var_th(i)が減少するため、より低いキューイング遅延を実現できます. 

del_var_thが増加する速度が減少する速度よりも高くなるように、K_u> K_dを選択することをお勧めします. この設定を使用すると、同時TCPフローの場合にしきい値を増やし、starvationを防ぎ、プロトコル内の公平性を強化することができます. del_var_th(0)、overuse_time_th、K_u、およびK_dの推奨値は、それぞれ12.5ミリ秒、10ミリ秒、0.01、および0.00018です. 

5.5. レート制御
レート制御は2つの部分に分割され、1つは遅延に基づいて帯域幅の見積もりを制御し、もう1つは損失に基づいて帯域幅の見積もりを制御します. どちらも、輻輳が検出されない限り、使用可能な帯域幅A_hatの推定値を増やし、最終的にチャネルの使用可能な帯域幅と一致させ、過剰使用を検出するように設計されています. 

過剰使用が検出されるとすぐに、遅延ベースのコントローラーによって推定される使用可能な帯域幅が減少します. このようにして、利用可能な帯域幅の再帰的かつ適応的な見積もりを取得します. 

このドキュメントでは、レート制御サブシステムが定期的に実行され、この期間が一定であると想定しています. 

レート制御サブシステムには、増加、減少、および保留の3つの状態があります. 「増加」は、輻輳が検出されなかったときの状態です. 「減少」は輻輳が検出された状態であり、「保留」は構築されたキューが空になるまで待機してから「増加」状態に移行する状態です. 

状態遷移(空白のフィールドは「状態を維持する」を意味します)は次のとおりです. 

   +----+--------+-----------+------------+--------+
   |     \ State |   Hold    |  Increase  |Decrease|
   |      \      |           |            |        |
   | Signal\     |           |            |        |
   +--------+----+-----------+------------+--------+
   |  Over-use   | Decrease  |  Decrease  |        |
   +-------------+-----------+------------+--------+
   |  Normal     | Increase  |            |  Hold  |
   +-------------+-----------+------------+--------+
   |  Under-use  |           |   Hold     |  Hold  |
   +-------------+-----------+------------+--------+
        
サブシステムは増加状態で開始し、検出器サブシステムによって過剰使用または過少使用が検出されるまで維持されます. 更新のたびに、利用可能な帯域幅の遅延ベースの見積もりが、現在の状態に応じて、乗算的または加算的に増加します. 

システムは、現在の帯域幅の見積もりが収束から遠いように見える場合は乗法的な増加を行い、収束に近いように見える場合は加法的な増加を行います. 現在入力されているビットレートR_hat(i) が、以前に減少状態にあったときの入力ビットレートの平均に近い場合、収束に近いと想定します. 「閉じる」は、この平均の周りの3つの標準偏差として定義されます. この平均と標準偏差は、平滑化係数0.95の指数移動平均で測定することをお勧めします. この平均は、減少状態にある複数の機会をカバーすると予想されるためです. これらの統計の有効な見積もりが利用できないときはいつでも、

R_hat(i) が平均最大ビットレートの3標準偏差を超えて増加した場合、現在の輻輳レベルが変化したと見なし、その時点で平均最大ビットレートをリセットして乗法増加状態に戻ります. 

R_hat(i) は、遅延ベースのコントローラーによってT秒ウィンドウで測定された着信ビットレートです. 

     R_hat(i) = 1/T * sum(L(j)) for j from 1 to N(i)
        
N(i)は過去T秒間に受信されたパケットの数であり、L(j)はパケットjのペイロードサイズです. 0.5〜1秒のウィンドウをお勧めします. 

乗法による増加の間、推定値は1秒あたり最大8％増加します. 

     eta = 1.08 ^ min(time_since_last_update_ms / 1000、1.0)
     A_hat(i) = eta * A_hat(i-1)
        
加算的な増加の間、推定値は、response_time間隔ごとに最大で半分のパケットで増加します. response_time間隔は、ラウンドトリップ時間に、過剰使用の推定器と検出器の反応時間の推定値として100ミリ秒を加えたものとして推定されます. 

    response_time_ms = 100 + rtt_ms
    alpha = 0.5 * min(time_since_last_update_ms / response_time_ms、1.0)
    A_hat(i) = A_hat(i-1)+ max(1000、alpha * expected_pa​​cket_size_bits)
        
expected_pa​​cket_size_bitsは、ビットレートが低い場合の加算的な増加に対して、わずかに遅いスロープを取得するために使用されます. たとえば、1秒あたり30フレームのフレームレートを想定することにより、現在のビットレートから計算できます. 

     bits_per_frame = A_hat(i-1)/ 30
     packet_per_frame = ceil(bits_per_frame /(1200 * 8))
     avg_packet_size_bits = bits_per_frame / packet_per_frame
        
システムは、チャネルを過剰に使用して現在利用可能な帯域幅の見積もりを確認することに依存しているため、見積もりが送信者が実際に送信しているレートから逸脱しないようにする必要があります. したがって、送信者が輻輳コントローラが要求しているビットレートでビットストリームを生成できない場合、利用可能な帯域幅の見積もりは指定された範囲内にとどまる必要があります. したがって、しきい値を導入します

     A_hat(i) <1.5 * R_hat(i) 
        
過剰使用が検出されると、システムは減少状態に移行します. この状態では、遅延ベースの使用可能な帯域幅の見積もりが、現在着信しているビットレートの1倍に減少します. 

     A_hat(i) =ベータ* R_hat(i) 
        
ベータは通常、[0.8、0.95]の間隔で選択され、0.85が推奨値です. 

検出器が使用中の信号をレート制御サブシステムに送信すると、ネットワークパスのキューが空になっていることがわかります. これは、使用可能な帯域幅の見積もりA_hatが実際の使用可能な帯域幅よりも低いことを示しています. その信号で、レート制御サブシステムはホールド状態に入ります. この状態では、キューがより低いレベルで安定するのを待つ間、受信側の利用可能な帯域幅の見積もりが一定に保たれます. これは、遅延を可能な限り低く保つ方法です. この遅延の減少は、使いすぎのために見積もりが減少した直後に望まれ、予想されますが、一部のリンクのクロストラフィックが減少した場合にも発生する可能性があります. 

A_hat(i) を更新するルーチンは、response_time間隔ごとに少なくとも1回実行することをお勧めします. 

5.6. パラメータ設定
   +-----------------+-----------------------------------+-------------+
   | Parameter       | Description                       | RECOMMENDED |
   |                 |                                   | Value       |
   +-----------------+-----------------------------------+-------------+
   | burst_time      | Time limit in milliseconds        | 5 ms        |
   |                 | between packet bursts which       |             |
   |                 | identifies a group                |             |
   | q               | State noise covariance matrix     | q = 10^-3   |
   | e(0)            | Initial value of the  system      | e(0) = 0.1  |
   |                 | error covariance                  |             |
   | chi             | Coefficient used  for the         | [0.1,       |
   |                 | measured noise variance           | 0.001]      |
   | del_var_th(0)   | Initial value for the adaptive    | 12.5 ms     |
   |                 | threshold                         |             |
   | overuse_time_th | Time required to trigger an       | 10 ms       |
   |                 | overuse signal                    |             |
   | K_u             | Coefficient for the adaptive      | 0.01        |
   |                 | threshold                         |             |
   | K_d             | Coefficient for the adaptive      | 0.00018     |
   |                 | threshold                         |             |
   | T               | Time window for measuring the     | [0.5, 1] s  |
   |                 | received bitrate                  |             |
   | beta            | Decrease rate factor              | 0.85        |
   +-----------------+-----------------------------------+-------------+
        
表1：遅延ベースのコントローラーの推奨値



6.損失ベースの制御
輻輳コントローラの2番目の部分は、ラウンドトリップ時間、パケット損失、および遅延ベースのコントローラから受信したA_hatの利用可能な帯域幅の見積もりに基づいて決定を下します. 損失ベースのコントローラーによって計算された利用可能な帯域幅の見積もりは、As_hatで示されます. 

遅延ベースのコントローラーによって生成された利用可能な帯域幅の見積もりA_hatは、パスに沿ったキューのサイズが十分に大きい場合にのみ信頼できます. キューが非常に短い場合、過剰使用はパケット損失によってのみ表示され、遅延ベースのコントローラーでは使用されません. 

損失ベースのコントローラーは、レシーバーからのフィードバックを受信するたびに実行する必要があります. 

o 受信者からの前回のレポート以降にパケットの2〜10％が失われた場合、送信者が利用できる帯域幅の見積もりAs_hat(i) は変更されません. 

o パケットの10％以上が失われた場合、新しい見積もりはAs_hat(i) = As_hat(i-1)(1-0.5p)として計算されます. ここで、pは損失率です. 

o 失われたパケットが2％未満である限り、As_hat(i) = 1.05(As_hat(i-1))としてAs_hat(i) が増加します. 

損失ベースの見積もりAs_hatは、遅延ベースの見積もりA_hatと比較されます. 実際の送信速度は、As_hatとA_hatの間の最小値として設定されます. 

過剰使用により伝送チャネルのパケット損失が少量である場合、送信者がビットレートを調整しないと、その量はすぐに増加することに注意して、パケット損失のしきい値を動機付けます. したがって、すぐに10％のしきい値を超えて、As_hat(i) を調整します. ただし、パケット損失率が上がらない場合は、自発的な輻輳とは関係がない可能性が高いため、対応すべきではありません. 

7.相互運用性に関する考慮事項
これらのアルゴリズムを実装する送信者が、提案されたRTCPメッセージとRTPヘッダー拡張のいずれも実装しない受信者と通信する場合、送信者はRTCP受信者レポートを監視し、失われたパケットの割合とラウンドトリップ時間を次のように使用することをお勧めします. 損失ベースのコントローラーへの入力. 遅延ベースのコントローラーは無効のままにしておく必要があります. 

8.実装経験
このアルゴリズムはオープンソースのWebRTCプロジェクトに実装されており、M23以降Chromeで使用されており、Googleハングアウトで使用されています. 

アルゴリズムの展開により、たとえば、混雑した、または問題のあるWiFiネットワークに関連する問題が明らかになり、アルゴリズムの改善につながりました. このアルゴリズムは、エンドポイント間の輻輳制御を終了する会議サーバーを使用したマルチパーティ会議シナリオでもテストされています. これにより、通常は会議サーバーでは制御できない最大の送受信ビットレートなどについて、輻輳制御によって想定が行われないことが保証されます. 

9.さらなる作業
このドラフトは、輻輳制御の議論への入力として提供されます. 

これに基づいて実行できる作業には、次のものがあります. 

o統合された損失管理の考慮事項：損失と遅延の管理をより適切に統合し、損失管理を改善する方法. 

o統制の所在に関する考慮事項：送信側と受信側の間でロジックを分割する場合と比較して、送信側にすべての輻輳制御ロジックがある場合のパフォーマンスを評価します. 

o輻輳推定およびリンクの過剰使用検出の信号としてECNを利用することの検討. 

10.IANAの考慮事項
このドキュメントはIANAに要求しません. 

RFCエディターへの注記：このセクションは、RFCとして公開されると削除される場合があります. 

11.セキュリティに関する考慮事項
接続でメッセージを挿入または削除する機能を持つ攻撃者は、レート制御を妨害する可能性があります. これにより、アルゴリズムがボトルネックリンク容量を十分に活用していない送信レートを生成するか、送信レートが高すぎてネットワークの輻輳を引き起こす可能性があります. 

この場合、制御情報はRTP内で伝送され、メディアと同様にSRTPを使用して変更やメッセージ挿入から保護できます. タイムスタンプは暗号化されていないRTPヘッダーで伝送されるため、これは開示から保護されていませんが、タイミング情報のみに基づいて攻撃を仕掛けるのは難しいようです. 

12.謝辞
このドラフトの以前のバージョンについて貴重なフィードバックを提供してくれたRandellJesup、Magnus Westerlund、Varun Singh、Tim Panton、Soo-Hyun Choo、Jim Gettys、Ingemar Johansson、MichaelWelzlなどに感謝します. 

13.参考文献
13.1. 規範的参考文献
[ID.alvestrand-rmcat-remb] Alvestrand、H. 、「Receiver Estimated Maximum BitrateのRTCPメッセージ」、draft-alvestrand-rmcat-remb-03(作業中)、2013年10月. 

[ID.holmer-rmcat-transport-wide-cc-extensions] Holmer、S.、Flodman、M. 、およびE. Sprang、「トランスポート全体の輻輳制御のためのRTP拡張機能」、draft-holmer-rmcat-transport-wide -cc-extensions-00(作業中)、2015年3月. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R. 、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、2003年7月. 

[abs-send-time]「絶対送信者時間のRTPヘッダー拡張」、<http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time>. 

13.2. 有益な参考文献
[Pv13] De Cicco、L.、Carlucci、G. 、およびS. Mascolo、「Google輻輳制御の動的動作の理解」、パケットビデオワークショップ、2013年12月. 

[RFC2914] Floyd、S. 、「Congestion Control Principles」、BCP 41、RFC 2914、2000年9月. 

付録A.変更ログ
A.1. バージョン-00から-01
o変更ログを追加しました

o新しい拡張機能の概要を説明する付録を追加しました

oセクション3.3「レート制御」の最後にフィードバックを送信するタイミングに関するセクションを追加し、最小/最大FB間隔を定義しました. 

o「さらなる作業」セクションに帯域幅超過見積もりの​​使用サイズを追加しました. 

o「今後の作業」セクションに起動時の考慮事項を追加しました. 

o「さらなる作業」セクションに送信者遅延の考慮事項を追加しました. 

oメーリングリストディスカッションの謝辞セクションに記入. 

A.2. バージョン-01から-02
o「フレーム」という用語を定義し、その定義に送信時間オフセットを組み込み、「ビデオフレーム」への参照を削除しました. 

o派生を明確にするために、本文から「m(i)」を参照しました. 

o実際に利用可能な帯域幅ではなく、利用可能な帯域幅の見積もりを変更することを明確にしました. 

o新しい拡張機能の概要を説明する付録を削除し、REMBドラフトおよびRFC5450へのポインターを追加しました. 

A.3. バージョン-02から-03
oRTPタイムスタンプからNTP時間への変換を使用して単一の推定器で複数のストリームを処理する方法に関するセクションを追加しました. 

o冒頭で、ドラフトはRMCATワーキンググループを対象としていると述べました. 

A.4. rtcweb-03からrmcat-00
ドラフト名をRMCATWGにリンクするために、ドラフトの名前を変更しました. 

A.5. rmcat-00から-01
スペルチェック. それ以外の場合、変更はありません. これは「キープアライブ」リリースです. 

A.6. rmcat-01から-02
o Luca DeCiccoとSaverioMascoloを著者として追加しました. 

o公平性のプロパティを改善するために、オフセットdel_var_thを動的に調整する方法に関する新しい技術的な詳細で、「過剰使用検出器」セクションを拡張しました. 

o提案されたアルゴリズムの動作を分析する論文への参照を追加しました. 

A.7. rmcat-02から-03
o受信側で遅延ベースのコントローラーを実行する必要がなくなったため、受信側/送信側のコントローラーを遅延ベース/損失ベースのコントローラーと交換しました. 

o複数のストリームと送信時間オフセットに関する説明を削除しました. 

o「フィードバックと拡張機能」に関する新しいセクションを導入しました. 

o「過剰使用検出器」セクションのしきい値適応の改善. 

o以前のMIMDレート制御アルゴリズムを新しいAIMDレート制御アルゴリズムに置き換えました. 

A.8. ietf-rmcat-00からietf-rmcat-01
o2次元カルマンフィルターからスカラーカルマンフィルターに変換された到着時間フィルター. 

o TFRC方程式の使用は、実際にはほとんどまたはまったく効果がないことが判明したため、損失ベースのコントローラーから削除されました. 

A.9. ietf-rmcat-01からietf-rmcat-02
oプレフィルタリングアルゴリズムをよりよく説明するセクションを追加しました. 

著者の住所

Stefan Holmer Google Kungsbron2ストックホルム11122スウェーデン

   メール：holmer@google.com Henrik Lundin
   グーグル
   Kungsbron 2
   ストックホルム11122
   スウェーデン
        
   メール：hlundin@google.com
        
Gaetano Carlucci Politecnico di Bari Via Orabona、4 Bari70125イタリア

   Eメール：gaetano.carlucci@poliba.it
        
Luca De Cicco Politecnico di Bari Via Orabona、4 Bari70125イタリア

   Eメール：l.decicco@poliba.it
        
Saverio Mascolo Politecnico di Bari Via Orabona、4 Bari70125イタリア

   Eメール：mascolo@poliba.it
        