RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
8831
RFC8831-WebRTCデータチャネル日本語訳
URL：https：//tools.ietf.org/html/rfc8831
パッケージ：RFC8831-WebRTCデータチャネル
翻訳：自動翻訳
インターネットエンジニアリングタスクフォース（IETF）R。Jesup
コメントのリクエスト：8831 Mozilla
カテゴリ：標準化過程S.ロレート
ISSN：2070-1721エリクソン
                                                                M.Tüxen
                                         ミュンスター大学 Applの。科学
                                                            2021年1月
        
WebRTCデータチャネル

概要

WebRTCフレームワークは、2つのピアのWebブラウザー間でオーディオ、ビデオ、およびデータを使用した、直接、インタラクティブ、リッチな通信のプロトコルサポートを指定します。このドキュメントでは、WebRTCフレームワークのメディア以外のデータ転送の側面について説明します。これは、Webブラウザがピアツーピアで一般的なデータを交換できるようにする一般的なトランスポートサービスとして、WebRTCコンテキストでStream Control Transmission Protocol（SCTP）がどのように使用されるかについてのアーキテクチャの概要を提供します。

このメモのステータス

これはインターネット標準化過程の文書です。

このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です。これは、IETFコミュニティのコンセンサスを表しています。パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました。インターネット標準の詳細については、RFC7841のセクション2を参照してください。

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8831で入手できます。

著作権表示

Copyright（c）2021 IETFTrustおよびドキュメントの作成者として識別された人物。全著作権所有。

このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。

目次

1.はじめに2.規則3.ユースケース3.1。信頼性の低いデータチャネルのユースケース3.2。信頼性の高いデータチャネルの使用例4.要件5.SCTP over DTLS overUDPの考慮事項6.データチャネルでのSCTPの使用6.1。SCTPプロトコルの考慮事項6.2。SCTPアソシエーション管理6.3。SCTPストリーム6.4。データチャネル定義6.5。データチャネルを開く6.6。データチャネルでのユーザーデータの転送6.7。データチャネルを閉じる7.セキュリティに関する考慮事項8.IANAに関する考慮事項9.参考資料9.1。規範的参考文献9.2。有益な参考文献謝辞著者のアドレス

1.はじめに
WebRTCフレームワークでは、当事者間の通信はメディア（オーディオやビデオなど）と非メディアデータで構成されます。メディアはSecureReal-time Transport Protocol（SRTP）を使用して送信されるため、ここでは特に指定しません。非メディアデータは、DTLSにカプセル化されたStream Control Transmission Protocol（SCTP）[RFC4960]を使用して処理されます。DTLS1.0は[RFC4347]で定義されています。現在の最新バージョンであるDTLS1.2は、[RFC6347]で定義されています。今後のバージョンであるDTLS1.3は、[TLS-DTLS13]で定義されています。

                               + ---------- +
                               | SCTP |
                               + ---------- +
                               | DTLS |
                               + ---------- +
                               | ICE / UDP |
                               + ---------- +
        
図1：基本的なスタック図

SCTP over DTLS（[RFC8261]を参照）over ICE / UDP（[RFC8445]を参照）のカプセル化は、機密性、ソース認証、および整合性保護された転送とともにNATトラバーサルソリューションを提供します。このデータトランスポートサービスはSRTPメディアトランスポートと並行して動作し、最終的にはすべてが単一のUDPポート番号を共有できます。

SCTPは、[RFC3758]で定義された部分信頼性拡張（PR-SCTP）および[RFC7496]で定義された追加ポリシーとともに、[RFC4960]で指定されているように、ユーザーに信頼性の高い、関連する部分的に信頼性のある配信モードをネイティブに提供します。メッセージ。[RFC6525]で定義されている再構成拡張機能を使用すると、SCTPアソシエーションの存続期間中にストリーム数を増やすことができ、個々のSCTPストリームをリセットできます。[RFC8260]を使用すると、大きなメッセージのインターリーブが独占を回避し、SCTPストリームの優先順位付けのサポートが追加されます。

このドキュメントの残りの部分は次のように構成されています。セクション3と4は、信頼性の低いピアツーピアデータチャネルの使用例と要件を示しています。セクション5では、SCTP over DTLS overUDPについて説明します。セクション6は、Webブラウザ間で非メディアデータを転送するためにWebRTCプロトコルフレームワークがSCTPをどのように使用するかを指定します。

2.コンベンション
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」 「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すように、すべて大文字で表示される場合にのみ解釈されます。

3.ユースケース
このセクションでは、データチャネルに固有のユースケースを定義します。このセクションは情報提供のみを目的としていることに注意してください。

3.1。信頼性の低いデータチャネルのユースケース
UC 1：位置とオブジェクトの状態情報が1つ以上の信頼できないデータチャネルを介して送信されるリアルタイムゲーム。いつでも、SRTPメディアチャネルがないか、すべてのSRTPメディアチャネルが非アクティブである可能性があり、信頼できるデータチャネルが使用されている可能性があることに注意してください。

UC 2：ミュート状態など、ビデオチャットまたは会議での状態更新の理由に関する重要ではない情報をユーザーに提供します。

3.2。信頼性の高いデータチャネルのユースケース
UC 3：制御情報などの重要な状態情報を転送する必要があるリアルタイムゲーム。このようなゲームにはSRTPメディアチャネルがないか、いつでも非アクティブであるか、ゲーム内のアクションによってのみ追加される可能性があります。

UC 4：チャットしている人の間での非リアルタイムのファイル転送。これには、画像のフォルダやファイルのディレクトリを共有する場合など、順次または並行して転送する多数のファイルが含まれる場合があることに注意してください。

UC 5：個人または会議の複数の人との音声通話および/またはビデオ通話中のリアルタイムテキストチャット。

UC 6：PeerConnectionの構成の再ネゴシエーション。

UC 7：プロキシブラウジング。ブラウザはPeerConnectionのデータチャネルを使用してHTTP / HTTPS要求とデータを送受信し、たとえば、ローカルインターネットのフィルタリングや監視を回避します。

4.要件
このセクションでは、2つのブラウザー間のピアツーピア（P2P）データチャネルの要件を示します。このセクションは情報提供のみを目的としていることに注意してください。

必須 1：複数の同時データチャネルをサポートする必要があります。同じPeerConnection内のデータチャネルと並列に0個以上のSRTPメディアストリームが存在する可能性があり、これらのSRTPメディアストリームの数と状態（アクティブ/非アクティブ）はいつでも変更される可能性があることに注意してください。

必須 2：信頼できるデータチャネルと信頼できないデータチャネルの両方をサポートする必要があります。

必須 3：PeerConnectionのデータチャネルは、個別に、クラスとして、またはPeerConnectionのSRTPメディアストリームと組み合わせて、輻輳制御する必要があります。これにより、データチャネルがこれらのSRTPメディアストリームの輻輳の問題を引き起こさず、WebRTCPeerConnectionがTCP接続と並行して実行されたときに過度の問題を引き起こさないことが保証されます。

必須 4：アプリケーションは、各データチャネルの相互の相対的な優先度、およびSRTPメディアストリームに対する相対的な優先度に関するガイダンスを提供できる必要があります。これは、輻輳制御アルゴリズムと相互作用します。

必須 5：データチャネルを保護する必要があります。これにより、機密性、整合性、およびソース認証が可能になります。詳細については、[RFC8826]および[RFC8827]を参照してください。

必須 6：データチャネルは、JavaScriptアプリケーションが送信するメッセージの大きさに関係なく、IP層の断片化を回避できるように、メッセージの断片化をサポートする必要があります。また、大規模なデータチャネル転送が他のデータチャネルのトラフィックを過度に遅延させないようにする必要があります。

必須 7：データチャネルトランスポートプロトコルは、プロトコルフィールド内にローカルIPアドレスをエンコードしてはなりません。そうすることで、潜在的に個人情報が明らかになり、アドレスが依存している場合は失敗につながります。

必須 8：データチャネルトランスポートプロトコルは、画像ファイル転送などのアプリケーション層で無制限の長さの「メッセージ」（つまり、仮想ソケットストリーム）をサポートする必要があります。実装により、妥当なメッセージサイズ制限が適用される場合があります。

必須 9：データチャネルトランスポートプロトコルは、IPフラグメンテーションを回避する必要があります。パスMTU（PMTU）検出をサポートする必要があり、特にPMTU検出の場合、ICMPまたはICMPv6の生成またはパスバックに依存してはなりません。

必須 10：ユーザーアプリケーションスペースにプロトコルスタックを実装できる必要があります。

5. SCTP over DTLS overUDPの考慮事項
WebRTCコンテキストでのSCTPの重要な機能は次のとおりです。

* TCP対応の輻輳制御の使用。

* SRTPメディアストリームの輻輳制御と統合するための変更可能な輻輳制御。

*複数の単方向ストリームのサポート。それぞれが順序付けられたメッセージ配信の独自の概念を提供します。

*順序付きおよび順序外のメッセージ配信のサポート。

*断片化と再構築を提供することにより、任意に大きなユーザーメッセージをサポートします。

* PMTUディスカバリーのサポート。

*信頼できるまたは部分的に信頼できるメッセージ転送のサポート。

WebRTCデータチャネルメカニズムは、SCTPマルチホーミングをサポートしていません。SCTPレイヤーは、シングルホームホストで実行されているかのように機能します。これは、DTLSレイヤー（コネクション型で信頼性の低いデータグラムサービス）が公開する抽象化であるためです。

[RFC8261]で定義されているSCTPover DTLSのカプセル化は、機密性、ソース認証、および整合性保護された転送を提供します。DTLS over UDPをInteractiveConnectivity Establishment（ICE）[RFC8445]と組み合わせて使用​​すると、IPv4およびIPv6ベースのネットワークでミドルボックストラバーサルが可能になります。[RFC4960]で指定されているSCTPは、[RFC3758]で定義されている拡張機能と組み合わせて使用​​する必要があり、ブラウザ間で非メディアデータを転送するための次の機能を提供します。

*複数の単方向ストリームのサポート。

*ユーザーメッセージの順序付きおよび順序なしの配信。

*ユーザーメッセージの信頼性と部分的に信頼性の高い転送。

各SCTPユーザーメッセージには、送信側の上位層によってSCTPに渡され、受信側の上位層に提供されるペイロードプロトコル識別子（PPID）が含まれています。PPIDを使用して、単一のSCTPアソシエーション上で複数の上位層を多重化/逆多重化できます。WebRTCコンテキストでは、PPIDは、UTF-8でエンコードされたユーザーデータ、バイナリでエンコードされたユーザーデータ、および[RFC8832]で定義されているデータチャネル確立プロトコル（DCEP）を区別するために使用されます。PPIDにはJavaScriptAPIを介してアクセスできないことに注意してください。

DTLSを介したSCTPのカプセル化は、上記のSCTP機能とともに、セクション4に記載されているすべての要件を満たします。

WebRTCのプロトコルの階層化を図2に示します。

                                 + ------ + ------ + ------ +
                                 | DCEP | UTF-8 |バイナリ|
                                 | | データ| データ|
                                 + ------ + ------ + ------ +
                                 | SCTP |
                   + ---------------------------------- +
                   | スタン| SRTP | DTLS |
                   + ---------------------------------- +
                   | ICE |
                   + ---------------------------------- +
                   | UDP1 | UDP2 | UDP3 | ... |
                   + ---------------------------------- +
        
図2：WebRTCプロトコルレイヤー

このスタック（特にDTLS over SCTP [RFC6083]とは対照的に、SCTP over UDP [RFC6951]との組み合わせ）は、次の理由で選択されました。

*任意の大きなユーザーメッセージの送信をサポートします。

* DTLS接続をPeerConnectionのSRTPメディアチャネルと共有します。そして

* SCTP制御情報のプライバシーを提供します。

図2に示すプロトコルスタックを参照してください。

* UDPを介したDTLS1.0の使用は、[RFC4347]で指定されています。

* [RFC6347]で指定されているUDPを介したDTLS1.2の使用。

* UDPを介したDTLS1.3の使用法は、今後のドキュメント[TLS-DTLS13]で指定されています。そして

* DTLS上でのSCTPの使用法は、[RFC8261]で指定されています。

NAT（STUN）[RFC5389]対SRTP対DTLSの逆多重化セッショントラバーサルユーティリティは、[RFC5764]のセクション5.1.2で説明されているように実行され、SCTPがDTLSの唯一のペイロードであることに注意してください。

DTLSは通常、ユーザーアプリケーションスペースに実装されるため、SCTPスタックもユーザーアプリケーションスペーススタックである必要があります。

ICE / UDPレイヤーは、DTLSおよびSCTPレイヤーとの対話を必要とせずに、セッション中のIPアドレスの変更を処理できます。ただし、アドレス変更が発生した場合は、SCTPに通知する必要があります。この場合、SCTPはパスMTUを再テストし、輻輳状態を初期状態にリセットする必要があります。[RFC4960]で指定されているようなウィンドウベースの輻輳制御の場合、これは輻輳ウィンドウとスロースタートしきい値を初期値に設定することを意味します。

対応する関連付けを識別する方法がないため、着信ICMPまたはICMPv6メッセージをSCTPレイヤーで処理することはできません。したがって、SCTPは、[RFC4820]で指定されたプローブメッセージを使用して、[RFC4821]で指定されたICMPまたはICMPv6に依存せずにパスMTU検出の実行をサポートする必要があります。IP層の初期パスMTUは、IPv4の場合は1200バイト、IPv6の場合は1280バイトを超えてはなりません。

一般に、SCTP実装の下位層インターフェイスは、IPv4とIPv6（コネクションレス型）またはDTLS（コネクション型）の違いに対処するように適合させる必要があります。

図2に示すプロトコルスタックを使用すると、DTLSは完全なSCTPパケットを保護するため、完全なSCTPパケットの機密性、整合性、および送信元認証を提供します。

SCTPは、アソシエーションごとに輻輳制御を提供します。これは、単一のSCTPアソシエーション内のすべてのSCTPストリームが同じ輻輳ウィンドウを共有することを意味します。SCTPを介して送信されないトラフィックは、SCTP輻輳制御の対象外です。標準とは異なる輻輳制御を使用すると、並列SRTPメディアストリームへの影響が改善される可能性があります。

SCTPは、TCPおよびUDPと同じポート番号の概念を使用します。したがって、SCTPアソシエーションは、各SCTPエンドポイントに1つずつ、合計2つのポート番号を使用します。

6.データチャネルでのSCTPの使用
6.1。SCTPプロトコルに関する考慮事項
[RFC8261]で説明されているSCTPパケットのDTLSカプセル化を使用する必要があります。

このSCTPスタックとその上位層は、複数のSCTPストリームの使用をサポートする必要があります。ユーザーメッセージは、部分的または完全な信頼性で、順序付きまたは順序なしで送信できます。

次のSCTPプロトコル拡張が必要です。

* [RFC6525]で定義されているストリーム再構成拡張機能をサポートする必要があります。チャネルを閉じるために使用されます。

* [RFC5061]で定義されている動的アドレス再構成拡張機能は、[RFC6525]で定義されているストリームリセット拡張機能のサポートを通知するために使用する必要があります。[RFC5061]の他の機能はオプションです。

* [RFC3758]で定義されている部分的な信頼性拡張をサポートする必要があります。[RFC3758]で定義されている時限信頼性PR-SCTPポリシーに加えて、[RFC7496]で定義されている制限付き再送信ポリシーをサポートする必要があります。再送信の数をゼロに制限し、順序付けられていない配信と組み合わせると、UDPのようなサービスが提供され、各ユーザーメッセージが1回だけ送信され、受信した順序で配信されます。

[RFC8260]で定義されているメッセージインターリーブのサポートを使用する必要があります。

6.2。SCTPアソシエーション管理
WebRTCコンテキストでは、SCTPアソシエーションは、通常はセッション記述プロトコル（SDP）の交換であるJavaScriptセッション確立プロトコル（JSEP）によってネゴシエートされるように、WebRTCPeerConnectionの2つのエンドポイントが開くことに同意したときにセットアップされます。 [RFC8829]。ICEを介して選択されたDTLS接続を使用します。通常、これはBUNDLEまたは同等のものを介して、SRTPメディアストリームのキーイングに使用されるDTLS接続と共有されます。

SCTPアソシエーションのセットアップ中にネゴシエートされるストリームの数は65535である必要があります。これは、アソシエーションのセットアップ中にネゴシエートできるストリームの最大数です。

SCTPは、SCTPアソシエーションを終了する2つの方法をサポートしています。最初の方法は適切な方法であり、関連付けのシャットダウン中にメッセージが失われないようにする手順が使用されます。2番目の方法は、一方の側が関連付けを中止できる非猶予的な方法です。

各SCTPエンドポイントは、ユーザーメッセージとテストメッセージの再送信回数を監視することにより、ピアの到達可能性を継続的に監視します。過度の再送信の場合、関連付けは非正常な方法で終了します。

SCTPアソシエーションが適切な方法で閉じられると、そのすべてのデータチャネルが閉じられます。正常でないティアダウンの場合、すべてのデータチャネルも閉じられますが、可能であればエラー表示を提供する必要があります。

6.3。SCTPストリーム
SCTPは、ストリームを、別のSCTPエンドポイントへのSCTPアソシエーション内に存在する単方向論理チャネルとして定義します。ストリームは、インシーケンス配信の概念を提供し、多重化するために使用されます。各ユーザーメッセージは、順序付きまたは順序なしの特定のストリームで送信されます。順序は、同じストリームで送信された順序付きメッセージに対してのみ保持されます。

6.4。データチャネルの定義
データチャネルは、付随するアプリケーションレベルのAPIがWebSocketのAPIを厳密に反映できるように定義されます。これは、データの双方向ストリームと、データチャネルの意味を識別するために使用される「ラベル」と呼ばれるテキストフィールドを意味します。

データチャネルの実現は、同じSCTPストリーム識別子を持つ1つの着信ストリームと1つの発信SCTPストリームのペアです。これらのSCTPストリーム識別子の選択方法は、プロトコルと実装によって異なります。これにより、双方向通信が可能になります。

さらに、各データチャネルには、各方向に次のプロパティがあります。

*信頼性または信頼性の低いメッセージ送信：信頼性の低い送信の場合、同じレベルの信頼性が使用されません。SCTPでは、これはSCTPユーザーメッセージのプロパティであり、SCTPストリームのプロパティではないことに注意してください。

*送信されたメッセージの順不同または順不同のメッセージ配信：SCTPでは、これはSCTPユーザーメッセージのプロパティであり、SCTPストリームのプロパティではないことに注意してください。

* 2バイトの符号なし整数である優先度：これらの優先度は、[RFC8260]でインターリーブをサポートする対応するストリームスケジューラの定義に従って、重み付き公平キューイングのスケジューリング優先度として解釈する必要があります。WebRTCで使用する場合、使用する値は128（「通常より低い」）、256（「通常」）、512（「高」）、または1024（「超高」）のいずれかである必要があります。

*オプションのラベル。

*オプションのプロトコル。

[RFC8832]で指定されたプロトコルでネゴシエートされているデータチャネルの場合、上記のプロパティはすべて両方向で同じであることに注意してください。

6.5。データチャネルを開く
データチャネルは、SCTPアソシエーション内のネゴシエーション（インバンドネゴシエーションと呼ばれる）またはアウトオブバンドネゴシエーションを使用して開くことができます。帯域外ネゴシエーションは、チャネルのパラメータとその作成に関して合意をもたらす任意の方法として定義されます。詳細は、このドキュメントの範囲外です。データチャネルを使用するアプリケーションは、両方のエンドポイントで一貫してネゴシエーション方式を使用する必要があります。

インバンドネゴシエーションの簡単なプロトコルは[RFC8832]で指定されています。

一方の側が帯域外ネゴシエーションを使用してチャネルを開きたい場合、ストリームを選択します。特に定義またはネゴシエートされていない限り、ストリームはDTLSロールに基づいて選択されます（クライアントは偶数のストリーム識別子を選択し、サーバーは奇数のストリーム識別子を選択します）。ただし、アプリケーションは、既存のストリームとの衝突を回避する責任があります。既存のデータチャネルの一部であるストリームを再利用しようとすると、追加は失敗しなければなりません（MUST）。アプリケーションは、ストリームの選択に加えて、メッセージの送信に使用するオプションも決定する必要があります。アプリケーションは、アプリケーション固有の方法で、ピアのアプリケーションが、使用する選択されたストリームと、その側からデータを送信するためのオプションも認識できるようにする必要があります。

6.6。データチャネルでのユーザーデータの転送
オプションが変更されたり、メッセージごとのオプションが上位レベルで指定されたりしない限り、データチャネルで双方向に送信されるすべてのデータは、データチャネルが開かれたときに定義された信頼性を使用して、基になるストリームを介して送信される必要があります。

SCTPのメッセージ指向は、ユーザーメッセージのメッセージ境界を保持するために使用されます。したがって、送信者は、SCTPユーザーメッセージに複数のアプリケーションメッセージを入れてはなりません（MUSTNOT）。非推奨のPPIDベースの断片化と再構築が使用されない限り、送信者は各SCTPユーザーメッセージに正確に1つのアプリケーションメッセージを含める必要があります。

SCTPペイロードプロトコル識別子（PPID）は、「ペイロードデータ」の解釈を通知するために使用されます。次のPPIDを使用する必要があります（セクション8を参照）。

WebRTC文字列：UTF-8でエンコードされた空でないJavaScript文字列を識別します。

WebRTC String Empty：UTF-8でエンコードされた空のJavaScript文字列を識別します。

WebRTCバイナリ：空でないJavaScriptバイナリデータ（ArrayBuffer、ArrayBufferView、またはBlob）を識別します。

WebRTC Binary Empty：空のJavaScriptバイナリデータ（ArrayBuffer、ArrayBufferView、またはBlob）を識別します。

SCTPは、空のユーザーメッセージの送信をサポートしていません。したがって、空のメッセージを送信する必要がある場合は、適切なPPID（WebRTC StringEmptyまたはWebRTCBinary Empty）が使用され、1つのゼロバイトのSCTPユーザーメッセージが送信されます。これらのPPIDのいずれかを含むSCTPユーザーメッセージを受信する場合、受信者はSCTPユーザーメッセージを無視し、それを空のメッセージとして処理する必要があります。

PPID「WebRTCStringPartial」および「WebRTCBinaryPartial」の使用は非推奨になりました。これらは、信頼性が高く順序付けられたデータチャネルに属するユーザーメッセージのPPIDベースの断片化と再構築に使用されました。

サポートされていないPPIDのメッセージが受信された場合、または受信したメッセージに関連するエラー状態が受信者によって検出された場合（たとえば、不正な順序付け）、受信者は対応するデータチャネルを閉じる必要があります。これは特に、追加のPPIDを使用する拡張機能は、事前のネゴシエーションなしでは使用できないことを意味します。

[RFC4960]で指定されているSCTP基本プロトコルは、ユーザーメッセージのインターリーブをサポートしていません。したがって、大きなユーザーメッセージを送信すると、SCTPの関連付けが独占される可能性があります。この制限を克服するために、[RFC8260]は、メッセージのインターリーブをサポートする拡張機能を定義しています。これを使用する必要があります。メッセージのインターリーブがサポートされていない限り、送信者は独占を避けるために最大メッセージサイズを16KBに制限する必要があります。

アプリケーションは任意の大きな単一メッセージをサポートできないため、メッセージサイズを特定のサイズ範囲内に維持することをお勧めします。この制限は、たとえば[RFC8841]を使用してネゴシエートする必要があります。

送信者は、待ち時間を最小限に抑えるために、Nagleアルゴリズム（[RFC1122]を参照）を無効にする必要があります。

6.7。データチャネルを閉じる
データチャネルの閉鎖は、対応する発信ストリームをリセットすることによって通知されなければならない[RFC6525]。これは、一方がデータチャネルを閉じることを決定した場合、対応する発信ストリームをリセットすることを意味します。ピアは、着信ストリームがリセットされたことを確認すると、対応する発信ストリームもリセットします。これが完了すると、データチャネルが閉じられます。ストリームをリセットすると、ストリームのストリームシーケンス番号（SSN）が「ゼロ」に戻り、リセットが実行されたことがアプリケーション層に通知されます。リセットが実行された後、ストリームを再利用できます。

[RFC6525]は、ストリームがリセットされる前に、すべてのメッセージが配信（または破棄）されることも保証します。

7.セキュリティに関する考慮事項
このドキュメントでは、[RFC8826]および[RFC8827]に記載されている考慮事項に追加の考慮事項は追加されていません。

受信者は、任意の大きなメッセージを送信しようとする送信者のために準備する必要があることに注意してください。

8.IANAの考慮事項
このドキュメントでは、すでに登録されている6つのSCTPペイロードプロトコル識別子（PPID）を使用しています。「DOMStringLast」、「Binary Data Partial」、「Binary Data Last」、「DOMString Partial」、「WebRTC String Empty」、「WebRTCBinaryEmpty」です。[RFC4960]は、これらの識別子が割り当てられた「SCTPペイロードプロトコル識別子」レジストリを作成します。IANAは、このドキュメントを指すようにこれら6つの割り当ての参照を更新し、最初の4つのPPIDの名前を変更しました。対応する日付は変更されません。

6つの割り当てが更新され、次のようになりました。

       + ====================== + =========== + =========== + == ========== +
       | 値| SCTP PPID | リファレンス| 日付|
       + ====================== + =========== + =========== + == ========== +
       | WebRTC文字列| 51 | RFC 8831 | 2013-09-20 |
       + ---------------------- + ----------- + ----------- +- ---------- +
       | WebRTCバイナリ| 52 | RFC 8831 | 2013-09-20 |
       | 部分的（非推奨）| | | |
       + ---------------------- + ----------- + ----------- +- ---------- +
       | WebRTCバイナリ| 53 | RFC 8831 | 2013-09-20 |
       + ---------------------- + ----------- + ----------- +- ---------- +
       | WebRTC文字列| 54 | RFC 8831 | 2013-09-20 |
       | 部分的（非推奨）| | | |
       + ---------------------- + ----------- + ----------- +- ---------- +
       | WebRTC文字列が空です| 56 | RFC 8831 | 2014-08-22 |
       + ---------------------- + ----------- + ----------- +- ---------- +
       | WebRTCバイナリが空です| 57 | RFC 8831 | 2014-08-22 |
       + ---------------------- + ----------- + ----------- +- ---------- +
        
表1

9.参考文献
9.1。規範的参考文献
[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。

[RFC3758] Stewart、R.、Ramalho、M.、Xie、Q.、Tuexen、M。、およびP. Conrad、「Stream Control Transmission Protocol（SCTP）Partial Reliability Extension」、RFC 3758、DOI 10.17487 / RFC3758、5月2004年、<https://www.rfc-editor.org/info/rfc3758>。

[RFC4820] Tuexen、M.、Stewart、R。、およびP. Lei、「ストリーム制御伝送プロトコル（SCTP）のパディングチャンクとパラメーター」、RFC 4820、DOI 10.17487 / RFC4820、2007年3月、<https：// www.rfc-editor.org/info/rfc4820>。

[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<https://www.rfc-editor.org/info/rfc4821>。

[RFC4960] Stewart、R.、Ed。、 "Stream Control Transmission Protocol"、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、<https://www.rfc-editor.org/info/rfc4960>。

[RFC5061] Stewart、R.、Xie、Q.、Tuexen、M.、Maruyama、S。、およびM. Kozuka、「Stream Control Transmission Protocol（SCTP）Dynamic Address Reconfiguration」、RFC 5061、DOI 10.17487 / RFC5061、9月2007、<https://www.rfc-editor.org/info/rfc5061>。

[RFC6525] Stewart、R.、Tuexen、M。、およびP. Lei、「Stream Control Transmission Protocol（SCTP）Stream Reconfiguration」、RFC 6525、DOI 10.17487 / RFC6525、2012年2月、<https：//www.rfc- editor.org/info/rfc6525>。

[RFC7496] Tuexen、M.、Seggelmann、R.、Stewart、R。、およびS. Loreto、「部分的に信頼できるストリーム制御伝送プロトコル拡張の追加ポリシー」、RFC 7496、DOI 10.17487 / RFC7496、2015年4月、<https ：//www.rfc-editor.org/info/rfc7496>。

[RFC8174] Leiba、B。、「RFC 2119キーワードにおける大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。

[RFC8260] Stewart、R.、Tuexen、M.、Loreto、S。、およびR. Seggelmann、「Stream Control Transmission Protocolのストリームスケジューラとユーザーメッセージインターリーブ」、RFC 8260、DOI 10.17487 / RFC8260、2017年11月、< https://www.rfc-editor.org/info/rfc8260>。

[RFC8261] Tuexen、M.、Stewart、R.、Jesup、R。、およびS. Loreto、「SCTPパケットのデータグラムトランスポート層セキュリティ（DTLS）カプセル化」、RFC 8261、DOI 10.17487 / RFC8261、2017年11月、<https ：//www.rfc-editor.org/info/rfc8261>。

[RFC8445] Keranen、A.、Holmberg、C。、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、< https://www.rfc-editor.org/info/rfc8445>。

[RFC8826] Rescorla、E。、「WebRTCのセキュリティに関する考慮事項」、RFC 8826、DOI 10.17487 / RFC8826、2021年1月、<https://www.rfc-editor.org/info/rfc8826>。

[RFC8827] Rescorla、E。、「WebRTC Security Architecture」、RFC 8827、DOI 10.17487 / RFC8827、2021年1月、<https://www.rfc-editor.org/info/rfc8827>。

[RFC8829] Uberti、J.、Jennings、C。、およびE. Rescorla、Ed。、「JavaScript Session Establishment Protocol（JSEP）」、RFC 8829、DOI 10.17487 / RFC8829、2021年1月、<https：//www.rfc -editor.org/info/rfc8829>。

[RFC8832] Jesup、R.、Loreto、S。、およびM.Tüxen、「WebRTC Data Channel Establishment Protocol」、RFC 8832、DOI 10.17487 / RFC8832、2021年1月、<https://www.rfc-editor.org/ info / rfc8832>。

[RFC8841] Holmberg、C.、Shpount、R.、Loreto、S。、およびG. Camarillo、「Datagram Transport Layer Security（DTLS）を介したStream Control Transmission Protocol（SCTP）のセッション記述プロトコル（SDP）オファー/アンサー手順トランスポート」、RFC 8841、DOI 10.17487 / RFC8841、2021年1月、<https://www.rfc-editor.org/info/rfc8841>。

9.2。有益な参考文献
[RFC1122] Braden、R.、Ed。、 "Requirements for Internet Hosts-Communication Layers"、STD 3、RFC 1122、DOI 10.17487 / RFC1122、October 1989、<https://www.rfc-editor.org/info/ rfc1122>。

[RFC4347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security」、RFC 4347、DOI 10.17487 / RFC4347、2006年4月、<https://www.rfc-editor.org/info/rfc4347>。

[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P。、およびD. Wing、「Session Traversal Utilities for NAT（STUN）」、RFC 5389、DOI 10.17487 / RFC5389、2008年10月、<https：// www.rfc-editor.org/info/rfc5389>。

[RFC5764] McGrew、D。およびE. Rescorla、「Secure Real-time Transport Protocol（SRTP）のキーを確立するためのDatagram Transport Layer Security（DTLS）Extension」、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、<https ：//www.rfc-editor.org/info/rfc5764>。

[RFC6083] Tuexen、M.、Seggelmann、R。、およびE. Rescorla、「Stream Control Transmission Protocol（SCTP）のデータグラムトランスポート層セキュリティ（DTLS）」、RFC 6083、DOI 10.17487 / RFC6083、2011年1月、<https： //www.rfc-editor.org/info/rfc6083>。

[RFC6347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>。

[RFC6951] Tuexen、M。and R. Stewart、 "UDP Encapsulation of Stream Control Transmission Protocol（SCTP）Packets for End-Host to End-Host Communication"、RFC 6951、DOI 10.17487 / RFC6951、May 2013、<https：/ /www.rfc-editor.org/info/rfc6951>。

[TLS-DTLS13] Rescorla、E.、Tschofenig、H。、およびN. Modadugu、「データグラムトランスポート層セキュリティ（DTLS）プロトコルバージョン1.3」、進行中の作業、インターネットドラフト、draft-ietf-tls-dtls13- 39、2020年11月2日、<https://tools.ietf.org/html/draft-ietf-tls-dtls13-39>。

謝辞

Harald Alvestrand、Richard Barnes、Adam Bergkvist、Alissa Cooper、Benoit Claise、Spencer Dawkins、GunnarHellström、Christer Holmberg、Cullen Jennings、Paul Kyzivat、Eric Rescorla、Adam Roach、IreneRüngeler、Randallからのコメント、アイデア、テキストに感謝します。 Stewart、Martin Stiemerling、Justin Uberti、MagnusWesterlund。

著者の住所

Randell JesupMozillaアメリカ合衆国

   Eメール：randell-ietf@jesup.org
        
サルヴァトーレロレートエリクソンヒルサランティ11FI-02420Jorvasフィンランド

   Eメール：salvatore.loreto@ericsson.com
        
ミヒャエルトゥクセンミュンスター応用科学大学Stegerwaldstrasse3948565シュタインフルトドイツ

   Eメール：tuexen@fh-muenster.de
        