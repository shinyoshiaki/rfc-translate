RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
4492
RFC 4492-トランスポート層セキュリティ（TLS）用の楕円曲線暗号（ECC）暗号スイート日本語訳
URL：https：//tools.ietf.org/html/rfc4492
パッケージ：RFC 4492-トランスポート層セキュリティ（TLS）用の楕円曲線暗号（ECC）暗号スイート
翻訳：自動生成
ネットワークワーキンググループS.ブレイク-ウィルソン
コメントのリクエスト：4492 SafeNet
カテゴリ：情報N. Bolyard
                                                        サンマイクロシステムズ
                                                                V.グプタ
                                                                サンラボ
                                                                 C.ホーク
                                                               コリエンテ
                                                              B.ムーラー
                                                         ルール大学ボーフム
                                                                2006年5月
        
トランスポート層セキュリティ（TLS）用の楕円曲線暗号（ECC）暗号スイート

このメモのステータス

このメモは、インターネットコミュニティに情報を提供します. いかなる種類のインターネット標準も指定していません. このメモの配布は無制限です. 

著作権表示

Copyright（C）The Internet Society（2006）. 

概要

このドキュメントでは、トランスポート層セキュリティ（TLS）プロトコル用の楕円曲線暗号（ECC）に基づく新しい鍵交換アルゴリズムについて説明します. 特に、TLSハンドシェイクでの楕円曲線ディフィーヘルマン（ECDH）鍵共有の使用と、新しい認証メカニズムとしての楕円曲線デジタル署名アルゴリズム（ECDSA）の使用を指定します. 

目次

   1.はじめに.........................................................  ..... 3
   2.鍵交換アルゴリズム......................................... 4
      2.1. ECDH_ECDSA.................................................  6
      2.2. ECDHE_ECDSA ................................................ 6
      2.3. ECDH_RSA.................................................  ..7
      2.4. ECDHE_RSA.................................................  . 7
      2.5. ECDH_anon.................................................  . 7
   3.クライアント認証........................................... 8
      3.1. ECDSA_sign.................................................  8
      3.2. ECDSA_fixed_ECDH ........................................... 9
      3.3. RSA_fixed_ECDH ............................................. 9
   4.ECCのTLS拡張.......................................... 9
   5.データ構造と計算............................... 10
      5.1. クライアントHello拡張機能................................... 10
           5.1.1. サポートされている楕円曲線拡張................ 12
           5.1.2. サポートされているポイントフォーマット拡張.................. 13
      5.2. Server Hello Extension .................................... 14
      5.3. サーバー証明書........................................ 15
      5.4. サーバーキー交換....................................... 17
      5.5. 証明書の要求....................................... 21
      5.6. クライアント証明書........................................ 22
      5.7. クライアントキー交換....................................... 23
      5.8. 証明書の確認........................................ 25
      5.9. 楕円曲線証明書............................... 26
      5.10. ECDH、ECDSA、およびRSAの計算........................ 26
   6.暗号スイート..............................................  .... 27
   7.セキュリティに関する考慮事項........................................ 28
   8.IANAの考慮事項............................................ 29
   9.謝辞...............................................  29
   10.参考文献...............................................  ..... 30
      10.1. 規範的参考文献..................................... 30
      10.2. 有益な参考資料................................... 31
   付録A.同等の曲線（参考情報）...................... 32
        
1.はじめに
楕円曲線暗号（ECC）は、特にモバイル（つまりワイヤレス）環境向けの魅力的な公開鍵暗号システムとして登場しています. RSAなどの現在普及している暗号システムと比較して、ECCはより小さなキーサイズで同等のセキュリティを提供します. これは、[18]に基づいて次の表に示されています. この表は、対称鍵暗号システムと非対称鍵暗号システムを攻撃するための最もよく知られたアルゴリズムに基づいて、それらの暗号システムにほぼ匹敵する鍵サイズを示しています. 

                    Symmetric  |   ECC   |  DH/DSA/RSA
                   ------------+---------+-------------
                        80     |   163   |     1024
                       112     |   233   |     2048
                       128     |   283   |     3072
                       192     |   409   |     7680
                       256     |   571   |    15360
        
表1：比較可能なキーサイズ（ビット単位）

キーサイズを小さくすると、電力、メモリ、帯域幅、計算コストが節約され、制約のある環境でECCが特に魅力的になります. 

このドキュメントでは、TLSバージョン1.0 [2]とTLSバージョン1.1 [3]の両方に適用可能な、ECCをサポートするためのTLSへの追加について説明します. 特に、それは定義します

o TLSプリマスターシークレットを確立するための、長期キーまたは一時キーを使用した楕円曲線ディフィーヘルマン（ECDH）キー合意スキームの使用. 

oTLSピアの認証のための固定ECDH証明書とECDSAの使用. 

このドキュメントの残りの部分は、次のように構成されています. セクション2では、TLS用のECCベースの鍵交換アルゴリズムの概要を説明します. セクション3では、クライアント認証のためのECC証明書の使用について説明します. クライアントが特定の曲線とポイント形式の使用をネゴシエートできるようにするTLS拡張は、セクション4に示されています. セクション5は、ECCベースのハンドシェイクに必要なさまざまなデータ構造、TLSメッセージでのエンコード、およびそれらのメッセージの処理を指定します. セクション6は、新しいECCベースの暗号スイートを定義し、この仕様のすべての実装に推奨されるこれらの小さなサブセットを識別します. セクション7では、セキュリティに関する考慮事項について説明します. セクション8では、このドキュメントで作成された名前空間に関するIANAの考慮事項について説明します. セクション9は謝辞を与えます. 

これに続いて、このドキュメントで引用されている規範的および有益な参考文献のリスト、著者の連絡先情報、および知的財産権と著作権に関する声明が続きます. 

この仕様を実装するには、TLS [2] [3]、TLS拡張[4]、およびECC [5] [6] [7] [11] [17]に精通している必要があります. 

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです.  RFC 2119 [1]で説明されているように解釈されます. 

2.鍵交換アルゴリズム
このドキュメントでは、TLS用の5つの新しいECCベースの鍵交換アルゴリズムを紹介します. それらはすべてECDHを使用してTLSプリマスターシークレットを計算し、ECDHキーの有効期間（長期または一時的）とそれらを認証するために使用されるメカニズム（存在する場合）のみが異なります. プリマスターシークレットからのTLSマスターシークレットの派生と、それに続くバルク暗号化/ MACキーおよび初期化ベクトルの生成は、キー交換アルゴリズムに依存せず、ECCの導入による影響を受けません. 

次の表は、DH_DSS、DHE_DSS、DH_RSA、DHE_RSA、およびDH_anonをそれぞれ模倣する新しい鍵交換アルゴリズムをまとめたものです（[2]および[3]を参照）. 

          Key
          Exchange
          Algorithm           Description
          ---------           -----------
        
         ECDH_ECDSAECDSA   署名付き証明書を使用したECDHを修正しました. 

         ECDHE_ECDSAECDSA  署名付きのエフェメラルECDH. 

         ECDH_RSARSA       署名付き証明書を使用したECDHを修正しました. 

         ECDHE_RSARSA      署名付きのエフェメラルECDH. 

         ECDH_anon         匿名ECDH、署名なし. 

表2：ECC鍵交換アルゴリズム

ECDHE_ECDSAおよびECDHE_RSA鍵交換メカニズムは、ForwardSecrecyを提供します. ECDHE_RSAを使用すると、サーバーは既存のRSA証明書を再利用でき、制約のあるクライアントの楕円曲線設定に簡単に準拠できます（セクション4を参照）. ただし、計算コスト

サーバーが負担するのは、ECDHE_RSAの方が、転送秘密を提供しない従来のRSA鍵交換よりも高くなります. 

ECDH_RSAメカニズムでは、サーバーがECC証明書を取得する必要がありますが、証明書発行者は引き続き既存のRSAキーを使用して署名できます. これにより、TLSクライアントによって受け入れられた信頼できる認証局のキーを更新する必要がなくなります. ECDH_ECDSAメカニズムには、サーバーと認証局のECCキーが必要であり、RSAをサポートできない制約のあるデバイスに最適です. 

匿名鍵交換アルゴリズムは、サーバーまたはクライアントの認証を提供しません. 他の匿名TLSキー交換と同様に、man-in-the-middle攻撃の対象となります. このアルゴリズムの実装は、他の手段による認証を提供する必要があります. 

ECDHキーとECDSAキーの間に構造上の違いはないことに注意してください. 証明書発行者は、X.509 v3 keyUsageおよびextendedKeyUsage拡張機能を使用して、ECC公開鍵の使用を特定の計算に制限することができます[15]. このドキュメントでは、ECDHでの使用が許可されている場合、ECCキーをECDH対応と呼びます. ECDSA対応も同様に定義されています. 

              Client                                        Server
              ------                                        ------

              ClientHello          -------->
                                                       ServerHello
                                                      Certificate*
                                                ServerKeyExchange*
                                              CertificateRequest*+
                                   <--------       ServerHelloDone
              Certificate*+
              ClientKeyExchange
              CertificateVerify*+
              [ChangeCipherSpec]
              Finished             -------->
                                                [ChangeCipherSpec]
                                   <--------              Finished

              Application Data     <------->      Application Data
        
*特定の条件下でメッセージが送信されない
+クライアント認証が必要でない限りメッセージが送信されない

図1：完全なTLSハンドシェイクでのメッセージフロー

図1は、TLSキー確立プロトコル（別名フルハンドシェイク）に関連するすべてのメッセージを示しています. ECCの追加は、ClientHello、ServerHello、サーバーの証明書メッセージ、ServerKeyExchange、ClientKeyExchange、CertificateRequest、クライアントの証明書メッセージ、およびCertificateVerifyにのみ直接影響します. 次に、これらのメッセージの内容と処理の観点から、各ECC鍵交換アルゴリズムについて詳しく説明します. 説明を簡単にするために、クライアント認証と関連メッセージ（図1では+で識別）の説明はセクション3まで、オプションのECC固有の拡張機能（Helloメッセージに影響を与える）の説明はセクション4まで延期します. 

2.1. ECDH_ECDSA
ECDH_ECDSAでは、サーバーの証明書にECDH対応の公開鍵が含まれ、ECDSAで署名されている必要があります. 

ServerKeyExchangeを送信してはなりません（サーバーの証明書には、クライアントがプリマスターシークレットに到達するために必要なすべての必要なキー情報が含まれています）. 

クライアントは、サーバーの長期公開鍵と同じ曲線上にECDH鍵ペアを生成し、その公開鍵をClientKeyExchangeメッセージで送信します（クライアント認証アルゴリズムECDSA_fixed_ECDHまたはRSA_fixed_ECDHを使用する場合を除きます. この場合、セクション3.2またはセクション3.3からの変更適用）. 

クライアントとサーバーの両方がECDH操作を実行し、結果の共有シークレットをプリマスターシークレットとして使用します. すべてのECDH計算は、セクション5.10で指定されているように実行されます. 

2.2. ECDHE_ECDSA （Elliptic Curve Diffie-Hellman Ephemeral）「Ephemeral」（短命の）
ECDHE_ECDSAでは、サーバーの証明書にECDSA対応の公開鍵が含まれ、ECDSAで署名されている必要があります. 

サーバーは、その一時的なECDH公開鍵と、対応する曲線の仕様をServerKeyExchangeメッセージで送信します. これらのパラメータは、サーバーの証明書の公開鍵に対応する秘密鍵を使用してECDSAで署名する必要があります. 

クライアントは、サーバーの一時的なECDHキーと同じ曲線上にECDHキーペアを生成し、その公開キーをClientKeyExchangeメッセージで送信します. 

クライアントとサーバーの両方がECDH操作（セクション5.10）を実行し、結果の共有シークレットをプリマスターシークレットとして使用します. 

2.3. ECDH_RSA
この鍵交換アルゴリズムは、サーバーの証明書がECDSAではなくRSAで署名されている必要があることを除いて、ECDH_ECDSAと同じです. 

2.4. ECDHE_RSA
この鍵交換アルゴリズムはECDHE_ECDSAと同じですが、サーバーの証明書には署名が許可されたRSA公開鍵が含まれている必要があり、ServerKeyExchangeメッセージの署名は対応するRSA秘密鍵を使用して計算する必要があります. サーバー証明書はRSAで署名する必要があります. 

2.5. ECDH_anon
ECDH_anonでは、サーバーの証明書、CertificateRequest、クライアントの証明書、およびCertificateVerifyメッセージを送信してはなりません（MUSTNOT）. 

サーバーは、一時的なECDH公開鍵と対応する曲線の仕様をServerKeyExchangeメッセージで送信する必要があります. これらのパラメータは署名してはなりません. 

クライアントは、サーバーの一時的なECDHキーと同じ曲線上にECDHキーペアを生成し、その公開キーをClientKeyExchangeメッセージで送信します. 

クライアントとサーバーの両方がECDH操作を実行し、結果の共有シークレットをプリマスターシークレットとして使用します. すべてのECDH計算は、セクション5.10で指定されているように実行されます. 

ECDH_ECDSA、ECDHE_ECDSA、ECDH_RSA、およびECDHE_RSA鍵交換アルゴリズムでは、サーバーの証明書に特定の署名スキームで署名する必要がありますが、この仕様（[2]および[[2]および[ 3]）証明書チェーンの他の場所で使用される署名スキームに制限を課しません. （多くの場合、このような制限は有用であり、認証局の署名慣行で考慮されることが期待されます. ただし、このような制限は一般に厳密に要求されるわけではありません. クライアントが完全に検証する能力を超えている場合でも特定のチェーンでは、クライアントはサーバーを検証できる可能性があります. 

3.クライアント認証
このドキュメントでは、ECDSA_sign、ECDSA_fixed_ECDH、およびRSA_fixed_ECDHの3つの新しいクライアント認証メカニズムを定義しています. ECDSA_signメカニズムは、セクション2で説明されている非匿名ECC鍵交換アルゴリズム、およびTLS [2] [3]で定義されている他の非匿名（非ECC）鍵交換アルゴリズムで使用できます. ECDSA_fixed_ECDHおよびRSA_fixed_ECDHメカニズムは、ECDH_ECDSAおよびECDH_RSAで使用できます. ECDHE_ECDSAおよびECDHE_RSAでの使用は禁止されています. これは、長期のECDHクライアントキーを使用すると、これらのアルゴリズムの転送秘密特性が危険にさらされるためです. 

サーバーは、CertificateRequestメッセージにこれらの証明書タイプの1つ以上を含めることにより、ECCベースのクライアント認証を要求できます. サーバーには、ネゴシエートされたキー交換アルゴリズムで禁止されている証明書タイプを含めないでください. クライアントは、サーバーによって提案された方法のいずれかに適切な証明書を所有しており、それを認証に使用する意思があるかどうかを確認する必要があります. 

これらの条件が満たされない場合、クライアントは証明書を含まないクライアント証明書メッセージを送信する必要があります. この場合、ClientKeyExchangeはセクション2で説明されているように送信する必要があり、CertificateVerifyは送信しないでください. サーバーがクライアント認証を必要とする場合、サーバーは致命的なハンドシェイク失敗アラートで応答する場合があります. 

クライアントが適切な証明書を持っていて、それを認証に使用する意思がある場合、クライアントの証明書メッセージでその証明書を送信し（セクション5.6に従って）、認証された鍵に対応する秘密鍵を所有していることを証明する必要があります. 適切な証明書を決定し、所有権を証明するプロセスは、認証メカニズムごとに異なり、以下で説明します. 

注：サーバーがサーバー証明書とは異なるタイプのクライアント証明書を要求する（およびクライアントが送信する）ことは許可されています. 

3.1. ECDSA_sign
この認証メカニズムを使用するには、クライアントはECDSA対応の公開鍵を含み、ECDSAで署名された証明書を所有している必要があります. 

クライアントは、セクション5.8で説明されているように、CertificateVerifyメッセージに署名を含めることにより、認証されたキーに対応する秘密キーの所有を証明します. 

3.2. ECDSA_fixed_ECDH
この認証メカニズムを使用するには、クライアントはECDH対応の公開鍵を含む証明書を所有している必要があり、その証明書はECDSAで署名されている必要があります. さらに、クライアントのECDHキーは、サーバーの長期（認定済み）ECDHキーと同じ楕円曲線上にある必要があります. これにより、このメカニズムの使用が閉じた環境に制限される可能性があります. クライアントが別の曲線上にECCキーを持っている状況では、ECDSA_signまたは非ECCメカニズム（RSAなど）のいずれかを使用して認証する必要があります. サーバーとクライアントの両方に固定ECDHを使用すると、ForwardSecrecyを提供するメカニズムよりも計算効率が高くなります. 

この認証メカニズムを使用する場合、クライアントはセクション5.7で説明されているように空のClientKeyExchangeを送信する必要があり、CertificateVerifyメッセージを送信してはなりません. サーバーがプリマスターシークレットを計算するために必要なクライアントのECDH公開鍵は、クライアントの証明書内で使用できるため、ClientKeyExchangeは空です. サーバーと同じプリマスターシークレットに到達するクライアントの機能（Finishedメッセージの交換が成功したことで示されます）は、認証された公開鍵に対応する秘密鍵を所有していることを証明し、CertificateVerifyメッセージは不要です. 

3.3. RSA_fixed_ECDH
この認証メカニズムは、クライアントの証明書がRSAで署名されている必要があることを除いて、ECDSA_fixed_ECDHと同じです. 

ECDSA_sign、ECDSA_fixed_ECDH、およびRSA_fixed_ECDHクライアント認証メカニズムでは、クライアントの証明書に特定の署名スキームで署名する必要がありますが、この仕様では、証明書チェーンの他の場所で使用される署名スキームに制限はありません. （多くの場合、このような制限は有用であり、認証局の署名慣行で考慮されることが期待されます. ただし、このような制限は一般に厳密に要求されるわけではありません. サーバーが完全に検証する能力を超えている場合でも特定のチェーンでは、サーバーは、チェーン内の中間証明書の1つとして表示されるトラストアンカーに依存することにより、クライアント証明書を検証できる場合があります. ）

4.ECCのTLS拡張
この仕様では、2つの新しいTLS拡張が定義されています. （i）サポートされている楕円曲線拡張と（ii）サポートされているポイント形式拡張です. これらにより、新しいセッションを開始するハンドシェイク中に、特定の曲線とポイント形式（たとえば、それぞれ圧縮と非圧縮）の使用をネゴシエートできます. これらの拡張機能は、限られた数の曲線またはポイント形式のみをサポートする可能性のある制約のあるクライアントに特に関係があります. それらは[4]で概説されている一般的なアプローチに従います. メッセージの詳細はセクション5で指定されます. クライアントは、ClientHelloメッセージに適切な拡張子を含めることにより、サポートする曲線と解析できるポイント形式を列挙します. サーバーは同様に、ServerHelloメッセージに拡張子を含めることにより、解析できるポイント形式を列挙します. 

ClientHelloメッセージでECC暗号スイートを提案するTLSクライアントは、これらの拡張機能を含める必要があります. ECC暗号スイートを実装するサーバーはこれらの拡張機能をサポートする必要があります. クライアントがこれらの拡張機能を使用する場合、サーバーは、クライアントが指定する曲線と圧縮技術の選択を尊重しながらハンドシェイクを完了できない限り、ECC暗号スイートの使用についてネゴシエートしてはなりません. これにより、クライアントがサーバーのECキーを処理できないために、ネゴシエートされたECCハンドシェイクが後で中止される可能性がなくなります. 

クライアントは、ECC暗号スイートを提案しない場合、ClientHelloメッセージにこれらの拡張機能を含めてはなりません（MUSTNOT）. ECC暗号スイートを提案するクライアントは、これらの拡張機能を含めないことを選択できます. この場合、サーバーはセクション5にリストされている楕円曲線またはポイント形式のいずれかを自由に選択できます. このセクションでは、これらの拡張機能の構造と処理についても詳しく説明します. 

セッション再開の場合、サーバーは、現在のClientHelloメッセージに表示されているSupported Elliptic CurvesExtensionとSupportedPoint FormatsExtensionを単に無視します. これらの拡張機能は、新しいセッションをネゴシエートするハンドシェイク中にのみ役割を果たします. 

5.データ構造と計算
このセクションでは、セクション2、3、および4で指定されたECCベースのキーメカニズムで使用されるデータ構造と計算を指定します. ここで使用される表示言語は、TLS [2] [3]で使用されるものと同じです. この仕様はTLSを拡張するため、これらの説明はTLS仕様およびTLSを拡張するその他の説明とマージする必要があります. これは、列挙型がすべての可能な値を指定するわけではなく、select（）句で選択された複数の形式の構造がすべての可能なケースを示すとは限らないことを意味します. 

5.1. クライアントHello拡張機能
このセクションでは、[4]で説明されているClientHelloメッセージに含めることができる2つのTLS拡張、サポートされている楕円曲線拡張とサポートされているポイント形式拡張を指定します. 

これらの拡張機能が送信されるとき：

拡張機能は、ECC暗号スイートを提案するClientHelloメッセージと一緒に送信する必要があります. 

これらの拡張子の意味：

これらの拡張機能により、クライアントは、サポートする楕円曲線や解析可能なポイント形式を列挙できます. 

これらの拡張機能の構造：

TLS拡張の一般的な構造は[4]で説明されており、この仕様はExtensionTypeに2つの新しいタイプを追加します. 

       列挙型{elliptic_curves（10）、ec_point_formats（11）} ExtensionType;
        
elliptic_curves（サポートされている楕円曲線拡張）：クライアントによってサポートされている楕円曲線のセットを示します. この拡張機能の場合、不透明なextension_dataフィールドにはEllipticCurveListが含まれます. 詳細については、セクション5.1.1を参照してください. 

ec_point_formats（サポートされているポイントフォーマット拡張）：クライアントが解析できるポイントフォーマットのセットを示します. この拡張機能の場合、不透明なextension_dataフィールドにはECPointFormatListが含まれます. 詳細については、セクション5.1.2を参照してください. 

送信者のアクション：

ClientHelloメッセージでECC暗号スイートを提案するクライアントは、これらの拡張機能を（他の拡張機能とともに）追加し、サポートする曲線と解析できるポイント形式を列挙します. クライアントは、サポートされている楕円曲線拡張機能とサポートされているポイント形式拡張機能の両方を送信する必要があります. サポートされているポイントフォーマット拡張が実際に送信される場合、ポイントフォーマットのリストの項目の1つとして値0（非圧縮）が含まれている必要があります. 

受信者のアクション：

これらの拡張機能の一方または両方を含むClientHelloを受信するサーバーは、クライアントの列挙された機能を使用して、適切な暗号スイートの選択をガイドする必要があります. 提案されたECC暗号スイートの1つは、サーバーがクライアントでサポートされている曲線とポイント形式を使用しながらハンドシェイクを正常に完了できる場合にのみネゴシエートする必要があります（セクション5.3および5.4を参照）. 

注：ECDHE-ECDSA鍵交換に参加しているサーバーは、（i）証明書のECDSA鍵、および（ii）ServerKeyExchangeメッセージの一時的なECDH鍵に異なる曲線を使用する場合があります. サーバーは、どちらの場合も拡張機能を考慮する必要があります. 

サーバーがサポートされている楕円曲線拡張を理解していない場合、サポートされているポイント形式拡張を理解していない場合、または列挙された曲線とポイント形式に制限しながらECCハンドシェイクを完了できない場合は、ECC暗号の使用をネゴシエートしてはなりません. スイート. クライアントによって提案され、サーバーによってサポートされている他の暗号スイートによっては、一般的な暗号スイートがないため、致命的なハンドシェイク失敗アラートが発生する場合があります. 

5.1.1. サポートされている楕円曲線拡張
        列挙型{
            sect163k1（1）、sect163r1（2）、sect163r2（3）、
            sect193r1（4）、sect193r2（5）、sect233k1（6）、
            sect233r1（7）、sect239k1（8）、sect283k1（9）、
            sect283r1（10）、sect409k1（11）、sect409r1（12）、
            sect571k1（13）、sect571r1（14）、secp160k1（15）、
            secp160r1（16）、secp160r2（17）、secp192k1（18）、
            secp192r1（19）、secp224k1（20）、secp224r1（21）、
            secp256k1（22）、secp256r1（23）、secp384r1（24）、
            secp521r1（25）、
            予約済み（0xFE00..0xFEFF）、
            任意のexplicit_prime_curves（0xFF01）、
            任意のexplicit_char2_curves（0xFF02）、
            （0xFFFF）
        } NamedCurve;
        
sect163k1など：対応する名前付き曲線または明示的に定義された曲線のクラスのサポートを示します. ここで定義されている名前付き曲線は、SEC 2 [13]で指定されているものです. これらの曲線の多くは、ANSI X9.62 [7]およびFIPS186-2 [11]でも推奨されていることに注意してください. 値0xFE00から0xFEFFは、私的使用のために予約されています. 値0xFF01および0xFF02は、クライアントがそれぞれ任意の素数曲線および標数2曲線をサポートすることを示します（曲線パラメーターはECParametersで明示的にエンコードする必要があります）. 

NamedCurve名前空間はIANAによって維持されています. 新しい値の割り当てを追加する方法については、セクション8を参照してください. 

        構造体{
            NamedCurveelliptic_curve_list <1..2 ^ 16-1>
        } EllipticCurveList;
        
elliptic_curve_listのアイテムは、クライアントの好みに従って順序付けられます（最初にお気に入りを選択します）. 

例として、secp192r1（別名NISTP-192;値19 = 0x0013）およびsecp224r1（別名NISTP-224;値21 = 0x0015）のみをサポートし、secp192r1の使用を好むクライアントには、以下で構成されるTLS拡張が含まれます. オクテット. 最初の2つのオクテットは、拡張タイプ（サポートされている楕円曲線拡張）を示していることに注意してください. 

00 0A 00 06 00 04 00 13 00 15

任意の明示的な特性2曲線（値0xFF02）をサポートするクライアントには、次のオクテットで構成される拡張機能が含まれます. 

00 0A 00 04 00 02 FF 02

5.1.2. サポートされているポイントフォーマット拡張
        列挙型{非圧縮（0）、ansiX962_compressed_prime（1）、
               ansiX962_compressed_char2（2）、予約済み（248..255）
        } ECPointFormat;
        
        構造体{
            ECPointFormat ec_point_format_list <1..2 ^ 8-1>
        } ECPointFormatList;
        
上記のECPointFormatの定義には、3つのポイント形式が含まれています. 非圧縮ポイント形式は、このドキュメントの実装がサポートされているすべての曲線でサポートされている必要があるという点で、デフォルトの形式です. 圧縮されたポイント形式は、ポイントのx座標とy座標の1ビットのみを含めることにより、帯域幅を削減します. このドキュメントの実装は、ansiX962_compressed_primeおよびansiX962_compressed_char2形式をサポートする場合があります. 前者は素数曲線にのみ適用され、後者は標数2曲線にのみ適用されます. （これらの形式は[7]で指定されています. ）値248から255は、私的使用のために予約されています. 

ECPointFormat名前空間はIANAによって維持されます. 新しい値の割り当てを追加する方法については、セクション8を参照してください. 

ec_point_format_list内のアイテムは、クライアントの設定に従って順序付けられます（最初にお気に入りを選択します）. 

非圧縮ポイント形式（値0）のみを解析できるクライアントには、次のオクテットで構成される拡張機能が含まれています. 最初の2つのオクテットは、拡張タイプ（Supported Point Formats Extension）を示していることに注意してください. 

00 0B 00 02 01 00

プライムフィールドの場合は非圧縮形式（値0）よりも圧縮形式（ansiX962_compressed_prime、値1）を優先しますが、特性2フィールドの場合は圧縮形式（値0）よりも非圧縮形式（値0）を優先するクライアントansiX962_compressed_char2、値2）は、次のオクテットで構成される拡張機能を含めることにより、これらの設定を示す場合があります. 

00 0B 00 04 03 01 00 02

5.2. Server Hello Extension
このセクションでは、[4]、サポートされているポイント形式の拡張機能で説明されているように、ServerHelloメッセージに含めることができるTLS拡張機能を指定します. 

この拡張機能が送信されるとき：

サポートされているポイントフォーマット拡張機能は、ECC暗号スイートをネゴシエートするときにサポートされているポイントフォーマット拡張機能を含むClientHelloメッセージへの応答としてServerHelloメッセージに含まれています. 

この拡張機能の意味：

この拡張機能により、サーバーは解析できるポイント形式を列挙できます（ECDHE_ECDSA、ECDHE_RSA、またはECDH_anon鍵交換アルゴリズムを使用するときにServerKeyExchangeメッセージに表示される曲線、またはサーバーの公開鍵で使用される曲線の場合） ECDH_ECDSAまたはECDH_RSAキー交換アルゴリズムを使用すると、証明書メッセージに表示されます）. 

この拡張機能の構造：

サーバーのサポートされているポイントフォーマット拡張機能は、クライアントのサポートされているポイントフォーマット拡張機能と同じ構造です（セクション5.1.2を参照）. ここでのelliptic_curve_listの項目は、サーバーの設定に従って順序付けられます（最初にお気に入りを選択します）. サーバーには、クライアントのリストに見つからなかったアイテムが含まれる場合があることに注意してください（たとえば、クライアントがこの形式を解析できない場合でも、サーバーは圧縮形式でポイントを受け取ることを好む場合があります. それでも、同じクライアントが圧縮形式でポイントを出力できる場合があります.  ）. 

送信者のアクション：

サポートされているポイント形式拡張機能を含むClientHelloメッセージに応答してECC暗号スイートを選択するサーバーは、この拡張機能を（他の拡張機能とともに）ServerHelloメッセージに追加し、解析できるポイント形式を列挙します. サポートされているポイント形式拡張機能を使用する場合、ポイント形式のリストの項目の1つとして値0（非圧縮）を含める必要があります. 

受信者のアクション：

サポートされているポイントフォーマット拡張機能を含むServerHelloメッセージを受信するクライアントは、ハンドシェイク中にサーバーが選択したポイントフォーマットを尊重する必要があります（セクション5.6および5.7を参照）. ServerHelloでサポートされているポイントフォーマット拡張機能が受信されない場合、これは非圧縮ポイントフォーマットのみを許可する拡張機能と同等です. 

5.3. Server Certificate
このメッセージが送信されたとき：

このメッセージは、すべての非匿名ECCベースの鍵交換アルゴリズムで送信されます. 

このメッセージの意味：

このメッセージは、サーバーの静的公開鍵をクライアントに確実に伝達するために使用されます. 次の表に、各キー交換アルゴリズムに適したサーバー証明書の種類を示します. セクション5.9で説明されているように、ECC公開鍵は証明書にエンコードする必要があります. 

注：サーバーの証明書メッセージは、一連の証明書を伝送できます. 表3に記載されている制限は、サーバーの証明書（チェーンの最初）にのみ適用されます. 

          Key Exchange Algorithm  Server Certificate Type
          ----------------------  -----------------------
        
         ECDH_ECDSA  証明書には、ECDH対応の公開鍵が含まれている必要があります. ECDSAで署名する必要があります. 

         ECDHE_ECDSA 証明書には、ECDSA対応の公開鍵が含まれている必要があります. ECDSAで署名する必要があります. 

         ECDH_RSA    証明書には、ECDH対応の公開鍵が含まれている必要があります. RSAで署名する必要があります. 

         ECDHE_RSA   証明書には、デジタル署名での使用が許可されたRSA公開鍵が含まれている必要があります. RSAで署名する必要があります. 

表3：サーバー証明書の種類

このメッセージの構造：

TLS証明書の形式と同じです. 

送信者のアクション：

サーバーは適切な証明書チェーンを構築し、それを証明書メッセージでクライアントに伝達します. クライアントがサポートされている楕円曲線拡張機能を使用している場合、サーバーの証明書の公開鍵は、クライアントが選択した楕円曲線を尊重する必要があります. 特に、公開鍵は、クライアントが適切なタイプの明示的な曲線のサポートを示していない限り、名前付き曲線（明示的な曲線と同じ曲線ではない）を使用する必要があります. クライアントがSupportedPoint Formats Extensionを使用している場合、サーバーの公開鍵ポイントと（明示的な曲線の場合）曲線の基点の両方が、クライアントが選択したポイント形式を尊重する必要があります. （これらの要件を満たすことができないサーバーは、ServerHelloメッセージでECC暗号スイートを選択してはなりません. ）受信者のアクション：

クライアントは証明書チェーンを検証し、サーバーの公開鍵を抽出し、鍵の種類がネゴシエートされた鍵交換アルゴリズムに適していることを確認します. （致命的なハンドシェイクの失敗の考えられる理由は、楕円曲線とポイント形式を処理するためのクライアントの機能を超えていることです. セクション5.1を参照してください. ）

5.4. サーバーキー交換
このメッセージが送信されたとき：

このメッセージは、ECDHE_ECDSA、ECDHE_RSA、およびECDH_anonキー交換アルゴリズムを使用している場合に送信されます. 

このメッセージの意味：

このメッセージは、サーバーの一時的なECDH公開鍵（および対応する楕円曲線ドメインパラメーター）をクライアントに伝達するために使用されます. 

このメッセージの構造：

        列挙型{explicit_prime（1）、explicit_char2（2）、
               named_curve（3）、reserved（248..255）} ECCurveType;
        
Explicit_prime：楕円曲線ドメインパラメータが詳細に伝達され、基礎となる有限体が素体であることを示します. 

Explicit_char2：楕円曲線ドメインパラメータが詳細に伝達され、基礎となる有限体が標数2体であることを示します. 

named_curve：名前付き曲線が使用されていることを示します. このオプションは、該当する場合に使用する必要があります. 

値248から255は、私的使用のために予約されています. 

ECCurveType名前空間はIANAによって維持されます. 新しい値の割り当てを追加する方法については、セクション8を参照してください. 

        構造体{
            不透明a <1..2 ^ 8-1>;
            不透明b <1..2 ^ 8-1>;
        } ECCurve;
        
a、b：これらのパラメーターは、楕円曲線の係数を指定します. 各値には、ANSI X9.62 [7]のセクション4.3.3の変換ルーチンに従ったフィールド要素のバイト文字列表現が含まれています. 

        構造体{
            不透明な点<1..2 ^ 8-1>;
        } ECPoint;
        
ポイント：これは、ANSI X9.62 [7]のセクション4.3.6の変換ルーチンに従った楕円曲線ポイントのバイト文字列表現です. このバイト文字列は、非圧縮形式または圧縮形式の楕円曲線ポイントを表す場合があります. この拡張機能が使用された場合、サポートされているポイントフォーマット拡張機能を通じてクライアントが要求したものに準拠する必要があります. 

        列挙型{ec_basis_trinomial、ec_basis_pentanomial} ECBasisType;
        
ec_basis_trinomial：三項式ベースを使用した標数2フィールドの表現を示します. 

ec_basis_pentanomial：ペンタノミアルベースを使用した標数2フィールドの表現を示します. 

        構造体{
            ECCurveTypecurve_type;
            select（curve_type）{
                ケースexplicit_prime：
                    不透明なprime_p <1..2 ^ 8-1>;
                    ECC曲線;
                    ECPointベース;
                    不透明な順序<1..2 ^ 8-1>;
                    不透明な補因子<1..2 ^ 8-1>;
                ケースexplicit_char2：
                    uint16 m;
                    ECBasisTypeベース;
                    選択（基本）{
                        ケースec_trinomial：
                            不透明k <1..2 ^ 8-1>;
                        ケースec_pentanomial：
                            不透明k1 <1..2 ^ 8-1>;
                            不透明なk2 <1..2 ^ 8-1>;
                            不透明なk3 <1..2 ^ 8-1>;
                    };
                    ECC曲線;
                    ECPointベース;
                    不透明な順序<1..2 ^ 8-1>;
                    不透明な補因子<1..2 ^ 8-1>;
        
                ケースnamed_curve：
                    NamedCurvenamedcurve;
            };
        } ECParameters;
        
Curve_type：これは楕円曲線ドメインパラメータのタイプを識別します. 

prime_p：これはフィールドFpを定義する奇数の素数です. 

曲線：楕円曲線Eの係数aとbを指定します. 

base：楕円曲線上の基点Gを指定します. 

order：基点の次数nを指定します. 

   補因子：補因子h = #E（Fq）/ nを指定します. ここで、＃E（Fq）
      定義された楕円曲線E上の点の数を表します
      フィールドFq（FpまたはF2 ^ mのいずれか）上. 
        
m：これは標数2フィールドF2 ^ mの次数です. 

k：三項式基底表現x ^ m + x ^ k + 1の指数k. 

k1、k2、k3：5乗表現の指数x ^ m + x ^ k3 + x ^ k2 + x ^ k1 + 1（k3> k2> k1のように）. 

namedcurve：推奨される楕円曲線ドメインパラメータのセットを指定します. 特定の曲線を参照するNamedCurveの値はすべて許可されます. 明示的に定義された曲線のクラスのサポートを示すNamedCurveの値は、ここでは許可されていません（ClientHello拡張機能でのみ許可されています）. これは、任意のexplicit_prime_curves（0xFF01）および任意のexplicit_char2_curves（0xFF02）に適用されます. 

        構造体{
            ECParameterscurve_params;
            ECPointパブリック;
        } ServerECDHParams;
        
Curve_params：ECDH公開鍵に関連付けられた楕円曲線ドメインパラメーターを指定します. 

public：一時的なECDH公開鍵. 

ServerKeyExchangeメッセージは次のように拡張されます. 

        列挙型{ec_diffie_hellman} KeyExchangeAlgorithm;
        
ec_diffie_hellman：ServerKeyExchangeメッセージにECDH公開鍵が含まれていることを示します. 

        select（KeyExchangeAlgorithm）{
            ケースec_diffie_hellman：
                ServerECDHParamsパラメータ;
                署名signed_pa​​rams;
        } ServerKeyExchange;
        
params：ECDH公開鍵および関連するドメインパラメーターを指定します. 

signed_pa​​rams：そのハッシュに適切な署名が適用されたparamsのハッシュ. サーバーの証明書メッセージで認証された公開鍵に対応する秘密鍵が署名に使用されます. 

          列挙型{ecdsa} SignatureAlgorithm;
        
          select（SignatureAlgorithm）{
              ケースecdsa：
                  デジタル署名された構造体{
                      不透明なsha_hash [sha_size];
                  };
          }署名;
        
        ServerKeyExchange.signed_pa​​rams.sha_hash
            SHA（ClientHello.random + ServerHello.random +
                                              ServerKeyExchange.params）;
        
注：SignatureAlgorithmは、ECDHE_RSA鍵交換アルゴリズムの場合は「rsa」であり、ECDH_anonの場合は「匿名」です. これらのケースはTLS [2] [3]で定義されています. SignatureAlgorithmは、ECDHE_ECDSAの「ecdsa」です. ECDSA署名は、セクション5.10で説明されているように生成および検証されます. したがって、上記のsha_hashのテンプレートのSHAは、SHA-1以外のハッシュアルゴリズムを示している場合があります. ANSI X9.62によると、ECDSA署名は、整数のペアrとsで構成されます. デジタル署名された要素は不透明なベクトル<0..2 ^ 16-1>としてエンコードされ、その内容は次のASN.1表記[8]に対応するDERエンコード[9]です. 

           Ecdsa-Sig-Value :: = SEQUENCE {
               r INTEGER、
               s INTEGER
           }
        
送信者のアクション：

サーバーは、IEEE 1363 [6]のECKAS-DH1スキームに従って、楕円曲線ドメインパラメーターとこれらのパラメーターに対応する一時的なECDH公開鍵を選択します. 上記で定義された形式を使用して、ServerKeyExchangeメッセージでこの情報をクライアントに伝達します. 

受信者のアクション：

クライアントは署名（存在する場合）を検証し、ServerKeyExchangeメッセージからサーバーの楕円曲線ドメインパラメーターと一時的なECDH公開鍵を取得します. （致命的なハンドシェイクの失敗の考えられる理由は、楕円曲線とポイント形式を処理するためのクライアントの機能を超えていることです. セクション5.1を参照してください. ）

5.5. 証明書要求
このメッセージが送信されたとき：

このメッセージは、クライアント認証を要求するときに送信されます. 

このメッセージの意味：

サーバーはこのメッセージを使用して、受け入れ可能なクライアント認証方法を提案します. 

このメッセージの構造：

TLSCertificateRequestメッセージは次のように拡張されます. 

        列挙型{
            ecdsa_sign（64）、rsa_fixed_ecdh（65）、
            ecdsa_fixed_ecdh（66）、（255）
        } ClientCertificateType;
        
ecdsa_signなど. サーバーがセクション3で指定された対応するクライアント認証方法を使用することを示します. 

送信者のアクション：

サーバーは、使用するクライアント認証方法を決定し、上記で定義された形式を使用してこの情報をクライアントに伝達します. 

受信者のアクション：

クライアントは、要求された方法のいずれかで使用するのに適した証明書があるかどうか、およびクライアント認証を続行するかどうかを決定します. 

5.6. クライアント証明書
このメッセージが送信されたとき：

このメッセージは、クライアントが適切な証明書を持っていて、クライアント認証を続行することを決定したときに、CertificateRequestに応答して送信されます. （サーバーがSupported Point Formats Extensionを使用している場合、証明書は、指定された公開鍵ポイントがサーバーのポイント形式の選択を尊重する場合にのみ、ECDSA_sign、RSA_fixed_ECDH、およびECDSA_fixed_ECDH認証方法での使用に適していると見なすことができます. サポートされているポイント形式拡張機能は使用されていません. 証明書は、ポイントが非圧縮のポイント形式で表されている場合にのみ、これらの認証方法での使用に適していると見なすことができます. ）

このメッセージの意味：

このメッセージは、クライアントの静的公開鍵をサーバーに確実に伝達するために使用されます. 次の表は、セクション3で説明したECCベースのクライアント認証メカニズムに適したクライアント証明書の種類をまとめたものです. ECC公開鍵は、セクション5.9で説明したように証明書にエンコードする必要があります. 

注：クライアントの証明書メッセージは、一連の証明書を運ぶことができます. 表4に記載されている制限は、クライアントの証明書（チェーンの最初）にのみ適用されます. 

          クライアント
          認証方法クライアント証明書の種類
          --------------------- -----------------------
        
ECDSA_sign証明書には、ECDSA対応の公開鍵が含まれ、ECDSAで署名されている必要があります. 

ECDSA_fixed_ECDH証明書には、サーバーの長期ECDHキーと同じ楕円曲線上にECDH対応の公開キーが含まれている必要があります. この証明書はECDSAで署名する必要があります. 

RSA_fixed_ECDH証明書には、サーバーの長期ECDHキーと同じ楕円曲線上にECDH対応の公開キーが含まれている必要があります. この証明書はRSAで署名する必要があります. 

表4：クライアント証明書の種類

このメッセージの構造：

TLSクライアント証明書の形式と同じです. 

送信者のアクション：

クライアントは適切な証明書チェーンを構築し、それを証明書メッセージでサーバーに伝達します. 

受信者のアクション：

TLSサーバーは、証明書チェーンを検証し、クライアントの公開鍵を抽出し、鍵の種類がクライアントの認証方法に適していることを確認します. 

5.7. クライアントキー交換
このメッセージが送信されたとき：

このメッセージは、すべての鍵交換アルゴリズムで送信されます. ECDSA_fixed_ECDHまたはRSA_fixed_ECDHを使用したクライアント認証が使用されている場合、このメッセージは空です. それ以外の場合は、クライアントの一時的なECDH公開鍵が含まれます. 

メッセージの意味：

このメッセージは、クライアントに属するキー交換に関連するエフェメラルデータ（エフェメラルECDH公開キーなど）を伝達するために使用されます. 

このメッセージの構造：

TLSClientKeyExchangeメッセージは次のように拡張されます. 

        列挙型{暗黙的、明示的} PublicValueEncoding;
        
暗黙的、明示的：ECC暗号スイートの場合、これは、クライアントのECDH公開鍵がクライアントの証明書にあるか（「暗黙的」）、または一時的なECDH公開鍵としてClientKeyExchangeメッセージで提供されるか（「明示的」）を示します. （これは、クライアントがECDSA_fixed_ECDHまたはRSA_fixed_ECDHクライアント認証メカニズムを使用する場合を除いて、ECC暗号スイートでは「明示的」です. ）

        構造体{
            select（PublicValueEncoding）{
                暗黙の場合：struct {};
                明示的な場合：ECPoint ecdh_Yc;
            } ecdh_public;
        } ClientECDiffieHellmanPublic;
        
ecdh_Yc：クライアントのエフェメラルECDH公開鍵をバイト文字列ECPoint.pointとして含みます. これは、非圧縮または圧縮形式の楕円曲線ポイントを表す場合があります. ここで、フォーマットは、この拡張機能が使用された場合、サポートされているポイントフォーマット拡張機能を通じてサーバーが要求したものに準拠する必要があり、この拡張機能が使用されなかった場合は非圧縮でなければなりません. 

        構造体{
            select（KeyExchangeAlgorithm）{
                ケースec_diffie_hellman：ClientECDiffieHellmanPublic;
            } exchange_keys;
        } ClientKeyExchange;
        
送信者のアクション：

クライアントは、IEEE 1363 [6]のECKAS-DH1スキームに従って、サーバーから受信したパラメータに対応する一時的なECDH公開鍵を選択します. 上記で定義された形式を使用して、ClientKeyExchangeメッセージでこの情報をクライアントに伝達します. 

受信者のアクション：

サーバーは、ClientKeyExchangeメッセージからクライアントの一時的なECDH公開鍵を取得し、それがサーバーのECDH鍵と同じ楕円曲線上にあることを確認します. 

5.8. 証明書の検証
このメッセージが送信されたとき：

このメッセージは、クライアントがデジタル署名に使用できる公開鍵を含むクライアント証明書を送信するときに送信されます. たとえば、クライアントがECDSA_signメカニズムを使用して認証される場合などです. 

メッセージの意味：

このメッセージには、クライアントの証明書メッセージの公開鍵に対応する秘密鍵の所有を証明する署名が含まれています. 

このメッセージの構造：

TLS CertificateVerifyメッセージと基礎となる署名タイプは[2]と[3]で定義されており、後者はここのセクション5.4で拡張されています. ecdsaの場合、CertificateVerifyメッセージの署名フィールドには、これまでに交換されたハンドシェイクメッセージで計算されたECDSA署名が含まれます. これは、[2]および[3]の他の署名アルゴリズムを使用したCertificateVerifyとまったく同じです. 

CertificateVerify.signature.sha_hash SHA（handshake_messages）;

ECDSA署名はセクション5.10で説明されているように計算され、sha_hashの上記のテンプレートのSHAは、それに応じてSHA-1以外のハッシュアルゴリズムを示している可能性があります. ANSI X9.62によると、ECDSA署名は、整数のペアrとsで構成されます. デジタル署名された要素は不透明なベクトル<0..2 ^ 16-1>としてエンコードされ、その内容は次のASN.1表記[8]に対応するDERエンコード[9]です. 

        Ecdsa-Sig-Value :: = SEQUENCE {
            r INTEGER、
            s INTEGER
        }
        
送信者のアクション：

クライアントは、クライアントhelloから始まり、このメッセージを含まないまでに送受信されるすべてのハンドシェイクメッセージに対して署名を計算します. 認定された公開鍵に対応する秘密鍵を使用して署名を計算します. 署名は、上記で定義された形式で伝達されます. 

受信者のアクション：

サーバーは、CertificateVerifyメッセージからクライアントの署名を抽出し、クライアントのCertificateメッセージで受信した公開鍵を使用して署名を検証します. 

5.9. 楕円曲線証明書
ECC公開鍵を含む、またはECDSAを使用して署名されたX.509証明書は、[14]またはそれを置き換えるまたは拡張する別のRFCに準拠する必要があります. クライアントは、ANSI X9.62 [7]、FIPS 186-2 [11]、およびSEC 2 [13]で推奨されている楕円曲線ドメインパラメータを使用する必要があります. 

5.10. ECDH、ECDSA、およびRSAの計算
すべてのECDH計算（パラメーターと鍵の生成、および共有秘密の計算を含む）は、鍵導出関数（KDF）としてIDマップを使用したECKAS-DH1スキームを使用して、[6]に従って実行されるため、プリマスター秘密はxです.  -オクテット文字列として表されるECDH共有秘密楕円曲線点の座標. フィールド要素からオクテット文字列への変換プリミティブであるFE2OSPによって出力されるこのオクテット文字列（IEEE 1363用語ではZ）は、任意のフィールドに対して一定の長さであることに注意してください. このオクテット文字列で見つかった先行ゼロは切り捨ててはなりません. 

（ID KDFのこの使用は技術的なものであることに注意してください. TLSはマスターシークレットの計算以外の目的でプリマスターシークレットを直接使用しないため、ECDHは重要なKDFで使用されます. TLS1.0以降[2]および1.1 [3]、これは、MD5およびSHA-1ベースのTLS PRFがKDFとして機能することを意味します. 将来のTLSバージョンまたは将来導入される新しいTLS拡張により、この計算が変わる可能性があります. ）

すべてのECDSA計算は、ANSI X9.62 [7]またはその後継に従って実行する必要があります. 署名/検証されるデータはハッシュされ、結果は追加のハッシュなしでECDSAアルゴリズムを介して直接実行されます. デフォルトのハッシュ関数はSHA-1 [10]で、sha_size（セクション5.4および5.8を参照）は20です. ただし、FIPS 180-2 [10]で指定されている新しいSHAハッシュ関数の1つなど、代替のハッシュ関数は、 ECパブリックを含む証明書の場合は、代わりに使用できます

キーは明示的に別のハッシュ関数の使用を必要とします. （必要なハッシュ関数を指定するメカニズムは標準化されていませんが、この規定はそのような標準化を想定しており、それに応じてこのドキュメントを更新する必要がありません. 将来のPKIX RFCは、たとえば、 subjectPublicKeyInfoのパラメータフィールドの公開鍵. ）

すべてのRSA署名は、PKCS＃1 [12]ブロックタイプ1に従って生成および検証する必要があります. 

6.暗号スイート
次の表は、セクション2で指定された鍵交換アルゴリズムを使用する新しいECC暗号スイートを定義しています. 

     CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA = {0xC0、0x01}
     CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA = {0xC0、0x02}
     CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = {0xC0、0x03}
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = {0xC0、0x04}
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = {0xC0、0x05}
        
     CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA = {0xC0、0x06}
     CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = {0xC0、0x07}
     CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = {0xC0、0x08}
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = {0xC0、0x09}
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = {0xC0、0x0A}
        
     CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA = {0xC0、0x0B}
     CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA = {0xC0、0x0C}
     CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = {0xC0、0x0D}
     CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = {0xC0、0x0E}
     CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = {0xC0、0x0F}
        
     CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA = {0xC0、0x10}
     CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA = {0xC0、0x11}
     CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = {0xC0、0x12}
     CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = {0xC0、0x13}
     CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = {0xC0、0x14}
        
     CipherSuite TLS_ECDH_anon_WITH_NULL_SHA = {0xC0、0x15}
     CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA = {0xC0、0x16}
     CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = {0xC0、0x17}
     CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA = {0xC0、0x18}
     CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA = {0xC0、0x19}
        
表5：TLSECC暗号スイート

これらの各暗号スイートの鍵交換方法、暗号、およびハッシュアルゴリズムは、名前を調べることで簡単に決定できます. 暗号（AES暗号を除く）とハッシュアルゴリズムは[2]と[3]で定義されています. AES暗号は[19]で定義されています. 

サーバー実装は次の暗号スイートのすべてをサポートする必要があり、クライアント実装はそれらの少なくとも1つをサポートする必要があります：TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_3DES_EDE_C

7.セキュリティに関する考慮事項
このメモでは、セキュリティの問題について説明しています. 

ECC暗号スイートを使用するTLSハンドシェイクの場合、[2]および[3]の付録D.2およびD.3のセキュリティに関する考慮事項がそれに応じて適用されます. 

ECCに固有のセキュリティに関する議論は、[6]と[7]にあります. 実装者とユーザーが考慮しなければならない重要な問題の1つは、楕円曲線の選択です. 適切な楕円曲線サイズを選択するためのガイダンスを表1に示します. 

楕円曲線のサイズを超えて、主な問題は楕円曲線の構造です. 一般的な原則として、代数的構造ができるだけ少ない楕円曲線を使用する方が保守的です. したがって、ランダム曲線はコブリッツ曲線などの特別な曲線よりも保守的であり、ランダムなpを使用したF_p上の曲線は、特別な形式のpを使用したF_p上の曲線よりも保守的です（ランダムなpを使用したF_p上の曲線は曲線よりも保守的であると見なされる場合があります特性2）について、同じサイズの複数のフィールド間で選択できないため、F_2 ^ mを超えます. ただし、代数的構造も実装の効率につながる可能性があるため、実装者とユーザーは保守性と効率の必要性のバランスをとる必要がある場合があることに注意してください. 具体的な攻撃は、超特異曲線など、ごく少数の特別なクラスの曲線に対してのみ知られています. 

もう1つの問題は、単一の楕円曲線が広く使用されている場合に壊滅的な障害が発生する可能性があることです. この場合、楕円曲線への攻撃により、多数のキーが危険にさらされる可能性があります. 繰り返しますが、この懸念は、広く使用されている曲線に関連する効率と相互運用性の改善とバランスを取る必要があるかもしれません. 楕円曲線の選択に関する実質的な追加情報は、[5]、[6]、[7]、および[11]にあります. 

実装者とユーザーは、転送秘密が必要かどうかも考慮する必要があります. Forward Secrecyとは、サーバーとクライアントに属する静的な認証済みキーが危険にさらされても、セッションキーが危険にさらされないという特性を指します. ECDHE_ECDSAおよびECDHE_RSAキー交換アルゴリズムは、サーバーキーが侵害された場合に転送秘密保護を提供しますが、ECDH_ECDSAおよびECDH_RSAは提供しません. 同様に、クライアントが静的な認証済みキーを提供している場合、ECDSA_signクライアント認証は、クライアントキーが侵害された場合に転送秘密保護を提供しますが、ECDSA_fixed_ECDHおよびRSA_fixed_ECDHは提供しません. したがって、完全転送秘密保護を取得するには、ECDHE_ECDSAまたはECDHE_RSAをキー交換に使用し、必要に応じてECDSA_signをクライアント認証に使用する必要があります. 

8.IANAの考慮事項
このドキュメントでは、TLSプロトコルで使用するための3つの新しい名前空間について説明します. 

o NamedCurve（セクション5.1）

o ECPointFormat（セクション5.1）

o ECCurveType（セクション5.4）

このドキュメントでは、名前空間ごとに、初期値の割り当てを定義し、プライベート使用のために予約された256個の値（NamedCurve）または8個の値（ECPointFormatおよびECCurveType）の範囲を定義します. 追加の割り当てには、IETFコンセンサスアクションが必要です[16]. 

9.謝辞
著者はBillAndersonとTimDierksに感謝します. 

10.参考文献
10.1. 規範的参考文献
[1] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、RFC 2119、1997年3月. 

[2] Dierks、T. およびC. Allen、「The TLS Protocol Version 1.0」、RFC 2246、1999年1月. 

[3] Dierks、T. およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.1」、RFC 4346、2006年4月. 

[4] Blake-Wilson、S.、Nystrom、M.、Hopwood、D.、Mikkelsen、J. 、およびT. Wright、「Transport Layer Security（TLS）Extensions」、RFC 4366、2006年4月. 

[5] SECG、「Elliptic Curve Cryptography」、SEC 1、2000、<http://www.secg.org/>. 

[6] IEEE、「公開鍵暗号の標準仕様」、IEEE 1363、2000. 

[7] ANSI、「金融サービス業界向けの公開鍵暗号化：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANSI X9.62、1998年. 

[8] International Telecommunication Union、「Information technology-Abstract Syntax Notation One（ASN.1）：Specification of basic notation」、ITU-T勧告X.680、2002. 

[9]国際電気通信連合、「情報技術-ASN.1エンコーディング規則：基本符号化規則（BER）、標準符号化規則（CER）、および識別符号化規則（DER）の仕様」、ITU-T勧告X.690、2002 . 

[10] NIST、「Secure Hash Standard」、FIPS 180-2、2002. 

[11] NIST、「デジタル署名標準」、FIPS 186-2、2000. 

[12] RSA Laboratories、「PKCS＃1：RSA Encryption Standardバージョン1.5」、PKCS 1、1993年11月. 

[13] SECG、「推奨される楕円曲線ドメインパラメータ」、SEC 2、2000、<http://www.secg.org/>. 

[14] Polk、T.、Housley、R. 、およびL. Bassham、「インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイルのアルゴリズムと識別子」、RFC 3279、2002年4月. 

[15] Housley、R.、Polk、T.、Ford、W. 、およびD. Solo、「インターネットX.509公開鍵インフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル」、RFC 3280、2002年4月. 

[16] Narten、T. およびH. Alvestrand、「RFCでIANA考慮事項セクションを作成するためのガイドライン」、RFC 2434、1998年10月. 

10.2. 有益な参考文献
[17] Harper、G.、Menezes、A. 、およびS. Vanstone、「鍵の長さが非常に短い公開鍵暗号システム」、暗号学の進歩-EUROCRYPT '92、LNCS 658、1993. 

[18] Lenstra、A. およびE. Verheul、「Selecting Cryptographic Key Sizes」、Journal of Cryptology 14（2001）255-293、<http://www.cryptosavvy.com/>. 

[19] Chown、P. 、 "Advanced Encryption Standard（AES）Ciphersuites for Transport Layer Security（TLS）"、RFC 3268、2002年6月. 

付録A.同等の曲線（参考情報）
すべてのNIST曲線[11]およびいくつかのANSI曲線[7]は、セクション5.1.1にリストされている曲線と同等です. 次の表で、1行の複数の名前は、同じ曲線のエイリアスを表しています. 

             ------------------------------------------
                       によって選択された曲線名
                  さまざまな標準化団体
             ------------ + --------------- + -------------
             SECG | ANSI X9.62 | NIST
             ------------ + --------------- + -------------
             sect163k1 | | NIST K-163
             sect163r1 | |
             sect163r2 | | NIST B-163
             sect193r1 | |
             sect193r2 | |
             sect233k1 | | NIST K-233
             sect233r1 | | NIST B-233
             sect239k1 | |
             sect283k1 | | NIST K-283
             sect283r1 | | NIST B-283
             sect409k1 | | NIST K-409
             sect409r1 | | NIST B-409
             sect571k1 | | NIST K-571
             sect571r1 | | NIST B-571
             secp160k1 | |
             secp160r1 | |
             secp160r2 | |
             secp192k1 | |
             secp192r1 | prime192v1 | NIST P-192
             secp224k1 | |
             secp224r1 | | NIST P-224
             secp256k1 | |
             secp256r1 | prime256v1 | NIST P-256
             secp384r1 | | NIST P-384
             secp521r1 | | NIST P-521
             ------------ + --------------- + -------------
        
表6：SECG、ANSI、およびNISTによって定義された同等の曲線

著者の住所

Simon Blake-Wilson SafeNet Technologies BV Amstelveenseweg 88-90 1075 XJ、アムステルダムNL

   電話番号：+31 653 899 836
   Eメール：sblakewilson@safenet-inc.com
        
Nelson Bolyard Sun Microsystems Inc. 4170 Network Circle MS SCA17-201 Santa Clara、CA 95054 US

   電話番号：+1 408 930 1443
   Eメール：nelson@bolyard.com
        
Vipul Gupta Sun Microsystems Laboratories 16 Network Circle MS UMPK16-160 Menlo Park、CA 94025 US

   電話番号：+1 650 786 7551
   Eメール：vipul.gupta@sun.com
        
Chris Hawk Corriente Networks LLC 1563 Solano Ave. 、＃484 Berkeley、CA 94707 US

電話：+1 510 527 0601電子メール：chris@corriente.net Bodo Moeller Ruhr-Uni Bochum Horst-Goertz-Institut、Lehrstuhl fuer Kommunikationssicherheit IC 4/139 44780 Bochum DE

   電話番号：+49 234 32 26795
   Eメール：bodo@openssl.org
        
完全な著作権表示

Copyright（C）The Internet Society（2006）. 

このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、作成者はすべての権利を保持します. 

このドキュメントおよびここに含まれる情報は「現状有姿」で提供され、寄稿者、組織の代表者、またはスポンサー（存在する場合）、インターネットソサエティおよびインターネットエンジニアリングタスクフォースは、明示または明示またはすべての保証を否認しますここに記載されている情報の使用が、商品性または特定目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを含むがこれに限定されない、黙示の保証. 

知的財産

IETFは、知的財産権または本書に記載されている技術の実装または使用に関連すると主張される可能性のあるその他の権利の有効性または範囲、あるいはそのような権利に基づくライセンスが可能性があるかどうかについては何の立場も取りません. 利用可能である; また、そのような権利を特定するために独自の努力をしたことを表すものでもありません. RFC文書の権利に関する手順に関する情報は、BCP78およびBCP79に記載されています. 

IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような所有権の使用に関する一般的なライセンスまたは許可を取得しようとした結果を取得できます.  http://www.ietf.org/iprのIETFオンラインIPRリポジトリから. 

IETFは、この標準を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、利害関係者を招待します. 情報をIETF（ietf-ipr@ietf.org）に送信してください. 

了承

RFC Editor機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます. 