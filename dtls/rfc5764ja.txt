RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
5764
RFC 5764-Secure Real-time Transport Protocol（SRTP）のキーを確立するためのデータグラムトランスポート層セキュリティ（DTLS）拡張
URL：https://tools.ietf.org/html/rfc5764
タイトル：RFC 5764-Datagram Transport Layer Security（DTLS）Extension to Establish Keys for the Secure Real-time Transport Protocol（SRTP）
翻訳編集：自動生成
インターネット技術特別調査委員会（IETF）D. McGrew
コメントの要求：5764シスコシステムズ
カテゴリー：Standards Track E. Rescorla
ISSN：2070-1721 RTFM、Inc.
                                                                2010年5月
        
セキュアリアルタイムトランスポートプロトコル（SRTP）のキーを確立するためのデータグラムトランスポート層セキュリティ（DTLS）拡張

概要

このドキュメントでは、Secure RTP（SRTP）およびSecure RTP Control Protocol（SRTCP）フローのキーを確立するためのデータグラムトランスポート層セキュリティ（DTLS）拡張について説明します. DTLSキーイングは、存在する帯域外シグナリングチャネルとは関係なく、メディアパスで発生します. 

このメモのステータス

これはInternet Standards Trackドキュメントです. 

このドキュメントは、IETF（Internet Engineering Task Force）の製品です. これは、IETFコミュニティのコンセンサスを表しています. これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています. インターネット標準の詳細については、RFC 5741のセクション2を参照してください. 

このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc5764で入手できます. 

著作権表示

Copyright（c）2010 IETF Trustおよびドキュメントの作成者として識別された人物. 全著作権所有. 

この文書は、BCP 78およびこの文書の発行日に有効なIETF文書に関するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます. 

このドキュメントには、2008年11月10日より前に公開または公開されたIETFドキュメントまたはIETFコントリビューションの素材が含まれている場合があります.  IETF標準プロセス外. このような資料の著作権を管理する人から適切なライセンスを取得しないと、このドキュメントはIETF標準プロセス外で変更できません. また、その派生物は、IETF標準プロセス外で作成できません.  RFCとして、またはそれを英語以外の言語に翻訳するための出版物. 

目次

   1.はじめに. . . . . . . . . . . . . . . . . . . . . . . . . ３
   2.このドキュメントで使用される規則. . . . . . . . . . . . . . ３
   3. DTLS-SRTP動作の概要. . . . . . . . . . . . . . . 4
   4. SRTPキー確立のためのDTLS拡張. . . . . . . . . . 5
     4.1. use_srtp拡張. . . . . . . . . . . . . . . . . . 5
       4.1.1. use_srtp拡張定義. . . . . . . . . . . . 7
       4.1.2. SRTP保護プロファイル. . . . . . . . . . . . . . . 8
       4.1.3. srtp_mki値. . . . . . . . . . . . . . . . . . . . 9
     4.2. 鍵の導出. . . . . . . . . . . . . . . . . . . . . . 10
     4.3. キースコープ. . . . . . . . . . . . . . . . . . . . . . . . 12
     4.4. 主要な使用制限 . . . . . . . . . . . . . . . . . 12
   5. DTLS-SRTPチャネルを介したRTPおよびRTCPの使用. . . . . . . . . 13
     5.1. データ保護. . . . . . . . . . . . . . . . . . . . . 13
       5.1.1. 伝送 . . . . . . . . . . . . . . . . . . . . . 13
       5.1.2. 受信. . . . . . . . . . . . . . . . . . . . . . 13
     5.2. Rehandshake and Rekey. . . . . . . . . . . . . . . . . . 16
   6.マルチパーティRTPセッション. . . . . . . . . . . . . . . . . . . 17
   7.セキュリティに関する考慮事項. . . . . . . . . . . . . . . . . . . 17
     7.1. 交渉の安全. . . . . . . . . . . . . . . . . 17
     7.2. フレーミング混乱. . . . . . . . . . . . . . . . . . . . 17
     7.3. シーケンス番号の相互作用. . . . . . . . . . . . . . . 18
       7.3.1. アラート. . . . . . . . . . . . . . . . . . . . . . . . 18
       7.3.2. 再交渉. . . . . . . . . . . . . . . . . . . . 18
     7.4. 復号化コスト. . . . . . . . . . . . . . . . . . . . . 19
   8. RTLS / SAVP over DTLSのセッションの説明. . . . . . . . . . 19
   9. IANAの考慮事項. . . . . . . . . . . . . . . . . . . . . 20
   10.謝辞. . . . . . . . . . . . . . . . . . . . . . . 20
   11.参考文献. . . . . . . . . . . . . . . . . . . . . . . . . . 21
     11.1 規範的な参照. . . . . . . . . . . . . . . . . . . 21
     11.2 有益な参照. . . . . . . . . . . . . . . . . . 21
   付録A. DTLSの概要. . . . . . . . . . . . . . . . . . 23
   付録B.複数のDTLSハンドシェイクのパフォーマンス. . . . . . . 24
        
1.はじめに
Secure RTP（SRTP）プロファイル[RFC3711]は、RTPデータおよびRTP制御（RTCP）トラフィックに機密性、メッセージ認証、および再生保護を提供できます. SRTPはキー管理機能を提供しませんが、代わりに外部キー管理に依存して秘密のマスターキーを交換し、それらのキーで使用するアルゴリズムとパラメーターをネゴシエートします. 

データグラムトランスポート層セキュリティ（DTLS）[RFC4347]は、統合されたキー管理、パラメータネゴシエーション、および安全なデータ転送を提供するチャネルセキュリティプロトコルです. DTLSデータ転送プロトコルは汎用であるため、RTPで使用するための最適化はSRTPほど最適化されていません. SRTPは、その目的のために特別に調整されています. 

このドキュメントでは、DTLSのSRTP拡張であるDTLS-SRTPについて説明します. これは、SRTPのパフォーマンスと暗号化の柔軟性の利点と、DTLS統合鍵および関連付け管理の柔軟性と利便性を組み合わせたものです. DTLS-SRTPは、SRTPの新しいキー管理方法として、およびDTLSの新しいRTP固有のデータ形式として、2つの同等の方法で表示できます. 

DTLS-SRTPの重要な点は次のとおりです. 

oアプリケーションデータはSRTPを使用して保護されます. 

o DTLSハンドシェイクは、SRTPのキー情報、アルゴリズム、およびパラメーターを確立するために使用されます. 

o DTLS拡張を使用してSRTPアルゴリズムをネゴシエートします. 

o他のDTLSレコード層コンテンツタイプは、通常のDTLSレコード形式を使用して保護されます. 

このメモの残りの部分は、次のように構成されています. セクション2では、規範的な要件を示すために使用される規則について説明します. セクション3では、DTLS-SRTP動作の概要を説明します. セクション4ではDTLS拡張を指定し、セクション5では、RTPおよびRTCPがDTLS-SRTPチャネルを介して転送される方法について説明します. セクション6では、マルチパーティセッションでの使用について説明します. セクション7とセクション9では、セキュリティとIANAの考慮事項について説明します. 

2.このドキュメントで使用される規則
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます. 

3. DTLS-SRTPオペレーションの概要
DTLS-SRTPは、ポイントツーポイントメディアセッション用に定義されており、参加者はちょうど2人です. 各DTLS-SRTPセッションには、単一のDTLSアソシエーション（TLS専門用語では「接続」と呼ばれます）、および2つのSRTPコンテキスト（メディアトラフィックが同じホスト/ポートカルテットで双方向に流れている場合）または1つのSRTPコンテキスト（メディアの場合）が含まれますトラフィックは一方向にのみ流れています）. 特定の方向でそのペアを介して流れるすべてのSRTPトラフィックは、単一のSRTPコンテキストを使用します. 単一のDTLS-SRTPセッションは、単一のUDP送信元と宛先ポートのペアで伝送されるデータのみを保護します. 

DTLS-SRTPの一般的なパターンは次のとおりです. RTPまたはRTCPフローごとに、ピアは同じ送信元ポートと宛先ポートのペアでDTLSハンドシェイクを実行して、DTLSアソシエーションを確立します. どちら側がDTLSクライアントで、どちら側がDTLSサーバーであるかは、SDPなどの帯域外メカニズムを介して確立する必要があります. そのハンドシェイクからのキーイングマテリアルがSRTPスタックに送られます. その関連付けが確立されると、RTPパケットはその鍵情報を使用して保護されます（SRTPになります）. 

RTPおよびRTCPトラフィックは通常、2つの別個のUDPポートで送信されます. 対称RTP [RFC4961]を使用する場合、2つの双方向DTLS-SRTPセッションが必要です. 1つはRTPポート用、もう1つはRTCPポート用です. RTPフローが対称的でない場合、4つの単方向DTLS-SRTPセッションが必要です（インバウンドとアウトバウンドのRTP、およびインバウンドとアウトバウンドのRTCPの場合）. 

対称RTP [RFC4961]は、TCP接続がポートを使用する方法と同様の方法で、送信元ポートと宛先ポート、およびアドレスが逆になっている2つのRTPセッションがある場合です. 各参加者には、インバウンドRTPセッションとアウトバウンドRTPセッションがあります. 対称RTPを使用する場合、単一のDTLS-SRTPセッションで両方のRTPセッションを保護できます. DTLS-SRTPで対称RTPを使用することをお勧めします. 

RTPおよびRTCPトラフィックは、単一のUDPポート[RFC5761]で多重化される場合があります. この場合、RTPパケットとRTCPパケットの両方が同じDTLS-SRTPセッションを介して送信され、必要なDTLS-SRTPセッションの数が半分になります. これにより、DTLSの暗号化パフォーマンスが向上しますが、RTCPとRTPが異なるネットワーク処理（たとえば、帯域幅の予約またはスケジューリングの理由）を受ける場合に問題が発生する可能性があります. 

1組の参加者間で、複数のメディアセッションが存在する場合があります. メディアセッションで使用される送信元ポートと宛先ポートの個別のペアごとに、個別のDTLS-SRTPセッションが存在する必要があります（セッションは単一のDTLSセッションを共有できるため、最初の公開キーハンドシェイクを償却できます）. 

DTLS-SRTPセッションは、SIPなどの外部シグナリングプロトコルによって示される場合があります. シグナリング交換が完全性保護されている場合（たとえば、デジタル署名によるSIP ID保護が使用されている場合）、DTLS-SRTPはこの完全性保証を利用して、メディアストリームの完全なセキュリティを提供できます. SIPおよびSDP [RFC4566]でDTLS-SRTPセッションを示す方法、およびフィンガープリントを使用してエンドポイントを認証する方法の説明は、[RFC5763]にあります. 

単純な実装では、複数のメディアセッションが存在する場合、各メディアチャネルに新しいDTLSセッションが確立されます（公開鍵暗号化が完了しています）. たとえば、テレビ電話はオーディオストリームとビデオストリームの両方を送信している可能性があり、それぞれが別々にDTLSセッションの確立交換を使用し、並行して進行します. 最適化として、DTLS-SRTP実装は次の戦略を使用する必要があります. 単一のDTLSアソシエーションが確立され、他のすべてのDTLSアソシエーションはその接続が確立されるまで待機してから、ハンドシェイクを続行します. この戦略により、後のセッションでDTLSセッションの再開を使用できるようになり、複数のDTLSハンドシェイクでの高価な公開鍵暗号化操作の償却が可能になります. 

クライアントが発信したパケットを保護するために使用されるSRTPキーは、サーバーが発信したパケットを保護するために使用されるSRTPキーとは異なります. 同じチャネルのクライアントから発信されたすべてのRTPソースは同じSRTPキーを使用し、同様に、同じチャネルのサーバーから発信されたすべてのRTPソースは同じSRTPキーを使用します. SRTP実装は、「2タイムパッド」の問題（セクションで説明）を回避するために、同じチャネルを介して同じデバイスから発生するすべてのRTPソースのすべての同期ソース（SSRC）値が異なることを確認する必要があります.  RFC 3711の9.1）. これは、SSRCの衝突が発生した場合でも、独立したキーイングマテリアルを使用する（異なるホスト/ポートカルテット上の）個別のメディアストリームの問題ではないことに注意してください. 

4. SRTPキー確立のためのDTLS拡張
4.1. use_srtp拡張
SRTPデータ保護の使用をネゴシエートするために、クライアントはDTLS拡張クライアントハローに「use_srtp」タイプの拡張を含めます. この拡張は、転送されるデータがRTPまたはRTCP [RFC3550]の場合にのみ使用する必要があります. この拡張の「extension_data」フィールドには、以下に示すように、受け入れ可能なSRTP保護プロファイルのリストが含まれています. 

「use_srtp」拡張を含む拡張helloを受信するサーバーは、タイプ「use_srtp」の拡張を拡張サーバーhelloで選択した保護プロファイルとともに含めることにより、SRTPの使用に同意できます. このプロセスを以下に示します. 

         Client                                               Server

         ClientHello + use_srtp       -------->
                                              ServerHello + use_srtp
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      <--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     -------->
                                                  [ChangeCipherSpec]
                                      <--------             Finished
         SRTP packets                 <------->      SRTP packets
        
「*」は常にDTLSで送信されるわけではないメッセージを示すことに注意してください. CertificateRequest、クライアントとサーバーの証明書、およびCertificateVerifyは、DTLS-SRTPで送信されます. 

「use_srtp」拡張がネゴシエートされると、RTPまたはRTCPアプリケーションデータはSRTPのみを使用して保護されます. アプリケーションデータは、DTLSレコード層の「application_data」パケットで送信されることはありません. むしろ、完全なRTPまたはRTCPパケットはDTLSスタックに渡され、DTLSスタックはそれらをSRTPスタックに渡して、適切に保護します. RTP / RTCP多重化[RFC5761]が使用されている場合、これは、RTPパケットとRTCPパケットの両方がDTLSスタックに渡される可能性があることを意味することに注意してください. DTLS層はパケットを処理しないため、パケットを区別する必要はありません. SRTPスタックは、[RFC5761]の手順を使用して、RTPとRTCPを区別できます. 

「use_srtp」拡張が有効な場合、実装は、データグラムごとに複数のアプリケーションデータ「レコード」を配置することはできません. （SRTPは本質的にパケットごとに1つのペイロードを指向するため、これはDTLSの観点からのみ意味がありますが、これは説明のためにのみ述べられています. ）

RTP / RTCP以外のデータ（つまり、TLS制御メッセージ）は、通常のDTLSフレーミングを使用する必要があり、SRTPデータとは別のデータグラムに配置する必要があります. 

DTLS-SRTPハンドシェイクは、1つ以上のSRTP暗号コンテキストを確立します. ただし、SRTP保護プロファイルとマスターキー識別子（MKI）があれば、それらはすべて同じです. MKIは、たとえば鍵の再生成などにより、別個のハンドシェイク間で鍵材料と保護プロファイルを区別するためにのみ使用されます. MKIがDTLS-SRTPセッションで確立されると、そのセッション内のすべてのSSRCに適用される必要があります-たとえば、フォーキングなどにより、単一のエンドポイントが複数のDTLS-SRTPセッションをネゴシエートする場合があります. （RFC 3711では、同じセッション内のパケットが異なるSSRCでもMKIを異なる方法で使用できることに注意してください. 対照的に、DTLS-SRTPでは、MKIとそれらに関連付けられているキーが同じ意味を持ち、SRTPセッション全体で統一されている必要があります.  ）

4.1.1. use_srtp拡張定義
クライアントは、「use_srtp」拡張のextension_dataフィールドにUseSRTPData値を入力する必要があります（登録についてはセクション9を参照）：

      uint8 SRTPProtectionProfile[2];

      struct {
         SRTPProtectionProfiles SRTPProtectionProfiles;
         opaque srtp_mki<0..255>;
      } UseSRTPData;

      SRTPProtectionProfile SRTPProtectionProfiles<2..2^16-1>;
        
SRTPProtectionProfilesリストは、クライアントがサポートしようとするSRTP保護プロファイルを、優先度の高い順に示しています. srtp_mki値には、クライアントがSRTPパケットに使用するSRTPマスターキー識別子（MKI）値（存在する場合）が含まれています. このフィールドの長さがゼロの場合、MKIは使用されません. 

注：TLS構文に不慣れな方のために、「srtp_mki <0..255>」は、長さが0〜255（両端を含む）の可変長値を示します. したがって、MKIの長さは最大255バイトです. 

サーバーがuse_srtp拡張を受け入れる用意がある場合は、ExtendedServerHelloの独自の「use_srtp」拡張で応答する必要があります. extension_dataフィールドには、サーバーがこの接続で使用するために選択した単一のSRTPProtectionProfile値を持つUseSRTPData値を含める必要があります. サーバーは、クライアントが提供していない値を選択してはなりません（MUST NOT）. 共有プロファイルがない場合、サーバーは、接続がネゴシエートされたDTLS暗号スイートにフォールバックする時点で、use_srtp拡張を返さないでください（SHOULD NOT）. それが受け入れられない場合、サーバーは適切なDTLSアラートを返す必要があります（SHOULD）. 

4.1.2. SRTP保護プロファイル
DTLS-SRTP SRTP保護プロファイルは、SRTP処理に有効なパラメーターとオプションを定義します. このドキュメントでは、次のSRTP保護プロファイルを定義しています. 

      SRTPProtectionProfile SRTP_AES128_CM_HMAC_SHA1_80 = {0x00、0x01};
      SRTPProtectionProfile SRTP_AES128_CM_HMAC_SHA1_32 = {0x00、0x02};
      SRTPProtectionProfile SRTP_NULL_HMAC_SHA1_80 = {0x00、0x05};
      SRTPProtectionProfile SRTP_NULL_HMAC_SHA1_32 = {0x00、0x06};
        
次のリストは、各保護プロファイルのSRTP変換パラメーターを示しています. パラメータcipher_key_length、cipher_salt_length、auth_key_length、およびauth_tag_lengthは、それらが参照する値のビット数を表します. maximum_lifetimeパラメータは、パラメータプロファイルが使用されているときに、各キーセットで保護できるパケットの最大数を示します. RTCPパラメータが個別に指定されていない限り、これらのパラメータはすべてRTPとRTCPの両方に適用されます. 

これらのプロファイルの暗号アルゴリズムはすべて[RFC3711]からのものです. 

   SRTP_AES128_CM_HMAC_SHA1_80
         cipher: AES_128_CM
         cipher_key_length: 128
         cipher_salt_length: 112
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 80
   SRTP_AES128_CM_HMAC_SHA1_32
         cipher: AES_128_CM
         cipher_key_length: 128
         cipher_salt_length: 112
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 32
         RTCP auth_tag_length: 80
   SRTP_NULL_HMAC_SHA1_80
         cipher: NULL
         cipher_key_length: 0
         cipher_salt_length: 0
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 80
   SRTP_NULL_HMAC_SHA1_32
         cipher: NULL
         cipher_key_length: 0
         cipher_salt_length: 0
         maximum_lifetime: 2^31
         auth_function: HMAC-SHA1
         auth_key_length: 160
         auth_tag_length: 32
         RTCP auth_tag_length: 80

これらすべてのSRTPパラメータプロファイルでは、次のSRTPオプションが有効です. 

o TLS疑似ランダム関数（PRF）は、SRTP鍵導出関数（KDF）に供給する鍵を生成するために使用されます. DTLS 1.2 [DTLS1.2]が使用されている場合、PRFは暗号スイートに関連付けられたものです. この仕様はDTLS 1.0またはDTLS 1.2と互換性があることに注意してください. 

o鍵導出率（KDR）がゼロに等しい. したがって、鍵はSRTPシーケンス番号に基づいて再派生されません. 

o RFC 4.311のAES-CM PRFを使用したセクション4.3の鍵導出手順が使用されます. 

o他のすべてのパラメーター（特に、SRTP再生ウィンドウサイズとFEC順序）には、デフォルト値が使用されます. 

これらのパラメーターのデフォルト以外の値が必要な場合は、SDP構文を指定する別の仕様を記述してそれらを通知することにより、それらを有効にできます. 

DTLS-SRTPを使用するアプリケーションは、RTPフローを保護するDTLS-SRTPセッションと、関連するRTCPフローを保護するDTLS-SRTPセッションの間でSRTP保護プロファイルを調整する必要があります（RTPとRTCPが共通で多重化されていない場合）港）. 特に、同一の暗号を使用する必要があります. 

新しいSRTPProtectionProfile値は、RFC 5226 [RFC5226]で定義されている「Specification Required」ポリシーに従って定義する必要があります. IANAの考慮事項については、セクション9を参照してください. 

4.1.3. srtp_mki値
srtp_mki値を使用して、SRTPおよびSRTCPパケットでSRTPマスターキー識別子（MKI）フィールドを使用する機能と希望を示すことができます. MKIフィールドは、そのフィールドを含むパケットを保護するために使用されたキーをSRTPレシーバーに示します. srtp_mkiフィールドには、このハンドシェイクから派生したSRTPマスターキーに関連付けられているSRTP MKIの値が含まれています. 各SRTPセッションには、常にパケットを保護するために使用されるマスターキーが1つだけ必要です. クライアントは、使用された最後のMKI値とは異なるようにMKI値を選択する必要があります. また、TLSセッションの期間中、これらの値を一意にする必要があります. 

「srtp_mki」フィールドを含む「use_srtp」拡張機能を受信すると、サーバーは次のいずれかを実行する必要があります（拡張機能をまったく受け入れる場合）. 

1.「use_srtp」拡張に一致する「srtp_mki」値を含めて、MKIを使用することを示します. または2.空の「srtp_mki」値を返し、MKIを使用できないことを示します. 

クライアントがサーバーの応答で、クライアントが提供したものとは異なる長さゼロ以外のMKIを検出した場合、クライアントはハンドシェイクを中止し、invalid_parameterアラートを送信する必要があります（SHOULD）. クライアントとサーバーがMKIに同意する場合、新しいセキュリティパラメータで保護されているすべてのSRTPパケットにそのMKIが含まれている必要があります. 

特定のDTLS-SRTPセッションには、アクティブなMKI（存在する場合）が1つしかないことに注意してください. したがって、常に、一連のエンドポイントは通常1つのMKIのみを使用します（主な例外は再ハンドシェイク中です）. 

4.2. 鍵導出
SRTPモードが有効な場合、通常のDTLSレコード保護とSRTPパケット保護に異なるキーが使用されます. これらの鍵は、TLSエクスポーター[RFC5705]を使用して生成され、

2 *（SRTPSecurityParams.master_key_len + SRTPSecurityParams.master_salt_len）バイトのデータ

以下のように割り当てられます. 関連付けごとのコンテキスト値は空です. 

   client_write_SRTP_master_key [SRTPSecurityParams.master_key_len];
   server_write_SRTP_master_key [SRTPSecurityParams.master_key_len];
   client_write_SRTP_master_salt [SRTPSecurityParams.master_salt_len];
   server_write_SRTP_master_salt [SRTPSecurityParams.master_salt_len];
        
この使用法のエクスポーターラベルは「EXTRACTOR-dtls_srtp」です. （「EXTRACTOR」接頭辞は、歴史的な互換性のためです. ）

図1に示すように、4つのキー素材の値（各方向のマスターキーとマスターソルト）は、SRTPキー導出メカニズムへの入力として提供されます. SRTP保護プロファイルの一部として別の鍵導出メカニズムが指定されていない限り、デフォルトでは、[RFC3711]のセクション4.3で定義されたメカニズムが使用されます. 

client_write_SRTP_master_keyおよびclient_write_SRTP_master_saltは、SRTPキー導出関数の1回の呼び出しに提供され、クライアントから送信されたパケットの暗号化と認証に使用されるSRTPキーを生成します. サーバーはこれらの鍵を使用して、受信パケットの復号化と信頼性の確認のみを行う必要があります. 

server_write_SRTP_master_keyおよびserver_write_SRTP_master_saltは、サーバーが送信するパケットの暗号化および認証に使用されるSRTPキーを生成するために、SRTPキー導出関数の1回の呼び出しに提供されます. クライアントは、これらの鍵を使用して、受信パケットの復号化と信頼性の確認のみを行う必要があります. 

   TLS master
     secret   label
      |         |
      v         v
   +---------------+
   | TLS extractor |
   +---------------+
          |                                         +------+   SRTP
          +-> client_write_SRTP_master_key ----+--->| SRTP |-> client
          |                                    | +->| KDF  |   write
          |                                    | |  +------+   keys
          |                                    | |
          +-> server_write_SRTP_master_key --  | |  +------+   SRTCP
          |                                  \ \--->|SRTCP |-> client
          |                                   \  +->| KDF  |   write
          |                                    | |  +------+   keys
          +-> client_write_SRTP_master_salt ---|-+
          |                                    |
          |                                    |    +------+   SRTP
          |                                    +--->| SRTP |-> server
          +-> server_write_SRTP_master_salt -+-|--->| KDF  |   write
                                             | |    +------+   keys
                                             | |
                                             | |    +------+   SRTCP
                                             | +--->|SRTCP |-> server
                                             +----->| KDF  |   write
                                                    +------+   keys

                Figure 1: The derivation of the SRTP keys.

RTCPとRTPの両方が同じ送信元ポートと宛先ポートを使用する場合、SRTPキーとSRTCPキーの両方が必要です. それ以外の場合は、2つのDTLS-SRTPセッションがあり、1つはRTPパケットを保護し、もう1つはRTCPパケットを保護します. 図2に示すように、各DTLS-SRTPセッションは、単一の送信元/宛先トランスポートアドレスのペアを通過するSRTPセッションの一部を保護します（図2に示すように、そのペアで使用されるSSRCは関係ありません）. DTLS-SRTPセッションがRTPを保護している場合、DTLSハンドシェイクから派生したSRTCPキーは不要であり、破棄されます. DTLS-SRTPセッションがRTCPを保護している場合、DTLSハンドシェイクから派生したSRTPキーは不要であり、破棄されます. 

      Client            Server
     (Sender)         (Receiver)
   (1)   <----- DTLS ------>    src/dst = a/b and b/a
         ------ SRTP ------>    src/dst = a/b, uses client write keys

   (2)   <----- DTLS ------>    src/dst = c/d and d/c
         ------ SRTCP ----->    src/dst = c/d, uses client write keys
         <----- SRTCP ------    src/dst = d/c, uses server write keys

図2：RTPを保護するDTLS-SRTPセッション（1）とRTCPを保護する別のセッション（2）、使用されるトランスポートアドレスとキーを示します. 

4.3. 主な範囲
パケットの並べ替えの可能性があるため、DTLS-SRTP実装は、受信者がキーのないパケットをドロップする必要を回避するために、キーの再生成中に複数のSRTPキーセットを格納する必要があります. 

4.4. 主要な使用制限
SRTP保護プロファイルのmaximum_lifetimeパラメータは、単一の暗号化および認証キーごとに保護できるパケットの最大数を示します. （RTPとRTCPは独立したキーで保護されているため、これらのプロトコルは、キーがいつまで有効期限に達したかを判別するために個別にカウントされます. ）各プロファイルは独自の制限を定義します. この制限に達すると、新しいDTLSセッションを使用して置換キーを確立する必要があり（SHOULD）、SRTP実装は、送信トラフィックまたは受信トラフィックの処理に既存のキーを使用してはなりません（MUST NOT）. 

5. DTLS-SRTPチャネルでのRTPおよびRTCPの使用
5.1. データ保護
DTLSハンドシェイクが完了すると、ピアは新しく作成されたチャネルを介してRTPまたはRTCPを送信できます. 最初に送信プロセスについて説明し、次に受信プロセスについて説明します. 

各RTPセッション内では、DTLSハンドシェイクが完了する前にSRTP処理を実行してはなりません. 

5.1.1. 伝送
DTLSおよびTLSは、いくつかのレコードコンテンツタイプを定義します. 通常のTLS / DTLSでは、すべてのデータが同じレコードエンコーディングとメカニズムを使用して保護されます. このドキュメントで説明されているメカニズムが有効な場合、DTLSの上位プロトコルクライアントによって書き込まれたデータがRTP / RTPであると想定され、標準のTLSレコードエンコーディングではなくSRTPを使用して暗号化されるように変更されます. 

DTLSのユーザーがSRTPモードでRTPパケットを送信したい場合、それを通常のアプリケーションデータ書き込み（SSL_write（）など）としてDTLS実装に配信します. 次に、DTLS実装は、RFC 3711のセクション3および4で説明されている処理を呼び出します. 結果のSRTPパケットは、DTLSフレーミングのない単一のデータグラムとして回線上に直接送信されます. これは、SRTPに準拠し、相互運用するデータのカプセル化を提供します. これらのパケットには、DTLSシーケンス番号ではなくRTPシーケンス番号が使用されることに注意してください. 

5.1.2. 受信
DTP-SRTPを使用してRTPセッションを保護する場合、RTPレシーバーはRTPポートに到着するパケットを逆多重化する必要があります. 到着するパケットのタイプは、RTP、DTLS、またはSTUN [RFC5389]です. これらが存在するパケットのタイプのみである場合、パケットのタイプは、その最初のバイトを調べることによって判別できます. 

パケットを逆多重化するプロセスは次のとおりです. 受信者はパケットの最初のバイトを調べます. このバイトの値が0または1の場合、パケットはSTUNです. 値が128〜191（両端を含む）の場合、パケットはRTP（またはRTCPとRTPの両方が同じ宛先ポートで多重化されている場合はRTCP）です. 値が20〜63（両端を含む）の場合、パケットはDTLSです. このプロセスを図3に要約します. 

                   +----------------+
                   | 127 < B < 192 -+--> forward to RTP
                   |                |
       packet -->  |  19 < B < 64  -+--> forward to DTLS
                   |                |
                   |       B < 2   -+--> forward to STUN
                   +----------------+
        
図3：DTLS-SRTPレシーバーのパケット逆多重化アルゴリズム. ここで、フィールドBはパケットの先頭バイトを示します. 

他のパケットタイプも多重化する場合、実装者や設計者は、これらの3つのパケットタイプから逆多重化できることを確認する必要があります. 

場合によっては、特定のSRTPエンドポイントに複数のDTLS-SRTPアソシエーションがあります. たとえば、アリスがボブとチャーリーの両方にSIPフォークされたコールを発信すると、図4に示すように、アリスは両方に同じローカルホスト/ポートのペアを使用します. XXXとYYYは異なるDTLS-SRTPアソシエーションを表します. （表示されているSSRCは、Aliceに流れるデータのSSRCです. ）

                                          Bob (192.0.2.1:6666)
                                         /
                                        /
                                       / SSRC=1
                                      /  DTLS-SRTP=XXX
                                     /
                                    v
               Alice (192.0.2.0:5555)
                                    ^
                                     \
                                      \  SSRC=2
                                       \ DTLS-SRTP=YYY
                                        \
                                         \
                                          Charlie (192.0.2.2:6666)

                 Figure 4: RTP sessions with SIP forking.

DTLSはホスト/ポートカルテットで動作するため、DTLSアソシエーションは引き続き正常に完了し、外部ホスト/ポートのペアが使用されて、アソシエーションを区別します. ただし、RTPでは送信元ホスト/ポートは使用されず、セッションは宛先ホスト/ポートとSSRCによって識別されます. したがって、どのSSRCがどのDTLSアソシエーションに対応するかを判別するための何らかのメカニズムが必要です. 次のメソッドを使用する必要があります. 

DTLS-SRTP実装は、ローカルのホスト/ポートのペアごとに、認識しているすべてのSSRCとそれらが対応するDTLS-SRTPアソシエーションをリストしたテーブルを維持します. 最初、このテーブルは空です. SRTPパケットが特定のRTPエンドポイント（宛先IP /ポートのペア）で受信されると、次の手順が使用されます. 

1.そのエンドポイントでSSRCがすでにわかっている場合は、対応するDTLS-SRTPアソシエーションとそのキーイングマテリアルを使用して、パケットを復号化および検証します. 2. SSRCが不明の場合、受信者は、そのエンドポイントの各DTLS-SRTPアソシエーションに対応するキー情報を使用して、SSRCを解読しようとします. 3.復号化と検証が成功すると（認証タグが検証）、SSRCをその関連付けにマッピングするテーブルにエントリが配置されます. 4.復号化と検証が失敗した場合、パケットは通知なく破棄されます. 5. DTLS-SRTPアソシエーションが閉じている場合（たとえば、フォークが放棄されたため）、そのエントリはマッピングテーブルから削除する必要があります. 

単一のSSRCに対するこのアルゴリズムの平均コストは、単一のパケットの復号化と検証の時間に、ホスト上の単一の受信ポートに対応する有効なDTLS-SRTPアソシエーションの数を掛けたものです. 実際には、これはフォークの数を意味します. したがって、図4に示すケースでは、2になります. その後、SSRCがマップテーブルに配置され、すぐに検索されるため、このコストは特定のSSRCに対して1回のみ発生します. 通常のRTPと同様に、このアルゴリズムでは、新しいSSRCをいつでもソースから導入できます. これらは自動的に正しいDTLSアソシエーションにマッピングされます. 

このアルゴリズムでは、同じアドレスとポートのペアから複数のSSRCを明示的に送信できることに注意してください. これが発生する1つの方法は、RTPトランスレータです. このアルゴリズムは、SSRCを正しい関連付けに自動的に割り当てます. SRTPパケットは暗号で保護されているため、このようなトランスレータは、1つのエンドポイントとキー情報を共有するか、整合性チェックが失敗するような方法でパケットを変更しないようにする必要があります. これはSRTPの一般的なプロパティであり、DTLS-SRTPに固有のものではありません. 

考慮すべき2つのエラーケースがあります. まず、SSRC衝突が発生した場合、最初のソースからのパケットのみが処理されます. 2番目のソースからのパケットが到着すると、最初のソースとのDTLSアソシエーションが復号化と検証に使用され、失敗し、パケットは破棄されます. これは、[RFC3550]と一致しています. 

1つのソースからのパケットを保持し、他のソースからそれらを破棄するレシーバー. もちろん、RFC 3550 SSRC衝突検出および処理手順にも従わなければなりません（MUST）. 

第2に、誤動作しているソースが、復号化および検証できない破損したパケットを送信している場合があります. この場合、復号化と検証は常に失敗するため、SSRCがマッピングテーブルに入力されることはありません. 受信者は、復号化と検証に一貫して失敗するマッピングされていないSSRCの記録を保持し、何らかの制限に達したら処理を中止することができます（MAY）. この制限は、伝送エラーの影響を考慮するのに十分な大きさでなければなりません. 関連するSRTPエンドポイントが削除された場合（たとえば、通話が終了した場合）、このテーブルからエントリをプルーニングする必要があり、それよりも早くタイムアウトする必要があります（ハード推奨はありませんが、10〜30秒が適切と思われます）. ピアの実装が修正された可能性. 

5.2. 再握手と鍵の再生成
DTLSでの鍵の再生成は、既存のDTLSチャネルで新しいハンドシェイクを実行することによって行われます. つまり、ハンドシェイクメッセージは既存のDTLS暗号スイートによって保護されます. このハンドシェイクはデータ転送と並行して実行できるため、データフローを中断する必要はありません. ハンドシェイクが完了すると、新しく派生したキーのセットを使用して、DTLSとSRTPの両方のすべての送信パケットが保護されます. 

パケットの並べ替えのため、ハンドシェイクが完了した後、以前のキーのセットによって保護されたパケットがネットワーク上に現れる可能性があります. この事実を補うために、受信者は、古いパケットを解読して検証できるように、両方のキーのセットをしばらく維持する必要があります. キーは、最大セグメントライフタイム（MSL）の間維持する必要があります. 

MKIを使用する場合、受信者は対応するキーのセットを使用して着信パケットを処理する必要があります. 一致するMKIが存在しない場合、パケットは拒否される必要があります. それ以外の場合、ハンドシェイクの完了後にパケットが到着すると、MKIがない限り、受信者は新しく導出されたキーのセットを使用してそのパケットを処理する必要があります（SHOULD）. （パケットが古いキーのセットで保護されている場合、認証の失敗が発生するため、この事実は受信者に明らかになります. ）パケットの認証チェックが失敗し、MKIが使用されていない場合、受信者は、古いキーのセットを含むパケット. その認証チェックがパケットが有効であることを示している場合、パケットは受け入れられるはずです. それ以外の場合は、パケットを破棄して拒否する必要があります. 

受信者は、鍵の選択を支援するためにSRTPパケットシーケンス番号を使用してもよい（MAY）. パケットが受信され、新しいキーセットで認証された後、シーケンス番号が大きいパケットはすべて新しいキーセットで保護されます. 

6.マルチパーティRTPセッション
DTLSはポイントツーポイントプロトコルであるため、DTLS-SRTPはユニキャストRTPセッションの保護のみを目的としています. これは、RTPミキサーでの使用を妨げるものではありません. たとえば、会議ブリッジはDTLS-SRTPを使用して、会議の各参加者との間の通信を保護できます. ただし、エンドポイントとミキサー間の各フローには独自のキーがあるため、ミキサーは各受信者のトラフィックを復号化してから再暗号化する必要があります. 

将来の仕様では、複数のDTLS-SRTPアソシエーション間で単一の鍵を共有する方法について説明し、会議システムが復号化/再暗号化段階を回避できるようにする可能性があります. ただし、メディアが変更されるシステム（たとえば、レベルバランシングまたはトランスコーディング）は通常、平文で実行する必要があり、認証タグを確実に破壊するため、復号化/再暗号化ステージが必要になります. 

7.セキュリティに関する考慮事項
同じハンドシェイクでネゴシエートされた複数のデータ保護フレーミングを使用すると、ここで説明するいくつかの複雑さが生じます. 

7.1. 交渉の安全
ここでの1つの懸念は、攻撃者が入札ダウン攻撃を実装して、ピアにSRTPではなく通常のDTLSを使用するよう強制できる可能性があることです. ただし、この拡張のネゴシエーションはDTLSハンドシェイクで実行されるため、終了メッセージによって保護されます. したがって、ビッドダウン攻撃は自動的に検出され、チャネルを制御できる攻撃者が乗せることのできるサービス拒否攻撃になります. 

7.2. 混乱をフレーミング
2つの異なるフレーミングフォーマットが使用されるため、攻撃者が受信者にSRTPフレームのRTPパケットをDTLSレコード（たとえば、ハンドシェイクメッセージ）として、またはその逆として扱うように仕向けることが懸念されます. この攻撃は、データのタイプごとにメッセージ認証コード（MAC）検証に異なるキーを使用することによって防止されます. したがって、このタイプの攻撃は、有効なMACでパケットを偽造できるようになり、DTLSとSRTPの両方の基本的なセキュリティの不変に違反します. 

DTLSハンドシェイクチャネルへの挿入に対する追加の防御策として、DTLSレコードタイプがMACに含まれています. したがって、SRTPレコードは不明なタイプとして扱われ、無視されます. （[RFC5246]のセクション6を参照してください. ）

7.3. シーケンス番号の相互作用
セクション5.1.1で説明されているように、SRTPおよびDTLSシーケンス番号スペースは異なります. つまり、SRTPパケットに関して特定のDTLS制御レコードを明確に順序付けることはできません. 一般的に、これは、アラートと再ハンドシェイクの2つの状況に関連しています. 

7.3.1. アラート
DTLSハンドシェイクとchange_cipher_specメッセージは、アラートと同じシーケンス番号スペースを共有するため、正しく順序付けできます. DTLSアラートは本質的に信頼性が低く、データパケットへの応答として生成されるべきではないため、SRTPパケットとDTLSアラートの間の信頼できるシーケンスは重要な機能ではありません. ただし、DTLSアラートを使用してSRTPエンコーディングの問題を通知する実装は、アラートが受信されるとすぐにアクションに対処し、時間的に連続したストリームを参照していると想定する必要があります. そのような実装は、アラートの再送信をチェックし、再送信されたアラートを破棄して、リプレイ攻撃に対する過剰反応を回避する必要があります. 

7.3.2. 再交渉
セクション5.2で指定された再ハンドシェイク遷移アルゴリズムでは、MKIが使用されていない場合に複数のキーセットを試す必要があるため、認証が少し弱まります. たとえば、nビットMACが使用され、k個の異なるキーセットが存在する場合、MACはlog_2（k）ビットによってn-log_2（k）に弱められます. 実際には、使用される鍵の数は非常に少なく、使用中のMACは通常強力です（SRTPのデフォルトは80ビットです）ため、ここでのセキュリティの低下は最小限です. 

ここでのもう1つの問題は、このアルゴリズムは複数の検証を試行する必要があるため、受信側の作業係数がわずかに増加することです. ただし、繰り返しになりますが、潜在的なキーの数は非常に少なく（攻撃者はキーを強制的に大きくすることはできません）、この手法は既にロールオーバーカウンターの管理に使用されているため、著者はこれを深刻な欠陥とは見なしていません. 

7.4. 復号化コスト
攻撃者は、正しく復号化されない表面上有効なSRTPパケットを送信することにより、受信者に計算コストを課すことができます. 一般的に、暗号化アルゴリズムは非常に高速であるため、消費される帯域幅と比較すると、このコストは非常に小さくなります. セクション5.1.2で説明されているSSRC-DTLSマッピングアルゴリズムは、攻撃者が受信者にパケットごとに複数回の復号化を実行させることができるため、攻撃者にわずかな利点をもたらします. ただし、受信者が行う復号化の数は、特定の宛先ホスト/ポートに対応する関連付けの数によって制限されるため、この利点は中程度です. 比較のために、単一の1024ビットRSA秘密鍵操作（DTLS-SRTPアソシエーションを確立するための一般的な最小コスト）は、SRTPパケットの暗号化解除の数百倍も高価です. 

実装は、未知のSSRCで観察され、認証タグチェックに失敗したSRTPパケットの数を追跡することにより、この形式の攻撃を検出できます. そのような攻撃を受けている場合、実装は、SSRCが既知であるか、DTLS-SRTPアソシエーションを持つピアの送信元アドレスと一致する送信元アドレスからのパケットの復号化と検証を優先する必要があります（SHOULD）. 

8. RTLS / SAVP over DTLSのセッションの説明
この仕様は、SDPメディア記述で使用されるプロトコルを記述するための新しいトークンを定義します（ "m ="行とその関連パラメーター）. protoフィールドに定義されている新しい値は次のとおりです. 

o RTP / SAVPまたはRTP / SAVPF [RFC5124]ストリームがデータグラム輻輳制御プロトコル（DCCP）でDTLSを介して転送される場合、トークンはそれぞれDCCP / TLS / RTP / SAVPまたはDCCP / TLS / RTP / SAVPFでなければなりません. 

o RTP / SAVPまたはRTP / SAVPFストリームがUDPを使用するDTLSを介して転送される場合、トークンはそれぞれUDP / TLS / RTP / SAVPまたはUDP / TLS / RTP / SAVPFでなければなりません. 

「fmt」パラメータは、RTP / SAVPに対して定義されたとおりである必要があります. 

DTLS-SRTPでオファー/アンサーを使用する方法については、[RFC5763]を参照してください. 

このドキュメントでは、TCPを介して転送されるRTPデータを保護する方法を指定していません. 可能性のあるアプローチには、RTP over TLS over TCP（[SRTP-NOT-MAND]を参照）またはTCPを介したこのドキュメントと同様のメカニズムの使用、TLSまたはDTLSのいずれかによる、信頼できるトランスポートと信頼できないトランスポート間の一貫性のためにDTLSを使用することが含まれます. 後者の場合、断片化と再送信が発生しないように、DTLSをプロファイルする必要があります. どちらの場合も、新しいドキュメントが必要になります. 

9. IANAに関する考慮事項
   このドキュメントは、DTLSの新しい拡張機能を追加します. 
   [RFC5246]：
        列挙型{use_srtp（14）} ExtensionType;
        
この拡張機能はDTLSでのみ使用する必要があり、TLS [RFC4572]では使用しないでください. これは、TLSをTCPで使用できるが、RTP / SAVPのTCPをアドレス指定しないことを指定します. 

セクション4.1.2では、すべてのSRTPProtectionProfile値がRFC 5226「Specification Required」で定義されている必要があります. IANAは、このドキュメントのセクション4.1.2の値を最初に入力したDTLS SRTPProtectionProfileレジストリを作成しました. 将来の値は、[RFC5226]の「Specification Required」プロファイルを介して割り当てる必要があります. 

この仕様は、[RFC4566]のセクション8.2.2で定義されている「セッション記述プロトコル（SDP）パラメータ」レジストリを更新します. 具体的には、次の値を「proto」フィールドのテーブルに追加します. 

           タイプSDP名の参照
           ---- ------------------ ---------
           proto UDP / TLS / RTP / SAVP [RFC5764]
           プロトDCCP / TLS / RTP / SAVP [RFC5764]
        
           プロトコルUDP / TLS / RTP / SAVPF [RFC5764]
           プロトDCCP / TLS / RTP / SAVPF [RFC5764]
        
IANAは、この仕様に対応するために、「EXTRACTOR-dtls_srtp」値をTLS Extractorラベルレジストリに登録しました. 

10.謝辞
入力、ディスカッション、およびガイダンスについて、Flemming Andreasen、Francois Audet、Pasi Eronen、Roni Even、Jason Fischl、Cullen Jennings、Colin Perkins、Dan Wing、およびBen Campbellに特に感謝します. Pasi Eronenは図1を提供しました. 

11.リファレンス
11.1 規範的な参考文献
[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

[RFC3711]バウアー、M. 、マクルー、D. 、ナスルンド、M. 、カララ、E. 、およびK.ノーマン、「Secure Real-time Transport Protocol（SRTP）」、RFC 3711、2004年3月. 

[RFC4347] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security」、RFC 4347、2006年4月. 

[RFC4961]ウィング、D. 、「対称RTP / RTP制御プロトコル（RTCP）」、BCP 131、RFC 4961、2007年7月. 

[RFC5246] Dierks、T. およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.2」、RFC 5246、2008年8月. 

[RFC5705] Rescorla、E. 、「トランスポート層セキュリティ（TLS）のキーマテリアルエクスポーター」、RFC 5705、2010年3月. 

[RFC5761] Perkins、C. およびM. Westerlund、「Multiplexing RTP Data and Control Packets on a Single Port」、RFC 5761、2010年4月. 

11.2 参考情報
[DTLS1.2] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security version 1.2」、Work in Progress、2009年10月. 

[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R. 、およびV. Jacobson、「RTP：A Transport Protocol for Real-Time Applications」、STD 64、RFC 3550、2003年7月. 

[RFC4566] Handley、M.、Jacobson、V. 、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、2006年7月. 

[RFC4572] Lennox、J. 、「Session Description Protocol（SDP）のトランスポート層セキュリティ（TLS）プロトコルを介した接続指向のメディアトランスポート」、RFC 4572、2006年7月. 

[RFC5124] Ott、J. およびE. Carrara、「リアルタイム転送制御プロトコル（RTCP）の拡張セキュアRTPプロファイル-ベースのフィードバック（RTP / SAVPF）」、RFC 5124、2008年2月. 

[RFC5226] Narten、T. およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 5226、2008年5月. 

[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P. 、およびD. Wing、「NAT用セッショントラバーサルユーティリティ（STUN）」、RFC 5389、2008年10月. 

[RFC5763] Fischl、J.、Tschofenig、H. 、およびE. Rescorla、「Datagram Transport Layer Security（DTLS）を使用したセキュアなリアルタイムトランスポートプロトコル（SRTP）セキュリティコンテキストを確立するためのフレームワーク」、RFC 5763、2010年5月. 

[SRTP-NOT-MAND] Perkins、C. およびM. Westerlund、「RTPが単一のセキュリティメカニズムを義務付けない理由」、2010年1月、進行中. 

付録A. DTLSの概要
このセクションでは、データグラムTLS（DTLS）について詳しくない方のために、概要を説明します. DTLSは、よく知られたTransport Layer Security（TLS）[RFC5246]プロトコルに基づくチャネルセキュリティプロトコルです. TLSが信頼できるトランスポートチャネル（通常はTCP）に依存している場合、DTLSはUDPなどの信頼できないトランスポートをサポートするように適合されています. それ以外の点では、DTLSはTLSとほぼ同じであり、通常は同じ暗号化メカニズムをサポートしています. 

各DTLSアソシエーションは、次に示すように、ピアが相互に認証し、アルゴリズム、モード、およびその他のパラメータをネゴシエートし、共有キー情報を確立するハンドシェイク交換（以下に示す）から始まります. 信頼できないトランスポートをサポートするために、各サイドは再送信タイマーを維持して、これらのメッセージの信頼できる配信を提供します. ハンドシェイクが完了すると、暗号化されたデータが送信されます. 

         Client                                               Server

         ClientHello                  -------->
                                                         ServerHello
                                                        Certificate*
                                                  ServerKeyExchange*
                                                 CertificateRequest*
                                      <--------      ServerHelloDone
         Certificate*
         ClientKeyExchange
         CertificateVerify*
         [ChangeCipherSpec]
         Finished                     -------->
                                                  [ChangeCipherSpec]
                                      <--------             Finished
         Application Data             <------->     Application Data

               '*' indicates messages that are not always sent.

        Figure 5: Basic DTLS Handshake Exchange (after [RFC4347]).

アプリケーションデータは、一連のDTLS「レコード」として送信されることにより保護されます. これらのレコードは独立しており、紛失や再注文があった場合でも正しく処理できます. DTLS-SRTPでは、このレコードプロトコルはSRTPに置き換えられます[RFC3711]

付録B.複数のDTLSハンドシェイクのパフォーマンス
インラインキー管理を行うTLS、DTLS、SSHなどのセキュリティプロトコルの標準的な方法は、基になるネットワークチャネル（TCP接続、UDPホスト/ポートカルテットなど）ごとに個別のセキュリティアソシエーションを作成することです. これには、各チャネルのセキュリティコンテキストが単純で独立しているという2つの利点があります. 

RTPセキュリティのコンテキストにおけるこの戦略のオーバーヘッドについて、3つの懸念が提起されています. 最初の問題は、チャネルごとに個別の公開鍵操作を実行することによる追加のパフォーマンスオーバーヘッドです. ここでの従来の手順（TLSおよびDTLSで使用されます）は、新しい関連付けの新しいトラフィックキーを導出するために使用できるマスターコンテキストを確立することです. TLS / DTLSでは、これは「セッション再開」と呼ばれ、ピア間で透過的にネゴシエートできます. 

2番目の問題は、後続の接続の確立と、既存の接続の（再キーイングのための）再ハンドシェイクのためのネットワーク帯域幅のオーバーヘッドです. 特に、チャネルは、再ハンドシェイクによってオーバーフローされるメディアに完全に割り当てられた非常に狭い容量要件を持っているという懸念があります. TLSでの（再開ありの）再ハンドシェイクのサイズの測定は、暗号スイートの完全な選択が提供されている場合、約300〜400バイトであることを示しています. （フルハンドシェイクのサイズは、証明書とキー情報の交換のため、約1〜2キロバイト大きくなります. ）

   3番目の問題は、関連する追加のラウンドトリップです. 
   2番目、3番目、...チャネルを確立します. TLS / DTLSでは、これらは
   すべてが並行して行われますが、セッションを利用するために
   最初のチャンネルが終わった後に再開する必要があります
   設立. 2つのチャネルの場合、これはラダー図を提供します
   このようなもの（括弧内の数字はメディアチャネル番号です）   
   
   Alice                                   Bob
   -------------------------------------------
                      <-       ClientHello (1)
   ServerHello (1)    ->
   Certificate (1)
   ServerHelloDone (1)
                      <- ClientKeyExchange (1)
                          ChangeCipherSpec (1)
                                  Finished (1)
   ChangeCipherSpec (1)->
   Finished         (1)->
                                                <--- Channel 1 ready

                      <-       ClientHello (2)
   ServerHello (2)    ->
   ChangeCipherSpec(2)->
   Finished(2)        ->
                      <-  ChangeCipherSpec (2)
                                  Finished (2)
                                                <--- Channel 2 ready

                Figure 6: Parallel DTLS-SRTP negotiations.

   したがって、チャネル1の後に1 RTT（往復時間）が追加されます. 
   チャネル2の準備が整う前に準備ができています. ピアが潜在的に
   再開を見越して、彼らは握手のようなインターレースをすることができます

   Alice                                   Bob
   -------------------------------------------
                      <-       ClientHello (1)
   ServerHello (1)    ->
   Certificate (1)
   ServerHelloDone (1)
                      <- ClientKeyExchange (1)
                          ChangeCipherSpec (1)
                                  Finished (1)
                      <-       ClientHello (2)
   ChangeCipherSpec (1)->
   Finished         (1)->
                                                <--- Channel 1 ready
   ServerHello (2)    ->
   ChangeCipherSpec(2)->
   Finished(2)        ->
                      <-  ChangeCipherSpec (2)
                                  Finished (2)
                                                <--- Channel 2 ready

               Figure 7: Interlaced DTLS-SRTP negotiations.

この場合、チャネルは同時に準備ができていますが、ハンドシェイク（1）のメッセージが失われた場合、ハンドシェイク（2）は完全な再ハンドシェイクを必要とするか、アリスが賢く、最初のハンドシェイクが完了するまで再開試行をキューに入れます. ボブは再送信するため、パケットをドロップするだけでも機能することに注意してください. 

著者のアドレス

David McGrew Cisco Systems 510 McCarthy Blvd. Milpitas、CA 95305 USA

メール：mcgrew@cisco.com

Eric Rescorla RTFM、Inc. 2064 Edgewood Drive Palo Alto、CA 94303 USA

メール：ekr@rtfm.com