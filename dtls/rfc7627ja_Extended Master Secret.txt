RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
7627
RFC 7627-トランスポート層セキュリティ（TLS）セッションハッシュとextended master secret拡張日本語
URL：https：//tools.ietf.org/html/rfc7627
パッケージ：RFC 7627-トランスポート層セキュリティ（TLS）セッションハッシュとextended master secret拡張
翻訳：自動翻訳
インターネットエンジニアリングタスクフォース（IETF）K. Bhargavan、Ed. 
コメントのリクエスト：7627 A. Delignat-Lavaud
更新：5246 A. Pironti
カテゴリ：標準化過程Inria Paris-Rocquencourt
ISSN：2070-1721A. ラングレー
                                                             Google Inc.
                                                                  M.レイ
                                                         Microsoft Corp.
                                                          2015年9月
        
トランスポート層セキュリティ（TLS）セッションハッシュとextended master secret拡張

概要

トランスポート層セキュリティ（TLS）master secretは、サーバー証明書などの重要なセッションパラメーターに暗号的にバインドされていません. その結果、アクティブな攻撃者が2つのセッションをセットアップする可能性があります. 1つはクライアントと、もう1つはサーバーと、2つのセッションのmaster secretが同じになるようにします. その後、セッションの再開など、認証にmaster secretに依存するメカニズムは、中間者攻撃に対して脆弱になります. この攻撃では、攻撃者はクライアントとサーバー間でメッセージを簡単に転送できます. この仕様は、master secretをそれを計算する完全なハンドシェイクのログにコンテキストでバインドするTLS拡張を定義し、そのような攻撃を防ぎます. 

このメモのステータス

これはインターネット標準化過程の文書です. 

このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です. これは、IETFコミュニティのコンセンサスを表しています. パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました. インターネット標準の詳細については、RFC5741のセクション2を参照してください. 

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc7627で入手できます. 

著作権表示

Copyright（c）2015 IETFTrustおよびドキュメントの作成者として特定された人物. 全著作権所有. 

このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます. 

目次

   1.はじめに...............................................  ..... 3
   2.要件表記........................................... 5
   3.TLSセッションハッシュ............................................ 5
   4.extended master secret...................................... 6
   5.延長交渉........................................... 6
      5.1. 拡張機能の定義....................................... 6
      5.2. クライアントとサーバーの動作：完全なハンドシェイク................. 7
      5.3. クライアントとサーバーの動作：短縮ハンドシェイク.......... 7
      5.4. 相互運用性に関する考慮事項............................ 9
   6.セキュリティに関する考慮事項......................................... 9
      6.1. トリプルハンドシェイクの前提条件と影響.................. 9
      6.2. ハッシュ関数の暗号化プロパティ............. 11
      6.3. セッションハッシュに含まれるハンドシェイクメッセージ........... 11
      6.4. SSL3.0サポートなし........................................ 12
   7.IANAの考慮事項............................................ 12
   8.参考文献...............................................  ...... 12
      8.1. 規範的参考文献...................................... 12
      8.2. 有益な参考資料.................................... 13
   謝辞.................................................  ..14
   著者のアドレス.........................................................  .15
        
1.はじめに
TLS [RFC5246]では、すべてのセッションに次のように計算される「master_secret」があります. 

   master_secret = PRF（pre_master_secret、 "master secret"、
                       ClientHello.random + ServerHello.random）
                       [0..47];
        
ここで、「pre_master_secret」はいくつかの鍵交換プロトコルの結果です. たとえば、ハンドシェイクがRSA暗号スイートを使用する場合、この値はクライアントによってランダムに均一に生成されますが、エフェメラルDiffie-Hellman（DHE）暗号スイートの場合、これはDiffie-Hellman鍵共有の結果です. 

[TRIPLE-HS]で説明されているように、RSAとDHEの両方の鍵交換で、アクティブな攻撃者は2つのTLSセッションを同期して、同じ「master_secret」を共有することができます. クライアントが認証されていないRSA鍵交換の場合、これは次のように実現されます. クライアントCがサーバーAに接続するとします. CはAが悪意のあるものであり、Aがバックグラウンドで正直なサーバーSに接続し、両方のハンドシェイクを完了することを認識していません. 簡単にするために、CとSはRSA暗号スイートのみを使用すると仮定します. 

1. Cは「ClientHello」をAに送信し、AはそれをSに転送します. 

2. Sは「ServerHello」をAに送信し、AはそれをCに転送します. 

3. Sは、証明書チェーンを含む「証明書」をAに送信します. Aはそれを独自の証明書チェーンに置き換えてCに送信します. 

4. Sは「ServerHelloDone」をAに送信し、AはそれをCに転送します. 

5. Cは、Aの公開鍵で暗号化された「pre_master_secret」を含む「ClientKeyExchange」をAに送信します. 復号化は「pre_master_secret」を復号化し、Sの公開鍵で再暗号化して、Sに送信します. 

6. Cは「Finished」をAに送信します. AはSとの接続について「Finished」を計算し、それをSに送信します. 

7. Sは「Finished」をAに送信します. AはCとの接続について「Finished」を計算し、それをCに送信します. 

この時点で、両方の接続（CとAの間、およびAとSの間）には、同じ「pre_master_secret」、「ClientHello.random」、「ServerHello.random」、およびその他のセッションパラメータを共有する新しいセッションがあります. セッション識別子と、オプションでセッションチケット. したがって、「master_secret」値は2つのセッションで等しくなり、2つの接続のサーバーIDが異なっていても、CとSの両方で同じセッションIDに関連付けられます. CはAの証明書のみを認識し、AとSの接続を認識しないことを思い出してください. さらに、2つの接続のレコードキーも同じになります. 

上記のシナリオは、TLSが、異なる接続で使用されるmaster secretとキーが異なることを保証しないことを示しています. クライアント認証が使用されている場合でも、2つのセッションがクライアントIDとサーバーIDの両方で異なることを除いて、シナリオは引き続き機能します. 

ハンドシェイクでDHE暗号スイートを使用すると、同様のシナリオを実現できます. クライアントまたはサーバーがRSAまたはDHEの使用を好まない場合でも、攻撃者はhelloメッセージでRSAまたはDHEのみを提供することにより、RSAまたはDHEの使用を強制できることに注意してください. Ephemeral Elliptic Curve Diffie-Hellman（ECDHE）暗号スイートを使用したハンドシェイクも、任意の明示的な曲線を許可したり、小さなサブグループの曲線を使用したりする場合に脆弱です. より強力な敵に対して、Secure Remote Password（SRP）やPre-Shared Key（PSK）などの他の鍵交換も脆弱であることが示されています[VERIFIED-BINDINGS]. 

Aが2つの接続を同期すると、キーは両側で同じであるため、離れてCとSの間でメッセージを透過的に転送し、必要に応じて読み取りと変更を行うことができます. 鍵交換の文献では、CとSが秘密を共有するため、このような発生は不明な鍵共有攻撃と呼ばれますが、どちらも秘密はAとのみ共有されると考えています. これらの攻撃自体は、正直な当事者間の整合性や機密性を損なうものではありません.  、ただし、CおよびSになりすまし攻撃を仕掛けるのに役立つ出発点を提供します. 

CがAとの新しい接続でセッションを再開しようとしたとします. 次に、Aは新しい接続でSとのセッションを再開し、CとSの間で変更されていない短縮ハンドシェイクメッセージを転送できます. 短縮ハンドシェイクは認証のためにmaster secretのみに依存するためまた、クライアントまたはサーバーのIDについては言及されていません. 両方のハンドシェイクが正常に完了し、同じセッションキーと同じハンドシェイクログが生成されます. Aはまだ接続キーを知っており、CとSの両方にメッセージを送信できます. 

重要なのは、新しい接続では、ハンドシェイクログでさえCとSで同じであるため、セキュアな再ネゴシエーション表示拡張[RFC5746]など、終了したメッセージの一意性に依存する中間者保護スキームを無効にすることです. またはTLSチャネルバインディング[RFC5929]. [TRIPLE-HS]は、このようなセッション同期攻撃に基づくいくつかのエクスプロイトについて説明しています. 特に、[RFC5746]の保護を回避して、セッション再開後にクライアント認証済みTLS再ネゴシエーションを中断する、「トリプルハンドシェイク」と呼ばれるman-in-the-middle攻撃について説明します. 同様の攻撃は、チャネルバインディング[RFC5929]またはTLSからエクスポートされたキーマテリアル[RFC5705]に依存するアプリケーションレベルの認証メカニズムに適用されます. 

これらの攻撃につながる根本的なプロトコルの問題は、TLSmaster secretが生成された完全なハンドシェイクにコンテキストバインドされていないため、セッション間で一意であることが保証されないことです. 最初のmaster secretの計算でこの問題を修正すれば、これらすべての攻撃を防ぐことができます. この仕様では、ハンドシェイクメッセージのログを含めることにより、フルハンドシェイクでの「master_secret」値の計算方法を変更するTLS拡張が導入されているため、構造上、異なるセッションが異なるmaster secretを持つことになります. これにより、[TRIPLE-HS]で説明され、[RFC7457]のセクション2.11で文書化されている攻撃が防止されます. 

2.要件表記
このドキュメントでは、TLSプロトコル仕様[RFC5246]で使用されているものと同じ表記法と用語を使用しています. 

キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」 "このドキュメントでは、RFC 2119 [RFC2119]で説明されているように解釈されます. 

3.TLSセッションハッシュ
完全なTLSハンドシェイクが行われると、次のように定義されます. 

         session_hash = Hash（handshake_messages）
        
ここで、「handshake_messages」は、ClientHelloから始まり、ClientKeyExchangeメッセージまで、ハンドシェイクメッセージのタイプフィールドと長さフィールドを含む、送受信されるすべてのハンドシェイクメッセージを指します. これは、[RFC5246]のセクション7.4で定義されているように、交換されたすべてのハンドシェイク構造の連結です. 

TLS 1.2の場合、「ハッシュ」関数は、[RFC5246]のセクション7.4.9で終了メッセージの計算用に定義されている関数です. 以前のすべてのバージョンのTLSの場合、「ハッシュ」関数はMD5とSHA1の連結を計算します. 

新しいセッションの作成につながらないため、再開されたハンドシェイクの「session_hash」はありません. 

4.The Extended master secret
extended master secret拡張がフルハンドシェイクでネゴシエートされると、「master_secret」は次のように計算されます. 

master_secret = PRF（pre_master_secret、 "extended master secret"、session_hash）[0..47];

extended master secretの計算は、[RFC5246]で説明されている計算と次の点で異なります. 

o「master secret」の代わりに「extended master secret」ラベルが使用されます. 

o「ClientHello.random」と「ServerHello.random」の代わりに「session_hash」が使用されます. 

「session_hash」は、「ClientHello.random」と「ServerHello.random」に加えて、暗号スイート、キー交換情報、およびクライアントとサーバーからの証明書（存在する場合）を含むハンドシェイクログに依存します. したがって、extended master secretは、これらすべてのセッションパラメータの選択に依存します. 

この設計は、キーを計算するセキュリティコンテキストにキーをバインドするという推奨事項を反映しています[SP800-108]. 鍵交換メッセージのハッシュをマスター鍵導出に混合する手法は、Secure Shell（SSH）[RFC4251]などの他のよく知られたプロトコルですでに使用されています. 

クライアントとサーバーは、extended master secretを使用しないハンドシェイクを受け入れるべきではありません. 特に、セクション6.1で説明されている脆弱なケースに該当する複合認証などの機能に依存している場合はそうです. 

5.Extension Negotiation
5.1. 拡張機能の定義
このドキュメントでは、新しいTLS拡張「extended_master_secret」（拡張タイプ0x0017）を定義します. これは、クライアントとサーバーの両方にextended master secret計算を使用するように通知するために使用されます. この拡張機能の「extension_data」フィールドは空です. したがって、拡張子のエンコード全体は00 17 00 00（16進数）です. 

このドキュメントはTLSのみに言及していますが、ここで提案されている拡張機能は、Datagram TLS（DTLS）[RFC6347]でも使用できます. 

クライアントとサーバーがこの拡張に同意し、完全なハンドシェイクが行われる場合、クライアントとサーバーの両方が、セクション4で定義されているextended master secret派生アルゴリズムを使用する必要があります. 他のすべての暗号計算は変更されません. 

5.2. クライアントとサーバーの動作：完全なハンドシェイク
以下では、致命的な「handshake_failure」アラートを送信してハンドシェイクを終了するための省略形として、「ハンドシェイクを中止する」というフレーズを使用します. 

すべてのハンドシェイクで、このドキュメントを実装するクライアントは、ClientHelloで「extended_master_secret」拡張機能を送信する必要があります. 

このドキュメントを実装するサーバーが「extended_master_secret」拡張子を受信した場合、ServerHelloメッセージにその拡張子を含める必要があります. 

ClientHelloとServerHelloの両方に拡張機能が含まれている場合、新しいセッションはextended master secret計算を使用します. 

サーバーが拡張機能のないClientHelloを受信した場合、レガシークライアントとの相互運用を望まない場合は、ハンドシェイクを中止する必要があります. ハンドシェイクを続行することを選択した場合、ServerHelloに拡張機能を含めてはなりません（MUSTNOT）. 

クライアントが拡張機能なしでServerHelloを受信した場合、レガシーサーバーとの相互運用を望まない場合は、ハンドシェイクを中止する必要があります. 

クライアントとサーバーが拡張機能なしで完全なハンドシェイクを続行することを選択した場合、新しいセッションには標準のmaster secret派生を使用する必要があります. この場合、新しいセッションは、このドキュメントで説明されているメカニズムによって保護されていません. したがって、実装者は、危険な使用シナリオを回避するために、セクション5.4のガイドラインに従う必要があります. 特に、新しいセッションから派生したmaster secretは、アプリケーションレベルの認証には使用しないでください. 

5.3. クライアントとサーバーの動作：簡略化されたハンドシェイク
クライアントは、extended master secretを使用しないセッションを再開するために短縮ハンドシェイクを提供するべきではありません（SHOULDNOT）. 代わりに、完全なハンドシェイクを提供する必要があります. 

クライアントが、レガシーの安全でない再開をサポートするために、そのようなセッションに対しても短縮ハンドシェイクを提供することを選択した場合、現在の接続はこのドキュメントのメカニズムによって保護されません. したがって、クライアントはセクション5.4のガイドラインに従う必要があります

危険な使用シナリオを回避するため. 特に、クライアントとサーバーが再ネゴシエーション表示拡張機能[RFC5746]をサポートしている場合でも、この接続では再ネゴシエーションは安全ではなくなります. 

短縮ハンドシェイクを提供する場合、クライアントはClientHelloで「extended_master_secret」拡張機能を送信する必要があります. 

サーバーが、既知の前のセッションを再開するための短縮ハンドシェイクオファリングのClientHelloを受信した場合、サーバーは次のように動作します. 

o元のセッションが「extended_master_secret」拡張機能を使用していなかったが、新しいClientHelloに拡張機能が含まれている場合、サーバーは省略されたハンドシェイクを実行してはなりません（MUSTNOT）. 代わりに、（セクション5.2で説明されているように）完全なハンドシェイクを続行して、新しいセッションをネゴシエートする必要があります. 

o元のセッションで「extended_master_secret」拡張機能が使用されていたが、新しいClientHelloに拡張機能が含まれていない場合、サーバーは省略されたハンドシェイクを中止する必要があります. 

o元のセッションも新しいClientHelloも拡張機能を使用しない場合、サーバーはハンドシェイクを中止する必要があります. 従来の安全でない再開をサポートするために簡略化されたハンドシェイクを続行する場合、接続はこのドキュメントのメカニズムによって保護されなくなり、サーバーはセクション5.4のガイドラインに従う必要があります. 

o新しいClientHelloに拡張機能が含まれていて、サーバーがハンドシェイクを続行することを選択した場合、サーバーはServerHelloメッセージに「extended_master_secret」拡張機能を含める必要があります. 

クライアントが短縮ハンドシェイクを受け入れるServerHelloを受信すると、次のように動作します. 

o元のセッションで「extended_master_secret」拡張機能が使用されていなかったが、新しいServerHelloに拡張機能が含まれている場合、クライアントはハンドシェイクを中止する必要があります. 

o元のセッションで拡張機能を使用したが、新しいServerHelloに拡張機能が含まれていない場合、クライアントはハンドシェイクを中止する必要があります. 

クライアントとサーバーが省略されたハンドシェイクを続行する場合、通常どおり、元のセッションのmaster secretから新しいセッションの接続キーを取得します. 

5.4. 相互運用性に関する考慮事項
レガシークライアントおよびサーバーとの相互運用性を可能にするために、TLSピアは、レガシーmaster secret計算を使用する完全なハンドシェイクを受け入れることを決定する場合があります. その場合、セッション状態にフラグを追加して、レガシーmaster secretとextended master secretを使用するセッションを区別する必要があります. 

クライアントまたはサーバーがextended master secret拡張なしで完全なハンドシェイクを続行することを選択した場合、新しいセッションはセクション1で説明されているman-in-the-middleキー同期攻撃に対して脆弱になります. したがって、クライアントまたはサーバーはしてはなりません. 後続のアプリケーションレベルの認証のために、新しいmaster secretに基づいてキーマテリアルをエクスポートします. 特に、[RFC5705]および複合認証[COMPOUND-AUTH]に依存するすべての拡張認証プロトコル（EAP）を無効にする必要があります. 

クライアントまたはサーバーが短縮ハンドシェイクを続行して、extended master secretを使用しないセッションを再開することを選択した場合、セクション1で説明したように、現在の接続は中間者ハンドシェイクログ同期攻撃に対して脆弱になります.  、クライアントまたはサーバーは、アプリケーションレベルの認証に現在のハンドシェイクの「verify_data」を使用してはなりません（MUSTNOT）. 特に、クライアントは、現在の接続での再ネゴシエーションと「tls-unique」チャネルバインディング[RFC5929]の使用を無効にする必要があります. 

元のセッションがextended master secretを使用しているが、短縮ハンドシェイクのClientHelloまたはServerHelloに拡張が含まれていない場合、元のセッションのextended master secretによって保護されているため、短縮ハンドシェイクを続行しても安全です. このシナリオは、たとえば、この拡張機能を実装するサーバーがセッションを確立したが、その後、拡張機能をサポートしていない別のサーバーでセッションが再開された場合に発生する可能性があります. このような状況は異常であり、一時的または不注意による設定ミスの結果である可能性が高いため、このドキュメントでは、クライアントとサーバーがこのようなハンドシェイクを中止する必要があることを推奨しています. 

6.セキュリティに関する考慮事項
6.1. トリプルハンドシェイクの前提条件と影響
トリプルハンドシェイク攻撃を実装する1つの方法は、攻撃によって破損するセキュリティメカニズムの説明とともに、セクション1で説明されています. より詳細な議論と図は[TRIPLE-HS]にあります. ここでは、攻撃の前提条件と影響についてさらに説明します. 

トリプルハンドシェイク攻撃を実装するには、2つの異なるセッションで同じmaster secretを強制できる必要があります. これを行うには、次の2つの前提条件を満たす必要があります. 

oクライアントCは、悪意のあるサーバーAに進んで接続する必要があります. Webなどの特定のコンテキストでは、信頼できない発信元からコンテンツをロードするようにブラウザーに指示できるため、これは簡単に実現できます. 

oプリmaster secretは2つのセッションで同期する必要があります. これは、RSAおよびDHEの鍵交換を使用すると特に簡単に実現できますが、状況によっては、ECDHE、SRP、およびPSKの鍵交換を利用してこの効果を得ることができます. 

master secretが2つのセッションで同期されると、master secretの一意性に依存するセキュリティプロパティが危険にさらされます. たとえば、TLSエクスポータ[RFC5705]は、現在のセッションにバインドされた一意のキーを提供しなくなりました. 

TLSセッションの再開は、再開するピアを認証するためにmaster secretの一意性にも依存します. したがって、同期されたセッションが再開された場合、ピアは互いのIDを確認できず、攻撃者は接続キーを認識します. 明らかに、攻撃のこのステップの前提条件は、クライアントとサーバーの両方がセッションの再開をサポートしていることです（セッション識別子またはセッションチケット[RFC5077]のいずれかを介して）. 

さらに、同期された省略ハンドシェイクでは、トランスクリプト全体（「verify_data」値を含む）が同期されます. したがって、簡略化されたハンドシェイクの後、「tls-unique」[RFC5929]のようなチャネルバインディングは、接続を一意に識別しなくなります. 

省略されたハンドシェイクでの「verify_data」の同期も、再ネゴシエーション表示拡張機能[RFC5746]のセキュリティ保証を損ない、再ネゴシエーション攻撃[Ray09]と同様のプレフィックスインジェクションの欠陥を再度有効にします. ただし、トリプルハンドシェイク攻撃では、クライアントはサーバー証明書が異なるフルハンドシェイク間で変化することを確認します. したがって、攻撃のこの段階を開始するための前提条件は、共通名が一致しない場合でも、クライアントがハンドシェイクごとに異なる証明書を受け入れることです. トリプルハンドシェイク攻撃が発見される前は、これは少なくとも一部のWebブラウザの間で広く行われていた動作でした. したがって、そのようなブラウザは攻撃に対して脆弱でした. 

拡張されたmaster secret拡張は、異なるセッションが必然的に異なるmaster secret値で終わることを保証することにより、最初の段階でトリプルハンドシェイク攻撃を阻止します. したがって、master secretの一意性に依存するすべてのセキュリティプロパティが保持されることが期待されます. 特に、TLSセッションがextended master secret拡張によって保護されている場合は、セッションを再開し、そのチャネルバインディングを使用し、再ネゴシエーション全体で証明書の変更を許可することが安全です. つまり、すべての証明書が同じピアによって制御されます. extended master secret拡張を正当化するシンボリック暗号プロトコル分析が[VERIFIED-BINDINGS]に表示されます. 

6.2. ハッシュ関数の暗号化プロパティ
2つの異なるセッションのセッションハッシュは区別する必要があります. したがって、「session_hash」の計算に使用される「Hash」関数は、衝突耐性が必要です. そのため、MD5やSHA1などのハッシュ関数は推奨されません. 

ハンドシェイクメッセージ（したがって「verify_data」）で意味のある衝突が発生する可能性があるため、終了メッセージの計算で使用される「ハッシュ」関数は、再ネゴシエーション表示拡張機能[RFC5746]が機能するためにすでに衝突耐性が必要であることがわかります.  -再ネゴシエーション攻撃を有効にします[Ray09]. 

セッションハッシュの計算に使用されるハッシュ関数は、TLSプロトコルのバージョンによって異なります. TLS 1.2用に定義されている現在のすべての暗号スイートはSHA256以上を使用しており、セッションハッシュも同様です. 以前のバージョンのプロトコルでは、MD5とSHA1のみがサポートされていると見なすことができ、このドキュメントでは、新しいハッシュ関数のサポートを追加するためのレガシー実装は必要ありません. これらのバージョンでは、セッションハッシュは、Finishedメッセージのように、MD5とSHA1の連結を使用します. 

6.3. セッションハッシュに含まれるハンドシェイクメッセージ
「session_hash」は、暗号スイートのネゴシエーション、キー交換メッセージ、クライアントとサーバーのIDなど、関連するすべてのセッション情報を網羅することを目的としています. ハッシュはextended master secretを計算するために必要であるため、Finishedメッセージの前に使用可能である必要があります. 

このドキュメントでは、ClientKeyExchangeまでのすべてのハンドシェイクメッセージをカバーするように「session_hash」を設定します. 既存のTLS暗号スイートの場合、これらのメッセージには新しいセッションのすべての重要なコンテンツが含まれます. CertificateVerifyはセッションコンテンツを変更しません. 同時に、これにより、extended master secretをプリmaster secretの直後に計算できるため、実装は一時的なプリmaster secretをメモリからできるだけ早く細断処理できます. 

新しい暗号スイートまたはTLS拡張には、重要なセッションコンテキストを追加するClientKeyExchangeとFinishedの間に追加のメッセージが含まれる可能性があります. このような場合、この仕様のセキュリティ保証の一部が適用されなくなり、新しいman-in-the-middle攻撃が発生する可能性があります. たとえば、クライアントとサーバーがセッションチケット拡張機能[RFC5077]をサポートしている場合、セッションハッシュはサーバーから送信された新しいセッションチケットをカバーしません. したがって、man-in-the-middleは、クライアントに現在のセッション用ではないセッションチケットを保存させることができる場合があります. このベクトルに基づく攻撃はまだわかっていませんが、セッションハッシュでカバーされている情報以外の追加情報をセッションチケットに保存するアプリケーションでは、注意深い分析が必要です. 

6.4. SSL3.0サポートなし
Secure Sockets Layer（SSL）プロトコルバージョン3.0 [RFC6101]はTLSプロトコルの前身であり、現在は弱いと見なされている廃止された暗号構造の使用に起因する他の脆弱性とともに、トリプルハンドシェイク攻撃に対しても同様に脆弱です. SSL3.0は非推奨になりました[RFC7568]. 

このドキュメントで説明されている対策はTLS拡張に依存しているため、SSL3.0では使用できません. このドキュメントを実装するクライアントとサーバーは、SSL3.0ハンドシェイクを拒否する必要があります. SSL 3.0をサポートすることを選択した場合、結果のセッションはレガシーmaster secret計算を使用する必要があり、セクション5.4の相互運用性の考慮事項が適用されます. 

7.IANAの考慮事項
IANAは、プロトタイプ実装で使用されている拡張コードポイント23（0x0017）を、TLS仕様[RFC5246]で指定されている「ExtensionTypeValues」レジストリに「extended_master_secret」拡張用に追加しました. 

8.参考文献
8.1. 規範的参考文献
[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>. 

[RFC5246] Dierks、T. およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / rfc5246>. 

8.2. 有益な参考文献
[COMPOUND-AUTH] Asokan、N.、Valtteri、N. 、およびK. Nyberg、「Man-in-the-Middle in Tunneled Authentication Protocols」、Security Protocols、LNCS、Volume 3364、DOI 10.1007 / 11542322_6、2005. 

[Ray09] Ray、M. 、「TLS再ネゴシエーションにおける認証ギャップ」、2009年. 

[RFC4251] Ylonen、T. およびC. Lonvick、Ed. 、「The Secure Shell（SSH）Protocol Architecture」、RFC 4251、DOI 10.17487 / RFC4251、2006年1月、<http://www.rfc-editor.org/ info / rfc4251>. 

[RFC5077] Salowey、J.、Zhou、H.、Eronen、P. 、およびH. Tschofenig、「サーバー側の状態のないトランスポート層セキュリティ（TLS）セッション再開」、RFC 5077、DOI 10.17487 / RFC5077、2008年1月、 <http://www.rfc-editor.org/info/rfc5077>. 

[RFC5705] Rescorla、E. 、「Keying Material Exporters for Transport Layer Security（TLS）」、RFC 5705、DOI 10.17487 / RFC5705、2010年3月、<http://www.rfc-editor.org/info/rfc5705>. 

[RFC5746] Rescorla、E.、Ray、M.、Dispensa、S. 、およびN. Oskov、「Transport Layer Security（TLS）Renegotiation Indication Extension」、RFC 5746、DOI 10.17487 / RFC5746、2010年2月、<http：/ /www.rfc-editor.org/info/rfc5746>. 

[RFC5929] Altman、J.、Williams、N. 、およびL. Zhu、「TLSのチャネルバインディング」、RFC 5929、DOI 10.17487 / RFC5929、2010年7月、<http://www.rfc-editor.org/info / rfc5929>. 

[RFC6101] Freier、A.、Karlton、P. 、およびP. Kocher、「The Secure Sockets Layer（SSL）Protocol Version 3.0」、RFC 6101、DOI 10.17487 / RFC6101、2011年8月、<http：//www.rfc -editor.org/info/rfc6101>. 

[RFC6347] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<http://www.rfc-editor.org/info/rfc6347>. 

[RFC7457] Sheffer、Y.、Holz、R. 、およびP. Saint-Andre、「トランスポート層セキュリティ（TLS）およびデータグラムTLS（DTLS）に対する既知の攻撃の要約」、RFC 7457、DOI 10.17487 / RFC7457、2015年2月、 <http://www.rfc-editor.org/info/rfc7457>. 

[RFC7568] Barnes、R.、Thomson、M.、Pironti、A. 、およびA. Langley、「Deprecating Secure Sockets Layer Version 3.0」、RFC 7568、DOI 10.17487 / RFC7568、2015年6月、<http：// www.  rfc-editor.org/info/rfc7568>. 

[SP800-108] Chen、L. 、「疑似乱数関数を使用した鍵導出の推奨事項（改訂）」、NIST Special Publication 800-108、2009年. 

[TRIPLE-HS] Bhargavan、K.、Delignat-Lavaud、A.、Fournet、C.、Pironti、A. 、およびPY. Strub、「Triple Handshakes and Cookie Cutters：Breaking and Fixing Authentication over TLS」、IEEE Symposium on Security and Privacy、DOI 10.1109 / SP.2014.14、2014. 

[検証済みのバインディング] Bhargavan、K.、Delignat-Lavaud、A. 、およびA. Pironti、「複合認証のための検証済みコントリビューティブチャネルバインディング」、ネットワークおよび分散システムセキュリティシンポジウム（NDSS）、2015年. 

謝辞

トリプルハンドシェイク攻撃は、もともとAntoine Delignat-Lavaud、Karthikeyan Bhargavan、およびAlfredoPirontiによって発見されました. それらはmiTLSチームによってさらに開発されました：Cedric Fournet、Pierre-Yves Strub、Markulf Kohlweiss、およびSantiagoZanella-Beguelin. このドキュメントのアイデアの多くは、Martin Abadi、Ben Laurie、Nikos Mavrogiannopoulos、Manuel Pegourie-Gonnard、Eric Rescorla、Martin Rex、およびBrianSmithとの話し合いから生まれました. 

著者の住所

Karthikeyan Bhargavan（編集者）Inria Paris-Rocquencourt 23、Avenue d'Italie Paris 75214 CEDEX 13 France

   Eメール：karthikeyan.bhargavan@inria.fr
        
Antoine Delignat-Lavaud Inria Paris-Rocquencourt 23、Avenue d'Italie Paris 75214 CEDEX13フランス

   Eメール：antoine.delignat-lavaud@inria.fr
        
Alfredo Pironti Inria Paris-Rocquencourt 23、Avenue d'Italie Paris 75214 CEDEX13フランス

   Eメール：alfredo.pironti@inria.fr
        
Adam Langley Google Inc. 1600 Amphitheatre Parkway Mountain View、CA 94043 United States

   メール：agl@google.com
        
Marsh Ray Microsoft Corp. 1 Microsoft Way Redmond、WA98052アメリカ合衆国

   Eメール：maray@microsoft.com
        