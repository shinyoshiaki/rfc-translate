Datagram Transport Layer Securityバージョン1.2 

概要 

このドキュメントでは、Datagram Transport Layer Security（DTLS）プロトコルのバージョン1.2を指定しています. DTLSプロトコルは、データグラムプロトコルの通信プライバシーを提供します. このプロトコルにより、クライアント/サーバーアプリケーションは、盗聴、改ざん、またはメッセージの偽造を防ぐように設計された方法で通信できます. DTLSプロトコルは、トランスポート層セキュリティ（TLS）プロトコルに基づいており、同等のセキュリティ保証を提供します. 基礎となるトランスポートのデータグラムセマンティクスは、DTLSプロトコルによって保持されます. このドキュメントは、TLSバージョン1.2で動作するようにDTLS 1.0を更新します. 

このドキュメントは、Internet Engineering Task Force（IETF）の製品です. IETFコミュニティのコンセンサスを表しています. これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています. インターネット標準の詳細については、RFC 5741のセクション2を参照してください. 

このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、http：//www.rfc-editor.org/info/rfc6347で入手できます.  

著作権表示 

Copyright（c）2012 IETF Trustおよび文書の著者として特定された人物. 全著作権所有. 

このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます. 

このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFコントリビューションの資料が含まれている場合があります. この資料の一部の著作権を管理する人は、IETFトラストにそのような資料の変更を許可する権利を付与していないIETF標準プロセスの外部. そのような資料の著作権を管理する人から適切なライセンスを取得しないと、このドキュメントはIETF標準プロセスの外で修正されず、その派生物はIETF標準プロセスの外で作成されます.  RFCとしての公開、または英語以外の言語への翻訳. 

Table of Contents

   1. Introduction ....................................................4
      1.1. Requirements Terminology ...................................5
   2. Usage Model .....................................................5
   3. Overview of DTLS ................................................5
      3.1. Loss-Insensitive Messaging .................................6
      3.2. Providing Reliability for Handshake ........................6
           3.2.1. Packet Loss .........................................6
           3.2.2. Reordering ..........................................7
           3.2.3. Message Size ........................................7
      3.3. Replay Detection ...........................................7
   4. Differences from TLS ............................................7
      4.1. Record Layer ...............................................8
           4.1.1. Transport Layer Mapping ............................10
                  4.1.1.1. PMTU Issues ...............................10
           4.1.2. Record Payload Protection ..........................12
                  4.1.2.1. MAC .......................................12
                  4.1.2.2. Null or Standard Stream Cipher ............13
                  4.1.2.3. Block Cipher ..............................13
                  4.1.2.4. AEAD Ciphers ..............................13
                  4.1.2.5. New Cipher Suites .........................13
                  4.1.2.6. Anti-Replay ...............................13
                  4.1.2.7. Handling Invalid Records ..................14
      4.2. The DTLS Handshake Protocol ...............................14
           4.2.1. Denial-of-Service Countermeasures ..................15
           4.2.2. Handshake Message Format ...........................18
           4.2.3. Handshake Message Fragmentation and Reassembly .....19
           4.2.4. Timeout and Retransmission .........................20
                  4.2.4.1. Timer Values ..............................24
           4.2.5. ChangeCipherSpec ...................................25
           4.2.6. CertificateVerify and Finished Messages ............25
           4.2.7. Alert Messages .....................................25
           4.2.8. Establishing New Associations with Existing
                  Parameters .........................................25
      4.3. Summary of New Syntax .....................................26
           4.3.1. Record Layer .......................................26
           4.3.2. Handshake Protocol .................................27
   5. Security Considerations ........................................27
   6. Acknowledgments ................................................28
   7. IANA Considerations ............................................28
   8. Changes since DTLS 1.0 .........................................29
   9. References .....................................................30
      9.1. Normative References ......................................30
      9.2. Informative References ....................................31

1.はじめに 

TLS [TLS]は、ネットワークトラフィックを保護するために最も広く導入されているプロトコルです. Webトラフィックの保護や、IMAP [IMAP]やPOP [POP]などの電子メールプロトコルで広く使用されています. TLSの主な利点は、透過的な接続指向のチャネルを提供することです. したがって、アプリケーション層とトランスポート層の間にTLSを挿入することにより、アプリケーションプロトコルを簡単に保護できます. ただし、TLSは信頼できるトランスポートチャネル（通常はTCP [TCP]）で実行する必要があります. したがって、信頼性の低いデータグラムトラフィックを保護するために使用することはできません. 

UDPトランスポートを使用するアプリケーション層プロトコルの設計が増えています. 特に、セッション開始プロトコル（SIP）[SIP]や電子ゲームプロトコルなどのプロトコルの人気が高まっています. （SIPはTCPとUDPの両方で実行できますが、UDPが望ましい状況があることに注意してください. ）現在、これらのアプリケーションの設計者は多くの不満足な選択に直面しています. まず、IPsec [RFC4301]を使用できます. ただし、[WHYIPSEC]で詳述されているいくつかの理由により、これは一部のアプリケーションにのみ適しています. 次に、カスタムアプリケーションレイヤーセキュリティプロトコルを設計できます. 残念ながら、アプリケーション層のセキュリティプロトコルは一般に優れたセキュリティプロパティ（たとえば、S / MIMEの場合のエンドツーエンドのセキュリティ）を提供しますが、

多くの場合、クライアント/サーバーアプリケーションを保護する最も望ましい方法はTLSを使用することです. ただし、データグラムセマンティクスの要件により、TLSの使用は自動的に禁止されます. このメモでは、この目的のプロトコルであるデータグラムトランスポート層セキュリティ（DTLS）について説明します. DTLSは、新しいセキュリティの発明を最小限に抑え、コードとインフラストラクチャの再利用の量を最大限にするために、TLSに可能な限り類似するように意図的に設計されています. 

DTLS 1.0 [DTLS1]は、元々[TLS11]からのデルタとして定義されていました. このドキュメントは、TLS 1.2 [TLS12]への一連のデルタとして定義されるDTLSの新しいバージョン、DTLS 1.2を紹介します. DTLS 1.1はありません. バージョン番号をTLSと調和させるために、そのバージョン番号はスキップされました. このバージョンでは、DTLS 1.0仕様のいくつかの紛らわしい点も明確にしています. 

TLS 1.2実装がTLSの以前のバージョンと相互運用できるように、DTLS 1.2とDTLS 1.0の両方を話す実装は、DTLS 1.0のみを話す実装と相互運用できます（もちろんDTLS 1.0を使用）（詳細については[TLS12]の付録E.1を参照） ）、ただしSSLv2またはSSLv3のDTLSバージョンがないため、これらのプロトコルの下位互換性の問題は適用されません. 1.1. 要件の用語

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」はRFC 2119 [REQ]で説明されているように解釈されます.  

2.使用モデル 

DTLSプロトコルは、通信するアプリケーション間でデータを保護するように設計されています. カーネルの変更を必要とせずに、アプリケーション空間で実行するように設計されています. 

データグラム転送では、データの信頼性の高い配信または順序どおりの配信は必要ありません. DTLSプロトコルは、ペイロードデータのこのプロパティを保持します. メディアストリーミング、インターネットテレフォニー、オンラインゲームなどのアプリケーションは、転送データの遅延に敏感な性質のため、通信にデータグラム転送を使用します. DTLSプロトコルはデータトラフィックの損失や並べ替えを補正しないため、DTLSプロトコルを使用して通信を保護しても、このようなアプリケーションの動作は変わりません. 

3. DTLSの概要 

DTLSの基本的な設計哲学は、「データグラム転送を介したTLS」を構築することです. TLSをデータグラム環境で直接使用できない理由は、パケットが失われたり並べ替えられたりする可能性があるためです. TLSには、この種の信頼性を処理するための内部機能はありません. したがって、TLS実装は、データグラムトランスポートでホストし直されたときに破損します. DTLSの目的は、この問題の修正に必要なTLSへの最小限の変更のみを行うことです. 可能な限り、DTLSはTLSと同一です. 新しいメカニズムを発明する必要があるときはいつでも、TLSのスタイルを維持するような方法でそれを試みます. 

信頼性が低いと、TLSの問題が2つのレベルで発生します.  

1. TLSは、個々のレコードの独立した復号化を許可しません. 整合性チェックはシーケンス番号に依存するため、レコードNが受信されない場合、レコードN + 1の整合性チェックは誤ったシーケンス番号に基づいて失敗します. （TLS 1.1より前は明示的なIVがなかったため、復号化も失敗することに注意してください. ）

2. TLSハンドシェイクレイヤーは、ハンドシェイクメッセージが確実に配信されると想定し、それらのメッセージが失われると中断します.  

このセクションの残りの部分では、DTLSがこれらの問題を解決するために使用するアプローチについて説明します. 

3.1. ロスインセンシティブメッセージング

TLSのトラフィック暗号化レイヤー（TLSレコードレイヤーと呼ばれる）では、レコードは独立していません. レコード間の依存関係には2種類あります. 

1.暗号化コンテキスト（ストリーム暗号キーストリーム）はレコード間で保持されます.  

2.アンチリプレイおよびメッセージ並べ替え保護は、シーケンス番号を含むMACによって提供されますが、シーケンス番号はレコードに暗黙的に含まれます.  

DTLSは、ストリーム暗号を禁止することで最初の問題を解決します. DTLSは、明示的なシーケンス番号を追加することにより、2番目の問題を解決します. 

3.2. ハンドシェイクの信頼性を提供する

TLSハンドシェイクは、ロックステップ暗号化ハンドシェイクです. メッセージは、定義された順序で送受信する必要があります. 他の順序はエラーです. 明らかに、これは並べ替えやメッセージの損失と互換性がありません. さらに、TLSハンドシェイクメッセージは特定のデータグラムよりも大きくなる可能性があるため、IPフラグメンテーションの問題が発生します. DTLSは、これらの問題の両方に対する修正を提供する必要があります. 

3.2.1. パケットロス

DTLSは、単純な再送信タイマーを使用してパケット損失を処理します. 次の図は、DTLSハンドシェイクの最初のフェーズを使用した基本概念を示しています. 

         Client                                   Server
         ------                                   ------
         ClientHello           ------>

                                 X<-- HelloVerifyRequest
                                                  (lost)

         [Timer Expires]

         ClientHello           ------>
         (retransmit)

クライアントがClientHelloメッセージを送信すると、サーバーからHelloVerifyRequestが表示されることを期待します. ただし、サーバーのメッセージが失われた場合、クライアントはClientHelloまたはHelloVerifyRequestのいずれかが失われたことを認識し、再送信します. サーバーは再送信を受信すると、再送信することを認識します. サーバーは再送信タイマーも維持し、そのタイマーが期限切れになると再送信します. 

サーバーで状態を作成する必要があるため、タイムアウトと再送信はHelloVerifyRequestには適用されないことに注意してください. HelloVerifyRequestは、それ自体が断片化されないように十分に小さく設計されているため、複数のHelloVerifyRequestをインターリーブする心配がありません. 

3.2.2.  Reordering

DTLSでは、各ハンドシェイクメッセージには、そのハンドシェイク内の特定のシーケンス番号が割り当てられます. ピアは、ハンドシェイクメッセージを受信すると、そのメッセージが予想される次のメッセージであるかどうかをすばやく判断できます. 存在する場合、処理します. そうでない場合は、以前のメッセージがすべて受信されると、将来の処理のためにキューに入れられます. 

3.2.3. メッセージサイズ

TLSおよびDTLSハンドシェイクメッセージは非常に大きくなる可能性があります（理論上は最大2 ^ 24-1バイト、実際には数キロバイト）. 対照的に、IPフラグメンテーションが望ましくない場合、UDPデータグラムは多くの場合<1500バイトに制限されます. この制限を補うために、各DTLSハンドシェイクメッセージは、それぞれが単一のIPデータグラムに収まるように意図された複数のDTLSレコードに分割される場合があります. 各DTLSハンドシェイクメッセージには、フラグメントオフセットとフラグメント長の両方が含まれています. したがって、ハンドシェイクメッセージのすべてのバイトを所有している受信者は、元の断片化されていないメッセージを再構築できます. 

3.3. リプレイ検出

DTLSは、オプションでレコード再生検出をサポートしています. 使用される手法は、受信したレコードのビットマップウィンドウを維持することにより、IPsec AH / ESPと同じです. ウィンドウに収まらないほど古いレコードや、以前に受信したレコードは、静かに破棄されます. パケットの重複は常に悪意があるわけではなく、ルーティングエラーが原因で発生する可能性があるため、リプレイ検出機能はオプションです. アプリケーションは重複パケットを検出し、それに応じてデータ送信戦略を変更する可能性があります. 

4. TLSとの違い 

セクション3で述べたように、DTLSは意図的にTLSに非常に似ています. したがって、DTLSを新しいプロトコルとして提示する代わりに、TLS 1.2 [TLS12]からの一連のデルタとして提示します. 明示的に違いを指摘しない場合、DTLSは[TLS12]と同じです. 

4.1.  Record Layer

DTLSレコードレイヤは、TLS 1.2のレイヤと非常に似ています. 唯一の変更点は、レコードに明示的なシーケンス番号を含めることです. このシーケンス番号により、受信者はTLS MACを正しく検証できます. DTLSレコード形式は次のとおりです. 

      struct {
           ContentType type;
           ProtocolVersion version;
           uint16 epoch;                                    // New field
           uint48 sequence_number;                          // New field
           uint16 length;
           opaque fragment[DTLSPlaintext.length];
         } DTLSPlaintext;

type TLS 1.2レコードのtypeフィールドに相当します.  

version使用されているプロトコルのバージョン. このドキュメントでは、バージョン{254、253}を使用するDTLSバージョン1.2について説明します. 254.253のバージョン値は、DTLSバージョン1.2の1の補数です. TLSとDTLSのバージョン番号間の最大間隔により、2つのプロトコルのレコードを簡単に区別できます. DTLSの将来のオンザワイヤバージョン番号の値は減少していることに注意してください（実際のバージョン番号の値は増加しています）. 

エポック暗号状態が変更されるたびに増分されるカウンター値.  

sequence_numberこのレコードのシーケンス番号.  

length TLS 1.2レコードの長さフィールドと同じです. TLS 1.2と同様に、長さは2 ^ 14を超えてはなりません. 

fragment TLS 1.2レコードのfragmentフィールドと同じです.  

DTLSは、レコードのsequence_numberフィールドで運ばれる暗黙の番号ではなく、明示的なシーケンス番号を使用します. シーケンス番号はエポックごとに個別に維持され、各エポックの最初のシーケンス番号は0です. たとえば、エポック0からのハンドシェイクメッセージが再送信されると、エポック1からのメッセージが最初に送信された場合でも、エポック1からのメッセージの後にシーケンス番号が付けられる場合があります. 再送信されたメッセージが正しいエポックとキーイングマテリアルを使用することを保証するために、ハンドシェイク中にいくつかの注意が必要であることに注意してください. 

複数のハンドシェイクが連続して実行される場合、同じシーケンス番号で異なる暗号状態からの複数のレコードがワイヤ上に存在する可能性があります. エポックフィールドにより、受信者はそのようなパケットを区別できます. エポック番号は最初はゼロであり、ChangeCipherSpecメッセージが送信されるたびに増分されます. 与えられたシーケンス/エポックのペアが一意であることを保証するために、実装はTCPの最大セグメント有効期間の2倍以内に同じエポック値を再利用することを許可してはなりません. 実際には、TLS実装はほとんど再ハンドシェイクしません. したがって、これが問題になるとは考えていません. 

DTLSレコードは並べ替えられる可能性があるため、エポック1からのレコードは、エポック2の開始後に受信される可能性があることに注意してください. 一般に、実装は以前のエポックからのパケットを破棄すべきである（SHOULD）が、パケットの損失が顕著な問題を引き起こす場合、TCP [TCP]に指定されたデフォルトのMSLまで以前のエポックからのキー情報を保持してパケットの並べ替えを可能にすることを選択してもよい（MAY）. （ここでの意図は、実装者がシステムTCPスタックが使用しているMSLに問い合わせようとするのではなく、MSLのIETFからの現在のガイダンスを使用することです. ）ハンドシェイクが完了するまで、実装は古いエポックからのパケットを受け入れなければなりません. 

逆に、新しくネゴシエートされたコンテキストによって保護されているレコードは、ハンドシェイクの完了前に受信される可能性があります. たとえば、サーバーはFinishedメッセージを送信してから、データの送信を開始できます. 実装は、このようなパケットをバッファリングまたは破棄できますが、DTLSが信頼できるトランスポート（SCTPなど）で使用される場合、ハンドシェイクが完了したらバッファリングして処理する必要があります（SHOULD）. パケットを送信できるタイミングに関するTLSの制限は引き続き適用され、受信者はパケットを正しい順序で送信したかのように扱うことに注意してください. 特に、最初のハンドシェイクが完了する前にデータを送信することは依然として許可されていません. 

既存のアソシエーションでの再ハンドシェイクの特殊なケースでは、再ハンドシェイクが既存のセッションを再開するか、正確に使用する場合、ChangeCipherSpecまたはFinishedメッセージがまだ受信されていない場合でも、データパケットをすぐに処理しても安全です. 既存の関連付けと同じセキュリティパラメータ. それ以外の場合、実装は、ダウングレード攻撃を防ぐためにFinishedメッセージの受信を待つ必要があります. 

TLSの場合と同様に、実装はシーケンス番号のラップを許可する前にアソシエーションを放棄するか、再ハンドシェイクする必要があります. 同様に、実装はエポックのラップを許可してはならず、代わりにセクション4.2.8で説明されているように古いアソシエーションを終了して、新しいアソシエーションを確立する必要があります. 実際には、実装が同じチャネルで繰り返し再ハンドシェークを行うことはめったにないため、これが問題になることはほとんどありません. 

4.1.1. トランスポート層マッピング

各DTLSレコードは、単一のデータグラム内に収まらなければなりません. IPフラグメンテーションを回避するために、DTLSレコードレイヤーのクライアントは、レコードレイヤーから取得したPMTU推定値に収まるようにレコードのサイズを設定する必要があります. 

IPsecとは異なり、DTLSレコードには関連付け識別子が含まれないことに注意してください. アプリケーションは、関連付け間で多重化するように調整する必要があります. UDPでは、これはおそらくホスト/ポート番号で行われます. 

1つのデータグラムに複数のDTLSレコードを配置できます. それらは単に連続してエンコードされます. DTLSレコードのフレーミングは、境界を決定するのに十分です. ただし、データグラムペイロードの最初のバイトはレコードの先頭でなければならないことに注意してください. レコードはデータグラムにまたがることはできません. 

DCCP [DCCP]などの一部のトランスポートは、独自のシーケンス番号を提供します. それらのトランスポートを介して運ばれると、DTLSとトランスポートシーケンス番号の両方が存在します. これにより少量の非効率性が生じますが、トランスポート層とDTLSシーケンス番号は異なる目的に使用されます. したがって、概念を簡単にするために、両方のシーケンス番号を使用することをお勧めします. 将来、制約された環境での展開にシーケンス番号の1つのセットのみの使用を許可するDTLSの拡張が指定される可能性があります. 

DCCPなどの一部のトランスポートは、伝送されるトラフィックの輻輳制御を提供します. 輻輳ウィンドウが十分に狭い場合、DTLSハンドシェイクの再送信はすぐに送信されるのではなく保持される可能性があり、タイムアウトとスプリアス再送信につながる可能性があります. このようなトランスポートでDTLSを使用する場合、可能性のある輻輳ウィンドウをオーバーランしないように注意する必要があります. [DCCPDTLS]は、これらの問題を考慮したDTLSのDCCPへのマッピングを定義します. 

4.1.1.1. PMTUの問題

一般に、DTLSの哲学は、PMTUの発見をアプリケーションに任せることです. ただし、DTLSは次の3つの理由でPMTUを完全に無視することはできません. -DTLSレコードフレーミングは、データグラムサイズを拡大し、アプリケーションの観点から有効なPMTUを低下させます. 

-実装によっては、アプリケーションがネットワークと直接通信しない場合があります. その場合、DTLSスタックはICMP [RFC1191] "Datagram Too Big"表示またはICMPv6 [RFC4443] "Packet Too Big"表示を吸収する場合があります.  

-DTLSハンドシェイクメッセージがPMTUを超える可能性があります.  

最初の2つの問題に対処するために、DTLSレコードレイヤーは以下のように動作する必要があります.  

基礎となるトランスポートプロトコルからPMTUの推定値が利用可能な場合、上位層のプロトコルで利用可能にする必要があります. 特に：

-DTLS over UDPの場合、上位層プロトコルは、IP層で維持されているPMTU推定値を取得できる必要があります.  

-DTLS over DCCPの場合、上位層プロトコルはPMTUの現在の推定値を取得できる必要があります.  

-データグラムを自動的にフラグメント化および再構成するDTLS over TCPまたはSCTPの場合、PMTUの制限はありません. ただし、上位層プロトコルは、最大レコードサイズ2 ^ 14バイトを超えるレコードを書き込まないでください. 

DTLSレコードレイヤーは、上位レイヤープロトコルがDTLS処理で予想されるレコード拡張の量を検出できるようにする必要があります. この数値は、ブロックパディングとDTLS圧縮の潜在的な使用のための推定値にすぎないことに注意してください. 

トランスポートプロトコルの表示がある場合（ICMPまたは[DCCP]のセクション14のようにデータグラムの送信拒否を介して）、DTLSレコード層は上位層プロトコルにエラーを通知しなければなりません（MUST）.  

DTLSレコード層は、[RFC1191]または[RFC4821]メカニズムを介してPMTUディスカバリを実行する上位層プロトコルと干渉すべきではありません（SHOULD NOT）. 特に：

-基礎となるトランスポートプロトコルで許可されている場合、上位層プロトコルは、DFビットの状態の設定（IPv4の場合）またはローカルフラグメンテーションの禁止（IPv6の場合）を許可する必要があります.  

-基礎となるトランスポートプロトコルでアプリケーションがPMTUプロービング（DCCPなど）を要求できる場合、DTLSレコードレイヤーはこの要求を尊重する必要があります. 最後の問題は、DTLSハンドシェイクプロトコルです. DTLSレコード層の観点から見ると、これは単なる別の上位層プロトコルです. ただし、DTLSハンドシェイクはまれにしか発生せず、数回のラウンドトリップしか含まれません. したがって、ハンドシェイクプロトコルのPMTU処理では、正確なPMTUディスカバリーよりも迅速な完了が重視されます. これらの状況下で接続を許可するために、DTLS実装は次の規則に従う必要があります. 

-DTLSレコードレイヤーがメッセージが大きすぎることをDTLSハンドシェイクレイヤーに通知する場合、PMTUに関する既存の情報を使用して、すぐにフラグメント化を試行する必要があります.  

-再送が繰り返されても応答が返されず、PMTUが不明な場合、後続の再送は、必要に応じてハンドシェイクメッセージを断片化し、より小さいレコードサイズに戻す必要があります. この標準では、バックオフする前に試行する再送信の正確な数は指定されていませんが、2〜3が適切と思われます. 

4.1.2.  Record Payload Protection

TLSと同様に、DTLSは一連の保護されたレコードとしてデータを送信します. このセクションの残りの部分では、その形式の詳細について説明します. 

4.1.2.1. マック

DTLS MACはTLS 1.2と同じです. ただし、TLSの暗黙のシーケンス番号を使用するのではなく、MACの計算に使用されるシーケンス番号は、エポックとシーケンス番号をワイヤに表示される順序で連結することによって形成される64ビット値です. DTLSエポック+シーケンス番号は、TLSシーケンス番号と同じ長さであることに注意してください. 

TLS MAC計算は、プロトコルバージョン番号でパラメーター化されます. これは、DTLSの場合、オンワイヤバージョン、つまりDTLS 1.2の{254、253}です.  

DTLSとTLS MAC処理の重要な違いの1つは、TLSではMACエラーが接続の終了をもたらす必要があることに注意してください. DTLSでは、受信側の実装は問題のあるレコードを単に破棄し、接続を続行する場合があります. DTLSレコードはTLSレコードのように相互に依存していないため、この変更が可能です. 

一般に、DTLS実装は、不正なMACを持つレコードまたはそれ以外の場合は無効なレコードを静かに破棄する必要があります. エラーを記録する場合があります. DTLS実装が無効なMACのメッセージを受信したときにアラートを生成することを選択した場合、致命的なレベルのbad_record_macアラートを生成し、その接続状態を終了しなければなりません. エラーは接続の終了を引き起こさないため、DTLSスタックはTLSスタックよりも効率的なエラータイプのオラクルであることに注意してください. したがって、[TLS12]のセクション6.2.3.2のアドバイスに従うことが特に重要です. 

4.1.2.2. ヌルまたは標準ストリーム暗号

DTLS NULL暗号は、TLS 1.2 NULL暗号とまったく同じように実行されます.  

TLS 1.2で説明されている唯一のストリーム暗号はRC4であり、ランダムにアクセスできません. RC4はDTLSと共に使用してはなりません. 

4.1.2.3. ブロック暗号

DTLSブロック暗号の暗号化と復号化は、TLS 1.2とまったく同じように実行されます.  

4.1.2.4. AEAD暗号

TLS 1.2は、追加データ（AEAD）暗号スイートを使用した認証暗号化を導入しました. [ECCGCM]および[RSAGCM]で定義されている既存のAEAD暗号スイートは、TLS 1.2とまったく同じようにDTLSで使用できます. 

4.1.2.5.  New Cipher Suites

登録時に、新しいTLS暗号スイートは、それらがDTLSの使用に適しているかどうか、もしあれば、どのような適応を行わなければならないかを示さなければなりません（IANAの考慮事項についてはセクション7を参照）.  

4.1.2.6.  Anti-Replay

DTLSレコードには、リプレイ保護を提供するシーケンス番号が含まれています. [ESP]のセクション3.4.3から借用した次のスライディングウィンドウ手順を使用して、シーケンス番号の検証を実行する必要があります. 

このセッションの受信者パケットカウンターは、セッションが確立されたときにゼロに初期化する必要があります. 受信したレコードごとに、受信者は、このセッションの存続期間中に受信した他のレコードのシーケンス番号と重複しないシーケンス番号がレコードに含まれていることを確認する必要があります. これは、重複レコードの拒否を高速化するために、セッションに一致した後のパケットに適用される最初のチェックである必要があります. 

重複は、スライディング受信ウィンドウを使用して拒否されます. （ウィンドウの実装方法はローカルの問題ですが、次のテキストは実装が示す必要がある機能を説明しています. ）最小ウィンドウサイズ32をサポートする必要がありますが、ウィンドウサイズ64が推奨され、デフォルトとして使用する必要があります.  . 別のウィンドウサイズ（最小値より大きい）が受信者によって選択される場合があります. （受信者はウィンドウサイズを送信者に通知しません. ）

ウィンドウの「右」端は、このセッションで受信した検証済みのシーケンス番号の最大値を表します. ウィンドウの「左」エッジよりも低いシーケンス番号を含むレコードは拒否されます. ウィンドウ内に収まるパケットは、ウィンドウ内の受信パケットのリストと照合されます. ビットマスクの使用に基づいてこのチェックを実行する効率的な手段は、[ESP]のセクション3.4.3で説明されています. 

受信したレコードがウィンドウ内にあり、新しい場合、またはパケットがウィンドウの右側にある場合、受信者はMAC検証に進みます. MAC検証が失敗した場合、受信者は受信したレコードを無効として破棄する必要があります. 受信ウィンドウは、MAC検証が成功した場合にのみ更新されます. 

4.1.2.7.  Handling Invalid Records

TLSとは異なり、DTLSは無効なレコード（無効なフォーマット、長さ、MACなど）に直面しても回復力があります. 一般に、無効なレコードは静かに破棄されるべきであり（SHOULD）、関連付けを保持します. ただし、診断目的でエラーが記録される場合があります. 代わりにアラートを生成することを選択した実装では、致命的なレベルのアラートを生成して、攻撃者が実装を繰り返しプローブしてさまざまなタイプのエラーへの応答方法を確認する攻撃を回避する必要があります. DTLSがUDP上で実行される場合、UDP偽造は非常に簡単であるため、これを実行する実装はサービス拒否（DoS）攻撃の影響を非常に受けやすいことに注意してください. したがって、この方法はこのようなトランスポートには推奨されません. 

偽造に耐性のあるトランスポート（たとえば、SCTP-AUTHを使用したSCTP）でDTLSが実行されている場合、攻撃者はトランスポート層によって拒否されないデータグラムを偽造するのが難しいため、アラートを送信する方が安全です.  

4.2.  The DTLS Handshake Protocol

DTLSは、TLSと同じハンドシェイクメッセージとフローをすべて使用しますが、3つの主要な変更があります.  

1.サービス拒否攻撃を防ぐために、ステートレスCookie交換が追加されました.  

2.メッセージの損失、並べ替え、およびDTLSメッセージの断片化を処理するためのハンドシェイクヘッダーの変更（IP断片化を回避するため）.  

3.メッセージ損失を処理するための再送信タイマー.  

これらの例外を除き、DTLSメッセージのフォーマット、フロー、およびロジックは、TLS 1.2のものと同じです.  

4.2.1.  Denial-of-Service Countermeasures

データグラムセキュリティプロトコルは、さまざまなDoS攻撃の影響を非常に受けやすくなっています. 特に懸念されるのは次の2つの攻撃です. 

1.攻撃者は、一連のハンドシェイク開始要求を送信することでサーバー上の過剰なリソースを消費し、サーバーに状態を割り当てさせ、潜在的に高価な暗号操作を実行させる可能性があります.  

2.攻撃者は、被害者の偽造ソースで接続開始メッセージを送信することにより、サーバーをアンプとして使用できます. サーバーは次に、被害者のマシンに次のメッセージ（DTLSの証明書メッセージで、非常に大きくなる可能性があります）を送信します. 

これらの攻撃の両方に対抗するために、DTLSはPhoturis [PHOTURIS]およびIKE [IKEv2]で使用されるステートレスCookie技術を借用します. クライアントがClientHelloメッセージをサーバーに送信すると、サーバーはHelloVerifyRequestメッセージで応答する場合があります. このメッセージには、[PHOTURIS]の手法を使用して生成されたステートレスCookieが含まれています. クライアントは、Cookieを追加してClientHelloを再送信する必要があります. サーバーは、Cookieを検証し、有効な場合にのみハンドシェイクを続行します. このメカニズムにより、攻撃者/クライアントはCookieを受信できるようになり、なりすましIPアドレスによるDoS攻撃が困難になります. このメカニズムは、有効なIPアドレスからマウントされたDoS攻撃に対する防御を提供しません. 

交換は次のとおりです.  

      Client                                   Server
      ------                                   ------
      ClientHello           ------>

                            <----- HelloVerifyRequest
                                   (contains cookie)

      ClientHello           ------>
      (with cookie)

      [Rest of handshake]

したがって、DTLSはCookie値を追加するためにClientHelloメッセージを変更します.  

   struct {
     ProtocolVersion client_version;
     Random random;
     SessionID session_id;
     opaque cookie<0..2^8-1>;                             // New field
     CipherSuite cipher_suites<2..2^16-1>;
           CompressionMethod compression_methods<1..2^8-1>;
   } ClientHello;

最初のClientHelloを送信するとき、クライアントにはまだCookieがありません. この場合、Cookieフィールドは空のままです（長さゼロ）. 

HelloVerifyRequestの定義は次のとおりです.  

   struct {
     ProtocolVersion server_version;
     opaque cookie<0..2^8-1>;
   } HelloVerifyRequest;


HelloVerifyRequestメッセージタイプはhello_verify_request（3）です.  

server_versionフィールドの構文は、TLSと同じです. ただし、初期ハンドシェイクでバージョンネゴシエーションを行う要件を回避するために、DTLS 1.2サーバー実装は、ネゴシエートされると予想されるTLSのバージョンに関係なく、DTLSバージョン1.0を使用する必要があります. DTLS 1.2および1.0クライアントは、バージョンネゴシエーションの一部としてではなく、パケットフォーマット（DTLS 1.2と1.0の両方で同じ）を示すためだけにバージョンを使用する必要があります. 特に、DTLS 1.2クライアントは、サーバーがHelloVerifyRequestでバージョン1.0を使用しているため、サーバーがDTLS 1.2ではないこと、または最終的にDTLS 1.2ではなくDTLS 1.0をネゴシエートすることを想定してはなりません. HelloVerifyRequestに応答するとき、クライアントは元のClientHelloと同じパラメーター値（バージョン、ランダム、session_id、cipher_suites、compression_method）を使用する必要があります. サーバーは、これらの値を使用してCookieを生成し、Cookieの受信時に正しいことを確認する必要があります. サーバーは、ServerHelloを送信するときに使用するのと同じバージョン番号をHelloVerifyRequestで使用する必要があります. ServerHelloを受信すると、クライアントはサーバーバージョン値が一致することを確認する必要があります. 複数のHelloVerifyRequestsの場合にシーケンス番号の重複を避けるために、サーバーはClientHelloのレコードシーケンス番号をHelloVerifyRequestのレコードシーケンス番号として使用する必要があります. 

注：この仕様は、将来の柔軟性を高めるために、Cookieサイズの制限を255バイトに増やします. DTLSの以前のバージョンの制限は32のままです. 

DTLSサーバーは、サーバー上でクライアントごとの状態を保持せずに検証できるように、Cookieを生成する必要があります. 1つの手法は、ランダムに生成されたシークレットを持ち、次のようにCookieを生成することです. 

      Cookie = HMAC(Secret, Client-IP, Client-Parameters)

2番目のClientHelloを受信すると、サーバーはCookieが有効であり、クライアントが特定のIPアドレスでパケットを受信できることを確認できます. 複数のCookie交換の場合にシーケンス番号の重複を避けるために、サーバーはClientHelloのレコードシーケンス番号を最初のServerHelloのレコードシーケンス番号として使用する必要があります. 後続のServerHellosは、サーバーが状態を作成した後にのみ送信され、通常は増加する必要があります. 

このスキームに対する潜在的な攻撃の1つは、攻撃者がさまざまなアドレスから多数のCookieを収集し、それらを再利用してサーバーを攻撃することです. サーバーは、Secret値を頻繁に変更することにより、これらのCookieを無効にすることにより、この攻撃を防御できます. サーバーが正当なクライアントが移行を介してハンドシェイクできるようにしたい場合（たとえば、サーバーがシークレット1でCookieを受信し、サーバーがシークレット2に変更された後に2番目のClientHelloを送信した場合）、サーバーは制限されたウィンドウを持つことができます両方の秘密を受け入れます. [IKEv2]は、このケースを検出するためにバージョン番号をCookieに追加することを提案しています. 別のアプローチは、単に両方の秘密で検証を試みることです. 

DTLSサーバーは、新しいハンドシェイクが実行されるたびにCookie交換を実行する必要があります. 増幅が問題にならない環境でサーバーが運用されている場合、Cookie交換を実行しないようにサーバーを構成することができます. ただし、デフォルトでは交換が実行される必要があります. さらに、サーバーは、セッションの再開時にCookie交換を行わないことを選択する場合があります. クライアントは、ハンドシェイクごとにCookie交換を行う準備をする必要があります. 

HelloVerifyRequestを使用する場合、最初のClientHelloおよびHelloVerifyRequestは、handshake_messages（CertificateVerifyメッセージ用）およびverify_data（Finishedメッセージ用）の計算に含まれません.  

サーバーが無効なCookieを持つClientHelloを受信した場合、Cookieを持たないClientHelloと同じように処理する必要があります. これにより、クライアントが何らかの形で不正なCookieを取得した場合（たとえば、サーバーがCookie署名キーを変更するため）に競合/デッドロック状態を回避できます. 

実装者への注意：これにより、クライアントが異なるCookieを持つ複数のHelloVerifyRequestメッセージを受信する可能性があります. クライアントは、新しいHelloVerifyRequestへの応答としてCookieを含む新しいClientHelloを送信することにより、これを処理する必要があります. 

4.2.2.  Handshake Message Format

メッセージの損失、並べ替え、およびメッセージの断片化をサポートするために、DTLSはTLS 1.2ハンドシェイクヘッダーを変更します.  

   struct {
     HandshakeType msg_type;
     uint24 length;
     uint16 message_seq;                               // New field
     uint24 fragment_offset;                           // New field
     uint24 fragment_length;                           // New field
     select (HandshakeType) {
       case hello_request: HelloRequest;
       case client_hello:  ClientHello;
       case hello_verify_request: HelloVerifyRequest;  // New type
       case server_hello:  ServerHello;
       case certificate:Certificate;
       case server_key_exchange: ServerKeyExchange;
       case certificate_request: CertificateRequest;
       case server_hello_done:ServerHelloDone;
       case certificate_verify:  CertificateVerify;
       case client_key_exchange: ClientKeyExchange;
       case finished: Finished;
     } body;
   } Handshake;

各ハンドシェイクで各側が最初に送信するメッセージには、常にmessage_seq = 0があります. 新しいメッセージが生成されるたびに、message_seq値は1ずつ増加します. 再ハンドシェイクの場合、これは、HelloRequestにmessage_seq = 0があり、ServerHelloにmessage_seq = 1があることを意味することに注意してください. メッセージが再送信されるとき、同じmessage_seq値が使用されます. 例えば：

         Client                             Server
         ------                             ------
         ClientHello (seq=0)  ------>

                                 X<-- HelloVerifyRequest (seq=0)
                                                 (lost)

         [Timer Expires]

         ClientHello (seq=0)  ------>
         (retransmit)

                              <------ HelloVerifyRequest (seq=0)

         ClientHello (seq=1)  ------>
         (with cookie)

                              <------        ServerHello (seq=1)
                              <------        Certificate (seq=2)
                              <------    ServerHelloDone (seq=3)

         [Rest of handshake]

ただし、DTLSレコードレイヤーの観点からは、再送信は新しいレコードであることに注意してください. このレコードには、新しいDTLSPlaintext.sequence_number値が含まれます. 

DTLS実装は、（少なくとも概念的には）next_receive_seqカウンターを維持します. このカウンターは、最初はゼロに設定されています. メッセージを受信すると、そのシーケンス番号がnext_receive_seqに一致する場合、next_receive_seqがインクリメントされ、メッセージが処理されます. シーケンス番号がnext_receive_seqより小さい場合、メッセージは破棄されなければなりません. シーケンス番号がnext_receive_seqより大きい場合、実装はメッセージをキューに入れる必要があります（SHOULD）が、破棄する場合があります. （これは単純なスペース/帯域幅のトレードオフです）. 

4.2.3.  Handshake Message Fragmentation and Reassembly

セクション4.1.1で述べたように、各DTLSメッセージは単一のトランスポート層データグラムに収まらなければなりません. ただし、ハンドシェイクメッセージは最大レコードサイズよりも大きくなる可能性があります. したがって、DTLSは、多数のレコードにわたってハンドシェイクメッセージを断片化するメカニズムを提供します. 各レコードは個別に送信できるため、IPフラグメンテーションを回避できます. ハンドシェイクメッセージを送信するとき、送信者はメッセージを一連のN個の連続したデータ範囲に分割します. これらの範囲は、ハンドシェイクフラグメントの最大サイズよりも大きくてはならず、ハンドシェイクメッセージ全体を一緒に含める必要があります. 範囲は重複してはいけません. 次に、送信者は、元のハンドシェイクメッセージと同じmessage_seq値を持つN個のハンドシェイクメッセージを作成します. 新しいメッセージには、fragment_offset（以前のフラグメントに含まれるバイト数）とfragment_length（このフラグメントの長さ）のラベルが付けられます. すべてのメッセージの長さフィールドは、元のメッセージの長さフィールドと同じです. 断片化されていないメッセージは、fragment_offset = 0およびfragment_length = lengthの縮退ケースです. 

DTLS実装は、ハンドシェイクメッセージフラグメントを受信すると、ハンドシェイクメッセージ全体を取得するまでバッファリングする必要があります. DTLS実装は、重複するフラグメント範囲を処理できる必要があります. これにより、PMTUの推定値が変更された場合、送信者はより小さなフラグメントサイズでハンドシェイクメッセージを再送信できます. 

TLSの場合と同様に、スペースがあり、同じフライトの一部である場合、複数のハンドシェイクメッセージを同じDTLSレコードに入れることができます. したがって、2つのDTLSメッセージを同じデータグラムにパックするには、2つの受け入れられる方法があります. 同じレコードまたは別々のレコードです. 

4.2.4.  Timeout and Retransmission

以下の図に従って、DTLSメッセージは一連のメッセージフライトにグループ化されます. メッセージの各フライトは多数のメッセージで構成されている場合がありますが、タイムアウトと再送信を目的として、モノリシックと見なす必要があります. 

   Client                                          Server
   ------                                          ------

   ClientHello             -------->                           Flight 1

                           <-------    HelloVerifyRequest      Flight 2

   ClientHello             -------->                           Flight 3

                                              ServerHello    \
                                             Certificate*     \
                                       ServerKeyExchange*      Flight 4
                                      CertificateRequest*     /
                           <--------      ServerHelloDone    /

   Certificate*                                              \
   ClientKeyExchange                                          \
   CertificateVerify*                                          Flight 5
   [ChangeCipherSpec]                                         /
   Finished                -------->                         /

                                       [ChangeCipherSpec]    \ Flight 6
                           <--------             Finished    /

               Figure 1. Message Flights for Full Handshake


   Client                                           Server
   ------                                           ------

   ClientHello             -------->                          Flight 1

                                              ServerHello    \
                                       [ChangeCipherSpec]     Flight 2
                            <--------             Finished    /

   [ChangeCipherSpec]                                         \Flight 3
   Finished                 -------->                         /

図2.セッション再開ハンドシェイクのメッセージフライト（Cookie交換なし） 

DTLSは、次のステートマシンで単純なタイムアウトと再送信スキームを使用します. DTLSクライアントは最初のメッセージ（ClientHello）を送信するため、それらはPREPARING状態で開始します. DTLSサーバーはWAITING状態で起動しますが、バッファーが空で、再送信タイマーはありません. 


                      +-----------+
                      | PREPARING |
                +---> |           | <--------------------+
                |     |           |                      |
                |     +-----------+                      |
                |           |                            |
                |           | Buffer next flight         |
                |           |                            |
                |          \|/                           |
                |     +-----------+                      |
                |     |           |                      |
                |     |  SENDING  |<------------------+  |
                |     |           |                   |  | Send
                |     +-----------+                   |  | HelloRequest
        Receive |           |                         |  |
           next |           | Send flight             |  | or
         flight |  +--------+                         |  |
                |  |        | Set retransmit timer    |  | Receive
                |  |       \|/                        |  | HelloRequest
                |  |  +-----------+                   |  | Send
                |  |  |           |                   |  | ClientHello
                +--)--|  WAITING  |-------------------+  |
                |  |  |           |   Timer expires   |  |
                |  |  +-----------+                   |  |
                |  |         |                        |  |
                |  |         |                        |  |
                |  |         +------------------------+  |
                |  |                Read retransmit      |
        Receive |  |                                     |
           last |  |                                     |
         flight |  |                                     |
                |  |                                     |
               \|/\|/                                    |
                                                         |
            +-----------+                                |
            |           |                                |
            | FINISHED  | -------------------------------+
            |           |
            +-----------+
                 |  /|\
                 |   |
                 |   |
                 +---+

              Read retransmit
           Retransmit last flight

図3. DTLSタイムアウトと再送信状態マシン

状態マシンには3つの基本的な状態があります.  

PREPARING状態では、実装は次のメッセージフライトを準備するために必要な計算を行います. 次に、送信のためにそれらをバッファリングし（最初にバッファを空にし）、SENDING状態に入ります. 

SENDING状態では、実装はメッセージのバッファーフライトを送信します. メッセージが送信されると、ハンドシェイクの最後のフライトである場合、実装はFINISHED状態になります. または、実装がさらにメッセージを受信することを期待している場合、再送信タイマーを設定してからWAITING状態に入ります. 

待機状態を終了するには、次の3つの方法があります.  

1.再送信タイマーが時間切れになります. 実装はSENDING状態に移行し、フライトを再送信し、再送信タイマーをリセットし、WAITING状態に戻ります.  

2.実装はピアから再送信されたフライトを読み取ります. 実装はSENDING状態に移行し、そこでフライトを再送信し、再送信タイマーをリセットし、WAITING状態に戻ります. ここでの理由は、重複メッセージの受信はピアでのタイマー満了の結果である可能性が高いため、以前のフライトの一部が失われたことを示唆しているからです. 

3.実装は次のメッセージフライトを受信します. これがメッセージの最終フライトである場合、実装はFINISHEDに移行します. 実装が新しいフライトを送信する必要がある場合、準備状態に移行します. 部分的な読み取り（部分的なメッセージまたはフライト内の一部のメッセージのみ）は、状態遷移またはタイマーリセットを引き起こしません. 

DTLSクライアントは最初のメッセージ（ClientHello）を送信するため、それらはPREPARING状態で開始します. DTLSサーバーはWAITING状態で起動しますが、バッファーが空で、再送信タイマーはありません. 

サーバーが再ハンドシェイクを要求すると、サーバーはFINISHED状態からPREPARING状態に移行してHelloRequestを送信します. クライアントがHelloRequestを受信すると、ClientHelloを送信するためにFINISHEDからPREPARINGに移行します. 

さらに、[TCP]で定義されているデフォルトのMSLの少なくとも2倍は、FINISHED状態の場合、最後のフライトを送信したノード(通常のハンドシェイクのサーバまたは再開されたハンドシェイクのクライアント)は、相手の最後のフライトの再送に対して、最後のフライトの再送で応答しなければならない[MUST]。 これにより、最後のフライトが失われた場合のデッドロック状態を回避することができます。 この要件は DTLS 1.0 にも適用され、[DTLS1] では明示されていませんが、ステートマシンが正しく機能するためには常に必要とされていました。 なぜこの要件が必要なのかを理解するために、通常のハンドシェイクで、サーバの Finished メッセージが失われた場合に何が起こるかを考えてみましょう。 クライアントがFinishedメッセージを待っている間に、クライアントの再送タイマーが作動し、クライアントのFinishedメッセージを再送します。 これにより、サーバは自身のFinishedメッセージで応答し、ハンドシェイクが完了します。 再開されたハンドシェイクについては、サーバ側でも同じロジックが適用されます。

パケットロスのため、一方の側が最初の側のFinishedメッセージを受信していなくても、他方の側がアプリケーションデータを送信している可能性があることに注意してください。 実装は、そのエポックのFinishedメッセージを受信するまで、新しいエポックのためのすべてのアプリケー ションデータパケットを破棄するかバッファリングしなければならない[MUST]。実装は、対応するFinishedメッセージを受信する前の新しいエポックでのアプリケーションデータの受信を、並べ替えまたはパケットロスの証拠として扱い、再送タイマーを短縮して最終フライトを直ちに再送してもよい[MAY]。

4.2.4.1. タイマー値

タイマー値は実装の選択ですが、タイマーの取り扱いを誤ると、深刻な輻輳の問題が発生する可能性があります. たとえば、DTLSの多くのインスタンスが早くタイムアウトになり、輻輳したリンクで再送信が速すぎる場合. 実装は、1秒の初期タイマー値（RFC 6298 [RFC6298]で定義された最小値）を使用し、最大60秒のRFC 6298以上の再送信ごとに値を2倍にする必要があります. 時間に敏感なアプリケーションの遅延を改善するために、3秒のRFC 6298のデフォルトではなく1秒のタイマーを推奨することに注意してください. DTLSはデータフローではなくハンドシェイクにのみ再送信を使用するため、輻輳への影響は最小限に抑える必要があります. 

実装は、損失のない送信が発生するまで現在のタイマー値を保持する必要があり、その時点で値は初期値にリセットされる可能性があります. 現在のタイマー値の10倍以上のアイドル状態が長時間続くと、実装はタイマーを初期値にリセットする場合があります. これが発生する可能性のある状況の1つは、実質的なデータ転送後に再ハンドシェイクが使用される場合です. 

4.2.5. ChangeCipherSpec

TLSと同様に、ChangeCipherSpecメッセージは技術的にはハンドシェイクメッセージではありませんが、タイムアウトと再送信の目的で、関連するFinishedメッセージと同じフライトの一部として扱わなければなりません. これにより、ChangeCipherSpecの順序を、メッセージが失われた場合のハンドシェイクメッセージに関して明確に確立できないため、潜在的なあいまいさが生じます. 

ChangeCipherSpecに論理的に先行するハンドシェイクメッセージの予想されるセットは、ハンドシェイク状態の残りから予測できるため、これは現在のTLSモードでは問題になりません. ただし、将来のモードでは、あいまいさを避けるよう注意する必要があります. 

4.2.6.  CertificateVerify and Finished Messages

CertificateVerifyおよびFinishedメッセージの形式は、TLSと同じです. ハッシュ計算には、DTLS固有のフィールド（message_seq、fragment_offset、fragment_length）を含む、ハンドシェイクメッセージ全体が含まれます. ただし、ハンドシェイクメッセージの断片化に対する感度を削除するために、各ハンドシェイクメッセージが単一のフラグメントとして送信されたかのように、Finished MACを計算する必要があります. Cookie交換が使用される場合、最初のClientHelloおよびHelloVerifyRequestをCertificateVerifyまたはFinished MAC計算に含めてはならないことに注意してください. 

4.2.7. アラートメッセージ

警告メッセージは、ハンドシェイクのコンテキストで発生した場合でも、まったく再送信されないことに注意してください. ただし、通常はアラートを発行するDTLS実装は、問題のあるレコードが再度受信された場合（たとえば、再送信されたハンドシェイクメッセージとして）、新しいアラートメッセージを生成する必要があります. 実装は、ピアが不正なメッセージを永続的に送信していることを検出する必要があり、そのような不正行為が検出された後にローカル接続状態を終了する必要があります. 

4.2.8.  Establishing New Associations with Existing Parameters 既存のパラメーターとの新しい関連付けの確立

同じホスト/ポートカルテットで繰り返し接続が発生するようにDTLSクライアント/サーバーペアが構成されている場合、クライアントが静かに1つの接続を放棄し、同じパラメーターで別の接続を開始する可能性があります（たとえば、リブート）. これは、epoch = 0の新しいハンドシェイクとしてサーバーに表示されます. 特定のホスト/ポートカルテットに既存のアソシエーションがあるとサーバーが判断し、epoch = 0 ClientHelloを受信する場合、サーバーは新しいハンドシェイクを続行する必要がありますが、クライアントが完了可能性を示すまで既存のアソシエーションを破棄してはなりませんCookieの交換、または検証可能な終了メッセージの配信を含む完全なハンドシェイクの完了. 正しいFinishedメッセージを受信した後、サーバーは、重複するエポックを持つ2つの有効なアソシエーション間の混乱を避けるために、以前のアソシエーションを放棄しなければなりません. 到達可能性の要件は、偽のClientHelloを送信するだけで、オフパス/ブラインド攻撃者がアソシエーションを破壊するのを防ぎます. 

4.3. 新しい構文の概要

このセクションには、TLS 1.2とDTLS 1.2の間で変更されたデータ構造の仕様が含まれています. この構文の定義については、[TLS12]を参照してください. 

4.3.1. Record Layer

   struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        opaque fragment[DTLSPlaintext.length];
      } DTLSPlaintext;

      struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        opaque fragment[DTLSCompressed.length];
      } DTLSCompressed;

      struct {
        ContentType type;
        ProtocolVersion version;
        uint16 epoch;                                     // New field
        uint48 sequence_number;                           // New field
        uint16 length;
        select (CipherSpec.cipher_type) {
          case block:  GenericBlockCipher;
          case aead:   GenericAEADCipher;                 // New field
        } fragment;
      } DTLSCiphertext;

4.3.2. ハンドシェイクプロトコル

   enum {
     hello_request(0), client_hello(1), server_hello(2),
     hello_verify_request(3),                          // New field
     certificate(11), server_key_exchange (12),
     certificate_request(13), server_hello_done(14),
     certificate_verify(15), client_key_exchange(16),
     finished(20), (255) } HandshakeType;

   struct {
     HandshakeType msg_type;
     uint24 length;
     uint16 message_seq;                               // New field
     uint24 fragment_offset;                           // New field
     uint24 fragment_length;                           // New field
     select (HandshakeType) {
       case hello_request: HelloRequest;
       case client_hello:  ClientHello;
       case server_hello:  ServerHello;
       case hello_verify_request: HelloVerifyRequest;  // New field
       case certificate:Certificate;
       case server_key_exchange: ServerKeyExchange;
       case certificate_request: CertificateRequest;
       case server_hello_done:ServerHelloDone;
       case certificate_verify:  CertificateVerify;
       case client_key_exchange: ClientKeyExchange;
       case finished: Finished;
     } body; } Handshake;

   struct {
     ProtocolVersion client_version;
     Random random;
     SessionID session_id;
     opaque cookie<0..2^8-1>;                             // New field
     CipherSuite cipher_suites<2..2^16-1>;
     CompressionMethod compression_methods<1..2^8-1>; } ClientHello;

   struct {
     ProtocolVersion server_version;
     opaque cookie<0..2^8-1>; } HelloVerifyRequest;

5.セキュリティに関する考慮事項 

このドキュメントでは、TLS 1.2のバリアントについて説明します. したがって、セキュリティに関する考慮事項のほとんどは、付録D、E、およびFで説明されているTLS 1.2 [TLS12]の考慮事項と同じです. 

DTLSによって提起される主な追加のセキュリティの考慮事項は、サービス拒否です. DTLSには、サービス拒否から保護するために設計されたCookie交換が含まれています. ただし、このCookie交換を使用しない実装は、依然としてDoSに対して脆弱です. 特に、Cookie交換を使用しないDTLSサーバーは、それ自体がDoSを経験していない場合でも、攻撃アンプとして使用できます. したがって、DTLSサーバーは、環境内で増幅が脅威ではないと考える十分な理由がない限り、Cookie交換を使用する必要があります. クライアントは、ハンドシェイクごとにCookie交換を行う準備をする必要があります. 

TLS実装とは異なり、DTLS実装は接続を終了することにより無効なレコードに応答すべきではありません. 詳細については、セクション4.1.2.7を参照してください. 

6.謝辞 

著者は、DTLSの設計に関する議論とコメントについて、Dan Boneh、Eu-Jin Goh、Russ Housley、Constantine Sapuntzakis、およびHovav Shachamに感謝します. コメントを寄せてくれたDTLS [DTLS]に関する元のNDSS論文の匿名NDSSレビューアーに感謝します. また、多くのポイントを明確にするのに役立ったフィードバックに対するSteve Kentに感謝します. PMTUに関するセクションは、DCCP仕様[DCCP]から引用されています. Pasi Eronenは、この仕様の詳細なレビューを提供しました. ピーター・サン・アンドレはセクション8の変更点のリストを提供しました. 文書に関する有益なコメントは、マーク・オールマン、ジャリ・アルコ、モハメド・バドラ、マイケル・デリコ、エイドリアン・ファレル、ジョエル・ハルパーン、テッド・ハーディ、チャリア・カウフマン、ペッカ・サヴォラからも受けました、アリソン・マンキン、ニコス・マブロジャンノポウロス、アレクセイ・メルニコフ、ロビン・セグゲルマン、マイケル・テクセン、ジュホ・ヴァハ・ヘルツア、フロリアン・ワイマー. 

7. IANAの考慮事項 

このドキュメントは、TLS [TLS12]と同じ識別子スペースを使用するため、新しいIANAレジストリは必要ありません. TLSに新しい識別子が割り当てられる場合、作成者はDTLSに適しているかどうかを指定する必要があります. IANAはすべてのTLSパラメータレジストリを変更して、DTLSで仕様を使用できるかどうかを示すDTLS-OKフラグを追加しました. 公開時点では、以下を除くすべての[TLS12]登録がDTLSに適しています. 登録の完全な表は[IANA]で入手できます. 

TLS暗号スイートレジストリから： 

      0x00,0x03 TLS_RSA_EXPORT_WITH_RC4_40_MD5        [RFC4346]
      0x00,0x04 TLS_RSA_WITH_RC4_128_MD5              [RFC5246]
      0x00,0x05 TLS_RSA_WITH_RC4_128_SHA              [RFC5246]
      0x00,0x17 TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    [RFC4346]
      0x00,0x18 TLS_DH_anon_WITH_RC4_128_MD5          [RFC5246]
      0x00,0x20 TLS_KRB5_WITH_RC4_128_SHA             [RFC2712]
      0x00,0x24 TLS_KRB5_WITH_RC4_128_MD5             [RFC2712]
      0x00,0x28 TLS_KRB5_EXPORT_WITH_RC4_40_SHA       [RFC2712]
      0x00,0x2B TLS_KRB5_EXPORT_WITH_RC4_40_MD5       [RFC2712]
      0x00,0x8A TLS_PSK_WITH_RC4_128_SHA              [RFC4279]
      0x00,0x8E TLS_DHE_PSK_WITH_RC4_128_SHA          [RFC4279]
      0x00,0x92 TLS_RSA_PSK_WITH_RC4_128_SHA          [RFC4279]
      0xC0,0x02 TLS_ECDH_ECDSA_WITH_RC4_128_SHA       [RFC4492]
      0xC0,0x07 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA      [RFC4492]
      0xC0,0x0C TLS_ECDH_RSA_WITH_RC4_128_SHA         [RFC4492]
      0xC0,0x11 TLS_ECDHE_RSA_WITH_RC4_128_SHA        [RFC4492]
      0xC0,0x16 TLS_ECDH_anon_WITH_RC4_128_SHA        [RFC4492]
      0xC0,0x33 TLS_ECDHE_PSK_WITH_RC4_128_SHA        [RFC5489]

TLSエクスポーターラベルレジストリから： 

      client EAP encryption       [RFC5216]
      ttls   keying material      [RFC5281]
      ttls   challenge            [RFC5281]

このドキュメントは、新しいハンドシェイクメッセージ、hello_verify_requestを定義します. その値は、[TLS12]で定義されたTLS HandshakeTypeレジストリから割り当てられています. 値「3」はIANAによって割り当てられています. 

8. DTLS 1.0以降の変更 

このドキュメントは、DTLS 1.0 [DTLS1]以降の次の変更を反映しています.  

-TLS 1.2 [TLS12]と一致するように更新されました.  

-セクション4.1.2.3のAEAD暗号の追加（TLS 1.2の変更の追跡.  

-セクション4.1のシーケンス番号とエポックに関する明確化、およびセクション4.2.8の状態損失に対処するための明確な手順.  

-セクション4.1.1.1のパスMTUの問題に関する明確化と詳細なルール. 断片化テキスト全体の明確化. 

-セクション4.1.2.7の無効なレコードの処理に関する説明.  

-セクション4.2.1の最後の無効なCookieの処理を説明する新しい段落.  

-セクション4.2.4の終わりに、ハンドシェイクのデッドロック状態を回避する方法を説明する新しいテキスト.  

-セクション4.2.6のCertificateVerifyメッセージに関する新しいテキスト.  

-セクション4.1のエポックラッピングの禁止.  

-IANA要件の明確化および各パラメーターの新しいIANA登録フラグの明示的な要件.  

-繰り返されるClientHelloメッセージを処理するためのレコードシーケンス番号ミラーリングテクニックを追加しました.  

-HelloVerifyRequestの固定バージョン番号を推奨します.  

-多数の編集上の変更.  

9.参照 

9.1. 規範的参考文献

[REQ] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月.  

[RFC1191] Mogul、J. およびS. Deering、「Path MTU discovery」、RFC 1191、1990年11月.  

[RFC4301] Kent、S.、K. Seo、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、2005年12月.  

[RFC4443] Conta、A.、Deering、S. 、およびM. Gupta、Ed. 、「インターネットプロトコルバージョン6（IPv6）仕様のためのインターネット制御メッセージプロトコル（ICMPv6）」、RFC 4443、2006年3月.  

[RFC4821] Mathis、M. 、およびJ. Heffner、「パケット化層パスMTUディスカバリー」、RFC 4821、2007年3月.  

[RFC6298] Paxson、V.、Allman、M.、Chu、J. 、およびM. Sargent、「Computing TCPの再送信タイマー」、RFC 6298、2011年6月.  

[RSAGCM] Salowey、J.、Choudhury、A. 、およびD. McGrew、「TLSのAESガロアカウンターモード（GCM）暗号スイート」、RFC 5288、2008年8月.  

[TCP]ポステル、J. 、「伝送制御プロトコル」、STD 7、RFC 793、1981年9月. [TLS12]ディールクス、T. およびE.レスコラ、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246 、2008年8月.  

9.2. 参考資料

[DCCP] Kohler、E.、Handley、M. 、およびS. Floyd、「データグラム輻輳制御プロトコル（DCCP）」、RFC 4340、2006年3月.  

[DCCPDTLS] Phelan、T.、「データグラム輻輳制御プロトコル（DCCP）上のデータグラムトランスポート層セキュリティ（DTLS）」、RFC 5238、2008年5月.  

[DTLS] Modadugu、N. およびE. Rescorla、「データグラムTLSの設計と実装」、ISOC NDSS 2004の議事録、2004年2月.  

[DTLS1] Rescorla、E. およびN. Modadugu、「データグラムトランスポート層セキュリティ」、RFC 4347、2006年4月.  

[ECCGCM] Rescorla、E. 、「TLS-楕円曲線暗号スイートとSHA-256 / 384およびAESガロアカウンターモード（GCM）」、RFC 5289、2008年8月.  

[ESP]ケント、S. 、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、2005年12月.  

[IANA] IANA、「Transport Layer Security（TLS）Parameters」、http：//www.iana.org/assignments/tls-parameters.  

[IKEv2] Kaufman、C.、Hoffman、P.、Nir、Y. 、およびP. Eronen、「インターネットキー交換プロトコルバージョン2（IKEv2）」、RFC 5996、2010年9月.  

[IMAP]クリスピン、M. 、「インターネットメッセージアクセスプロトコル-バージョン4rev1」、RFC 3501、2003年3月.  

[PHOTURIS]カーン、P. およびW.シンプソン、「Photuris：セッションキー管理プロトコル」、RFC 2522、1999年3月.  

[POP]マイヤーズ、J. およびM.ローズ、「郵便局プロトコル-バージョン3」、STD 53、RFC 1939、1996年5月.  

[SIP] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. 、およびE. Schooler、「SIP：Session Initiation Protocol」 、RFC 3261、2002年6月.  

[TLS] Dierks、T. およびC. Allen、「TLSプロトコルバージョン1.0」、RFC 2246、1999年1月.  

[TLS11] Dierks、T. 、およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.1」、RFC 4346、2006年4月.  

[WHYIPSEC] Bellovin、S. 、「IPsecバージョン2の使用を指定するためのガイドライン」、BCP 146、RFC 5406、2009年2月.  

著者のアドレス 

Eric Rescorla RTFM、Inc. 2064 Edgewood Driveパロアルト、カリフォルニア94303 

メール：ekr@rtfm.com 



Nagendra Modadugu Google、Inc. 

メール：nagendra@cs.stanford.edu 
