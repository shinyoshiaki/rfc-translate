RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
5746
RFC 5746-トランスポート層セキュリティ（TLS）再ネゴシエーション表示拡張日本語
URL：https：//tools.ietf.org/html/rfc5746
パッケージ：RFC 5746-トランスポート層セキュリティ（TLS）再ネゴシエーション表示拡張
翻訳：自動翻訳
インターネットエンジニアリングタスクフォース（IETF）E. Rescorla
コメントのリクエスト：5746 RTFM、Inc. 
更新：5246、4366、4347、4346、2246 M. Ray
カテゴリ：標準化過程S. Dispensa
ISSN：2070-1721 PhoneFactor
                                                                N.オスコフ
                                                               マイクロソフト
                                                           2010年2月
        
トランスポート層セキュリティ（TLS）再ネゴシエーション表示拡張

概要

Secure Socket Layer（SSL）およびTransport Layer Security（TLS）の再ネゴシエーションは、攻撃者がターゲットサーバーとTLS接続を形成し、選択したコンテンツを挿入してから、クライアントからの新しいTLS接続を接続する攻撃に対して脆弱です. サーバーは、クライアントの最初のTLSハンドシェイクを再ネゴシエーションとして扱い、攻撃者によって送信された最初のデータが後続のクライアントデータと同じエンティティからのものであると信じています. この仕様は、再ネゴシエーションを実行されているTLS接続に暗号的に結び付けるためのTLS拡張を定義しているため、この攻撃を防ぎます. 

このメモのステータス

これはインターネット標準化過程の文書です. 

このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です. これは、IETFコミュニティのコンセンサスを表しています. パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました. インターネット標準の詳細については、RFC5741のセクション2を参照してください. 

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、http：//www.rfc-editor.org/info/rfc5746で入手できます. 

著作権表示

Copyright（c）2010 IETFTrustおよびドキュメントの作成者として特定された人物. 全著作権所有. 

このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（http://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます. 

目次

   1.はじめに...............................................  ..... 3
   2.このドキュメントで使用されている規則............................... 4
   3.安全な再ネゴシエーションの定義................................. 4
      3.1. 追加の接続状態................................ 4
      3.2. 拡張機能の定義....................................... 5
      3.3. 再ネゴシエーション保護要求シグナリング暗号
           スイートの価値................................................ 6
      3.4. クライアントの動作：初期ハンドシェイク......................... 6
      3.5. クライアントの動作：安全な再ネゴシエーション...................... 7
      3.6. サーバーの動作：初期ハンドシェイク......................... 7
      3.7. サーバーの動作：安全な再ネゴシエーション...................... 8
   4.下位互換性.......................................... 9
      4.1. クライアントの考慮事項...................................... 9
      4.2. クライアントの動作：レガシー（安全でない）再ネゴシエーション.......... 10
      4.3. サーバーに関する考慮事項..................................... 10
      4.4. サーバーの動作：レガシー（安全でない）再ネゴシエーション.......... 11
      4.5. SSLv3.................................................  .... 11
   5.セキュリティに関する考慮事項........................................ 12
   6.IANAの考慮事項............................................ 13
   7.謝辞...............................................  13
   8.参考文献...............................................  ...... 13
      8.1. 規範的参考文献...................................... 13
      8.2. 有益な参考資料.................................... 13
        
1.はじめに
TLS [RFC5246]を使用すると、クライアントまたはサーバーのいずれかが再ネゴシエーションを開始できます. これは、新しい暗号化パラメーターを確立する新しいハンドシェイクです. 残念ながら、新しいハンドシェイクは元のハンドシェイクによって確立された暗号化パラメーターを使用して実行されますが、2つの間に暗号化バインディングはありません. これにより、クライアントのトランスポート層接続を傍受できる攻撃者が、クライアントとサーバーとの対話のプレフィックスとして自分のトラフィックを注入できる攻撃の機会が生まれます. この攻撃の1つの形式[Ray09]は、次のように進行します. 

   Client                        Attacker                        Server
   ------                        -------                         ------
                                     <----------- Handshake ---------->
                                     <======= Initial Traffic ========>
   <--------------------------  Handshake ============================>
   <======================== Client Traffic ==========================>

攻撃を開始するために、攻撃者はサーバーへのTLS接続を形成します（おそらく、クライアントからの最初の傍受された接続に応答して）. 次に、選択したトラフィックをサーバーに送信します. これには、アプリケーション層での複数の要求と応答が含まれる場合もあれば、クライアントのデータのプレフィックスを付けることを目的とした部分的なアプリケーション層の要求である場合もあります. このトラフィックは、暗号化されていることを示すために==で示されています. 次に、クライアントのTLSハンドシェイクがサーバーで続行できるようにします. ハンドシェイクは攻撃者には明らかですが、サーバーへの攻撃者のTLS接続を介して暗号化されます. ハンドシェイクが完了すると、クライアントはサーバーと新しく確立されたセキュリティパラメータを介してサーバーと通信します. 攻撃者はこのトラフィックを読み取ることができません. 

証明書ベースのクライアント認証が使用されている場合、サーバーは、最初のバイトは保護されているがTLSによって認証されておらず、後続のバイトはTLSによって認証され、クライアントの証明書にバインドされているバイトのストリームを認識します. 一部のプロトコル（特にHTTPS）では、認証前と認証後の段階が区別されず、バイトが均一に処理されるため、サーバーは初期トラフィックが認証されたクライアントIDに対応していると見なします. 証明書ベースの認証がなくても、攻撃者がサーバーからのデータをクライアントからのデータとして受け入れるようにサーバーを説得するさまざまな攻撃が発生する可能性があります. たとえば、HTTPS [RFC2818]がHTTPCookie [RFC2965]で使用されている場合、攻撃者はクライアントのCookieによって検証された選択した要求を生成できる可能性があります. 

一部のプロトコル（IMAPやSMTPなど）では、認証フェーズと非認証フェーズの間でより明示的な遷移があり、そのような遷移でプロトコルステートマシンを部分的または完全にリセットする必要があります. 厳密に従えば、これらのルールは攻撃の影響を制限する可能性があります. 残念ながら、TLS再ネゴシエーションでステートマシンをリセットする必要はありません. したがって、たとえば、攻撃者が見える領域に書き込むコマンドの前に、攻撃者を含むクライアントによるコマンドを付けるなど、脆弱性の潜在的なウィンドウがあります. パスワード. これにより、クライアントのパスワードが攻撃者に見えるようになります（この正確な攻撃は、チャレンジ/レスポンス認証スキームでは機能しませんが、他の攻撃が行われる可能性があることに注意してください）. SMTPでも同様の攻撃が可能です. 

どちらの場合も、クライアントがTLS接続を介してサーバーから特定のデータを必要とせずに一方的な認証情報を送信するため、これらの攻撃が発生する可能性があることに注意することが重要です. クライアントが機密情報を送信する前にTLSを介してサーバーへのラウンドトリップを必要とするプロトコルは、脆弱性が低い可能性があります. 

これらの攻撃は、再ネゴシエーションハンドシェイクを囲んでいるTLS暗号化パラメーターに暗号的にバインドすることで防止できます. これにより、サーバーは再ネゴシエーションを最初のネゴシエーションと区別し、接続間で再ネゴシエーションがスプライスされるのを防ぎます. 攻撃者が上記のように自分自身を注入しようとすると、暗号化バインディングの不一致が発生するため、検出できます. 拡張機能で使用されるデータは、[TLS-CHANNEL-BINDINGS]で説明されているtls-uniqueおよび/またはtls-unique-for-telnetチャネルバインディングで使用されるデータと似ていますが、同じではありません. ただし、この拡張機能は、汎用のRFC 5056 [RFC5056]チャネルバインディング機能ではありません. 

2.このドキュメントで使用されている規則
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです.  [RFC2119]で説明されているように解釈されます. 

3.安全な再交渉の定義
3.1. 追加の接続状態
クライアントとサーバーの両方が、TLS接続状態ごとに3つの追加値を格納する必要があります（RFC 5246、セクション6.1を参照）. これらの値は接続に固有であることに注意してください（TLSセッションキャッシュエントリではありません）. 

o a「secure_renegotiation」フラグ. この接続でセキュアな再ネゴシエーションが使用されているかどうかを示します. 

o "client_verify_data"：直前のハンドシェイクでクライアントから送信されたFinishedメッセージのverify_data. 現在定義されているTLSバージョンと暗号スイートの場合、これは12バイトの値になります. SSLv3の場合、これは36バイトの値になります. 

o "server_verify_data"：直前のハンドシェイクでサーバーから送信されたFinishedメッセージのverify_data. 

3.2. 拡張機能の定義
このドキュメントは、新しいTLS拡張「renegotiation_info」（拡張タイプ0xff01）を定義します. これには、再ネゴシエーションが実行されている、囲んでいるTLS接続（存在する場合）への暗号化バインディングが含まれます. この拡張機能の「拡張機能データ」フィールドには、「RenegotiationInfo」構造が含まれています. 

      struct {
          opaque renegotiated_connection<0..255>;
      } RenegotiationInfo;
        
この拡張機能の内容は次のとおりです. 

o これが接続の最初のハンドシェイクである場合、「renegotiated_connection」フィールドの長さはClientHelloとServerHelloの両方でゼロです. したがって、拡張機能のエンコーディング全体はff 01 00 01 00です. 最初の2つのオクテットは拡張機能のタイプを表し、3番目と4番目のオクテットは拡張機能自体の長さを表し、最後のオクテットは「renegotiated_connection」フィールドの長さゼロのバイトを表します.  . 

o再ネゴシエーション中のClientHelloの場合、このフィールドにはセクション3.1で指定された「client_verify_data」が含まれます. 

o再ネゴシエートしているServerHelloの場合、このフィールドにはclient_verify_dataとserver_verify_dataの連結が含まれます. TLSの現在のバージョンでは、これは24バイトの値になります（SSLv3の場合、72バイトの値になります）. 

この拡張機能は、Datagram TLS（DTLS）[RFC4347]でも使用できます. 編集を簡単にするために、このドキュメントではTLSについて言及していますが、このドキュメントのすべての要件はDTLSにも同様に適用されます. 

3.3. 再ネゴシエーション保護要求シグナリング暗号スイート値
SSLv3仕様とTLS1.0 / TLS 1.1仕様はどちらも、ClientHelloに続くデータ（つまり、拡張機能）を理解できない場合、それを無視するように実装する必要があります. ただし、一部のSSLv3およびTLS 1.0実装は、このような場合にハンドシェイクに誤って失敗します. これは、「renegotiation_info」拡張機能を提供するクライアントでハンドシェイクの失敗が発生する可能性があることを意味します. このようなサーバーとの互換性を強化するために、このドキュメントでは、コードポイント{0x00、0xFF}を使用して、特別なシグナリング暗号スイート値（SCSV）「TLS_EMPTY_RENEGOTIATION_INFO_SCSV」を介した2番目のシグナリングメカニズムを定義します. このSCSVは真の暗号スイートではなく（有効なアルゴリズムのセットに対応していません）、ネゴシエートできません. 代わりに、次のセクションで説明するように、空の「renegotiation_info」拡張機能と同じセマンティクスを持ちます. SSLv3とTLSの実装は未知の暗号スイートを確実に無視するため、SCSVはどのサーバーにも安全に送信できます. SCSVは、SSLv2の下位互換性のあるCLIENT-HELLOに含めることもできます（[RFC5246]の付録E.2を参照）. 

注：再ネゴシエーションをまったくサポートしない最小限のクライアントは、すべての初期ハンドシェイクでSCSVを使用できます. 次のセクションのルールにより、準拠しているサーバーは、そのようなクライアントによる再ネゴシエーションの明らかな試みを検出すると、ハンドシェイクを中止します. 

3.4. クライアントの動作：最初のハンドシェイク
このセクションとセクション3.5は、フルハンドシェイクとセッション再開ハンドシェイクの両方に適用されることに注意してください. 

oクライアントは、空の「renegotiation_info」拡張機能、またはTLS_EMPTY_RENEGOTIATION_INFO_SCSVシグナリング暗号スイート値のいずれかをClientHelloに含める必要があります. 両方を含めることはお勧めしません. 

o ServerHelloを受信すると、クライアントは「renegotiation_info」拡張子が含まれているかどうかを確認する必要があります. 

*拡張機能が存在しない場合、サーバーは安全な再ネゴシエーションをサポートしません. secure_renegotiationフラグをFALSEに設定します. この場合、一部のクライアントは、続行する代わりにハンドシェイクを終了したい場合があります. 議論についてはセクション4.1を参照してください. 

*拡張機能が存在する場合は、secure_renegotiationフラグをTRUEに設定します. 次に、クライアントは「renegotiated_connection」フィールドの長さがゼロであることを確認する必要があり、そうでない場合は、ハンドシェイクを中止する必要があります（致命的なhandshake_failureアラートを送信することにより）. 

注：セクション3の後半では、「ハンドシェイクの中止」は「致命的なhandshake_failureアラートを送信して接続を終了する」の省略形として使用されます. 

oハンドシェイクが完了したら、クライアントは将来の使用のためにclient_verify_dataとserver_verify_dataの値を保存する必要があります. 

3.5. クライアントの動作：安全な再ネゴシエーション
このテキストは、接続の「secure_renegotiation」フラグがTRUEに設定されている場合に適用されます（FALSEに設定されている場合は、セクション4.2を参照してください）. 

oクライアントは、保存されたclient_verify_dataを含む「renegotiation_info」拡張機能をClientHelloに含める必要があります. SCSVを含めてはなりません. 

o ServerHelloを受信すると、クライアントは「renegotiation_info」拡張子が存在することを確認する必要があります. そうでない場合、クライアントはハンドシェイクを中止する必要があります. 

o次に、クライアントは、「renegotiated_connection」フィールドの前半が保存されたclient_verify_data値と等しく、後半が保存されたserver_verify_data値と等しいことを確認する必要があります. そうでない場合、クライアントはハンドシェイクを中止する必要があります. 

oハンドシェイクが完了したら、クライアントは新しいclient_verify_dataとserver_verify_dataの値を保存する必要があります. 

3.6. サーバーの動作：初期ハンドシェイク
このセクションとセクション3.7は、フルハンドシェイクとセッション再開ハンドシェイクの両方に適用されることに注意してください. 

o ClientHelloを受信すると、サーバーはTLS_EMPTY_RENEGOTIATION_INFO_SCSVSCSVが含まれているかどうかを確認する必要があります. 含まれている場合は、secure_renegotiationフラグをTRUEに設定します. 

oサーバーは、「renegotiation_info」拡張子がClientHelloに含まれているかどうかを確認する必要があります. 拡張機能が存在する場合は、secure_renegotiationフラグをTRUEに設定します. 次に、サーバーは「renegotiated_connection」フィールドの長さがゼロであることを確認する必要があり、そうでない場合は、ハンドシェイクを中止する必要があります. 

o TLS_EMPTY_RENEGOTIATION_INFO_SCSV SCSVも「renegotiation_info」拡張機能も含まれていない場合は、secure_renegotiationフラグをFALSEに設定します. この場合、一部のサーバーは続行する代わりにハンドシェイクを終了したい場合があります. 議論についてはセクション4.3を参照してください. 

o secure_renegotiationフラグがTRUEに設定されている場合、サーバーはServerHelloメッセージに空の「renegotiation_info」拡張子を含める必要があります. 

oハンドシェイクが完了したら、サーバーは将来の使用のためにclient_verify_dataとserver_verify_dataの値を保存する必要があります. 

この仕様を実装するTLSサーバーは、クライアントによって提供される不明な拡張機能を無視する必要があり、最大バージョン番号よりも大きいバージョン番号を受け入れて、最大共通バージョンをネゴシエートする必要があります. これらの2つの要件は、RFC 5246の既存の要件を繰り返しており、上位互換性のためにここに記載されているだけです. 

SCSVのみを含むClientHelloに応答して「renegotiation_info」拡張機能を送信することは、RFC 5246のセクション7.4.1.4で、一方的な拡張機能を送信するサーバーでの禁止の明示的な例外であり、クライアントがその意思を通知しているためにのみ許可されることに注意してください.  TLS_EMPTY_RENEGOTIATION_INFO_SCSVSCSVを介して拡張機能を受信します. TLS実装は、他のすべての拡張機能について、引き続きセクション7.4.1.4に準拠する必要があります. 

3.7. サーバーの動作：安全な再ネゴシエーション
このテキストは、接続の「secure_renegotiation」フラグがTRUEに設定されている場合に適用されます（FALSEに設定されている場合は、セクション4.4を参照してください）. 

o ClientHelloを受信すると、サーバーはTLS_EMPTY_RENEGOTIATION_INFO_SCSVSCSVが含まれていないことを確認する必要があります. SCSVが存在する場合、サーバーはハンドシェイクを中止する必要があります. 

oサーバーは、「renegotiation_info」拡張子が存在することを確認する必要があります. そうでない場合、サーバーはハンドシェイクを中止する必要があります. 

oサーバーは、「renegotiated_connection」フィールドの値が保存されたclient_verify_data値と等しいことを確認する必要があります. そうでない場合、サーバーはハンドシェイクを中止する必要があります. 

oサーバーは、ServerHelloに保存されたclient_verify_dataとserver_verify_dataを含む「renegotiation_info」拡張機能を含める必要があります. 

oハンドシェイクが完了したら、サーバーは新しいclient_verify_dataとserver_verify_dataの値を保存する必要があります. 

4.下位互換性
この拡張機能をサポートしない既存の実装は広く展開されており、一般に、この拡張機能をサポートする新しい実装と相互運用する必要があります. このセクションでは、下位互換性のある相互運用に関する考慮事項について説明します. 

4.1. クライアントに関する考慮事項
クライアントが「renegotiation_info」拡張機能またはTLS_EMPTY_RENEGOTIATION_INFO_SCSVSCSVを提供し、サーバーがServerHelloで「renegotiation_info」で応答しない場合、これはサーバーが安全な再ネゴシエーションをサポートしていないことを示します. 一部の攻撃（セクション1を参照）は、クライアントにとって1回のハンドシェイクのように見えるため、クライアントは接続が攻撃を受けているかどうかを判断できません. ただし、サーバーが拡張機能を認識しないからといって、それが脆弱であることを意味するわけではないことに注意してください. すべての再交渉を拒否し、単に通知しないことを選択する場合があります. ただし、これが当てはまるかどうかをクライアントがTLSメカニズムを介して純粋に判断することはできません. 

クライアントがそのような攻撃が不可能であることを確認したい場合は、ハンドシェイクを完了せずに拡張機能を受信できなかった場合、すぐに接続を終了する必要があります. このようなクライアントは、接続を終了する前に、致命的な「handshake_failure」アラートを生成する必要があります. ただし、再ネゴシエーションをサポートしない（したがって脆弱ではない）多くのTLSサーバーもこの拡張機能をサポートしないことが予想されるため、一般に、この動作を実装するクライアントは相互運用性の問題に遭遇します. 移行期間中にセキュリティを保証し、最大の相互運用性を実現する一連のクライアント動作はありません. クライアントは、アップグレードされていない可能性のあるサーバーを処理するときに、どちらか一方の設定を選択する必要があります. 

4.2. クライアントの動作：レガシー（安全でない）再ネゴシエーション
このテキストは、接続の「secure_renegotiation」フラグがFALSEに設定されている場合に適用されます. 

アップグレードされていないサーバーがクライアントに再ネゴシエーションを要求する可能性があります. クライアントがこの再ネゴシエーション要求を拒否することをお勧めします. そうするクライアントは、「no_renegotiation」アラートでそのような要求に応答する必要があります（RFC 5246では、このアラートが「警告」レベルである必要があります）. 明らかにアップグレードされていないサーバーが実際には攻撃者であり、クライアントが別の正当なアップグレードされたサーバーと再ネゴシエートすることを許可している可能性があります. それでもクライアントが再交渉を選択した場合は、以下に説明するように動作する必要があります. 

再交渉を選択したクライアントは、ClientHelloでTLS_EMPTY_RENEGOTIATION_INFO_SCSVSCSVまたは「renegotiation_info」のいずれかを提供する必要があります. アップグレードされていないサーバーとの正当な再ネゴシエーションでは、そのサーバーはこれらのシグナルの両方を無視する必要があります. ただし、サーバーが（誤って）拡張機能を無視できない場合、「renegotiation_info」拡張機能を送信すると、ハンドシェイクが失敗する可能性があります. したがって、推奨されていませんが、クライアントが単にSCSVを送信することは許可されています. これは、クライアントが再ネゴシエーションに使用されるClientHelloで「renegotiation_info」拡張子を送信しないことを許可されている唯一の状況です. 

ダウングレード攻撃の場合、これがサーバーの観点からの最初のハンドシェイクである場合、クライアントからのSCSVの使用は、サーバーによるこの攻撃の検出を妨げることに注意してください（これがサーバーの観点からの再ネゴシエーションである場合、攻撃を検出します）. ただし、サーバーが空の「renegotiation_info」拡張機能を送信し、クライアントが以前のverify_dataを含む拡張機能を予期している場合、攻撃はクライアントによって検出されます. 対照的に、クライアントが「renegotiation_info」拡張子を送信すると、サーバーはすぐに攻撃を検出します. 

ServerHelloを受信すると、クライアントは「renegotiation_info」拡張子が含まれていないことを確認する必要があります. 含まれている場合、クライアントはハンドシェイクを中止する必要があります. （サーバーは安全な再ネゴシエーションをサポートしていないことをすでに示しているため、これが発生する唯一の方法は、サーバーが壊れているか、攻撃があった場合です. ）

4.3. サーバーに関する考慮事項
クライアントが「renegotiation_info」拡張機能またはTLS_EMPTY_RENEGOTIATION_INFO_SCSVSCSVを提供していない場合、これはクライアントが安全な再ネゴシエーションをサポートしていないことを示しています. セクション1で説明されている攻撃は、2回の握手のように見えますが

サーバーでは、再ネゴシエーションがクライアントだけに見られる他の攻撃が発生する可能性があります. サーバーがそのような攻撃が不可能であることを確認したい場合は、安全な再ネゴシエーションの使用のネゴシエーションに失敗するとすぐに接続を終了する必要があります. パッチが適用されていないクライアントからの接続を許可することを選択したサーバーは、それらの接続の再ネゴシエーションを拒否することで、セクション1で説明した攻撃を防ぐことができます. 

クライアントがプローブできるようにするには、再ネゴシエーションをサポートしないサーバーでも、最初のハンドシェイクのためにこのドキュメントで説明されている拡張機能の最小バージョンを実装する必要があります. これにより、アップグレードされたことを通知します. 

4.4. サーバーの動作：レガシー（安全でない）再ネゴシエーション
このテキストは、接続の「secure_renegotiation」フラグがFALSEに設定されている場合に適用されます. 

サーバーはレガシー再ネゴシエーションを許可しないことをお勧めします. それでもサーバーが許可する場合は、このセクションの要件に従わなければなりません. 

o ClientHelloを受信すると、サーバーはTLS_EMPTY_RENEGOTIATION_INFO_SCSVSCSVが含まれていないことを確認する必要があります. SCSVが存在する場合、サーバーはハンドシェイクを中止する必要があります. 

oサーバーは、「renegotiation_info」拡張子が存在しないことを確認する必要があります. そうである場合、サーバーはハンドシェイクを中止しなければなりません（MUST）. 

4.5. SSLv3
SSLv3はIETF変更管理下のプロトコルではありませんが（[SSLv3]を参照）、TLSの元々の基盤であり、ほとんどのTLS実装もSSLv3をサポートしています. IETFは、SSLv3の実装で、このドキュメントで定義されている「renegotiation_info」拡張機能とSCSVを採用することを推奨しています. SCSVと拡張機能のセマンティクスは、verify_data値のサイズがそれぞれ36バイトであることを除いて、TLSスタックと同じです. これには、そのようなスタックに少なくとも最小限の拡張処理を追加する必要があることに注意してください. SSLv3をサポートし、（SCSVまたは "renegotiation_info"を介して）安全な再ネゴシエーションを提供するクライアントは、サーバーのバージョンが{0x03、0x00}であっても、サーバーからの "renegotiation_info"拡張子を受け入れ、この仕様で説明されているように動作する必要があります. 安全な再ネゴシエーションをサポートし、SSLv3をサポートするTLSサーバーは、SCSVまたは「renegotiation_info」拡張を受け入れ、提供されるクライアントバージョンが{0x03、0x00}であっても、この仕様に記載されているように応答する必要があります. SSLv3は、「no_renegotiation」アラートを定義していません（また、「警告」レベルでの再ネゴシエーションの拒否を示す方法を提供していません）. 再ネゴシエーションを拒否するSSLv3クライアントは、致命的なhandshake_failureアラートを使用する必要があります. 

5.セキュリティに関する考慮事項
このドキュメントで説明されている拡張機能は、TLSへの攻撃を防ぎます. この拡張機能が使用されていない場合、TLS再ネゴシエーションは攻撃の対象となり、攻撃者はクライアントの会話のプレフィックスとしてTLSサーバーとの独自の会話を挿入できます. この攻撃はクライアントには見えず、サーバーに対する通常の再ネゴシエーションのように見えます. このドキュメントで定義されている拡張機能により、再ネゴシエーションを安全に実行できます. サーバーは、クライアントがこの拡張機能を使用せずに再ネゴシエートすることを許可すべきではありません（SHOULDNOT）. 多くのサーバーは、再交渉をまったく拒否するだけで、この攻撃を軽減できます. 

この拡張機能は、概要で説明されているman-in-the-middle攻撃を軽減しますが、アプリケーションが再ネゴシエーションを認識していない場合に発生する可能性のあるすべての問題を解決するわけではありません. たとえば、再ネゴシエーション中に、クライアントまたはサーバーのいずれかが、以前に使用されたものとは異なる証明書を提示できます. これは、アプリケーション開発者（たとえば、「getPeerCertificates（）」API呼び出しが2回呼び出された場合に同じ値を返すことを期待していた可能性があります）にとっては驚きであり、安全でない方法で処理される可能性があります. 

TLS実装は、再ネゴシエーションを無効および有効にするメカニズムを提供する必要があります. 

TLS実装者は、再ネゴシエーションがアプリケーションに提供されるAPIとどのように相互作用するかを明確に文書化することをお勧めします（たとえば、どのAPI呼び出しが異なる呼び出しで異なる値を返すか、またはどのコールバックが複数回呼び出されるか）. 

再ネゴシエーションを使用するが、認証後に証明書が変更されることを期待しないアプリケーションの作業を簡素化するために、TLS実装では、ピアが別の証明書で認証しようとした場合に再ネゴシエーションを中止するオプションをアプリケーションに提供することもできます. または、以前に使用されたものとは異なるサーバー名（server_name拡張子内）. あるいは、TLS実装は、クライアント証明書が認証された後、再ネゴシエーションを無効にするオプションを提供する場合があります. ただし、すべてのアプリケーションでこれらのオプションをデフォルトで有効にすると、再ネゴシエーションを使用して証明書を変更することに依存している既存のアプリケーションが破損する可能性があります. （たとえば、長期間有効なTLS接続は更新された証明書に変更される可能性があります. または、再ネゴシエーションでは、別の証明書を使用する必要がある別の暗号スイートを選択できます. ）最後に、再ネゴシエーションに依存するアプリケーションの設計者は、多くのTLSAPIがアプリケーションデータを単純なオクテットストリームとして表すことに注意してください. アプリケーションは、再ネゴシエーションの前、最中、または後に、どのアプリケーションデータオクテットが受信されたかを正確に判別できない場合があります. 特に、ピアが再ネゴシエーション中に別の証明書を提示する場合、アプリケーションがデータを処理する方法を指定するときに注意が必要です. 

6.IANAの考慮事項
IANAは、プロトタイプの実装に使用されている拡張コードポイント65281（0xff01）を、TLSExtensionType値レジストリの「renegotiation_info」拡張に追加しました. 

IANAは、TLS_EMPTY_RENEGOTIATION_INFO_SCSVという名前のTLS暗号スイート番号0x00,0xFFをTLS暗号スイートレジストリに追加しました. 

7.謝辞
この脆弱性は、もともとMarsh Rayによって発見され、MartinRexによって独自に再発見されました. ここで説明する拡張機能の背後にある一般的な概念は、Steve Dispensa、Nasko Oskov、Eric Rescorlaによって独自に考案され、Nelson Bolyard、Pasi Eronen、Michael D'Errico、Stephen Farrell、Michael Grey、David-Sarah Hopwood、Ben Laurie、Davidから改良されました.  Makepeace、Bodo Moeller、Martin Rex、Peter Robinson、Jesse Walker、Nico Williams、およびProjectMogulチームとTLSWGの他のメンバー. 

8.参考文献
8.1. 規範的参考文献
[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月. 

[RFC5246] Dierks、T. およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、2008年8月. 

8.2. 有益な参考文献
[RFC4347] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security」、RFC 4347、2006年4月. 

[RFC5056] Williams、N. 、「セキュリティで保護されたチャネルへのチャネルバインディングの使用について」、RFC 5056、2007年11月. 

[TLS-CHANNEL-BINDINGS] Altman、J.、Williams、N. 、およびL. Zhu、「TLSのチャネルバインディング」、作業中、2009年10月. 

[RFC2818] Rescorla、E. 、「HTTP Over TLS」、RFC 2818、2000年5月. 

[RFC2965] Kristol、D. およびL. Montulli、「HTTP状態管理メカニズム」、RFC 2965、2000年10月. 

[Ray09] Ray、M. 、「TLS再ネゴシエーションの認証ギャップ」、2009年11月、<http://extendedsubset.com/?p=8>. 

[SSLv3] Freier、A.、Karlton、P. 、およびP. Kocher、「SSLプロトコルバージョン3.0」、作業中、1996年11月. 

著者の住所

Eric Rescorla RTFM、Inc. 2064 Edgewood Drive Palo Alto、CA 94303 USA

Eメール：ekr@rtfm.com

Marsh Ray PhoneFactor 7301 W 129th Street Overland Park、KS 66213 USA

Eメール：marsh@extendedsubset.com

Steve Dispensa PhoneFactor 7301 W 129th Street Overland Park、KS 66213 USA

Eメール：dispensa@phonefactor.com

Nasko Oskov Microsoft One Microsoft Way Redmond、WA 98052 USA

Eメール：nasko.oskov@microsoft.com