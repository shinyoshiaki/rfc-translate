RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
5246
RFC 5246-トランスポート層セキュリティ（TLS）プロトコルバージョン1. 2日本語訳
URL：https：//tools.ietf.org/html/rfc5246
パッケージ：RFC 5246-トランスポート層セキュリティ（TLS）プロトコルバージョン1.2
翻訳：自動翻訳
ネットワークワーキンググループT.Dierks
コメントのリクエスト：5246独立
廃止：3268、4346、4366 E. Rescorla
更新：4492 RTFM、Inc. 
カテゴリ：標準化過程2008年8月
        
トランスポート層セキュリティ（TLS）プロトコルバージョン1.2

このメモのステータス

このドキュメントは、インターネットコミュニティのインターネット標準追跡プロトコルを指定し、改善のための議論と提案を要求します. このプロトコルの標準化の状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください. このメモの配布は無制限です. 

概要

このドキュメントでは、トランスポート層セキュリティ（TLS）プロトコルのバージョン1.2を指定しています. TLSプロトコルは、インターネットを介した通信セキュリティを提供します. このプロトコルにより、クライアント/サーバーアプリケーションは、盗聴、改ざん、またはメッセージの偽造を防止するように設計された方法で通信できます. 

目次

   1.はじめに.........................................................  ..... 4
      1.1. 要件の用語................................... 5
      1.2. TLS1.1との主な違い............................. 5
   2.目標...............................................  ............ 6
   3.このドキュメントの目的.......................................... 7
   4.プレゼンテーション言語........................................... 7
      4.1. 基本ブロックサイズ........................................... 7
      4.2. その他.............................................. 8
      4.3. ベクトル.................................................  ... 8
      4.4. 数字.................................................  ... 9
      4.5. 列挙................................................ 9
      4.6. 構築されたタイプ......................................... 10
           4.6.1. バリアント........................................... 10
      4.7. 暗号属性.................................. 12
      4.8. 定数.................................................  14
   5.HMACと疑似乱数関数............................. 14
   6.TLSレコードプロトコル........................................ 15
      6.1. 接続状態......................................... 16
      6.2. レコードレイヤー.............................................. 19
           6.2.1. 断片化...................................... 19
        
           6.2.2. レコードの圧縮と解凍............... 20
           6.2.3. ペイロード保護の記録.......................... 21
                  6.2.3.1. ヌルまたは標準ストリーム暗号............ 22
                  6.2.3.2. CBCブロック暗号.......................... 22
                  6.2.3.3. AEAD暗号.............................. 24
      6.3. キーの計算........................................... 25
   7.TLSハンドシェイクプロトコル.................................. 26
      7.1. 暗号仕様プロトコルの変更............................... 27
      7.2. アラートプロトコル............................................ 28
           7.2.1. 閉鎖アラート..................................... 29
           7.2.2. エラーアラート....................................... 30
      7.3. ハンドシェイクプロトコルの概要............................... 33
      7.4. ハンドシェイクプロトコル........................................ 37
           7.4.1. こんにちはメッセージ..................................... 38
                  7.4.1.1. こんにちはリクエスト............................. 38
                  7.4.1.2. クライアントこんにちは.............................. 39
                  7.4.1.3. サーバーこんにちは.............................. 42
                  7.4.1.4. こんにちは拡張機能.......................... 44
                           7.4.1.4.1. 署名アルゴリズム........... 45
           7.4.2. サーバー証明書................................. 47
           7.4.3. サーバーキー交換メッセージ........................ 50
           7.4.4. 証明書の要求................................ 53
           7.4.5. サーバーこんにちは完了.................................. 55
           7.4.6. クライアント証明書................................. 55
           7.4.7. クライアントキー交換メッセージ........................ 57
                  7.4.7.1. RSA暗号化プリマスターシークレットメッセージ.... 58
                  7.4.7.2. クライアントディフィーヘルマン公開値........ 61
           7.4.8. 証明書の検証................................. 62
           7.4.9. 終了........................................... 63
   8.暗号計算..................................... 64
      8.1. マスターシークレットの計算............................... 64
           8.1.1. RSA ................................................ 65
           8.1.2. Diffie-Hellman ..................................... 65
   9.必須の暗号スイート........................................ 65
   10.アプリケーションデータプロトコル..................................... 65
   11.セキュリティに関する考慮事項....................................... 65
   12.IANAの考慮事項........................................... 65
   付録A.プロトコルデータ構造と定数値.......... 68
      A.1. レコードレイヤー.............................................. 68
      A.2. 暗号仕様の変更メッセージ............................... 69
      A.3. 警告メッセージ............................................ 69
      A.4. ハンドシェイクプロトコル........................................ 70
           A.4.1. こんにちはメッセージ..................................... 71
           A.4.2. サーバー認証と鍵交換メッセージ.... 72
           A.4.3. クライアント認証と鍵交換メッセージ.... 74
           A.4.4. ハンドシェイクファイナライズメッセージ..................... 74
      A.5. 暗号スイート.......................................... 75
      A.6. セキュリティパラメータ................................... 77
        
      A.7. RFC4492への変更....................................... 78
   付録B.用語集..............................................  78
   付録C.暗号スイートの定義.............................. 83
   付録D.実装上の注意.................................. 85
      D.1. 乱数の生成とシード...................... 85
      D.2. 証明書と認証........................... 85
      D.3. 暗号スイート............................................. 85
      D.4. 実装の落とし穴................................... 85
   付録E.下位互換性................................ 87
      E.1. TLS 1.0 /1.1およびSSL3.0との互換性................ 87
      E.2. SSL2.0との互換性................................ 88
      E.3. Man-in-the-Middleバージョンのロールバックの回避............... 90
   付録F.セキュリティ分析..................................... 91
      F.1. ハンドシェイクプロトコル........................................ 91
           F.1.1. 認証と鍵交換.................... 91
                  F.1.1.1. 匿名鍵交換.................... 91
                  F.1.1.2. RSAキー交換と認証....... 92
                  F.1.1.3. Diffie-Hellman Key Exchange with
                           認証............................ 92
           F.1.2. バージョンのロールバック攻撃........................... 93
           F.1.3. ハンドシェイクプロトコルに対する攻撃の検出... 94
           F.1.4. セッションの再開.................................. 94
      F.2. アプリケーションデータの保護............................... 94
      F.3. 明示的なIV .............................................. 95
      F.4. 複合暗号モードのセキュリティ........................ 95
      F.5. サービス拒否......................................... 96
      F.6. ファイナルノート......................................................... 96
   規範的参考文献.............................................. 97
   有益な参考資料............................................ 98
   ワーキンググループ情報........................................ 101
   寄稿者.................................................  .... 101
        
1.はじめに
TLSプロトコルの主な目標は、通信する2つのアプリケーション間にプライバシーとデータの整合性を提供することです. このプロトコルは、TLSレコードプロトコルとTLSハンドシェイクプロトコルの2つの層で構成されています. 信頼できるトランスポートプロトコル（TCP [TCP]など）の上に階層化された最下位レベルは、TLSレコードプロトコルです. TLSレコードプロトコルは、2つの基本的なプロパティを持つ接続セキュリティを提供します. 

-接続はプライベートです. データの暗号化には対称暗号化が使用されます（例：AES [AES]、RC4 [SCH]など）. この対称暗号化のキーは、接続ごとに一意に生成され、別のプロトコル（TLSハンドシェイクプロトコルなど）によってネゴシエートされたシークレットに基づいています. レコードプロトコルは、暗号化せずに使用することもできます. 

-接続は信頼できます. メッセージトランスポートには、キー付きMACを使用したメッセージ整合性チェックが含まれます. MAC計算には、セキュアハッシュ関数（SHA-1など）が使用されます. レコードプロトコルはMACなしで動作できますが、通常はこのモードでのみ使用され、別のプロトコルがセキュリティパラメータをネゴシエートするためのトランスポートとしてレコードプロトコルを使用しています. 

TLSレコードプロトコルは、さまざまな高レベルプロトコルのカプセル化に使用されます. このようなカプセル化されたプロトコルの1つであるTLSハンドシェイクプロトコルを使用すると、サーバーとクライアントは相互に認証し、アプリケーションプロトコルがデータの最初のバイトを送受信する前に暗号化アルゴリズムと暗号化キーをネゴシエートできます. TLSハンドシェイクプロトコルは、次の3つの基本的なプロパティを持つ接続セキュリティを提供します. 

-ピアのIDは、非対称暗号化または公開鍵暗号化（RSA [RSA]、DSA [DSS]など）を使用して認証できます. この認証はオプションにすることができますが、通常、少なくとも1つのピアに必要です. 

-共有シークレットのネゴシエーションは安全です. ネゴシエートされたシークレットは盗聴者が利用できず、認証された接続では、接続の途中に身を置くことができる攻撃者でもシークレットを取得できません. 

-ネゴシエーションは信頼できます. 攻撃者は、通信の当事者によって検出されることなく、ネゴシエーション通信を変更することはできません. 

TLSの利点の1つは、アプリケーションプロトコルに依存しないことです. 高レベルのプロトコルは、TLSプロトコルの上に透過的に重ねることができます. ただし、TLS標準では、プロトコルがTLSでセキュリティを追加する方法を指定していません. TLSハンドシェイクを開始する方法と、交換された認証証明書を解釈する方法に関する決定は、TLS上で実行されるプロトコルの設計者と実装者の判断に委ねられています. 

1.1. 要件の用語
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」は次のとおりです.  RFC 2119 [REQ]で説明されているように解釈されます. 

1.2. TLS1.1との主な違い
このドキュメントは、TLS 1.1 [TLS1.1]プロトコルの改訂版であり、特に暗号化アルゴリズムのネゴシエーションのための柔軟性が向上しています. 主な変更点は次のとおりです. 

-疑似ランダム関数（PRF）のMD5 / SHA-1の組み合わせは、暗号スイートで指定されたPRFに置き換えられました. このドキュメントのすべての暗号スイートはP_SHA256を使用します. 

-デジタル署名された要素のMD5 / SHA-1の組み合わせは、単一のハッシュに置き換えられました. 署名された要素には、使用されるハッシュアルゴリズムを明示的に指定するフィールドが含まれるようになりました. 

-受け入れるハッシュおよび署名アルゴリズムを指定するクライアントおよびサーバーの機能の大幅なクリーンアップ. これにより、以前のバージョンのTLSからの署名およびハッシュアルゴリズムに対する制約の一部も緩和されることに注意してください. 

-追加のデータモードによる認証付き暗号化のサポートの追加. 

-TLS拡張定義とAES暗号スイートが外部の[TLSEXT]と[TLSAES]からマージされました. 

-EncryptedPreMasterSecretのバージョン番号のより厳密なチェック. 

-いくつかの要件を厳しくしました. 

-Verify_dataの長さは暗号スイートに依存するようになりました（デフォルトは12のままです）. 

--Bleichenbacher / Klimaの攻撃防御の説明をクリーンアップしました. 

-多くの場合、アラートを送信する必要があります. 

-certificate_requestの後、使用可能な証明書がない場合、クライアントは空の証明書リストを送信する必要があります. 

-TLS_RSA_WITH_AES_128_CBC_SHAは、暗号スイートを実装するために必須になりました. 

-HMAC-SHA256暗号スイートを追加しました. 

-IDEAおよびDES暗号スイートを削除しました. これらは非推奨になり、別のドキュメントに記載される予定です. 

-SSLv2の下位互換性のあるhelloのサポートは、SHOULDではなくMAYになり、SHOULDNOTを送信するようになりました. サポートはおそらく将来的にすべきではありません. 

-プレゼンテーション言語に限定的な「フォールスルー」を追加して、複数のケースアームが同じエンコーディングを持つことができるようにしました. 

-実装の落とし穴セクションを追加しました

-通常の説明と編集作業. 

2.目標
TLSプロトコルの目標は、優先度の高い順に次のとおりです. 

1.暗号化セキュリティ：TLSを使用して、2者間の安全な接続を確立する必要があります. 

2.相互運用性：独立したプログラマーは、TLSを利用して、互いのコードを知らなくても暗号化パラメーターを正常に交換できるアプリケーションを開発できる必要があります. 

3.拡張性：TLSは、必要に応じて新しい公開鍵とバルク暗号化方式を組み込むことができるフレームワークを提供しようとしています. これにより、2つのサブ目標も達成されます. 新しいプロトコルを作成する必要性を防ぐ（そして、新しい弱点が発生するリスクを冒す）ことと、新しいセキュリティライブラリ全体を実装する必要性を回避することです. 

4.相対的な効率：暗号化操作、特に公開鍵操作は、CPUに非常に負荷がかかる傾向があります. このため、TLSプロトコルには、最初から確立する必要のある接続の数を減らすために、オプションのセッションキャッシュスキームが組み込まれています. さらに、ネットワークアクティビティを減らすように注意が払われています. 

3.このドキュメントの目的
このドキュメントとTLSプロトコル自体は、Netscapeによって公開されているSSL3.0プロトコル仕様に基づいています. このプロトコルとSSL3.0の違いは劇的ではありませんが、TLSとSSL 3.0のさまざまなバージョンが相互運用しないほど重要です（ただし、各プロトコルには、実装を以前のバージョンに戻すことができるメカニズムが組み込まれています）. このドキュメントは、主にプロトコルを実装する読者と、プロトコルの暗号化分析を行う読者を対象としています. 仕様はこれを念頭に置いて作成されており、これら2つのグループのニーズを反映することを目的としています. そのため、アルゴリズムに依存するデータ構造とルールの多くは、（付録ではなく）テキストの本文に含まれており、それらに簡単にアクセスできます. 

このドキュメントは、サービス定義またはインターフェイス定義の詳細を提供することを目的としていませんが、堅固なセキュリティの維持に必要なポリシーの特定の領域をカバーしています. 

4.プレゼンテーション言語
このドキュメントでは、外部表現でのデータのフォーマットについて説明します. 次の非常に基本的でややカジュアルに定義されたプレゼンテーション構文が使用されます. 構文は、その構造内のいくつかのソースから取得されます. 構文はプログラミング言語「C」に、構文と意図はXDR [XDR]に似ていますが、あまりにも多くの類似点を描くのは危険です. このプレゼンテーション言語の目的は、TLSのみを文書化することです. その特定の目標を超える一般的な用途はありません. 

4.1. 基本ブロックサイズ
すべてのデータ項目の表現は明示的に指定されています. 基本的なデータブロックサイズは1バイト（つまり、8ビット）です. 複数バイトのデータ項目は、左から右、上から下へのバイトの連結です. バイトストリームから、マルチバイト項目（例では数値）が（C表記を使用して）次のように形成されます. 

      値=（byte [0] << 8 *（n-1））| （バイト[1] << 8 *（n-2））|
              ... | バイト[n-1];
        
マルチバイト値のこのバイト順序は、一般的なネットワークバイト順序またはビッグエンディアン形式です. 

4.2. その他
コメントは「/ *」で始まり、「* /」で終わります. 

オプションのコンポーネントは、「[[]]」の二重括弧で囲むことによって示されます. 

解釈されないデータを含むシングルバイトエンティティは、不透明（OPAQUE）型です. 

4.3. ベクトル
ベクトル（一次元配列）は、同種のデータ要素のストリームです. ベクトルのサイズは、文書化時に指定することも、実行時まで指定しないでおくこともできます. いずれの場合も、長さはベクトル内の要素数ではなくバイト数を宣言します. タイプTの固定長ベクトルである新しいタイプT 'を指定するための構文は次のとおりです. 

T T '[n];

ここで、T 'はデータストリーム内でnバイトを占めます. ここで、nはTのサイズの倍数です. ベクトルの長さはエンコードされたストリームに含まれません. 

次の例では、データはプロトコルが解釈しない3つの連続したバイトとして定義されていますが、データは3つの連続したデータであり、合計9バイトを消費します. 

      不透明なデータム[3]; / * 3つの未解釈バイト* /
      データムデータ[9]; / * 3つの連続する3バイトベクトル* /
        
可変長ベクトルは、表記<floor..ceiling>を使用して、有効な長さのサブ範囲を包括的に指定することによって定義されます. これらがエンコードされると、実際の長さはバイトストリーム内のベクトルの内容に先行します. 長さは、ベクトルの指定された最大（上限）長を保持するために必要な数のバイトを消費する数値の形式になります. 実際の長さフィールドがゼロの可変長ベクトルは、空のベクトルと呼ばれます. 

      T T '<floor..ceiling>;
        
次の例では、必須は不透明（OPAQUE）型の300〜400バイトを含む必要があるベクトルです. 空になることはありません. 実際の長さフィールドは、値400を表すのに十分な2バイトのuint16を消費します（セクション4.4を参照）. 一方、longerは、最大800バイトのデータまたは400 uint16要素を表すことができ、空の場合があります. そのエンコーディングには、ベクトルの前に2バイトの実際の長さフィールドが含まれます. エンコードされたベクトルの長さは、単一要素の長さの偶数倍でなければなりません（たとえば、uint16の17バイトのベクトルは違法です）. 

      不透明必須<300..400>;
            / *長さフィールドは2バイトで、空にすることはできません* /
      uint16 long <0..800>;
            / *ゼロから400の16ビット符号なし整数* /
        
4.4. 数字
基本的な数値データ型は符号なしバイト（uint8）です. すべての大きな数値データ型は、セクション4.1で説明されているように連結された固定長の一連のバイトから形成され、符号なしでもあります. 次の数値タイプは事前定義されています. 

      uint8 uint16 [2];
      uint8 uint24 [3];
      uint8 uint32 [4];
      uint8 uint64 [8];
        
ここおよび仕様の他の場所にあるすべての値は、ネットワークバイト（ビッグエンディアン）の順序で格納されます. 16進バイト0102 03 04で表されるuint32は、10進値16909060と同等です. 

場合によっては（DHパラメータなど）、整数を不透明なベクトルとして表す必要があることに注意してください. このような場合、それらは符号なし整数として表されます（つまり、最上位ビットが設定されている場合でも、先行ゼロオクテットは必要ありません）. 

4.5. 列挙
enumと呼ばれる追加のスパースデータ型が利用可能です. 列挙型のフィールドは、定義で宣言された値のみを想定できます. それぞれの定義は異なるタイプです. 同じタイプの列挙型のみを割り当てたり、比較したりできます. 次の例に示すように、列挙されたすべての要素に値を割り当てる必要があります. 列挙された要素は順序付けられていないため、任意の一意の値を任意の順序で割り当てることができます. 

      列挙型{e1（v1）、e2（v2）、...、en（vn）[[、（n）]]} Te;
        
列挙されたものは、バイトストリーム内で、定義された最大の順序値と同じ量のスペースを占有します. 次の定義では、Colorタイプのフィールドを運ぶために1バイトが使用されます. 

      列挙型{赤（3）、青（5）、白（7）}色;
        
オプションで、関連するタグなしで値を指定して、余分な要素を定義せずに幅の定義を強制することができます. 

次の例では、Tasteはデータストリームで2バイトを消費しますが、値1、2、または4しか想定できません. 

      列挙型{sweet（1）、sour（2）、bitter（4）、（32000）}味;
        
列挙型の要素の名前は、定義された型内でスコープされます. 最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueになります. 割り当てのターゲットが適切に指定されている場合、このような資格は必要ありません. 

      色color = Color.blue; / *過剰指定、合法* /
      色color =青; / *正解、暗黙的に入力* /
        
外部表現に変換されない列挙の場合、数値情報は省略できます. 

      列挙型{低、中、高}量;
        
4.6. 構築されたタイプ
構造型は、便宜上、プリミティブ型から構築できます. 各仕様は、新しい一意のタイプを宣言しています. 定義の構文はCの構文とよく似ています. 

      構造体{
          T1 f1;
          T2 f2;
          ... 
          Tn fn;
      } [[T]];
        
構造内のフィールドは、列挙型で使用できる構文とよく似た構文で、型の名前を使用して修飾できます. たとえば、T.f2は前の宣言の2番目のフィールドを参照します. 構造定義を埋め込むことができます. 

4.6.1. バリアント
定義された構造には、環境内で利用可能ないくつかの知識に基づいたバリアントが含まれる場合があります. セレクターは、構造体が定義する可能性のあるバリアントを定義する列挙型である必要があります. selectで宣言された列挙のすべての要素にケースアームが必要です. ケースアームのフォールスルーは限られています. 2つのケースアームがフィールドを挟まずに連続して続く場合、両方に同じフィールドが含まれます. したがって、以下の例では、「オレンジ」と「バナナ」の両方にV2が含まれています. これはTLS1.2の新しい構文であることに注意してください. 

バリアント構造の本体には、参照用のラベルを付けることができます. 実行時にバリアントが選択されるメカニズムは、プレゼンテーション言語によって規定されていません. 

      構造体{
          T1 f1;
          T2 f2;
          .... 
          Tn fn;
           選択（E）{
               ケースe1：Te1;
               ケースe2：Te2;
               ケースe3：ケースe4：Te3;
               .... 
               ケースen：10;
           } [[F V]];
      } [[Tv]];
        
例えば：

      列挙型{リンゴ、オレンジ、バナナ} VariantTag;
        
      構造体{
          uint16番号;
          不透明な文字列<0..10>; / *可変長* /
      } V1;
        
      構造体{
          uint32番号;
          不透明な文字列[10]; / *固定長* /
      } V2;
        
      構造体{
          select（VariantTag）{/ *セレクターの値は暗黙的です* /
              ケースアップル：
                V1; / * VariantBody、タグ=アップル* /
              ケースオレンジ：
              ケースバナナ：
                V2; / * VariantBody、タグ=オレンジまたはバナナ* /
          } Variant_body; / *バリアントのオプションのラベル* /
      } VariantRecord;
        
4.7. 暗号属性
5つの暗号化操作（デジタル署名、ストリーム暗号化暗号化、ブロック暗号化暗号化、追加データによる認証付き暗号化（AEAD）暗号化、および公開鍵暗号化）は、デジタル署名、ストリーム暗号化、ブロック暗号化、aead暗号化として指定されます.  、およびpublic-key-encrypted、それぞれ. フィールドの暗号化処理は、フィールドのタイプ指定の前に適切なキーワード指定を付加することによって指定されます. 暗号化キーは、現在のセッション状態によって暗示されます（セクション6.1を参照）. 

デジタル署名された要素は、構造体DigitallySignedとしてエンコードされます. 

      構造体{
         SignatureAndHashAlgorithmアルゴリズム;
         不透明な署名<0..2 ^ 16-1>;
      } DigitallySigned;
        
アルゴリズムフィールドは、使用されるアルゴリズムを指定します（このフィールドの定義については、セクション7.4.1.4.1を参照してください）. アルゴリズムフィールドの導入は、以前のバージョンからの変更であることに注意してください. 署名は、要素のコンテンツに対してこれらのアルゴリズムを使用するデジタル署名です. 内容自体はワイヤーに表示されませんが、単純に計算されます. 署名の長さは、署名アルゴリズムとキーによって指定されます. 

RSA署名では、不透明なベクトルには、[PKCS1]で定義されているRSASSA-PKCS1-v1_5署名スキームを使用して生成された署名が含まれます. [PKCS1]で説明されているように、DigestInfoはDERエンコードされている必要があります[X680] [X690]. パラメータのないハッシュアルゴリズム（SHA-1を含む）の場合、DigestInfo.AlgorithmIdentifier.parametersフィールドはNULLでなければなりませんが、実装はパラメータなしとNULLパラメータありの両方を受け入れる必要があります. 以前のバージョンのTLSは、DigestInfoエンコーディングを含まない別のRSA署名スキームを使用していたことに注意してください. 

DSAでは、SHA-1ハッシュの20バイトは、追加のハッシュなしでデジタル署名アルゴリズムを介して直接実行されます. これにより、rとsの2つの値が生成されます. DSA署名は、上記のように不透明なベクトルであり、その内容は次のDERエンコーディングです. 

      Dss-Sig-Value :: = SEQUENCE {
          r INTEGER、
          s INTEGER
      }
        
注：現在の用語では、DSAはデジタル署名アルゴリズムを指し、DSSはNIST標準を指します. 元のSSLおよびTLS仕様では、「DSS」が広く使用されていました. このドキュメントでは、「DSA」を使用してアルゴリズムを参照し、「DSS」を使用して標準を参照し、コードポイント定義で「DSS」を使用して履歴の連続性を示します. 

ストリーム暗号暗号化では、平文は、暗号的に安全なキー付き疑似乱数ジェネレーターから生成された同じ量の出力と排他的OR演算されます. 

ブロック暗号暗号化では、平文のすべてのブロックが暗号文のブロックに暗号化されます. すべてのブロック暗号暗号化はCBC（Cipher Block Chaining）モードで実行され、ブロック暗号化されるすべてのアイテムは暗号ブロック長の正確な倍数になります. 

AEAD暗号化では、平文は同時に暗号化され、整合性が保護されます. 入力は任意の長さにすることができ、整合性チェック値に対応するために、認証付き出力は一般に入力よりも大きくなります. 

公開鍵暗号化では、公開鍵アルゴリズムを使用して、一致する秘密鍵でのみ復号化できるようにデータを暗号化します. 公開鍵で暗号化された要素は、不透明なベクトル<0..2 ^ 16-1>としてエンコードされます. ここで、長さは暗号化アルゴリズムと鍵によって指定されます. 

RSA暗号化は、[PKCS1]で定義されているRSAES-PKCS1-v1_5暗号化スキームを使用して行われます. 

次の例では

      ストリーム暗号化された構造体{
          uint8 field1;
          uint8 field2;
          デジタル署名された不透明{
            uint8 field3 <0..255>;
            uint8 field4;
          };
      } ユーザータイプ;
        
内部構造体の内容（field3およびfield4）は、署名/ハッシュアルゴリズムの入力として使用され、構造全体がストリーム暗号で暗号化されます. この構造の長さ（バイト単位）は、field1とfield2の2バイト、署名とハッシュアルゴリズムの2バイト、署名の長さの2バイト、および署名アルゴリズムの出力の長さに等しくなります.  . この構造をエンコードまたはデコードする前に、署名に使用されるアルゴリズムとキーがわかっているため、署名の長さはわかっています. 

4.8. 定数
型付き定数は、目的の型のシンボルを宣言し、それに値を割り当てることにより、仕様の目的で定義できます. 

指定が不足しているタイプ（不透明、可変長ベクトル、および不透明を含む構造）には値を割り当てることができません. 複数要素の構造またはベクトルのフィールドを削除することはできません. 

例えば：

      構造体{
          uint8 f1;
          uint8 f2;
      }例1;
        
      例1ex1 = {1、4}; / * f1 = 1、f2 = 4を割り当てます* /
        
5.HMACと疑似乱数関数
TLSレコード層は、キー付きメッセージ認証コード（MAC）を使用してメッセージの整合性を保護します. このドキュメントで定義されている暗号スイートは、ハッシュ関数に基づく[HMAC]で説明されているHMACと呼ばれる構造を使用しています. 他の暗号スイートは、必要に応じて独自のMAC構造を定義できます（MAY）. 

さらに、キーの生成または検証の目的で、秘密をデータのブロックに拡張するための構築が必要です. この疑似ランダム関数（PRF）は、入力としてシークレット、シード、および識別ラベルを受け取り、任意の長さの出力を生成します. 

このセクションでは、HMACに基づいて1つのPRFを定義します. SHA-256ハッシュ関数を備えたこのPRFは、このドキュメントで定義されているすべての暗号スイートと、TLS1.2がネゴシエートされるときにこのドキュメントより前に公開されたTLSドキュメントで使用されます. 新しい暗号スイートは、PRFを明示的に指定する必要があり、一般に、SHA-256またはより強力な標準ハッシュ関数でTLSPRFを使用する必要があります. 

最初に、単一のハッシュ関数を使用してシークレットとシードを任意の量の出力に拡張するデータ拡張関数P_hash（secret、data）を定義します. 

P_hash（シークレット、シード）= HMAC_hash（シークレット、A（1）+シード）+ HMAC_hash（シークレット、A（2）+シード）+ HMAC_hash（シークレット、A（3）+シード）+ .. ..

ここで、+は連結を示します. 

A（）は次のように定義されます. 

      A（0）=シード
      A（i）= HMAC_hash（secret、A（i-1））
        
P_hashは、必要な量のデータを生成するために必要な回数だけ繰り返すことができます. たとえば、P_SHA256を使用して80バイトのデータを作成する場合、（A（3）を介して）3回繰り返す必要があり、96バイトの出力データを作成します. 最後の反復の最後の16バイトは破棄され、80バイトの出力データが残ります. 

TLSのPRFは、次のようにシークレットにP_hashを適用することによって作成されます. 

      PRF（シークレット、ラベル、シード）= P_ <ハッシュ>（シークレット、ラベル+シード）
        
ラベルはASCII文字列です. 長さバイトまたは末尾のヌル文字なしで指定された正確な形式で含める必要があります. たとえば、ラベル「slithy toves」は、次のバイトをハッシュすることによって処理されます. 

73 6C 69 74 68 79 20 74 6F 76 65 73

6.TLSレコードプロトコル
TLSレコードプロトコルは階層化されたプロトコルです. 各レイヤーで、メッセージには長さ、説明、およびコンテンツのフィールドが含まれる場合があります. Record Protocolは、送信するメッセージを受け取り、データを管理可能なブロックにフラグメント化し、オプションでデータを圧縮し、MACを適用し、暗号化して、結果を送信します. 受信したデータは、復号化、検証、解凍、再構築されてから、上位レベルのクライアントに配信されます. 

このドキュメントでは、レコードプロトコルを使用する4つのプロトコル、ハンドシェイクプロトコル、アラートプロトコル、暗号仕様変更プロトコル、およびアプリケーションデータプロトコルについて説明します. TLSプロトコルの拡張を可能にするために、追加のレコードコンテンツタイプをレコードプロトコルでサポートできます. 新しいレコードコンテンツタイプの値は、セクション12で説明されているように、TLSコンテンツタイプレジストリのIANAによって割り当てられます. 

実装は、何らかの拡張機能によってネゴシエートされない限り、このドキュメントで定義されていないレコードタイプを送信してはなりません（MUSTNOT）. TLS実装が予期しないレコードタイプを受信した場合、予期しないメッセージアラートを送信する必要があります. 

TLSを介して使用するように設計されたプロトコルは、それに対するすべての可能な攻撃に対処するように注意深く設計する必要があります. 実際問題として、これは、プロトコル設計者がTLSが提供するセキュリティプロパティと提供しないセキュリティプロパティを認識している必要があり、後者に安全に依存できないことを意味します. 

特に、レコードのタイプと長さは暗号化によって保護されていないことに注意してください. この情報自体が機密情報である場合、アプリケーション設計者は、情報漏えいを最小限に抑えるための手順（パディング、トラフィックのカバー）を実行することをお勧めします. 

6.1. 接続状態
TLS接続状態は、TLSレコードプロトコルの動作環境です. 圧縮アルゴリズム、暗号化アルゴリズム、およびMACアルゴリズムを指定します. さらに、これらのアルゴリズムのパラメーターは既知です. 読み取り方向と書き込み方向の両方で接続するためのMACキーとバルク暗号化キーです. 論理的には、未処理の接続状態は常に4つあります. 現在の読み取りと書き込みの状態、および保留中の読み取りと書き込みの状態です. すべてのレコードは、現在の読み取りおよび書き込み状態で処理されます. 保留状態のセキュリティパラメータはTLSハンドシェイクプロトコルによって設定でき、ChangeCipherSpecは保留状態のいずれかを選択的に現在の状態にすることができます. この場合、適切な現在の状態が破棄され、保留状態に置き換えられます. その後、保留状態は空の状態に再初期化されます. セキュリティパラメータで初期化されていない状態を現在の状態にすることは違法です. 初期の現在の状態は、暗号化、圧縮、またはMACが使用されないことを常に指定します. 

TLS接続の読み取りおよび書き込み状態のセキュリティパラメータは、次の値を指定することによって設定されます. 

接続終了このエンティティがこの接続で「クライアント」または「サーバー」と見なされるかどうか. 

PRFアルゴリズムマスターシークレットからキーを生成するために使用されるアルゴリズム（セクション5および6.3を参照）. 

バルク暗号化アルゴリズムバルク暗号化に使用されるアルゴリズム. この仕様には、このアルゴリズムのキーサイズ、ブロック、ストリーム、またはAEAD暗号のいずれであるか、暗号のブロックサイズ（該当する場合）、および明示的および暗黙的な初期化ベクトル（またはナンス）の長さが含まれます. 

MACアルゴリズムメッセージ認証に使用されるアルゴリズム. この仕様には、MACアルゴリズムによって返される値のサイズが含まれています. 

圧縮アルゴリズムデータ圧縮に使用されるアルゴリズム. この仕様には、アルゴリズムが圧縮を行うために必要なすべての情報を含める必要があります. 

マスターシークレット接続内の2つのピア間で共有される48バイトのシークレット. 

clientrandomクライアントによって提供される32バイトの値. 

サーバーランダムサーバーによって提供される32バイトの値. 

これらのパラメーターは、プレゼンテーション言語で次のように定義されています. 

      列挙型{サーバー、クライアント} ConnectionEnd;
        
      列挙型{tls_prf_sha256} PRFAlgorithm;
        
      列挙型{null、rc4、3des、aes}
        BulkCipherAlgorithm;
        
      列挙型{ストリーム、ブロック、aead} CipherType;
        
      列挙型{null、hmac_md5、hmac_sha1、hmac_sha256、
           hmac_sha384、hmac_sha512} MACAlgorithm;
        
      列挙型{null（0）、（255）} CompressionMethod;
        
      / * CompressionMethod、PRFAlgorithm、で指定されたアルゴリズム
         BulkCipherAlgorithm、およびMACAlgorithmをに追加できます. * /
        
      構造体{
          ConnectionEndエンティティ;
          PRFAlgorithm prf_algorithm;
          BulkCipherAlgorithm Bulk_cipher_algorithm;
          CipherType cipher_type;
          uint8 enc_key_length;
          uint8 block_length;
          uint8 fixed_iv_length;
          uint8 record_iv_length;
          MACAlgorithm mac_algorithm;
          uint8 mac_length;
          uint8 mac_key_length;
          CompressionMethod Compression_algorithm;
          不透明なmaster_secret [48];
          不透明なclient_random [32];
          不透明なserver_random [32];
      } SecurityParameters;
        
レコード層はセキュリティパラメータを使用して、次の6つのアイテムを生成します（そのうちのいくつかはすべての暗号で必要とされるわけではないため、空です）. 

クライアント書き込みMACキーサーバー書き込みMACキークライアント書き込み暗号化キーサーバー書き込み暗号化キークライアント書き込みIVサーバー書き込みIV

クライアント書き込みパラメーターは、レコードを受信および処理するときにサーバーによって使用され、その逆も同様です. セキュリティパラメータからこれらのアイテムを生成するために使用されるアルゴリズムは、セクション6.3で説明されています. 

セキュリティパラメータが設定され、キーが生成されると、接続状態を現在の状態にすることでインスタンス化できます. これらの現在の状態は、処理されるレコードごとに更新する必要があります. 各接続状態には、次の要素が含まれます. 

圧縮状態圧縮アルゴリズムの現在の状態. 

暗号状態暗号化アルゴリズムの現在の状態. これは、その接続のスケジュールされたキーで構成されます. ストリーム暗号の場合、これには、ストリームがデータの暗号化または復号化を続行できるようにするために必要な状態情報も含まれます. 

MACキー上記で生成された、この接続のMACキー. 

シーケンス番号各接続状態にはシーケンス番号が含まれており、読み取り状態と書き込み状態で別々に維持されます. 接続状態がアクティブ状態になるときはいつでも、シーケンス番号をゼロに設定する必要があります. シーケンス番号はuint64タイプであり、2 ^ 64-1を超えることはできません. シーケンス番号は折り返されません. TLS実装でシーケンス番号をラップする必要がある場合は、代わりに再ネゴシエートする必要があります. シーケンス番号は、各レコードの後に​​インクリメントされます. 具体的には、特定の接続状態で送信される最初のレコードは、シーケンス番号0を使用する必要があります. 

6.2. レコードレイヤー
TLSレコード層は、任意のサイズの空でないブロックの上位層から未解釈のデータを受信します. 

6.2.1. 断片化
レコード層は、情報ブロックを2 ^ 14バイト以下のチャンクでデータを運ぶTLSPlaintextレコードにフラグメント化します. クライアントメッセージの境界はレコードレイヤーに保持されません（つまり、同じContentTypeの複数のクライアントメッセージを1つのTLSPlaintextレコードに統合するか、1つのメッセージを複数のレコードに分割することができます）. 

      構造体{
          uint8メジャー;
          uint8マイナー;
      } ProtocolVersion;
        
      列挙型{
          change_cipher_spec（20）、alert（21）、handshake（22）、
          application_data（23）、（255）
      } ContentType;
        
      構造体{
          ContentTypeタイプ;
          ProtocolVersionバージョン;
          uint16の長さ;
          不透明なフラグメント[TLSPlaintext.length];
      } TLSPlaintext;
        
type囲まれたフラグメントの処理に使用される高レベルのプロトコル. 

version使用されているプロトコルのバージョン. このドキュメントでは、バージョン{3、3}を使用するTLSバージョン1.2について説明します. バージョン値3.3は履歴であり、TLS 1.0での{3、1}の使用に由来します. （付録A.1を参照してください. ）TLSの複数のバージョンをサポートするクライアントは、ServerHelloを受信する前に、どのバージョンが採用されるかを知らない場合があることに注意してください. ClientHelloに使用するレコードレイヤーのバージョン番号については、付録Eを参照してください. 

length次のTLSPlaintext.fragmentの長さ（バイト単位）. 長さは2 ^ 14を超えてはなりません. 

フラグメントアプリケーションデータ. このデータは透過的であり、typeフィールドで指定された高レベルのプロトコルによって処理される独立したブロックとして扱われます. 

実装は、Handshake、Alert、またはChangeCipherSpecコンテンツタイプの長さゼロのフラグメントを送信してはなりません（MUSTNOT）. アプリケーションデータの長さゼロのフラグメントは、トラフィック分析の対策として役立つ可能性があるため、送信される場合があります. 

注：異なるTLSレコードレイヤーコンテンツタイプのデータはインターリーブされる場合があります. アプリケーションデータは、通常、他のコンテンツタイプよりも送信の優先順位が低くなります. ただし、レコードは、レコード層によって保護されているのと同じ順序でネットワークに配信する必要があります. 受信者は、接続の最初のトラフィックに続くハンドシェイク中に、インターリーブされたアプリケーション層トラフィックを受信して​​処理する必要があります. 

6.2.2. レコードの圧縮と解凍
すべてのレコードは、現在のセッション状態で定義されている圧縮アルゴリズムを使用して圧縮されます. 常にアクティブな圧縮アルゴリズムがあります. ただし、最初はCompressionMethod.nullとして定義されています. 圧縮アルゴリズムは、TLSPlaintext構造をTLSCompressed構造に変換します. 圧縮機能は、接続状態がアクティブになるたびにデフォルトの状態情報で初期化されます. [RFC3749]は、TLSの圧縮アルゴリズムについて説明しています. 

圧縮はロスレスである必要があり、コンテンツの長さを1024バイトを超えて増やすことはできません. 解凍関数が2 ^ 14バイトを超える長さに解凍するTLSCompressed.fragmentを検出した場合、致命的な解凍失敗エラーを報告する必要があります. 

      構造体{
          ContentTypeタイプ; / * TLSPlaintext.typeと同じ* /
          ProtocolVersionバージョン; / * TLSPlaintext.versionと同じ* /
          uint16の長さ;
          不透明なフラグメント[TLSCompressed.length];
      } TLSCompressed;
        
length次のTLSCompressed.fragmentの長さ（バイト単位）. 長さは2 ^ 14 +1024を超えてはなりません. 

フラグメントTLSPlaintext.fragmentの圧縮形式. 

注：CompressionMethod.null操作はID操作です. フィールドは変更されません. 

実装上の注意：解凍関数は、メッセージが内部バッファオーバーフローを引き起こさないようにする責任があります. 

6.2.3. ペイロード保護の記録
暗号化およびMAC機能は、TLSCompressed構造をTLSCiphertextに変換します. 復号化機能はプロセスを逆にします. レコードのMACにはシーケンス番号も含まれているため、欠落したメッセージ、余分なメッセージ、または繰り返されたメッセージを検出できます. 

      構造体{
          ContentTypeタイプ;
          ProtocolVersionバージョン;
          uint16の長さ;
          select（SecurityParameters.cipher_type）{
              ケースストリーム：GenericStreamCipher;
              ケースブロック：GenericBlockCipher;
              ケースaead：GenericAEADCipher;
          }フラグメント;
      } TLSCiphertext;
        
type typeフィールドは、TLSCompressed.typeと同じです. 

versionバージョンフィールドはTLSCompressed.versionと同じです. 

length次のTLSCiphertext.fragmentの長さ（バイト単位）. 長さは2 ^ 14 +2048を超えてはなりません. 

フラグメントMACを使用したTLSCompressed.fragmentの暗号化された形式. 

6.2.3.1. ヌルまたは標準のストリーム暗号
ストリーム暗号（BulkCipherAlgorithm.nullを含む. 付録A.6を参照）は、TLSCompressed.fragment構造をストリームTLSCiphertext.fragment構造との間で変換します. 

      ストリーム暗号化された構造体{
          不透明なコンテンツ[TLSCompressed.length];
          不透明なMAC [SecurityParameters.mac_length];
      } GenericStreamCipher;
        
MACは次のように生成されます. 

      MAC（MAC_write_key、seq_num +
                            TLSCompressed.type +
                            TLSCompressed.version +
                            TLSCompressed.length +
                            TLSCompressed.fragment）;
        
ここで、「+」は連結を示します. 

seq_numこのレコードのシーケンス番号. 

MACSecurityParameters.mac_algorithmで指定されたMACアルゴリズム. 

MACは暗号化の前に計算されることに注意してください. ストリーム暗号は、MACを含むブロック全体を暗号化します. 同期ベクトルを使用しないストリーム暗号（RC4など）の場合、1つのレコードの終わりからのストリーム暗号状態は、後続のパケットで単に使用されます. 暗号スイートがTLS_NULL_WITH_NULL_NULLの場合、暗号化はID操作で構成されます（つまり、データは暗号化されず、MACサイズはゼロであり、MACが使用されていないことを意味します）. null暗号とストリーム暗号の両方の場合、TLSCiphertext.lengthはTLSCompressed.lengthにSecurityParameters.mac_lengthを加えたものです. 

6.2.3.2. CBCブロック暗号
ブロック暗号（3DESやAESなど）の場合、暗号化およびMAC関数は、TLSCompressed.fragment構造をブロックTLSCiphertext.fragment構造との間で変換します. 

      構造体{
          不透明なIV [SecurityParameters.record_iv_length];
          ブロック暗号化された構造体{
              不透明なコンテンツ[TLSCompressed.length];
              不透明なMAC [SecurityParameters.mac_length];
              uint8 padding [GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;
        
MACは、セクション6.2.3.1で説明されているように生成されます. 

IV初期化ベクトル（IV）はランダムに選択する必要があり、予測できないものでなければなりません. 1.1より前のバージョンのTLSでは、IVフィールドがなく、前のレコードの最後の暗号文ブロック（「CBC残基」）がIVとして使用されていたことに注意してください. これは、[CBCATT]で説明されている攻撃を防ぐために変更されました. ブロック暗号の場合、IVの長さはSecurityParameters.record_iv_lengthであり、これはSecurityParameters.block_sizeと同じです. 

パディング平文の長さをブロック暗号のブロック長の整数倍にするために追加されるパディング. TLSCiphertext.lengthがブロック長の整数倍になる限り、パディングは最大255バイトの任意の長さにすることができます. 交換されたメッセージの長さの分析に基づくプロトコルへの攻撃を妨げるには、必要以上の長さが望ましい場合があります. パディングデータベクトルの各uint8には、パディング長の値を入力する必要があります. 受信者はこのパディングをチェックし、bad_record_macアラートを使用してパディングエラーを示す必要があります. 

padding_lengthパディングの長さは、GenericBlockCipher構造体の合計サイズが暗号のブロック長の倍数になるようにする必要があります. 有効な値の範囲は0から255までです. この長さは、padding_lengthフィールド自体を除いたパディングフィールドの長さを指定します. 

暗号化されたデータの長さ（TLSCiphertext.length）は、SecurityParameters.block_length、TLSCompressed.length、SecurityParameters.mac_length、およびpadding_lengthの合計より1つ長くなります. 

例：ブロック長が8バイト、コンテンツ長（TLSCompressed.length）が61バイト、MAC長が20バイトの場合、パディング前の長さは82バイトです（これにはIVは含まれません. したがって、パディング全長を8バイト（ブロック長）の偶数倍にするには、8を法とする長さが6に等しくなければなりません. パディング長は6、14、22など、254までです. 必要最小限の6、パディングは6バイトで、それぞれに値6が含まれます. したがって、ブロック暗号化前のGenericBlockCipherの最後の8オクテットはxx 06 06 06 06 06 06 06になります. ここで、xxはの最後のオクテットです. マック. 

注：CBCモード（暗号ブロック連鎖）のブロック暗号では、暗号文が送信される前に、レコードのプレーンテキスト全体がわかっていることが重要です. そうしないと、攻撃者が[CBCATT]で説明されている攻撃を仕掛ける可能性があります. 

実装ノート：Canvel etal. [CBCTIME]は、MACの計算に必要な時間に基づいたCBCパディングに対するタイミング攻撃を示しています. この攻撃から防御するために、実装は、パディングが正しいかどうかに関係なく、レコード処理時間が本質的に同じであることを確認する必要があります. 一般に、これを行う最善の方法は、パディングが正しくない場合でもMACを計算し、パケットを拒否することです. たとえば、パッドが正しくないように見える場合、実装は長さがゼロのパッドを想定してからMACを計算する場合があります. MACのパフォーマンスはデータフラグメントのサイズにある程度依存するため、これにより小さなタイミングチャネルが残りますが、既存のMACのブロックサイズが大きく、サイズが小さいため、悪用できるほど大きくないと考えられます. タイミング信号. 

6.2.3.3. AEAD暗号
AEAD [AEAD]暗号（[CCM]や[GCM]など）の場合、AEAD関数はTLSCompressed.fragment構造をAEADTLSCiphertext.fragment構造との間で変換します. 

      構造体{
         不透明なnonce_explicit [SecurityParameters.record_iv_length];
         aead-ciphered struct {
             不透明なコンテンツ[TLSCompressed.length];
         };
      } GenericAEADCipher;
        
AEAD暗号は、[AEAD]のセクション2.1で説明されているように、認証チェックに含まれる単一のキー、ナンス、プレーンテキスト、および「追加データ」を入力として受け取ります. キーはclient_write_keyまたはserver_write_keyのいずれかです. MACキーは使用されません. 

各AEAD暗号スイートは、AEAD操作に提供されるナンスがどのように構築されるか、およびGenericAEADCipher.nonce_explicit部分の長さを指定する必要があります. 多くの場合、[AEAD]のセクション3.2.1で説明されている部分的に暗黙的なナンス手法を使用することが適切です. record_iv_lengthは、明示的な部分の長さです. この場合、暗黙的な部分はkey_blockからclient_write_ivおよびserver_write_ivとして派生する必要があり（セクション6.3で説明）、明示的な部分はGenericAEAEDCipher.nonce_explicitに含まれています. 

平文はTLSCompressed.fragmentです. 

追加の認証済みデータ（additional_dataと表記）は、次のように定義されます. 

      追加データ= seq_num + TLSCompressed.type +
                        TLSCompressed.version + TLSCompressed.length;
        
ここで、「+」は連結を示します. 

aead_outputは、AEAD暗号化操作によって出力された暗号文で構成されます. 通常、長さはTLSCompressed.lengthより大きくなりますが、AEAD暗号によって異なります. 暗号にはパディングが組み込まれている可能性があるため、オーバーヘッドの量はTLSCompressed.lengthの値によって異なる可能性があります. 各AEAD暗号は、1024バイトを超える拡張を生成してはなりません（MUSTNOT）. 象徴的に、

AEADEncrypted = AEAD-Encrypt（write_key、nonce、plaintext、additional_data）

復号化して検証するために、暗号は入力としてキー、ナンス、「additional_data」、およびAEADEncrypted値を取ります. 出力は、プレーンテキストか、復号化が失敗したことを示すエラーのいずれかです. 個別の整合性チェックはありません. あれは：

TLSCompressed.fragment = AEAD-Decrypt（write_key、nonce、AEADEncrypted、additional_data）

復号化が失敗した場合、致命的なbad_record_macアラートを生成する必要があります. 

6.3. キーの計算
レコードプロトコルには、ハンドシェイクプロトコルによって提供されるセキュリティパラメータから、現在の接続状態（付録A.6を参照）に必要なキーを生成するアルゴリズムが必要です. 

マスターシークレットは一連のセキュアバイトに展開され、クライアント書き込みMACキー、サーバー書き込みMACキー、クライアント書き込み暗号化キー、およびサーバー書き込み暗号化キーに分割されます. これらはそれぞれ、バイトシーケンスからこの順序で生成されます. 未使用の値は空です. 一部のAEAD暗号では、クライアント書き込みIVとサーバー書き込みIVが追加で必要になる場合があります（セクション6.2.3.3を参照）. 

キーとMACキーが生成されると、マスターシークレットがエントロピーソースとして使用されます. 

キーマテリアルを生成するには、

key_block = PRF（SecurityParameters.master_secret、 "キー拡張"、SecurityParameters.server_random + SecurityParameters.client_random）;

十分な出力が生成されるまで. 次に、key_blockは次のように分割されます. 

client_write_MAC_key [SecurityParameters.mac_key_length] server_write_MAC_key [SecurityParameters.mac_key_length] client_write_key [SecurityParameters.enc_key_length] server_write_key [SecurityParameters.enc_key_length] client_write_IV [SecurityParameters.fixed_iv_length] server_write_IV [SecurityParameters.fix

現在、client_write_IVとserver_write_IVは、[AEAD]のセクション3.2.1で説明されているように、暗黙のナンス手法に対してのみ生成されます. 

実装上の注意：最も多くの材料を必要とする現在定義されている暗号スイートはAES_256_CBC_SHA256です. 2 x32バイトのキーと2x 32バイトのMACキーが必要で、合計128バイトのキーマテリアルが必要です. 

7.TLSハンドシェイクプロトコル
TLSには3つのサブプロトコルがあり、ピアがレコード層のセキュリティパラメータに同意し、自身を認証し、ネゴシエートされたセキュリティパラメータをインスタンス化し、エラー状態を相互に報告できるようにします. 

ハンドシェイクプロトコルは、次の項目で構成されるセッションのネゴシエーションを担当します. セッション識別子アクティブまたは再開可能なセッション状態を識別するためにサーバーによって選択される任意のバイトシーケンス. 

ピア証明書X509v3 [PKIX]ピアの証明書. 状態のこの要素はnullである可能性があります. 

圧縮方法暗号化の前にデータを圧縮するために使用されるアルゴリズム. 

暗号仕様キーイングマテリアルの生成に使用される疑似ランダム関数（PRF）、バルクデータ暗号化アルゴリズム（null、AESなど）、およびMACアルゴリズム（HMAC-SHA1など）を指定します. また、mac_lengthなどの暗号化属性も定義します. （正式な定義については、付録A.6を参照してください. ）

マスターシークレットクライアントとサーバー間で共有される48バイトのシークレット. 

再開可能ですセッションを使用して新しい接続を開始できるかどうかを示すフラグ. 

これらの項目は、アプリケーションデータを保護するときにレコード層で使用するセキュリティパラメータを作成するために使用されます. TLSハンドシェイクプロトコルの再開機能を介して、同じセッションを使用して多くの接続をインスタンス化できます. 

7.1. 暗号仕様プロトコルの変更
暗号仕様変更プロトコルは、暗号化戦略の遷移を通知するために存在します. プロトコルは単一のメッセージで構成され、現在の（保留中ではない）接続状態で暗号化および圧縮されます. メッセージは、値1の1バイトで構成されます. 

      構造体{
          列挙型{change_cipher_spec（1）、（255）}タイプ;
      } ChangeCipherSpec;
        
ChangeCipherSpecメッセージは、クライアントとサーバーの両方から送信され、受信側に、後続のレコードが新しくネゴシエートされたCipherSpecとキーで保護されることを通知します. このメッセージを受信すると、受信者は、読み取り保留状態を読み取り現在の状態にすぐにコピーするようにレコード層に指示します. このメッセージを送信した直後に、送信者はレコード層に書き込み保留状態を書き込みアクティブ状態にするように指示する必要があります. 

（セクション6.1を参照してください. ）ChangeCipherSpecメッセージは、セキュリティパラメータが合意された後、検証終了メッセージが送信される前に、ハンドシェイク中に送信されます. 

注：接続でデータが流れているときに再ハンドシェイクが発生した場合、通信側は古いCipherSpecを使用してデータを送信し続ける可能性があります. ただし、ChangeCipherSpecが送信されたら、新しいCipherSpecを使用する必要があります. ChangeCipherSpecを送信する最初の側は、反対側が新しいキー情報の計算を終了したことを認識していません（たとえば、時間のかかる公開キー操作を実行する必要がある場合）. したがって、受信者がデータをバッファリングしなければならない小さな時間枠が存在する可能性があります. 実際には、最近のマシンでは、この間隔はかなり短い可能性があります. 

7.2. アラートプロトコル
TLSレコードレイヤーでサポートされているコンテンツタイプの1つは、アラートタイプです. アラートメッセージは、メッセージの重大度（警告または致命的）とアラートの説明を伝えます. 致命的なレベルのアラートメッセージは、接続の即時終了につながります. この場合、セッションに対応する他の接続が継続する可能性がありますが、セッションIDを無効にして、失敗したセッションが新しい接続の確立に使用されないようにする必要があります. 他のメッセージと同様に、アラートメッセージは、現在の接続状態で指定されているように、暗号化および圧縮されます. 

      列挙型{warning（1）、fatal（2）、（255）} AlertLevel;
        
      列挙型{
          close_notify（0）、
          予期しないメッセージ（10）、
          bad_record_mac（20）、
          復号化に失敗しました_RESERVED（21）、
          record_overflow（22）、
          decompression_failure（30）、
          handshake_failure（40）、
          no_certificate_RESERVED（41）、
          bad_certificate（42）、
          unsupported_certificate（43）、
          証明書失効（44）、
          証明書の有効期限（45）、
          証明書不明（46）、
          illegal_parameter（47）、
          unknown_ca（48）、
          access_denied（49）、
          decode_error（50）、
          復号化エラー（51）、export_restriction_RESERVED（60）、
          protocol_version（70）、
          不十分なセキュリティ（71）、
          internal_error（80）、
          user_canceled（90）、
          no_renegotiation（100）、
          unsupported_extension（110）、
          （255）
      } AlertDescription;
        
      構造体{
          AlertLevelレベル;
          AlertDescriptionの説明;
      }アラート;
        
7.2.1. 閉鎖アラート
クライアントとサーバーは、切り捨て攻撃を回避するために、接続が終了しているという知識を共有する必要があります. どちらの当事者も、クロージングメッセージの交換を開始できます. 

close_notifyこのメッセージは、送信者がこの接続でこれ以上メッセージを送信しないことを受信者に通知します. TLS 1.1以降、接続を適切に閉じることができなくても、セッションを再開する必要がなくなったことに注意してください. これは、TLS 1.0からの変更であり、広範な実装慣行に準拠しています. 

どちらの当事者も、close_notifyアラートを送信してクローズを開始できます. 閉鎖アラートの後に受信したデータはすべて無視されます. 

他の致命的なアラートが送信されていない限り、各当事者は、接続の書き込み側を閉じる前にclose_notifyアラートを送信する必要があります. 相手側は、自身のclose_notifyアラートで応答し、接続をただちに閉じて、保留中の書き込みを破棄する必要があります. クローズのイニシエーターは、接続の読み取り側を閉じる前に、応答するclose_notifyアラートを待つ必要はありません. 

TLSを使用するアプリケーションプロトコルが、TLS接続が閉じられた後、基になるトランスポートを介してデータを伝送できることを提供する場合、TLS実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答するclose_notifyアラートを受信する必要があります. アプリケーションプロトコルが追加のデータを転送せず、基礎となるトランスポート接続のみを閉じる場合、実装は、応答するclose_notifyを待たずにトランスポートを閉じることを選択できます（MAY）. この標準のいかなる部分も、接続が開かれたときや閉じられたときを含め、TLSの使用プロファイルがデータ転送を管理する方法を指示するために取られるべきではありません. 

注：接続を閉じると、トランスポートを破棄する前に保留中のデータが確実に配信されると想定されています. 

7.2.2. エラーアラート
TLSハンドシェイクプロトコルでのエラー処理は非常に簡単です. エラーが検出されると、検出側は相手にメッセージを送信します. 致命的なアラートメッセージを送信または受信すると、両方の当事者はすぐに接続を閉じます. サーバーとクライアントは、失敗した接続に関連付けられたセッションID、キー、およびシークレットをすべて忘れなければなりません. したがって、致命的なアラートで終了した接続を再開してはなりません. 

実装が致命的なアラートとして定義されている状態に遭遇した場合は常に、接続を閉じる前に適切なアラートを送信する必要があります. アラートレベルが明示的に指定されていないすべてのエラーについて、送信側は、これを致命的なエラーとして扱うかどうかを独自の裁量で決定することができます. 実装がアラートの送信を選択したが、直後に接続を閉じる予定の場合、致命的なアラートレベルでそのアラートを送信する必要があります. 

警告レベルのアラートが送受信された場合、通常、接続は正常に続行できます. 受信側が接続を続行しないことを決定した場合（たとえば、受け入れたくないというno_renegotiationアラートを受信した後）、接続を終了するために致命的なアラートを送信する必要があります. これを考えると、一般に、送信側は受信側がどのように動作するかを知ることができません. したがって、送信側が接続を継続したい場合、警告アラートはあまり役に立ちません. そのため、省略されることがあります. たとえば、ピアが期限切れの証明書を受け入れることを決定し（おそらくユーザーにこれを確認した後）、接続を継続したい場合、通常、certificate_expiredアラートを送信しません. 

次のエラーアラートが定義されています. 

expected_message不適切なメッセージを受信しました. このアラートは常に致命的であり、適切な実装間の通信では決して観察されるべきではありません. 

bad_record_macこのアラートは、誤ったMACでレコードを受信した場合に返されます. TLSCiphertextが無効な方法で復号化されたためにアラートが送信された場合も、このアラートを返す必要があります. ブロック長の倍数ではなかったか、チェックしたときのパディング値が正しくありませんでした. このメッセージは常に致命的であり、適切な実装間の通信では決して観察されるべきではありません（メッセージがネットワークで破損した場合を除く）. 

cryptoion_failed_RESERVEDこのアラートは以前のバージョンのTLSで使用されており、CBCモード[CBCATT]に対する特定の攻撃を許可している可能性があります. 準拠した実装によって送信してはなりません. 

record_overflow 2 ^ 14 + 2048バイトを超える長さのTLSCiphertextレコード、または2 ^ 14 +1024バイトを超えるTLSCompressedレコードに復号化されたレコードを受信しました. このメッセージは常に致命的であり、適切な実装間の通信では決して観察されるべきではありません（メッセージがネットワークで破損した場合を除く）. 

decompression_failure解凍関数が不適切な入力を受け取りました（たとえば、過度の長さに拡張されるデータ）. このメッセージは常に致命的であり、適切な実装間の通信では決して観察されるべきではありません. 

handshake_failure handshake_failureアラートメッセージの受信は、使用可能なオプションを指定して、送信者が許容可能なセキュリティパラメータのセットをネゴシエートできなかったことを示します. これは致命的なエラーです. 

no_certificate_RESERVEDこのアラートはSSLv3で使用されましたが、TLSのどのバージョンでも使用されませんでした. 準拠した実装によって送信してはなりません. 

bad_certificate証明書が破損しているか、正しく検証されなかった署名が含まれているなど. 

unsupported_certificate証明書はサポートされていないタイプでした. 

certificate_revoked証明書は署名者によって取り消されました. 

certificate_expired証明書の有効期限が切れているか、現在有効ではありません. 

certificate_unknown証明書の処理中に他の（指定されていない）問題が発生し、証明書が受け入れられなくなりました. 

illegal_parameterハンドシェイクのフィールドが範囲外であるか、他のフィールドと矛盾していました. このメッセージは常に致命的です. 

unknown_ca有効な証明書チェーンまたは部分チェーンを受信しましたが、CA証明書が見つからなかったか、既知の信頼できるCAと一致しなかったため、証明書は受け入れられませんでした. このメッセージは常に致命的です. 

access_denied有効な証明書を受信しましたが、アクセス制御が適用されたときに、送信者はネゴシエーションを続行しないことを決定しました. このメッセージは常に致命的です. 

decode_error一部のフィールドが指定された範囲外であるか、メッセージの長さが正しくないため、メッセージをデコードできませんでした. このメッセージは常に致命的であり、適切な実装間の通信では決して観察されるべきではありません（メッセージがネットワークで破損した場合を除く）. 

復号化エラー署名を正しく検証できない、または終了メッセージを検証できないなど、ハンドシェイク暗号化操作が失敗しました. このメッセージは常に致命的です. 

export_restriction_RESERVEDこのアラートは、以前のバージョンのTLSで使用されていました. 準拠した実装によって送信してはなりません. 

protocol_versionクライアントがネゴシエートしようとしたプロトコルバージョンは認識されますが、サポートされていません. （たとえば、セキュリティ上の理由から、古いプロトコルバージョンは回避される場合があります. ）このメッセージは常に致命的です. 

ネゴシエーションが失敗した場合、特にサーバーがクライアントでサポートされている暗号よりも安全な暗号を必要とするために、handshake_failureの代わりに返されます. このメッセージは常に致命的です. 

internal_errorピアまたはプロトコルの正確性に関係のない内部エラー（メモリ割り当ての失敗など）により、続行できなくなります. このメッセージは常に致命的です. 

user_canceledこのハンドシェイクは、プロトコルの失敗とは関係のない何らかの理由でキャンセルされています. ハンドシェイクの完了後にユーザーが操作をキャンセルする場合は、close_notifyを送信して接続を閉じる方が適切です. このアラートの後にclose_notifyを続ける必要があります. このメッセージは通常、警告です. 

no_renegotiation hello要求に応答してクライアントによって送信されるか、最初のハンドシェイク後にクライアントhelloに応答してサーバーによって送信されます. これらのいずれかは通常、再交渉につながります. それが適切でない場合、受信者はこのアラートで応答する必要があります. その時点で、元のリクエスターは接続を続行するかどうかを決定できます. これが適切である1つのケースは、サーバーが要求を満たすためにプロセスを生成した場合です. プロセスは起動時にセキュリティパラメータ（キーの長さ、認証など）を受け取る可能性があり、それ以降はこれらのパラメータへの変更を伝達することが困難になる可能性があります. このメッセージは常に警告です. 

unsupported_extensionは、対応するクライアントhelloに配置しなかった拡張機能を含む拡張サーバーhelloを受信するクライアントによって送信されます. このメッセージは常に致命的です. 

セクション12で説明されているように、新しいアラート値はIANAによって割り当てられます. 

7.3. ハンドシェイクプロトコルの概要
セッション状態の暗号化パラメータは、TLSレコード層の上で動作するTLSハンドシェイクプロトコルによって生成されます. TLSクライアントとサーバーが最初に通信を開始するとき、プロトコルバージョンに同意し、暗号化アルゴリズムを選択し、オプションで相互に認証し、公開鍵暗号化技術を使用して共有シークレットを生成します. 

TLSハンドシェイクプロトコルには、次の手順が含まれます. 

-helloメッセージを交換して、アルゴリズムに同意し、ランダムな値を交換し、セッションの再開を確認します. 

-クライアントとサーバーがプリマスターシークレットについて合意できるように、必要な暗号化パラメーターを交換します. 

-証​​明書と暗号化情報を交換して、クライアントとサーバーが自分自身を認証できるようにします. 

-プリマスターシークレットからマスターシークレットを生成し、ランダムな値を交換します. 

-セキュリティパラメータをレコードレイヤーに提供します. 

-クライアントとサーバーが、ピアが同じセキュリティパラメータを計算したこと、および攻撃者による改ざんなしにハンドシェイクが発生したことを確認できるようにします. 

上位層は、TLSが常に2つのピア間で可能な限り強力な接続をネゴシエートするかどうかに過度に依存してはならないことに注意してください. man-in-the-middle攻撃者が、2つのエンティティを、サポートする最も安全性の低い方法にドロップダウンさせようとする方法はいくつかあります. プロトコルはこのリスクを最小限に抑えるように設計されていますが、利用可能な攻撃はまだあります. たとえば、攻撃者は安全なサービスが実行されているポートへのアクセスをブロックしたり、ピアに認証されていない接続をネゴシエートさせようとしたりする可能性があります. 基本的なルールは、上位レベルはセキュリティ要件が何であるかを認識している必要があり、必要なレベルよりも安全性の低いチャネルを介して情報を送信しないことです. TLSプロトコルは、どの暗号スイートも約束されたレベルのセキュリティを提供するという点で安全です. 

これらの目標は、ハンドシェイクプロトコルによって達成されます. これは、次のように要約できます. クライアントがClientHelloメッセージを送信し、サーバーがServerHelloメッセージで応答する必要があります. そうしないと、致命的なエラーが発生し、接続が失敗します. ClientHelloとServerHelloは、クライアントとサーバー間のセキュリティ強化機能を確立するために使用されます. ClientHelloとServerHelloは、プロトコルバージョン、セッションID、暗号スイート、および圧縮方法の属性を確立します. さらに、ClientHello.randomとServerHello.randomの2つのランダムな値が生成され、交換されます. 

実際の鍵交換では、サーバー証明書、ServerKeyExchange、クライアント証明書、およびClientKeyExchangeの最大4つのメッセージが使用されます. これらのメッセージの形式を指定し、メッセージの使用を定義してクライアントとサーバーが共有シークレットに同意できるようにすることで、新しいキー交換方法を作成できます. この秘密はかなり長くなければなりません. 現在定義されている鍵交換方法は、46バイト以上の範囲の秘密を交換します. 

helloメッセージに続いて、サーバーは、認証される場合、証明書メッセージで証明書を送信します. さらに、ServerKeyExchangeメッセージは、必要な場合（たとえば、サーバーに証明書がない場合、またはその証明書が署名専用である場合）に送信される場合があります. サーバーが認証されている場合、選択した暗号スイートに適切であれば、サーバーはクライアントに証明書を要求することがあります. 次に、サーバーはServerHelloDoneメッセージを送信し、ハンドシェイクのhelloメッセージフェーズが完了したことを示します. その後、サーバーはクライアントの応答を待ちます. サーバーがCertificateRequestメッセージを送信した場合、クライアントは証明書メッセージを送信する必要があります. これで、ClientKeyExchangeメッセージが送信され、そのメッセージの内容は、ClientHelloとServerHelloの間で選択された公開鍵アルゴリズムによって異なります. 

この時点で、ChangeCipherSpecメッセージがクライアントによって送信され、クライアントは保留中の暗号仕様を現在の暗号仕様にコピーします. クライアントはすぐに、新しいアルゴリズム、キー、およびシークレットの下で終了メッセージを送信します. それに応じて、サーバーは独自のChangeCipherSpecメッセージを送信し、保留中のメッセージを現在の暗号仕様に転送し、新しい暗号仕様で終了メッセージを送信します. この時点で、ハンドシェイクは完了し、クライアントとサーバーはアプリケーション層データの交換を開始できます. （以下のフローチャートを参照してください. ）最初のハンドシェイクが完了する前（TLS_NULL_WITH_NULL_NULL以外の暗号スイートが確立される前）にアプリケーションデータを送信してはなりません（MUSTNOT）. 

クライアントサーバー

      ClientHello -------->
                                                      ServerHello
                                                     証明書*
                                               ServerKeyExchange *
                                              CertificateRequest *
                                   <-------- ServerHelloDone
      証明書*
      ClientKeyExchange
      CertificateVerify *
      [ChangeCipherSpec]
      終了-------->
                                               [ChangeCipherSpec]
                                   <--------終了しました
      アプリケーションデータ<------->アプリケーションデータ
        
図1.完全なハンドシェイクのメッセージフロー

*常に送信されるとは限らないオプションまたは状況依存のメッセージを示します. 

注：パイプラインストールを回避するために、ChangeCipherSpecは独立したTLSプロトコルコンテンツタイプであり、実際にはTLSハンドシェイクメッセージではありません. 

クライアントとサーバーが（新しいセキュリティパラメータをネゴシエートする代わりに）前のセッションを再開するか、既存のセッションを複製することを決定した場合、メッセージフローは次のようになります. 

クライアントは、再開するセッションのセッションIDを使用してClientHelloを送信します. 次に、サーバーはセッションキャッシュで一致するものをチェックします. 一致するものが見つかり、サーバーが指定されたセッション状態で接続を再確立する場合、サーバーは同じセッションID値でServerHelloを送信します. この時点で、クライアントとサーバーの両方がChangeCipherSpecメッセージを送信し、Finishedメッセージに直接進む必要があります. 再確立が完了すると、クライアントとサーバーはアプリケーション層データの交換を開始できます（MAY）. （以下のフローチャートを参照してください. ）セッションIDの一致が見つからない場合、サーバーは新しいセッションIDを生成し、TLSクライアントとサーバーは完全なハンドシェイクを実行します. 

クライアントサーバー

      ClientHello -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------終了しました
      [ChangeCipherSpec]
      終了-------->
      アプリケーションデータ<------->アプリケーションデータ
        
図2.短縮ハンドシェイクのメッセージフロー

各メッセージの内容と重要性については、次のセクションで詳しく説明します. 

7.4. ハンドシェイクプロトコル
TLSハンドシェイクプロトコルは、TLSレコードプロトコルで定義されている上位レベルのクライアントの1つです. このプロトコルは、セッションの安全な属性をネゴシエートするために使用されます. ハンドシェイクメッセージはTLSレコードレイヤーに提供され、そこで1つ以上のTLSPlaintext構造内にカプセル化され、現在のアクティブなセッション状態で指定されたとおりに処理および送信されます. 

      列挙型{
          hello_request（0）、client_hello（1）、server_hello（2）、
          証明書（11）、server_key_exchange（12）、
          certificate_request（13）、server_hello_done（14）、
          Certificate_verify（15）、client_key_exchange（16）、
          終了（20）、（255）
      } HandshakeType;
        
      構造体{
          HandshakeType msg_type; / *ハンドシェイクタイプ* /
          uint24の長さ; / *メッセージのバイト* /
          select（HandshakeType）{
              ケースhello_request：HelloRequest;
              ケースclient_hello：ClientHello;
              ケースserver_hello：ServerHello;
              ケース証明書：証明書;
              ケースserver_key_exchange：ServerKeyExchange;
              ケースcertificate_request：CertificateRequest;
              ケースserver_hello_done：ServerHelloDone;
              ケースcertificate_verify：CertificateVerify;
              ケースclient_key_exchange：ClientKeyExchange;
              ケースが終了しました：終了しました. 
          } 体;
      }ハンドシェイク;
        
ハンドシェイクプロトコルメッセージは、送信する必要のある順序で以下に示されています. 予期しない順序でハンドシェイクメッセージを送信すると、致命的なエラーが発生します. ただし、不要なハンドシェイクメッセージは省略できます. 順序付けの1つの例外に注意してください. 証明書メッセージは、ハンドシェイクで2回（サーバーからクライアントへ、次にクライアントからサーバーへ）使用されますが、最初の位置でのみ記述されます. これらの順序付けルールに拘束されないメッセージの1つは、HelloRequestメッセージです. これはいつでも送信できますが、ハンドシェイクの途中で到着した場合、クライアントは無視する必要があります. 

セクション12で説明されているように、新しいハンドシェイクメッセージタイプはIANAによって割り当てられます. 

7.4.1. こんにちはメッセージ
helloフェーズメッセージは、クライアントとサーバー間でセキュリティ強化機能を交換するために使用されます. 新しいセッションが開始されると、レコードレイヤーの接続状態の暗号化、ハッシュ、および圧縮アルゴリズムがnullに初期化されます. 現在の接続状態は、再ネゴシエーションメッセージに使用されます. 

7.4.1.1. こんにちはリクエスト
このメッセージが送信されるタイミング：

HelloRequestメッセージは、サーバーからいつでも送信できます. 

このメッセージの意味：

HelloRequestは、クライアントがネゴシエーションプロセスを新たに開始する必要があるという単純な通知です. それに応じて、クライアントは都合の良いときにClientHelloメッセージを送信する必要があります. このメッセージは、どちらの側がクライアントまたはサーバーであるかを確認することを目的としたものではなく、単に新しいネゴシエーションを開始することを目的としています. サーバーは、クライアントの最初の接続の直後にHelloRequestを送信するべきではありません（SHOULDNOT）. その時点でClientHelloを送信するのはクライアントの仕事です. 

クライアントが現在セッションをネゴシエートしている場合、このメッセージはクライアントによって無視されます. このメッセージは、セッションの再ネゴシエーションを望まない場合、クライアントによって無視される場合があります. または、クライアントは、必要に応じて、no_renegotiationアラートで応答する場合があります. ハンドシェイクメッセージは、アプリケーションデータよりも送信を優先することを目的としているため、クライアントから数レコードしか受信されないうちにネゴシエーションが開始されることが予想されます. サーバーがHelloRequestを送信したが、応答としてClientHelloを受信しなかった場合、サーバーは致命的なアラートで接続を閉じる可能性があります. 

HelloRequestを送信した後、サーバーは、後続のハンドシェイクネゴシエーションが完了するまで要求を繰り返さないでください（SHOULDNOT）. 

このメッセージの構造：

      struct {} HelloRequest;
        
このメッセージは、ハンドシェイク全体で維持され、完了メッセージと証明書検証メッセージで使用されるメッセージハッシュに含めてはなりません. 

7.4.1.2. クライアントこんにちは
このメッセージが送信されるタイミング：

クライアントが最初にサーバーに接続するとき、最初のメッセージとしてClientHelloを送信する必要があります. クライアントは、HelloRequestに応答して、または既存の接続のセキュリティパラメータを再ネゴシエートするために、独自のイニシアチブでClientHelloを送信することもできます. 

このメッセージの構造：

ClientHelloメッセージには、プロトコルの後半で使用されるランダムな構造が含まれています. 

         構造体{
             uint32 gmt_unix_time;
             不透明なrandom_bytes [28];
         }ランダム;
        
gmt_unix_time送信者の内部クロックに従った、標準UNIX 32ビット形式の現在の時刻と日付（1970年1月1日UTCから始まる深夜からの秒数. うるう秒は無視されます）. 基本的なTLSプロトコルでクロックを正しく設定する必要はありません. 高レベルまたはアプリケーションプロトコルは、追加の要件を定義する場合があります. 歴史的な理由から、データ要素には、現在の世界的なタイムベースであるUTCの前身であるGMTを使用して名前が付けられていることに注意してください. 

random_bytes安全な乱数ジェネレーターによって生成された28バイト. 

ClientHelloメッセージには、可変長のセッション識別子が含まれています. 空でない場合、値は、クライアントが再利用したいセキュリティパラメータを持つ同じクライアントとサーバー間のセッションを識別します. セッション識別子は、以前の接続、この接続、または現在アクティブな別の接続からのものである可能性があります. 2番目のオプションは、クライアントが接続のランダム構造と派生値のみを更新する場合に役立ちます. 3番目のオプションを使用すると、完全なハンドシェイクプロトコルを繰り返さずに、複数の独立した安全な接続を確立できます. これらの独立した接続は、順次または同時に発生する可能性があります. SessionIDは、それをネゴシエートするハンドシェイクが完了メッセージの交換で完了したときに有効になり、エージングまたはセッションに関連付けられた接続で致命的なエラーが発生したために削除されるまで存続します. SessionIDの実際の内容は、サーバーによって定義されます. 

      不透明なSessionID <0..32>;
        
警告：SessionIDは暗号化または即時のMAC保護なしで送信されるため、サーバーはセッションIDに機密情報を配置したり、偽のセッションIDの内容がセキュリティ違反を引き起こしたりしてはなりません. （SessionIDを含むハンドシェイク全体のコンテンツは、ハンドシェイクの最後に交換される終了メッセージによって保護されることに注意してください. ）

ClientHelloメッセージでクライアントからサーバーに渡される暗号スイートリストには、クライアントがサポートする暗号化アルゴリズムの組み合わせが、クライアントの優先順位に従って含まれています（優先選択が最初）. 各暗号スイートは、鍵交換アルゴリズム、バルク暗号化アルゴリズム（秘密鍵の長さを含む）、MACアルゴリズム、およびPRFを定義します. サーバーは暗号スイートを選択するか、受け入れ可能な選択肢が提示されない場合は、ハンドシェイク失敗アラートを返し、接続を閉じます. サーバーが認識、サポート、または使用したくない暗号スイートがリストに含まれている場合、サーバーはそれらの暗号スイートを無視し、残りの暗号スイートを通常どおり処理する必要があります. 

      uint8 CipherSuite [2]; / *暗号スイートセレクター* /
        
ClientHelloには、クライアントがサポートする圧縮アルゴリズムのリストが含まれており、クライアントの好みに従って並べられています. 

      列挙型{null（0）、（255）} CompressionMethod;
        
      構造体{
          ProtocolVersion client_version;
          ランダムランダム;
          SessionID session_id;
          CipherSuite cipher_suites <2..2 ^ 16-2>;
          CompressionMethodcompression_methods <1..2 ^ 8-1>;
          select（extensions_present）{
              ケースfalse：
                  構造体{};
              真の場合：
                  拡張拡張<0..2 ^ 16-1>;
          };
      } ClientHello;
        
TLSを使用すると、拡張機能は拡張機能ブロックのcompression_methodsフィールドに従うことができます. 拡張機能の存在は、ClientHelloの最後にcompression_methodsの後にバイトがあるかどうかを判別することで検出できます. オプションのデータを検出するこの方法は、可変長フィールドを持つ通常のTLS方法とは異なりますが、拡張機能が定義される前のTLSとの互換性のために使用されることに注意してください. 

client_versionクライアントがこのセッション中に通信することを希望するTLSプロトコルのバージョン. これは、クライアントがサポートする最新の（最も価値の高い）バージョンである必要があります. このバージョンの仕様では、バージョンは3.3になります（下位互換性の詳細については、付録Eを参照してください）. 

randomクライアントによって生成されたランダム構造. 

session_idクライアントがこの接続に使用するセッションのID. 使用可能なsession_idがない場合、またはクライアントが新しいセキュリティパラメータを生成したい場合、このフィールドは空です. 

cipher_suitesこれは、クライアントがサポートする暗号化オプションのリストであり、クライアントの最初の優先順位が最初になります. session_idフィールドが空でない場合（セッション再開要求を意味する）、このベクトルには少なくともそのセッションからのcipher_suiteが含まれている必要があります. 値は付録A.5で定義されています. 

Compression_methodsこれは、クライアントがサポートする圧縮方法のリストであり、クライアントの設定でソートされています. session_idフィールドが空でない場合（セッション再開要求を意味する）、そのセッションからのcompression_methodを含める必要があります. このベクトルには、CompressionMethod.nullが含まれている必要があり、すべての実装でサポートされている必要があります. したがって、クライアントとサーバーは常に圧縮方法について合意することができます. 

拡張機能クライアントは、拡張機能フィールドにデータを送信することにより、サーバーに拡張機能を要求できます（MAY）. 実際の「拡張」フォーマットはセクション7.4.1.4で定義されています. 

クライアントが拡張機能を使用して追加機能を要求し、この機能がサーバーによって提供されていない場合、クライアントはハンドシェイクを中止してもよい[MAY]. サーバーは、拡張子フィールドがある場合とない場合の両方でClientHelloメッセージを受け入れる必要があり、（他のすべてのメッセージと同様に）メッセージ内のデータ量がこれらの形式の1つと正確に一致することを確認する必要があります. そうでない場合は、致命的な「decode_error」アラートを送信する必要があります. 

ClientHelloメッセージを送信した後、クライアントはServerHelloメッセージを待ちます. HelloRequestを除いて、サーバーから返されるハンドシェイクメッセージは、致命的なエラーとして扱われます. 

7.4.1.3. サーバーこんにちは
このメッセージが送信されるタイミング：

サーバーは、受け入れ可能なアルゴリズムのセットを見つけることができたときに、ClientHelloメッセージに応答してこのメ​​ッセージを送信します. そのような一致が見つからない場合は、ハンドシェイク失敗アラートで応答します. 

このメッセージの構造：

      構造体{
          ProtocolVersion server_version;
          ランダムランダム;
          SessionID session_id;
          暗号スイートcipher_suite;
          CompressionMethodcompression_method;
          select（extensions_present）{
              ケースfalse：
                  構造体{};
              真の場合：
                  拡張拡張<0..2 ^ 16-1>;
          };
      } ServerHello;
        
拡張機能の存在は、ServerHelloの最後にあるcompression_methodフィールドの後にバイトがあるかどうかを判別することで検出できます. 

server_versionこのフィールドには、クライアントhelloでクライアントによって提案されたものの低い方と、サーバーでサポートされている最も高いものが含まれます. このバージョンの仕様では、バージョンは3.3です. （下位互換性の詳細については、付録Eを参照してください. ）

ランダムこの構造はサーバーによって生成され、ClientHello.randomから独立して生成する必要があります. 

session_idこれは、この接続に対応するセッションのIDです. ClientHello.session_idが空でない場合、サーバーはセッションキャッシュで一致するものを探します. 一致するものが見つかり、サーバーが指定されたセッション状態を使用して新しい接続を確立する意思がある場合、サーバーはクライアントから提供されたのと同じ値で応答します. これは、セッションが再開されたことを示し、当事者が終了メッセージに直接進む必要があることを示します. それ以外の場合、このフィールドには、新しいセッションを識別する別の値が含まれます. サーバーは空のsession_idを返し、セッションがキャッシュされないため再開できないことを示す場合があります. セッションを再開する場合は、最初にネゴシエートされたのと同じ暗号スイートを使用して再開する必要があります. 以前にsession_idを提供していた場合でも、サーバーがセッションを再開する必要はないことに注意してください. クライアントは、ハンドシェイク中に完全なネゴシエーション（新しい暗号スイートのネゴシエーションを含む）を実行する準備をしなければなりません. 

cipher_suiteClientHello.cipher_suitesのリストからサーバーによって選択された単一の暗号スイート. 再開されたセッションの場合、このフィールドは再開されているセッションの状態からの値です. 

Compression_methodClientHello.compression_methodsのリストからサーバーによって選択された単一の圧縮アルゴリズム. 再開されたセッションの場合、このフィールドは再開されたセッション状態の値です. 

拡張機能拡張機能のリスト. クライアントによって提供された拡張機能のみがサーバーのリストに表示されることに注意してください. 

7.4.1.4. こんにちは拡張機能
拡張形式は次のとおりです. 

      構造体{
          ExtensionType extension_type;
          不透明なextension_data <0..2 ^ 16-1>;
      }拡張機能;
        
      列挙型{
          Signature_algorithms（13）、（65535）
      } ExtensionType;
        
ここに：

-「extension_type」は、特定の拡張タイプを識別します. 

-「extension_data」には、特定の拡張タイプに固有の情報が含まれています. 

拡張機能の初期セットは、コンパニオンドキュメント[TLSEXT]で定義されています. 拡張タイプのリストは、セクション12で説明されているようにIANAによって維持されます. 

同じ拡張タイプが対応するClientHelloに表示されない限り、拡張タイプはServerHelloに表示されてはなりません（MUSTNOT）. クライアントが、関連付けられたClientHelloで要求しなかった拡張タイプをServerHelloで受信した場合、unsupported_extensionの致命的なアラートでハンドシェイクを中止する必要があります. 

それにもかかわらず、「サーバー指向」の拡張機能は、将来、このフレームワーク内で提供される可能性があります. このような拡張機能（たとえば、タイプx）では、クライアントが最初にタイプxの拡張機能をClientHelloで空のextension_dataとともに送信して、拡張機能タイプをサポートしていることを示す必要があります. この場合、クライアントは拡張機能のタイプを理解する機能を提供しており、サーバーはクライアントをその提供に応じています. 

ClientHelloまたはServerHelloメッセージに異なるタイプの複数の拡張子が存在する場合、拡張子は任意の順序で表示される場合があります. 同じタイプの拡張子が複数存在してはなりません. 

最後に、拡張機能は、新しいセッションを開始するときとセッションの再開を要求するときの両方で送信できることに注意してください. 実際、セッションの再開を要求するクライアントは、一般にサーバーがこの要求を受け入れるかどうかを知らないため、再開を試みていない場合に送信するのと同じ拡張子を送信する必要があります. 

一般に、各拡張タイプの仕様では、完全なハンドシェイクとセッション再開の両方での拡張の効果を説明する必要があります. 現在のほとんどのTLS拡張は、セッションが開始された場合にのみ関連します. 古いセッションが再開されると、サーバーはこれらの拡張をClient Helloで処理せず、ServerHelloに含めません. ただし、一部の拡張機能では、セッション再開時に異なる動作が指定される場合があります. 

このプロトコルでは、新しい機能と既存の機能の間で微妙な（そしてそれほど微妙ではない）相互作用が発生する可能性があり、その結果、全体的なセキュリティが大幅に低下する可能性があります. 新しい拡張機能を設計するときは、次の考慮事項を考慮する必要があります. 

-サーバーが拡張機能に同意しない場合はエラー状態であり、特定の機能のサポートを単に拒否する場合もあります. 一般に、前者にはエラーアラートを使用し、後者にはサーバー拡張応答のフィールドを使用する必要があります. 

-拡張機能は、可能な限り、ハンドシェイクメッセージの操作によって特定の機能の使用（または不使用）を強制する攻撃を防ぐように設計する必要があります. この機能がセキュリティ上の問題を引き起こすと考えられるかどうかに関係なく、この原則に従う必要があります. 

多くの場合、拡張フィールドが完了メッセージハッシュへの入力に含まれているという事実で十分ですが、拡張がハンドシェイクフェーズで送信されるメッセージの意味を変更する場合は、細心の注意が必要です. 設計者と実装者は、ハンドシェイクが認証されるまで、アクティブな攻撃者がメッセージを変更し、拡張機能を挿入、削除、または置換できるという事実に注意する必要があります. 

-拡張機能を使用してTLSの設計の主要な側面を変更することは技術的に可能です. たとえば、暗号スイートネゴシエーションの設計. これはお勧めしません. TLSの新しいバージョンを定義する方が適切です. 特に、TLSハンドシェイクアルゴリズムにはバージョン番号に基づいたバージョンロールバック攻撃に対する特定の保護があり、バージョンロールバックの可能性は主要な設計変更において重要な考慮事項となるはずです. 

7.4.1.4.1. 署名アルゴリズム
クライアントは「signature_algorithms」拡張機能を使用して、デジタル署名で使用できる署名/ハッシュアルゴリズムのペアをサーバーに示します. この拡張機能の「extension_data」フィールドには、「supported_signature_algorithms」値が含まれています. 

      列挙型{
          none（0）、md5（1）、sha1（2）、sha224（3）、sha256（4）、sha384（5）、
          sha512（6）、（255）
      } HashAlgorithm;
        
      列挙型{anonymous（0）、rsa（1）、dsa（2）、ecdsa（3）、（255）}
        SignatureAlgorithm;
        
      構造体{
            HashAlgorithmハッシュ;
            SignatureAlgorithm署名;
      } SignatureAndHashAlgorithm;
        
      SignatureAndHashAlgorithm
        support_signature_algorithms <2..2 ^ 16-2>;
        
各SignatureAndHashAlgorithm値は、クライアントが検証することをいとわない単一のハッシュ/署名ペアをリストします. 値は優先度の高い順に示されています. 

注：すべての署名アルゴリズムとハッシュアルゴリズムが実装で受け入れられるとは限らないため（たとえば、SHA-1を使用したDSAで、SHA-256は受け入れられない）、ここではアルゴリズムをペアでリストしています. 

hashこのフィールドは、使用できるハッシュアルゴリズムを示します. 値は、ハッシュされていないデータ、MD5 [MD5]、SHA-1、SHA-224、SHA-256、SHA-384、およびSHA-512 [SHS]のサポートをそれぞれ示しています. 「none」値は、署名前にハッシュを必要としない署名アルゴリズムの場合に、将来の拡張性のために提供されます. 

シグニチャこのフィールドは、使用できるシグニチャアルゴリズムを示します. 値は、匿名署名、RSASSA-PKCS1-v1_5 [PKCS1]とDSA [DSS]、およびECDSA [ECDSA]をそれぞれ示します. 「匿名」値は、このコンテキストでは無意味ですが、セクション7.4.3で使用されます. この拡張機能に表示してはなりません. 

暗号スイートは許容される署名アルゴリズムを示しますが、ハッシュアルゴリズムは示さないため、この拡張機能のセマンティクスはやや複雑です. セクション7.4.2および7.4.3では、適切なルールについて説明します. 

クライアントがデフォルトのハッシュおよび署名アルゴリズム（このセクションにリストされている）のみをサポートしている場合、signature_algorithms拡張を省略してもよい[MAY]. クライアントがデフォルトのアルゴリズムをサポートしていない場合、または他のハッシュアルゴリズムと署名アルゴリズムをサポートしている場合（サーバーから送信されたメッセージの検証、つまりサーバー証明書とサーバーキー交換にそれらを使用する場合）、signature_algorithms拡張機能を送信する必要があります. 受け入れても構わないと思っているアルゴリズムをリストします. 

クライアントがsignature_algorithms拡張機能を送信しない場合、サーバーは次のことを行わなければなりません. 

-ネゴシエートされた鍵交換アルゴリズムが（RSA、DHE_RSA、DH_RSA、RSA_PSK、ECDH_RSA、ECDHE_RSA）のいずれかである場合、クライアントが値{sha1、rsa}を送信したかのように動作します. 

-ネゴシエートされたキー交換アルゴリズムが（DHE_DSS、DH_DSS）のいずれかである場合、クライアントが値{sha1、dsa}を送信したかのように動作します. 

-ネゴシエートされたキー交換アルゴリズムが（ECDH_ECDSA、ECDHE_ECDSA）のいずれかである場合、クライアントが値{sha1、ecdsa}を送信したかのように動作します. 

注：これは、明示的なルールがないTLS 1.1からの変更ですが、実際問題として、ピアはMD5とSHA-1をサポートしていると想定できます. 

注：この拡張機能は、1.2より前のTLSバージョンでは意味がありません. 以前のバージョンを提供している場合、クライアントはそれを提供してはなりません. ただし、クライアントがそれを提供している場合でも、[TLSEXT]で指定されているルールでは、サーバーが理解できない拡張機能を無視する必要があります. 

サーバーはこの拡張機能を送信してはなりません（MUSTNOT）. TLSサーバーは、この拡張機能の受信をサポートする必要があります. 

セッション再開を実行する場合、この拡張機能はServer Helloに含まれず、サーバーはClient Helloの拡張機能を無視します（存在する場合）. 

7.4.2. サーバー証明書
このメッセージが送信されるタイミング：

サーバーは、合意された鍵交換方法が認証に証明書を使用する場合は常に証明書メッセージを送信する必要があります（これには、DH_anonを除くこのドキュメントで定義されているすべての鍵交換方法が含まれます）. このメッセージは、常にServerHelloメッセージの直後に表示されます. 

このメッセージの意味：

このメッセージは、サーバーの証明書チェーンをクライアントに伝えます. 

証明書は、ネゴシエートされた暗号スイートのキー交換アルゴリズムおよびネゴシエートされた拡張に適切である必要があります. 

このメッセージの構造：

      不透明なASN.1Cert <1..2 ^ 24-1>;
        
      構造体{
          ASN.1Certcertificate_list <0..2 ^ 24-1>;
      }証明書;
        
certificate_listこれは証明書のシーケンス（チェーン）です. 送信者の証明書は、リストの最初に来る必要があります. 次の各証明書は、その前の証明書を直接証明する必要があります. 証明書の検証ではルートキーを個別に配布する必要があるため、ルート認証局を指定する自己署名証明書は、どのような場合でも検証するためにリモートエンドがすでに所有している必要があるという前提で、チェーンから省略できます. 

証明書要求メッセージに対するクライアントの応答には、同じメッセージタイプと構造が使用されます. サーバーの認証要求に応答して送信する適切な証明書がない場合、クライアントは証明書を送信しない場合があることに注意してください. 

注：PKCS＃6 [PKCS6]拡張証明書は使用されないため、PKCS＃7 [PKCS7]は証明書ベクトルの形式として使用されません. また、PKCS＃7はSEQUENCEではなくSETを定義しているため、リストを解析するタスクがより困難になります. 

サーバーから送信される証明書には、次のルールが適用されます. 

-明示的に別の方法でネゴシエートされない限り（[TLSPGP]など）、証明書の種類はX.509v3である必要があります. 

-エンドエンティティ証明書の公開鍵（および関連する制限）は、選択した鍵交換アルゴリズムと互換性がなければなりません. 

鍵交換アルゴリズム. 証明書キータイプ

RSARSA公開鍵; 証明書は、RSA_PSKキーを暗号化に使用できるようにする必要があります（キー使用拡張が存在する場合は、keyEnciphermentビットを設定する必要があります）. 注：RSA_PSKは[TLSPSK]で定義されています. 

DHE_RSARSA公開鍵; 証明書は、サーバーの鍵交換メッセージで使用される署名スキームとハッシュアルゴリズムを使用して、ECDHE_RSA鍵を署名に使用できるようにする必要があります（鍵使用拡張が存在する場合は、digitalSignatureビットを設定する必要があります）. 注：ECDHE_RSAは[TLSECC]で定義されています. 

DHE_DSSDSA公開鍵; 証明書は、サーバーの鍵交換メッセージで使用されるハッシュアルゴリズムを使用した署名に鍵を使用できるようにする必要があります. 

DH_DSSDiffie-Hellman公開鍵; キー使用拡張が存在する場合は、keyAgreementビットDH_RSAを設定する必要があります. 

ECDH_ECDSAECDH対応の公開鍵. [TLSECC]で説明されているように、公開鍵はECDH_RSAがクライアントでサポートされている曲線と点の形式を使用する必要があります. 

ECDHE_ECDSAECDSA対応の公開鍵. 証明書は、サーバーの鍵交換メッセージで使用されるハッシュアルゴリズムを使用した署名に鍵を使用できるようにする必要があります. 公開鍵は、[TLSECC]で説明されているように、クライアントでサポートされている曲線と点の形式を使用する必要があります. 

-「server_name」および「trusted_ca_keys」拡張子[TLSEXT]は、証明書の選択をガイドするために使用されます. 

クライアントが「signature_algorithms」拡張機能を提供した場合、サーバーによって提供されるすべての証明書は、その拡張機能に表示されるハッシュ/署名アルゴリズムのペアによって署名される必要があります. これは、ある署名アルゴリズムのキーを含む証明書が、別の署名アルゴリズム（たとえば、DSAキーで署名されたRSAキー）を使用して署名される可能性があることを意味することに注意してください. これは、アルゴリズムが同じである必要があるTLS1.1からの逸脱です. これは、DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSA鍵交換アルゴリズムが、証明書の署名に使用されるアルゴリズムを制限しないことも意味することに注意してください. 修正されたDH証明書は、拡張機能に表示されるハッシュ/署名アルゴリズムのペアで署名される場合があります. DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSAという名前は歴史的なものです. 

サーバーに複数の証明書がある場合、サーバーは上記の基準に基づいて1つを選択します（トランスポート層のエンドポイント、ローカル構成、設定などの他の基準に加えて）. サーバーに単一の証明書がある場合、サーバーはこれらの基準を満たしていることを検証しようとする必要があります. 

現在TLSで使用できないアルゴリズムやアルゴリズムの組み合わせを使用する証明書があることに注意してください. たとえば、TLSが対応する署名アルゴリズムを定義していないため、RSASSA-PSS署名キー（SubjectPublicKeyInfoのid-RSASSA-PSS OID）を持つ証明書は使用できません. 

新しい鍵交換方法を指定する暗号スイートはTLSプロトコルに指定されているため、証明書の形式と必要なエンコードされた鍵情報を意味します. 

7.4.3. サーバーキー交換メッセージ
このメッセージが送信されるタイミング：

このメッセージは、サーバー証明書メッセージ（または匿名ネゴシエーションの場合はServerHelloメッセージ）の直後に送信されます. 

ServerKeyExchangeメッセージは、サーバー証明書メッセージ（送信された場合）にクライアントがプリマスターシークレットを交換するのに十分なデータが含まれていない場合にのみ、サーバーによって送信されます. これは、次の鍵交換方法に当てはまります. 

DHE_DSS DHE_RSA DH_anon

次のキー交換方法に対してServerKeyExchangeメッセージを送信することは違法です. 

RSA DH_DSS DH_RSA

[TLSECC]で定義されているものなど、他の鍵交換アルゴリズムでは、ServerKeyExchangeメッセージを送信するかどうかを指定する必要があります. メッセージが送信された場合、その内容. 

このメッセージの意味：

このメッセージは、クライアントがプリマスターシークレット（クライアントがキー交換を完了できるDiffie-Hellman公開キー（結果はプリマスターシークレット））または他のアルゴリズムの公開キーを通信できるようにするための暗号化情報を伝達します. 

このメッセージの構造：

      列挙型{dhe_dss、dhe_rsa、dh_anon、rsa、dh_dss、dh_rsa
            / *たとえば、ECDHの場合は拡張できます-[TLSECC]を参照* /
           } KeyExchangeAlgorithm;
        
      構造体{
          不透明なdh_p <1..2 ^ 16-1>;
          不透明なdh_g <1..2 ^ 16-1>;
          不透明なdh_Ys <1..2 ^ 16-1>;
      } ServerDHParams; / *エフェメラルDHパラメータ* /
        
dh_pDiffie-Hellman演算に使用される素数係数. 

dh_gDiffie-Hellman操作に使用されるジェネレータ. 

dh_YsサーバーのDiffie-Hellman公開値（g ^ X mod p）. 

      構造体{
          select（KeyExchangeAlgorithm）{
              ケースdh_anon：
                  ServerDHParamsパラメータ;
              ケースdhe_dss：
              ケースdhe_rsa：
                  ServerDHParamsパラメータ;
                  デジタル署名された構造体{
                      不透明なclient_random [32];
                      不透明なserver_random [32];
                      ServerDHParamsパラメータ;
                  } signed_pa​​rams;
              ケースrsa：
              ケースdh_dss：
              ケースdh_rsa：
                  struct {};
                 / * rsa、dh_dss、およびdh_rsaのメッセージは省略されます* /
              / *たとえば、ECDHの場合は拡張できます-[TLSECC]を参照* /
          };
      } ServerKeyExchange;
        
paramsサーバーの鍵交換パラメーター. 

signed_pa​​rams非匿名の鍵交換の場合、サーバーの鍵交換パラメーターに対する署名. 

クライアントが「signature_algorithms」拡張機能を提供している場合、署名アルゴリズムとハッシュアルゴリズムは、その拡張機能にリストされているペアである必要があります. ここで不整合が発生する可能性があることに注意してください. たとえば、クライアントはDHE_DSSキー交換を提供しますが、「signature_algorithms」拡張機能からDSAペアを省略します. 正しくネゴシエートするために、サーバーは、候補となる暗号スイートを選択する前に、「signature_algorithms」拡張子と照合する必要があります. これはややエレガントではありませんが、元の暗号スイートの設計への変更を最小限に抑えるように設計された妥協案です. 

さらに、ハッシュおよび署名アルゴリズムは、サーバーのエンドエンティティ証明書のキーと互換性がなければなりません. RSAキーは、証明書の制限がある場合はそれを条件として、許可されたハッシュアルゴリズムで使用できます. 

DSA署名にはハッシュアルゴリズムの安全な表示が含まれていないため、任意のキーで複数のハッシュが使用される可能性がある場合、ハッシュ置換のリスクがあります. 現在、DSA [DSS]はSHA-1でのみ使用できます. DSS [DSS-3]の将来の改訂では、DSAで他のダイジェストアルゴリズムを使用できるようになるとともに、各キーサイズでどのダイジェストアルゴリズムを使用するかについてのガイダンスが提供される予定です. さらに、[PKIX]の将来のリビジョンでは、DSAで使用するダイジェストアルゴリズムを示す証明書のメカニズムが指定される可能性があります. 

新しい鍵交換アルゴリズムを含む追加の暗号スイートがTLSに定義されているため、鍵交換アルゴリズムに関連付けられた証明書タイプがクライアントがプリマスターシークレットを交換するのに十分な情報を提供しない場合にのみ、サーバー鍵交換メッセージが送信されます. 

7.4.4. 証明書要求
このメッセージが送信されるタイミング：

匿名でないサーバーは、選択した暗号スイートに適切な場合、オプションでクライアントに証明書を要求できます. このメッセージは、送信された場合、ServerKeyExchangeメッセージの直後に続きます（送信された場合、それ以外の場合、このメッセージはサーバーの証明書メッセージの後に続きます）. 

このメッセージの構造：

      列挙型{
          rsa_sign（1）、dss_sign（2）、rsa_fixed_dh（3）、dss_fixed_dh（4）、
          rsa_ephemeral_dh_RESERVED（5）、dss_ephemeral_dh_RESERVED（6）、
          fortezza_dms_RESERVED（20）、（255）
      } ClientCertificateType;
        
      不透明なDistinguishedName <1..2 ^ 16-1>;
        
      構造体{
          ClientCertificateTypecertificate_types <1..2 ^ 8-1>;
          SignatureAndHashAlgorithm
            support_signature_algorithms <2 ^ 16-1>;
          DistinguishedNamecertificate_authorities <0..2 ^ 16-1>;
      } CertificateRequest;
        
certificate_typesクライアントが提供する可能性のある証明書タイプのタイプのリスト. 

rsa_signRSAキーを含む証明書dss_signDSAキーを含む証明書rsa_fixed_dh静的DHキーを含む証明書. dss_fixed_dh静的DHキーを含む証明書

support_signature_algorithmsサーバーが検証できるハッシュ/署名アルゴリズムのペアのリスト. 優先度の高い順にリストされています. 

certificate_authoritiesDERでエンコードされた形式で表された受け入れ可能なcertificate_authoritiesの識別名[X501]のリスト. これらの識別名は、ルートCAまたは下位CAに必要な識別名を指定できます. したがって、このメッセージを使用して、既知のルートと必要な許可スペースを説明できます. Certificate_authoritiesリストが空の場合、反対の外部の取り決めがない限り、クライアントは適切なClientCertificateTypeの証明書を送信できます（MAY）. 

Certificate_typesフィールドとsupported_signature_algorithmsフィールドの相互作用はやや複雑です. Certificate_typesはSSLv3以降TLSに存在していましたが、やや過小評価されていました. その機能の多くは、supported_signature_algorithmsに置き換えられています. 次のルールが適用されます. 

-クライアントによって提供される証明書は、supported_signature_algorithmsにあるハッシュ/署名アルゴリズムのペアを使用して署名する必要があります. 

-クライアントによって提供されるエンドエンティティ証明書には、certificate_typesと互換性のあるキーが含まれている必要があります. キーが署名キーである場合、supported_signature_algorithmsのハッシュ/署名アルゴリズムのペアで使用できる必要があります. 

-歴史的な理由から、一部のクライアント証明書タイプの名前には、証明書の署名に使用されるアルゴリズムが含まれています. たとえば、以前のバージョンのTLSでは、rsa_fixed_dhは、RSAで署名され、静的DHキーを含む証明書を意味していました. TLS 1.2では、この機能はsupported_signature_algorithmsによって廃止され、証明書の種類によって、証明書の署名に使用されるアルゴリズムが制限されなくなりました. たとえば、サーバーがdss_fixed_dh証明書タイプと{{sha1、dsa}、{sha1、rsa}}署名タイプを送信する場合、クライアントはRSA-SHA1で署名された静的DHキーを含む証明書で応答してもよい[MAY]. 

新しいClientCertificateType値は、セクション12で説明されているようにIANAによって割り当てられます. 

注：RESERVEDとしてリストされている値は使用できません. それらはSSLv3で使用されました. 

注：匿名サーバーがクライアント認証を要求することは、致命的なhandshake_failureアラートです. 

7.4.5. サーバーこんにちは完了
このメッセージが送信されるタイミング：

ServerHelloDoneメッセージは、ServerHelloおよび関連するメッセージの終了を示すためにサーバーによって送信されます. このメッセージを送信した後、サーバーはクライアントの応答を待ちます. 

このメッセージの意味：

このメッセージは、サーバーが鍵交換をサポートするためのメッセージの送信を完了し、クライアントが鍵交換のフェーズを続行できることを意味します. 

ServerHelloDoneメッセージを受信すると、クライアントは、必要に応じてサーバーが有効な証明書を提供したことを確認し、サーバーのhelloパラメーターが受け入れ可能であることを確認する必要があります. 

このメッセージの構造：

      struct {} ServerHelloDone;
        
7.4.6. クライアント証明書
このメッセージが送信されるタイミング：

これは、ServerHelloDoneメッセージを受信した後にクライアントが送信できる最初のメッセージです. このメッセージは、サーバーが証明書を要求した場合にのみ送信されます. 適切な証明書が利用できない場合、クライアントは証明書を含まない証明書メッセージを送信する必要があります. つまり、certificate_list構造の長さはゼロです. クライアントが証明書を送信しない場合、サーバーはその裁量でクライアント認証なしでハンドシェイクを続行するか、致命的なhandshake_failureアラートで応答することができます. また、証明書チェーンの一部の側面が受け入れられない場合（たとえば、既知の信頼できるCAによって署名されていない場合）、サーバーはその裁量でハンドシェイクを続行するか（クライアントが認証されていないと見なす）、致命的なアラートを送信できます. 

クライアント証明書は、セクション7.4.2で定義されている証明書構造を使用して送信されます. 

このメッセージの意味：

このメッセージは、クライアントの証明書チェーンをサーバーに伝えます. サーバーは、CertificateVerifyメッセージの検証（クライアント認証が署名に基づく場合）またはプリマスターシークレットの計算（非エフェメラルDiffie-Hellmanの場合）時にこれを使用します. 証明書は、ネゴシエートされた暗号スイートのキー交換アルゴリズム、およびネゴシエートされた拡張に適切である必要があります. 

特に：

-明示的に別の方法でネゴシエートされない限り（[TLSPGP]など）、証明書の種類はX.509v3である必要があります. 

-エンドエンティティ証明書の公開鍵（および関連する制限）は、CertificateRequestにリストされている証明書タイプと互換性がある必要があります. 

クライアント証明書. タイプ証明書キータイプ

rsa_signRSA公開鍵; 証明書は、証明書検証メッセージで使用される署名スキームとハッシュアルゴリズムを使用した署名にキーを使用できるようにする必要があります. 

dss_signDSA公開鍵; 証明書は、証明書検証メッセージで使用されるハッシュアルゴリズムを使用した署名にキーを使用できるようにする必要があります. 

ecdsa_signECDSA対応の公開鍵. 証明書は、証明書検証メッセージで使用されるハッシュアルゴリズムを使用した署名にキーを使用できるようにする必要があります. 公開鍵は、サーバーでサポートされている曲線と点の形式を使用する必要があります. 

rsa_fixed_dhDiffie-Hellman公開鍵; サーバーのキーと同じdss_fixed_dhパラメーターを使用する必要があります. 

rsa_fixed_ecdhECDH対応の公開鍵. サーバーのキーと同じ曲線のecdsa_fixed_ecdhを使用する必要があり、サーバーでサポートされているポイント形式を使用する必要があります. 

-証​​明書要求メッセージのcertificate_authoritiesリストが空でない場合、証明書チェーン内の証明書の1つは、リストされているCAの1つによって発行される必要があります. 

-証​​明書は、セクション7.4.4で説明されているように、許容可能なハッシュ/署名アルゴリズムのペアを使用して署名する必要があります. これにより、以前のバージョンのTLSに見られた証明書署名アルゴリズムの制約が緩和されることに注意してください. 

サーバー証明書と同様に、現在TLSでは使用できないアルゴリズム/アルゴリズムの組み合わせを使用する証明書があることに注意してください. 

7.4.7. クライアントキー交換メッセージ
このメッセージが送信されるタイミング：

このメッセージは常にクライアントから送信されます. 送信された場合は、クライアント証明書メッセージの直後に続く必要があります. それ以外の場合は、ServerHelloDoneメッセージを受信した後、クライアントによって送信される最初のメッセージである必要があります. 

このメッセージの意味：

このメッセージでは、RSA暗号化シークレットを直接送信するか、各側が同じプリマスターシークレットに同意できるようにするDiffie-Hellmanパラメーターを送信することにより、プリマスターシークレットが設定されます. 

クライアントが一時的なDiffie-Hellman指数を使用している場合、このメッセージにはクライアントのDiffie-Hellman公開値が含まれます. クライアントが静的DH指数を含む証明書を送信している場合（つまり、fixed_dhクライアント認証を実行している場合）、このメッセージを送信する必要がありますが、空にする必要があります. 

このメッセージの構造：

メッセージの選択は、選択した鍵交換方法によって異なります. KeyExchangeAlgorithmの定義については、セクション7.4.3を参照してください. 

      構造体{
          select（KeyExchangeAlgorithm）{
              ケースrsa：
                  EncryptedPreMasterSecret;
              ケースdhe_dss：
              ケースdhe_rsa：
              ケースdh_dss：
              ケースdh_rsa：
              ケースdh_anon：
                  ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;
        
7.4.7.1. RSA暗号化プリマスターシークレットメッセージ
このメッセージの意味：

RSAがキーの合意と認証に使用されている場合、クライアントは48バイトのプリマスターシークレットを生成し、サーバーの証明書の公開キーを使用して暗号化し、その結果を暗号化されたプリマスターシークレットメッセージで送信します. この構造はClientKeyExchangeメッセージの変形であり、それ自体はメッセージではありません. 

このメッセージの構造：

      構造体{
          ProtocolVersion client_version;
          不透明なランダム[46];
      } PreMasterSecret;
        
client_versionクライアントがサポートする最新（最新）のバージョン. これは、バージョンのロールバック攻撃を検出するために使用されます. 

ランダム46の安全に生成されたランダムバイト. 

      構造体{
          公開鍵暗号化されたPreMasterSecretpre_master_secret;
      } EncryptedPreMasterSecret;
        
pre_master_secretこのランダムな値はクライアントによって生成され、セクション8.1で指定されているように、マスターシークレットを生成するために使用されます. 

注：PreMasterSecretのバージョン番号は、ClientHello.client_versionでクライアントによって提供されたバージョンであり、接続用にネゴシエートされたバージョンではありません. この機能は、ロールバック攻撃を防ぐように設計されています. 残念ながら、一部の古い実装では代わりにネゴシエートされたバージョンが使用されるため、バージョン番号を確認すると、そのような誤ったクライアント実装との相互運用に失敗する可能性があります. 

クライアント実装は、常にPreMasterSecretで正しいバージョン番号を送信する必要があります. ClientHello.client_versionがTLS1.1以降の場合、サーバー実装は、以下の注で説明されているようにバージョン番号を確認する必要があります. バージョン番号がTLS1.0以前の場合、サーバー実装はバージョン番号をチェックする必要がありますが、チェックを無効にする構成オプションがある場合があります. チェックが失敗した場合、PreMasterSecretは以下に説明するようにランダム化されるべきであることに注意してください. 

注：Bleichenbacher [BLEI]とKlimaetalによって発見された攻撃. [KPR03]を使用して、TLSサーバーを攻撃し、特定のメッセージが復号化されたときに、適切にPKCS＃1形式であるか、有効なPreMasterSecret構造を含むか、または正しいバージョン番号を持っているかを明らかにできます. 

Klima [KPR03]で説明されているように、これらの脆弱性は、正しくフォーマットされたRSAブロックと区別できない方法で、誤ってフォーマットされたメッセージブロックや不一致のバージョン番号を処理することで回避できます. 言い換えると：

1.46ランダムバイトの文字列Rを生成します

2.メッセージを復号化して平文Mを復元します

3. PKCS＃1のパディングが正しくない場合、またはメッセージMの長さが正確に48バイトではない場合：pre_master_secret = ClientHello.client_version || R else ClientHello.client_version <= TLS 1.0で、バージョン番号チェックが明示的に無効になっている場合：pre_master_secret = M else：pre_master_secret = ClientHello.client_version || M [2..47]

ClientHello.client_versionを使用してpre_master_secretを明示的に構築すると、クライアントが元のpre_master_secretで間違ったバージョンを送信した場合、無効なmaster_secretが生成されることに注意してください. 

別のアプローチは、バージョン番号の不一致をPKCS-1フォーマットエラーとして扱い、プリマスターシークレットを完全にランダム化することです. 

1.48ランダムバイトの文字列Rを生成します

2.メッセージを復号化して平文Mを復元します

3. PKCS＃1のパディングが正しくない場合、またはメッセージMの長さが正確に48バイトでない場合：pre_master_secret = R else ClientHello.client_version <= TLS 1.0で、バージョン番号チェックが明示的に無効になっている場合：premaster secret = M else If M [0..1]！= ClientHello.client_version：premaster secret = R else：premaster secret = M

この構造に対する実際的な攻撃は知られていないが、Klima etal. [KPR03]はいくつかの理論上の攻撃について説明しているため、最初に説明した構成をお勧めします. 

いずれの場合も、RSAで暗号化されたプリマスターシークレットメッセージの処理が失敗した場合、またはバージョン番号が期待どおりでない場合、TLSサーバーはアラートを生成してはなりません（MUSTNOT）. 代わりに、ランダムに生成されたプリマスターシークレットを使用してハンドシェイクを続行する必要があります. トラブルシューティングの目的で、障害の本当の原因をログに記録すると便利な場合があります. ただし、攻撃者に情報が漏洩しないように注意する必要があります（タイミング、ログファイル、その他のチャネルなどを介して）. 

[PKCS1]で定義されているRSAES-OAEP暗号化スキームは、Bleichenbacher攻撃に対してより安全です. ただし、以前のバージョンのTLSとの互換性を最大限に高めるために、この仕様ではRSAES-PKCS1-v1_5スキームを使用しています. 上記の推奨事項に従えば、ブライヘンバッハー攻撃の変種は存在しないことがわかっています. 

実装上の注意：公開鍵で暗号化されたデータは、不透明なベクトル<0..2 ^ 16-1>として表されます（セクション4.7を参照）. したがって、ClientKeyExchangeのRSA暗号化PreMasterSecretの前には、2つの長さのバイトがあります. RSAの場合、これらのバイトは冗長です. これは、EncryptedPreMasterSecretがClientKeyExchange内の唯一のデータであり、その長さを明確に決定できるためです. SSLv3仕様は、公開鍵暗号化データのエンコードについて明確ではなかったため、多くのSSLv3実装には長さバイトが含まれていません. つまり、RSA暗号化データをClientKeyExchangeメッセージに直接エンコードします. 

この仕様では、長さバイトを含むEncryptedPreMasterSecretを正しくエンコードする必要があります. 結果として得られるPDUは、多くのSSLv3実装と互換性がありません. SSLv3からアップグレードする実装者は、正しいエンコーディングを生成して受け入れるように実装を変更する必要があります. SSLv3とTLSの両方との互換性を希望する実装者は、実装の動作をプロトコルバージョンに依存させる必要があります. 

実装上の注意：少なくともクライアントとサーバーが同じLAN上にある場合、TLSに対するリモートタイミングベースの攻撃が可能であることがわかっています. したがって、静的RSAキーを使用する実装では、[TIMING]で説明されているように、RSAブラインドまたはその他のタイミング防止技術を使用する必要があります. 

7.4.7.2. クライアントDiffie-HellmanPublic Value
このメッセージの意味：

この構造は、クライアントの証明書にまだ含まれていない場合、クライアントのDiffie-Hellman公開値（Yc）を伝達します. Ycに使用されるエンコーディングは、列挙されたPublicValueEncodingによって決定されます. この構造は、クライアントキー交換メッセージの変形であり、メッセージ自体ではありません. 

このメッセージの構造：

      列挙型{暗黙的、明示的} PublicValueEncoding;
        
暗黙的クライアントが適切なDiffie-Hellmanキー（fixed_dhクライアント認証用）を含む証明書を送信した場合、Ycは暗黙的であり、再度送信する必要はありません. この場合、クライアントキー交換メッセージが送信されますが、空である必要があります. 

明示的なYcを送信する必要があります. 

      構造体{
          select（PublicValueEncoding）{
              暗黙の場合：struct {};
              明示的な場合：不透明dh_Yc <1..2 ^ 16-1>;
          } dh_public;
      } ClientDiffieHellmanPublic;
        
dh_YcクライアントのDiffie-Hellman公開値（Yc）. 

7.4.8. 証明書の検証
このメッセージが送信されるタイミング：

このメッセージは、クライアント証明書の明示的な検証を提供するために使用されます. このメッセージは、署名機能を持つクライアント証明書（つまり、固定のDiffie-Hellmanパラメーターを含む証明書を除くすべての証明書）の後にのみ送信されます. 送信されると、クライアントの鍵交換メッセージの直後に続く必要があります. 

このメッセージの構造：

      構造体{
           デジタル署名された構造体{
               不透明なhandshake_messages [handshake_messages_length];
           }
      } CertificateVerify;
        
ここで、handshake_messagesは、クライアントhelloから始まり、このメッセージまで（ただし、このメッセージを含まない）、ハンドシェイクメッセージのタイプフィールドと長さフィールドを含む、送受信されるすべてのハンドシェイクメッセージを指します. これは、これまでに交換されたすべてのハンドシェイク構造（セクション7.4で定義）の連結です. これには、CertificateVerifyの計算時まで、メッセージをバッファリングするか、すべての潜在的なハッシュアルゴリズムの実行中のハッシュを計算する必要があることに注意してください. サーバーは、CertificateRequestメッセージで制限されたダイジェストアルゴリズムのセットを提供することにより、この計算コストを最小限に抑えることができます. 

署名で使用されるハッシュおよび署名アルゴリズムは、CertificateRequestメッセージのsupported_signature_algorithmsフィールドに存在するものの1つでなければなりません. さらに、ハッシュおよび署名アルゴリズムは、クライアントのエンドエンティティ証明書のキーと互換性がなければなりません. RSAキーは、証明書の制限がある場合はそれを条件として、許可されたハッシュアルゴリズムで使用できます. 

DSA署名にはハッシュアルゴリズムの安全な表示が含まれていないため、任意のキーで複数のハッシュが使用される可能性がある場合、ハッシュ置換のリスクがあります. 現在、DSA [DSS]はSHA-1でのみ使用できます. DSS [DSS-3]の将来の改訂では、DSAで他のダイジェストアルゴリズムを使用できるようになるとともに、各キーサイズでどのダイジェストアルゴリズムを使用するかについてのガイダンスが提供される予定です. さらに、[PKIX]の将来のリビジョンでは、DSAで使用するダイジェストアルゴリズムを示す証明書のメカニズムが指定される可能性があります. 

7.4.9. 終了しました
このメッセージが送信されるタイミング：

終了メッセージは、鍵交換および認証プロセスが成功したことを確認するために、暗号仕様の変更メッセージの直後に常に送信されます. 他のハンドシェイクメッセージとFinishedメッセージの間で暗号仕様変更メッセージを受信することが不可欠です. 

このメッセージの意味：

終了メッセージは、ネゴシエートされたばかりのアルゴリズム、キー、およびシークレットで保護された最初のメッセージです. 終了メッセージの受信者は、内容が正しいことを確認する必要があります. サイドがFinishedメッセージを送信し、ピアからFinishedメッセージを受信して​​検証すると、接続を介したアプリケーションデータの送受信を開始できます. 

このメッセージの構造：

      構造体{
          不透明なverify_data [verify_data_length];
      }終了しました. 
        
      verify_data
         PRF（master_secret、finished_label、Hash（handshake_messages））
            [0..verify_data_length-1];
        
finish_labelクライアントから送信された終了メッセージの場合、文字列「clientfinished」. サーバーから送信されたFinishedメッセージの場合、文字列「serverfinished」. 

ハッシュは、ハンドシェイクメッセージのハッシュを示します. セクション5で定義されたPRFの場合、ハッシュはPRFの基礎として使用されるハッシュでなければなりません. 異なるPRFを定義する暗号スイートは、Finished計算で使用するハッシュも定義する必要があります. 

以前のバージョンのTLSでは、verify_dataは常に12オクテットの長さでした. TLSの現在のバージョンでは、暗号スイートに依存します. verify_data_lengthを明示的に指定しない暗号スイートには、12に等しいverify_data_lengthがあります. これには、既存のすべての暗号スイートが含まれます. この表現は、以前のバージョンと同じエンコーディングであることに注意してください. 将来の暗号スイートは他の長さを指定するかもしれませんが、そのような長さは少なくとも12バイトでなければなりません. 

handshake_messagesこのハンドシェイク内のすべてのメッセージ（HelloRequestメッセージを含まない）からこのメッセージまでのすべてのデータ（ただし、このメッセージは含まない）. これはハンドシェイクレイヤーで表示されるデータのみであり、レコードレイヤーヘッダーは含まれません. これは、これまでに交換された、セクション7.4で定義されているすべてのハンドシェイク構造の連結です. 

ハンドシェイクの適切なポイントでFinishedメッセージの前にChangeCipherSpecメッセージがない場合、致命的なエラーになります. 

値handshake_messagesには、ClientHelloから始まり、この終了メッセージまでのすべてのハンドシェイクメッセージが含まれます. これは、CertificateVerifyメッセージ（送信された場合）が含まれるため、セクション7.4.8のhandshake_messagesとは異なる場合があります. また、クライアントによって送信されたFinishedメッセージのhandshake_messagesは、サーバーによって送信されたFinishedメッセージのhandshake_messagesとは異なります. これは、2番目に送信されるメッセージに前のメッセージが含まれるためです. 

注：ChangeCipherSpecメッセージ、アラート、およびその他のレコードタイプは、ハンドシェイクメッセージではなく、ハッシュ計算には含まれません. また、HelloRequestメッセージはハンドシェイクハッシュから省略されます. 

8.暗号計算
接続保護を開始するために、TLSレコードプロトコルでは、一連のアルゴリズム、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります. 認証、暗号化、およびMACアルゴリズムは、サーバーによって選択され、ServerHelloメッセージで明らかにされるcipher_suiteによって決定されます. 圧縮アルゴリズムはhelloメッセージでネゴシエートされ、ランダムな値がhelloメッセージで交換されます. 残っているのは、マスターシークレットを計算することだけです. 

8.1. マスターシークレットの計算
すべての鍵交換方法で、同じアルゴリズムを使用してpre_master_secretをmaster_secretに変換します. master_secretが計算されたら、pre_master_secretをメモリから削除する必要があります. 

      master_secret = PRF（pre_master_secret、 "マスターシークレット"、
                          ClientHello.random + ServerHello.random）
                          [0..47];
        
マスターシークレットの長さは常に正確に48バイトです. プリマスターシークレットの長さは、鍵交換方法によって異なります. 

8.1.1. RSA
サーバー認証と鍵交換にRSAを使用する場合、48バイトのpre_master_secretがクライアントによって生成され、サーバーの公開鍵で暗号化されてサーバーに送信されます. サーバーは秘密鍵を使用してpre_master_secretを復号化します. 次に、上記のように、両方の当事者がpre_master_secretをmaster_secretに変換します. 

8.1.2. ディフィー・ヘルマン
従来のDiffie-Hellman計算が実行されます. ネゴシエートされたキー（Z）はpre_master_secretとして使用され、上記のようにmaster_secretに変換されます. すべてゼロビットを含むZの先頭バイトは、pre_master_secretとして使用される前に削除されます. 

注：Diffie-Hellmanパラメーターはサーバーによって指定され、一時的であるか、サーバーの証明書に含まれている可能性があります. 

9.必須の暗号スイート
特に明記されていないアプリケーションプロファイル標準がない場合、TLS準拠のアプリケーションは暗号スイートTLS_RSA_WITH_AES_128_CBC_SHAを実装する必要があります（定義については付録A.5を参照）. 

10.アプリケーションデータプロトコル
アプリケーションデータメッセージはレコードレイヤーによって伝送され、現在の接続状態に基づいてフラグメント化、圧縮、および暗号化されます. メッセージは、レコード層に対して透過的なデータとして扱われます. 

11.セキュリティに関する考慮事項
セキュリティの問題については、このメモ全体、特に付録D、E、およびFで説明しています. 

12.IANAの考慮事項
このドキュメントでは、[TLS1.1]で最初に作成されたいくつかのレジストリを使用しています. IANAは、このドキュメントを参照するためにこれらを更新しました. レジストリとその割り当てポリシー（[TLS1.1]から変更なし）を以下に示します. 

--TLS ClientCertificateType Identifiersレジストリ：0〜63（10進数）の範囲の将来の値は、標準アクション[RFC2434]を介して割り当てられます. 64-223（10進数）を含む範囲の値は、仕様が必要[RFC2434]を介して割り当てられます. 224-255（10進数）を含む値は、私的使用のために予約されています[RFC2434]. 

-TLS暗号スイートレジストリ：0〜191（10進数）の範囲の最初のバイトを持つ将来の値は、標準アクション[RFC2434]を介して割り当てられます. 最初のバイトが192〜254（10進数）の範囲の値は、仕様が必要[RFC2434]を介して割り当てられます. 最初のバイトが255（10進数）の値は、私的使用のために予約されています[RFC2434]. 

-このドキュメントでは、いくつかの新しいHMAC-SHA256ベースの暗号スイートを定義しています. これらの値（付録A.5）は、TLS暗号スイートレジストリから割り当てられています. 

-TLS ContentTypeレジストリ：将来の値は、標準アクション[RFC2434]を介して割り当てられます. 

-TLSアラートレジストリ：将来の値は、標準アクション[RFC2434]を介して割り当てられます. 

-TLS HandshakeTypeレジストリ：将来の値は、標準アクション[RFC2434]を介して割り当てられます. 

このドキュメントでは、[RFC4366]で最初に作成されたレジストリも使用しています. IANAは、このドキュメントを参照するように更新しました. レジストリとその割り当てポリシー（[RFC4366]から変更なし）を以下に示します. 

-TLS ExtensionTypeレジストリ：将来の値は、IETFコンセンサス[RFC2434]を介して割り当てられます. IANAはこのレジストリを更新して、signature_algorithms拡張機能とそれに対応する値を含めました（セクション7.4.1.4を参照）. 

さらに、このドキュメントでは、IANAが管理する2つの新しいレジストリを定義しています. 

--TLS SignatureAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1で説明されている値が最初に入力されています. 0〜63（10進数）を含む範囲の将来価値は、標準アクション[RFC2434]を介して割り当てられます. 64-223（10進数）を含む範囲の値は、仕様が必要[RFC2434]を介して割り当てられます. 224-255（10進数）を含む値は、私的使用のために予約されています[RFC2434]. 

--TLS HashAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1で説明されている値が最初に入力されています. 0〜63（10進数）を含む範囲の将来価値は、標準アクション[RFC2434]を介して割り当てられます. 64-223（10進数）を含む範囲の値は、仕様が必要[RFC2434]を介して割り当てられます. 224-255（10進数）を含む値は、私的使用のために予約されています[RFC2434]. 

このドキュメントでは、[RFC3749]で定義されているTLS圧縮メソッド識別子レジストリも使用しています. IANAは、「null」圧縮方法に値0を割り当てました. 

付録A.プロトコルのデータ構造と定数値
このセクションでは、プロトコルのタイプと定数について説明します. 

A.1. レコードレイヤー
   構造体{
       uint8メジャー;
       uint8マイナー;
   } ProtocolVersion;
        
   ProtocolVersionバージョン= {3、3}; / * TLS v1.2 * /
        
   列挙型{
       change_cipher_spec（20）、alert（21）、handshake（22）、
       application_data（23）、（255）
   } ContentType;
        
   構造体{
       ContentTypeタイプ;
       ProtocolVersionバージョン;
       uint16の長さ;
       不透明なフラグメント[TLSPlaintext.length];
   } TLSPlaintext;
        
   構造体{
       ContentTypeタイプ;
       ProtocolVersionバージョン;
       uint16の長さ;
       不透明なフラグメント[TLSCompressed.length];
   } TLSCompressed;
        
   構造体{
       ContentTypeタイプ;
       ProtocolVersionバージョン;
       uint16の長さ;
       select（SecurityParameters.cipher_type）{
           ケースストリーム：GenericStreamCipher;
           ケースブロック：GenericBlockCipher;
           ケースaead：GenericAEADCipher;
       }フラグメント;
   } TLSCiphertext;
        
   ストリーム暗号化された構造体{
       不透明なコンテンツ[TLSCompressed.length];
       不透明なMAC [SecurityParameters.mac_length];
   } GenericStreamCipher;
        
   構造体{
       不透明なIV [SecurityParameters.record_iv_length];
       ブロック暗号化された構造体{
           不透明なコンテンツ[TLSCompressed.length];
           不透明なMAC [SecurityParameters.mac_length];
           uint8 padding [GenericBlockCipher.padding_length];
           uint8 padding_length;
       };
   } GenericBlockCipher;
        
   構造体{
      不透明なnonce_explicit [SecurityParameters.record_iv_length];
      aead-ciphered struct {
          不透明なコンテンツ[TLSCompressed.length];
      };
   } GenericAEADCipher;
        
A.2. 暗号仕様の変更メッセージ
   構造体{
       列挙型{change_cipher_spec（1）、（255）}タイプ;
   } ChangeCipherSpec;
        
A.3. 警告メッセージ
   列挙型{warning（1）、fatal（2）、（255）} AlertLevel;
        
   列挙型{
       close_notify（0）、
       予期しないメッセージ（10）、
       bad_record_mac（20）、
       復号化に失敗しました_RESERVED（21）、
       record_overflow（22）、
       decompression_failure（30）、
       handshake_failure（40）、
       no_certificate_RESERVED（41）、
       bad_certificate（42）、
       unsupported_certificate（43）、
       証明書失効（44）、
       証明書の有効期限（45）、
       証明書不明（46）、
       illegal_parameter（47）、
       unknown_ca（48）、
       access_denied（49）、
       decode_error（50）、
       復号化エラー（51）、
       export_restriction_RESERVED（60）、
       protocol_version（70）、不十分なセキュリティ（71）、
       internal_error（80）、
       user_canceled（90）、
       no_renegotiation（100）、
       unsupported_extension（110）、/ *新しい* /
       （255）
   } AlertDescription;
        
   構造体{
       AlertLevelレベル;
       AlertDescriptionの説明;
   }アラート;
        
A.4. ハンドシェイクプロトコル
   列挙型{
       hello_request（0）、client_hello（1）、server_hello（2）、
       証明書（11）、server_key_exchange（12）、
       certificate_request（13）、server_hello_done（14）、
       Certificate_verify（15）、client_key_exchange（16）、
       終了（20）
       （255）
   } HandshakeType;
        
   構造体{
       HandshakeType msg_type;
       uint24の長さ;
       select（HandshakeType）{
           ケースhello_request：HelloRequest;
           ケースclient_hello：ClientHello;
           ケースserver_hello：ServerHello;
           ケース証明書：証明書;
           ケースserver_key_exchange：ServerKeyExchange;
           ケースcertificate_request：CertificateRequest;
           ケースserver_hello_done：ServerHelloDone;
           ケースcertificate_verify：CertificateVerify;
           ケースclient_key_exchange：ClientKeyExchange;
           ケースが終了しました：終了しました. 
       } 体;
   }ハンドシェイク;
        
A.4.1. こんにちはメッセージ
   struct {} HelloRequest;
        
   構造体{
       uint32 gmt_unix_time;
       不透明なrandom_bytes [28];
   }ランダム;
        
   不透明なSessionID <0..32>;
        
uint8 CipherSuite [2];

   列挙型{null（0）、（255）} CompressionMethod;
        
   構造体{
       ProtocolVersion client_version;
       ランダムランダム;
       SessionID session_id;
       CipherSuite cipher_suites <2..2 ^ 16-2>;
       CompressionMethodcompression_methods <1..2 ^ 8-1>;
       select（extensions_present）{
           ケースfalse：
               構造体{};
           真の場合：
               拡張拡張<0..2 ^ 16-1>;
       };
   } ClientHello;
        
   構造体{
       ProtocolVersion server_version;
       ランダムランダム;
       SessionID session_id;
       暗号スイートcipher_suite;
       CompressionMethodcompression_method;
       select（extensions_present）{
           ケースfalse：
               構造体{};
           真の場合：
               拡張拡張<0..2 ^ 16-1>;
       };
   } ServerHello;
        
   構造体{
       ExtensionType extension_type;
       不透明なextension_data <0..2 ^ 16-1>;
   }拡張機能;
        
   列挙型{
       Signature_algorithms（13）、（65535）
   } ExtensionType;
        
   列挙型{
       none（0）、md5（1）、sha1（2）、sha224（3）、sha256（4）、sha384（5）、
       sha512（6）、（255）
   } HashAlgorithm;
   列挙型{
      匿名（0）、rsa（1）、dsa（2）、ecdsa（3）、（255）
   } SignatureAlgorithm;
        
   構造体{
         HashAlgorithmハッシュ;
         SignatureAlgorithm署名;
   } SignatureAndHashAlgorithm;
        
   SignatureAndHashAlgorithm
    support_signature_algorithms <2..2 ^ 16-1>;
        
A.4.2. サーバー認証と鍵交換メッセージ
   不透明なASN.1Cert <2 ^ 24-1>;
        
   構造体{
       ASN.1Certcertificate_list <0..2 ^ 24-1>;
   }証明書;
        
   列挙型{dhe_dss、dhe_rsa、dh_anon、rsa、dh_dss、dh_rsa
          / *たとえば、ECDHの場合は拡張できます-[TLSECC]を参照* /
        } KeyExchangeAlgorithm;
        
   構造体{
       不透明なdh_p <1..2 ^ 16-1>;
       不透明なdh_g <1..2 ^ 16-1>;
       不透明なdh_Ys <1..2 ^ 16-1>;
   } ServerDHParams; / *エフェメラルDHパラメータ* / struct {
       select（KeyExchangeAlgorithm）{
           ケースdh_anon：
               ServerDHParamsパラメータ;
           ケースdhe_dss：
           ケースdhe_rsa：
               ServerDHParamsパラメータ;
               デジタル署名された構造体{
                   不透明なclient_random [32];
                   不透明なserver_random [32];
                   ServerDHParamsパラメータ;
               } signed_pa​​rams;
           ケースrsa：
           ケースdh_dss：
           ケースdh_rsa：
               struct {};
              / * rsa、dh_dss、およびdh_rsaのメッセージは省略されます* /
           / *たとえば、ECDHの場合は拡張できます-[TLSECC]を参照* /
   } ServerKeyExchange;
        
   列挙型{
       rsa_sign（1）、dss_sign（2）、rsa_fixed_dh（3）、dss_fixed_dh（4）、
       rsa_ephemeral_dh_RESERVED（5）、dss_ephemeral_dh_RESERVED（6）、
       fortezza_dms_RESERVED（20）、
       （255）
   } ClientCertificateType;
        
   不透明なDistinguishedName <1..2 ^ 16-1>;
        
   構造体{
       ClientCertificateTypecertificate_types <1..2 ^ 8-1>;
       DistinguishedNamecertificate_authorities <0..2 ^ 16-1>;
   } CertificateRequest;
        
   struct {} ServerHelloDone;
        
A.4.3. クライアント認証と鍵交換メッセージ
   構造体{
       select（KeyExchangeAlgorithm）{
           ケースrsa：
               EncryptedPreMasterSecret;
           ケースdhe_dss：
           ケースdhe_rsa：
           ケースdh_dss：
           ケースdh_rsa：
           ケースdh_anon：
               ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;
        
   構造体{
       ProtocolVersion client_version;
       不透明なランダム[46];
   } PreMasterSecret;
        
   構造体{
       公開鍵暗号化されたPreMasterSecretpre_master_secret;
   } EncryptedPreMasterSecret;
        
   列挙型{暗黙的、明示的} PublicValueEncoding;
        
   構造体{
       select（PublicValueEncoding）{
           暗黙の場合：struct {};
           明示的な場合：不透明なDH_Yc <1..2 ^ 16-1>;
       } dh_public;
   } ClientDiffieHellmanPublic;
        
   構造体{
        デジタル署名された構造体{
            不透明なhandshake_messages [handshake_messages_length];
        }
   } CertificateVerify;
        
A.4.4. ハンドシェイクファイナライズメッセージ
   構造体{
       不透明なverify_data [verify_data_length];
   }終了しました. 
        
A.5. 暗号スイート
次の値は、ClientHelloおよびServerHelloメッセージで使用される暗号スイートコードを定義します. 

暗号スイートは、TLSバージョン1.2でサポートされている暗号仕様を定義します. 

TLS_NULL_WITH_NULL_NULLが指定されており、そのチャネルでの最初のハンドシェイク中のTLS接続の初期状態ですが、セキュリティで保護されていない接続以上の保護を提供しないため、ネゴシエートしてはなりません. 

      CipherSuite TLS_NULL_WITH_NULL_NULL = {0x00,0x00};
        
次のCipherSuite定義では、サーバーがキー交換に使用できるRSA証明書を提供する必要があります. サーバーは、証明書要求メッセージで署名対応の証明書を要求できます. 

      CipherSuite TLS_RSA_WITH_NULL_MD5 = {0x00,0x01};
      CipherSuite TLS_RSA_WITH_NULL_SHA = {0x00,0x02};
      CipherSuite TLS_RSA_WITH_NULL_SHA256 = {0x00,0x3B};
      CipherSuite TLS_RSA_WITH_RC4_128_MD5 = {0x00,0x04};
      CipherSuite TLS_RSA_WITH_RC4_128_SHA = {0x00,0x05};
      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = {0x00,0x0A};
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = {0x00,0x2F};
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = {0x00,0x35};
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = {0x00,0x3C};
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x3D};
        
次の暗号スイート定義は、サーバー認証（およびオプションでクライアント認証）のDiffie-Hellmanに使用されます. DHは、サーバーの証明書に認証局（CA）によって署名されたDiffie-Hellmanパラメーターが含まれている暗号スイートを示します. DHEは、一時的なDiffie-Hellmanを示します. ここで、Diffie-Hellmanパラメーターは、CAによって署名された署名対応証明書によって署名されます. サーバーが使用する署名アルゴリズムは、CipherSuite名のDHEコンポーネントの後に指定されます. サーバーは、クライアント認証のためにクライアントに署名対応の証明書を要求することも、Diffie-Hellman証明書を要求することもできます. クライアントによって提供されるDiffie-Hellman証明書は、サーバーによって記述されたパラメーター（グループおよびジェネレーター）を使用する必要があります. 

      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = {0x00,0x0D};
      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = {0x00,0x10};
      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = {0x00,0x13};
      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = {0x00,0x16};
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = {0x00,0x30};
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = {0x00,0x31};
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = {0x00,0x32};
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = {0x00,0x33};
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = {0x00,0x36};
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = {0x00,0x37};
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = {0x00,0x38};
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = {0x00,0x39};
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = {0x00,0x3E};
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = {0x00,0x3F};
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = {0x00,0x40};
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = {0x00,0x67};
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = {0x00,0x68};
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x69};
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = {0x00,0x6A};
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x6B};
        
次の暗号スイートは、どちらの当事者も認証されない完全に匿名のDiffie-Hellman通信に使用されます. このモードはman-in-the-middle攻撃に対して脆弱であることに注意してください. したがって、このモードの使用は限定的に使用されます. アプリケーション層が匿名鍵交換を許可するように特に要求していない限り、これらの暗号スイートをTLS1.2実装で使用してはなりません. （匿名の鍵交換は、たとえば、認証のセットアップが行われていない場合や、認証を保証する他の手段を持つより複雑なセキュリティプロトコルの一部としてTLSが使用されている場合に、日和見暗号化をサポートするために受け入れられる場合があります. ）

      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = {0x00,0x18};
      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = {0x00,0x1B};
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = {0x00,0x34};
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = {0x00,0x3A};
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = {0x00,0x6C};
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = {0x00,0x6D};
        
実際に鍵交換を検証せずに非匿名鍵交換を使用することは、本質的に匿名鍵交換と同等であり、同じ予防措置が適用されることに注意してください. 非匿名鍵交換は、一般に匿名鍵交換よりも計算コストと通信コストが高くなりますが、アプリケーション層が匿名鍵交換を許可している場合に非匿名鍵交換を無効にしないことが相互運用性の利益になる可能性があります. 

セクション12で説明されているように、新しい暗号スイート値がIANAによって割り当てられました. 

注：暗号スイートの値{0x00、0x1C}および{0x00、0x1D}は、SSL3でのFortezzaベースの暗号スイートとの衝突を回避するために予約されています. 

A.6. セキュリティパラメータ
これらのセキュリティパラメータは、TLSハンドシェイクプロトコルによって決定され、接続状態を初期化するためにTLSレコード層にパラメータとして提供されます. SecurityParametersには次のものが含まれます. 

   列挙型{null（0）、（255）} CompressionMethod;
        
   列挙型{サーバー、クライアント} ConnectionEnd;
        
   列挙型{tls_prf_sha256} PRFAlgorithm;
        
   列挙型{null、rc4、3des、aes} BulkCipherAlgorithm;
        
   列挙型{ストリーム、ブロック、aead} CipherType;
        
   列挙型{null、hmac_md5、hmac_sha1、hmac_sha256、hmac_sha384、
     hmac_sha512} MACAlgorithm;
        
   / *他の値がで指定されたアルゴリズムに追加される場合があります
   CompressionMethod、PRFAlgorithm、BulkCipherAlgorithm、および
   MACAlgorithm. * /
        
   構造体{
       ConnectionEndエンティティ;
       PRFAlgorithm prf_algorithm;
       BulkCipherAlgorithm Bulk_cipher_algorithm;
       CipherType cipher_type;
       uint8 enc_key_length;
       uint8 block_length;
       uint8 fixed_iv_length;
       uint8 record_iv_length;
       MACAlgorithm mac_algorithm;
       uint8 mac_length;
       uint8 mac_key_length;
       CompressionMethod Compression_algorithm;
       不透明なmaster_secret [48];
       不透明なclient_random [32];
       不透明なserver_random [32];
   } SecurityParameters;
        
A.7. RFC4492への変更
RFC 4492 [TLSECC]は、楕円曲線暗号スイートをTLSに追加します. このドキュメントは、そのドキュメントで使用されている構造の一部を変更します. このセクションでは、RFC4492とTLS1.2の両方の実装者に必要な変更について詳しく説明します. RFC4492を実装していないTLS1.2の実装者は、このセクションを読む必要はありません. 

このドキュメントでは、署名の作成に使用される署名とダイジェストアルゴリズムを識別するために、デジタル署名された要素に「signature_algorithm」フィールドを追加します. この変更は、ECDSAを使用して形成されたデジタル署名にも適用されるため、ECDSA署名をSHA-1以外のダイジェストアルゴリズムで使用できるようになります. ただし、そのような使用は、証明書および[PKIX]の将来のリビジョンによって課される制限と互換性があります. 

セクション7.4.2および7.4.6で説明されているように、証明書の署名に使用される署名アルゴリズムの制限は、暗号スイート（サーバーで使用される場合）またはClientCertificateType（クライアントで使用される場合）に関連付けられなくなりました. したがって、RFC4492のセクション2および3で指定されている証明書の署名に使用されるアルゴリズムの制限も緩和されます. このドキュメントのように、エンドエンティティ証明書のキーに対する制限は残ります. 

付録B.用語集
Advanced Encryption Standard（AES）AES [AES]は、広く使用されている対称暗号化アルゴリズムです. AESは、128、192、または256ビットのキーと16バイトのブロックサイズを持つブロック暗号です. TLSは現在、128ビットと256ビットのキーサイズのみをサポートしています. 

アプリケーションプロトコルアプリケーションプロトコルは、通常、トランスポート層の上に直接階層化されるプロトコルです（TCP / IPなど）. 例としては、HTTP、TELNET、FTP、SMTPなどがあります. 

非対称暗号公開鍵暗号を参照してください. 

追加データを使用した認証付き暗号化（AEAD）機密性とメッセージの整合性を同時に提供する対称暗号化アルゴリズム. 

認証認証とは、あるエンティティが別のエンティティのIDを判別する機能です. 

ブロック暗号ブロック暗号は、ブロックと呼ばれるビットのグループの平文を操作するアルゴリズムです. 64ビットは一般的なブロックサイズであり、128ビットは一般的なブロックサイズです. 

バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム. 

暗号ブロック連鎖（CBC）CBCは、ブロック暗号で暗号化されたすべての平文ブロックが最初に前の暗号文ブロック（または最初のブロックの場合は初期化ベクトル）と排他ORされるモードです. 復号化の場合、すべてのブロックが最初に復号化され、次に前の暗号文ブロック（またはIV）と排他ORされます. 

証明書X.509プロトコル（別名ISO認証フレームワーク）の一部として、証明書は信頼できる認証局によって割り当てられ、当事者のIDまたはその他の属性とその公開鍵との間に強力なバインディングを提供します. 

clientサーバーへのTLS接続を開始するアプリケーションエンティティ. これは、クライアントが基盤となるトランスポート接続を開始したことを意味する場合としない場合があります. サーバーとクライアントの主な操作上の違いは、サーバーは通常認証されますが、クライアントはオプションでのみ認証されることです. 

クライアント書き込みキークライアントによって書き込まれたデータを暗号化するために使用されるキー. 

クライアント書き込みMACキークライアントによって書き込まれたデータを認証するために使用される秘密データ. 

接続接続は、適切なタイプのサービスを提供するトランスポート（OSI階層化モデル定義内）です. TLSの場合、このような接続はピアツーピアの関係です. 接続は一時的なものです. すべての接続は1つのセッションに関連付けられています. 

データ暗号化標準DES [DES]は、現在ではかなり弱いと考えられていますが、依然として非常に広く使用されている対称暗号化アルゴリズムです. DESは、56ビットのキーと8バイトのブロックサイズを持つブロック暗号です. TLSでは、キー生成の目的で、DESは8バイトのキー長（64ビット）を持つものとして扱われますが、それでも56ビットの保護しか提供しないことに注意してください. （各キーバイトの下位ビットは、そのキーバイトで奇数パリティを生成するように設定されていると見なされます. ）DESは、データの各ブロックに3つの独立したキーと3つの暗号化が使用されるモード[3DES]でも動作できます. これは168ビットのキー（TLSキー生成方法では24バイト）を使用し、112ビットのセキュリティに相当します. 

デジタル署名標準（DSS）米国国立標準技術研究所によって承認されたデジタル署名アルゴリズムを含むデジタル署名の標準. NISTFIPSPUB186-2、「デジタル署名標準」、2000年1月に米国商務省によって定義されています. 商務省[DSS]. 重要な更新[DSS-3]がドラフトされ、2006年3月に公開されました. 

デジタル署名デジタル署名は、公開鍵暗号化と一方向ハッシュ関数を利用して、認証可能なデータの署名を生成し、偽造や否認が困難です. 

ハンドシェイクトランザクションのパラメータを確立する、クライアントとサーバー間の最初のネゴシエーション. 

初期化ベクトル（IV）ブロック暗号がCBCモードで使用される場合、初期化ベクトルは、暗号化の前に最初の平文ブロックと排他的OR演算されます. 

メッセージ認証コード（MAC）メッセージ認証コードは、メッセージといくつかの秘密データから計算される一方向のハッシュです. 秘密のデータを知らずに偽造することは困難です. その目的は、メッセージが変更されたかどうかを検出することです. 

マスターシークレット暗号化キー、MACシークレット、およびIVの生成に使用されるセキュアシークレットデータ. 

MD5 MD5 [MD5]は、任意の長さのデータストリームを固定サイズ（16バイト）のハッシュに変換するハッシュ関数です. 暗号解読の大幅な進歩により、このドキュメントの公開時点で、MD5は「安全な」ハッシュ関数とは見なされなくなりました. 

公開鍵暗号化2鍵暗号を使用する暗号技術のクラス. 公開鍵で暗号化されたメッセージは、関連付けられた秘密鍵でのみ復号化できます. 逆に、秘密鍵で署名されたメッセージは、公開鍵で検証できます. 

一方向ハッシュ関数任意の量のデータを固定長ハッシュに変換する一方向変換. 変換を元に戻したり、衝突を見つけたりすることは、計算上困難です. MD5とSHAは、一方向ハッシュ関数の例です. 

RC4 RonRivestによって発明されたストリーム暗号. 互換性のある暗号については、[SCH]で説明されています. 

RSA暗号化またはデジタル署名のいずれかに使用できる非常に広く使用されている公開鍵アルゴリズム. [RSA]

サーバーサーバーは、クライアントからの接続要求に応答するアプリケーションエンティティです. 「クライアント」も参照してください. 

セッションTLSセッションは、クライアントとサーバー間の関連付けです. セッションは、ハンドシェイクプロトコルによって作成されます. セッションは、複数の接続間で共有できる暗号化セキュリティパラメータのセットを定義します. セッションは、接続ごとに新しいセキュリティパラメータのコストのかかるネゴシエーションを回避するために使用されます. 

セッション識別子セッション識別子は、特定のセッションを識別するサーバーによって生成される値です. 

サーバー書き込みキーサーバーによって書き込まれたデータを暗号化するために使用されるキー. 

サーバー書き込みMACキーサーバーによって書き込まれたデータを認証するために使用される秘密データ. 

SHAセキュアハッシュアルゴリズム[SHS]は、FIPS PUB180-2で定義されています. 20バイトの出力を生成します. SHAへのすべての参照（数値の接尾辞なし）は、実際には変更されたSHA-1アルゴリズムを使用することに注意してください. 

SHA-256 256ビットのセキュアハッシュアルゴリズムは、FIPS PUB180-2で定義されています. 32バイトの出力を生成します. 

SSLNetscapeのSecureSocketLayerプロトコル[SSL3]. TLSはSSLバージョン3.0に基づいています. 

ストリーム暗号キーを暗号的に強力なキーストリームに変換する暗号化アルゴリズム. このキーストリームは、プレーンテキストと排他的OR演算されます. 

対称暗号バルク暗号を参照してください. 

トランスポート層セキュリティ（TLS）このプロトコル. また、インターネット技術特別調査委員会（IETF）のトランスポート層セキュリティワーキンググループ. このドキュメントの最後にある「ワーキンググループ情報」（99ページを参照）を参照してください. 

付録C.暗号スイートの定義
暗号スイートキー暗号MacExchange

TLS_NULL_WITH_NULL_NULL NULL NULL NULL TLS_RSA_WITH_NULL_MD5 RSA NULL MD5 TLS_RSA_WITH_NULL_SHA RSA NULL SHA TLS_RSA_WITH_NULL_SHA256 RSA NULL SHA256 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA RSA AES_128_CBC SHA TLS_RSA_WITH_AES_256_CBC_SHA RSA AES_256_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA256 RSA AES_128_CBC SHA256 TLS_RSA_WITH_AES_256_CBC_SHA256 RSA AES_256_CBC SHA256 TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_WITH_RC4_128TLS_DH_DSS_WITH_AES_128_CBC_SHA DH_DSS AES_128_CBC SHA TLS_DH_RSA_WITH_AES_128_CBC_SHA DH_RSA AES_128_CBC SHA TLS_DHE_DSS_WITH_AES_128_CBC_SHA DHE_DSS AES_128_CBC SHA TLS_DHE_RSA_WITH_AES_128_CBC_SHA DHE_RSA AES_128_CBC SHA TLS_DH_anon_WITH_AES_128_CBC_SHA DH_anon AES_128_CBC SHA TLS_DH_DSS_WITH_AES_256_CBC_SHA DH_DSS AES_256_CBC SHA TLS_DH_RSA_WITH_AES_256_CBC_SHA DH_RSA AES_256_CBC SHA TLS_DHE_DSS_WITH_AES_256_CBC_SHA DHE_DSS AES_256_CBC SHA TLS_DHE_RSA_WITH_AES_256_CBC_SHA DHE_RSA AES_256_CBC SHA TLS_DH_anon_WITH_AES_256_CBC_SHA DH_anon AES_256_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA256 DH_DSS AES_128_CBC SHA256 TLS_DH_RSA_WITH_AES_128_CBC_SHA256 DH_RSA AES_128_CBC SHA256 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 DHE_DSS AES_128_CBC SHA256 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 DHE_RSA AES_128_CBC SHA256 TLS_DH_anon_WITH_AES_128_CBC_SHA256 DH_anonAES_128_CBC SHA256 TLS_DH_DSS_WITH_AES_256_CBC_SHA256 DH_DSS AES_256_CBC SHA256 TLS_DH_RSA_WITH_AES_256_CBC_SHA256 DH_RSA AES_256_CBC SHA256 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 DHE_DSS AES_256_CBC SHA256 TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 DHE_RSA AES_256_CBC SHA256 TLS_DH_anon_WITH_AES_256_CBC_SHA256 DH_anon AES_256_CBC SHA256

                        キーIVブロック
暗号タイプ材質サイズサイズ
------------ ------ -------- ---- -----
NULLストリーム00該当なし
RC4_128ストリーム160 N / A
3DES_EDE_CBCブロック248 8
AES_128_CBCブロック161616
AES_256_CBCブロック321616
        
MACアルゴリズムmac_lengthmac_key_length
-------- ----------- ---------- --------------
NULL該当なし00
MD5 HMAC-MD5 16 16
SHA HMAC-SHA1 20 20
SHA256 HMAC-SHA256 32 32
        
タイプこれがCBCモードで実行されているストリーム暗号かブロック暗号かを示します. 

キーマテリアル書き込みキーの生成に使用されるkey_blockからのバイト数. 

IVサイズ初期化ベクトル用に生成する必要のあるデータの量. ストリーム暗号の場合はゼロ. ブロック暗号のブロックサイズに等しい（これはSecurityParameters.record_iv_lengthに等しい）. 

ブロックサイズブロ​​ック暗号が1つのチャンクで暗号化するデータの量. CBCモードで実行されているブロック暗号は、そのブロックサイズの偶数倍しか暗号化できません. 

付録D.実装上の注意
TLSプロトコルは、多くの一般的なセキュリティミスを防ぐことはできません. このセクションでは、実装者を支援するためのいくつかの推奨事項を示します. 

D.1. 乱数の生成とシード
TLSには、暗号的に安全な疑似乱数生成器（PRNG）が必要です. PRNGの設計とシードには注意が必要です. セキュアハッシュ操作に基づくPRNG、特にSHA-1は許容されますが、乱数ジェネレーターの状態のサイズよりも高いセキュリティを提供することはできません. 

生成されるシード材料の量を見積もるには、各シードバイトに予測できない情報のビット数を追加します. たとえば、PC互換の18.2 Hzタイマーから取得したキーストロークタイミング値は、カウンター値の合計サイズが16ビット以上であっても、それぞれ1ビットまたは2ビットのセキュアビットを提供します. したがって、128ビットPRNGをシードするには、約100個のそのようなタイマー値が必要になります. 

[RANDOM]は、ランダム値の生成に関するガイダンスを提供します. 

D.2. 証明書と認証
実装は、証明書の整合性を検証する責任があり、通常、証明書失効メッセージをサポートする必要があります. 信頼できる認証局（CA）による適切な署名を確実にするために、証明書は常に検証する必要があります. 信頼できるCAの選択と追加は、慎重に行う必要があります. ユーザーは、証明書とルートCAに関する情報を表示できる必要があります. 

D.3. 暗号スイート
TLSは、セキュリティを提供しない、または最小限のセキュリティを提供するものを含め、さまざまなキーサイズとセキュリティレベルをサポートします. 適切な実装では、おそらく多くの暗号スイートをサポートしません. たとえば、匿名のDiffie-Hellmanは、man-in-the-middle攻撃を防ぐことができないため、強くお勧めしません. アプリケーションは、最小および最大のキーサイズも適用する必要があります. たとえば、512ビットのRSAキーまたは署名を含む証明書チェーンは、高セキュリティアプリケーションには適していません. 

D.4. 実装の落とし穴
実装の経験から、以前のTLS仕様の特定の部分は理解しにくく、相互運用性とセキュリティの問題の原因となっていることがわかっています. これらの領域の多くはこのドキュメントで明確にされていますが、この付録には、実装者による特別な注意が必要な最も重要な事項の短いリストが含まれています. 

TLSプロトコルの問題：

-複数のTLSレコードにフラグメント化されたハンドシェイクメッセージを正しく処理していますか（セクション6.2.1を参照）. いくつかの小さなフラグメントに分割されるClientHelloのようなコーナーケースを含みますか？最大フラグメントサイズを超えるハンドシェイクメッセージをフラグメント化しますか？特に、証明書および証明書要求ハンドシェイクメッセージは、断片化を必要とするほど大きくなる可能性があります. 

-ServerHelloより前のすべてのTLSレコードのTLSレコードレイヤーのバージョン番号を無視しますか（付録E.1を参照）？

-拡張機能フィールドを完全に省略するなど、ClientHelloでTLS拡張機能を正しく処理していますか？

-クライアントとサーバーの両方で開始された再ネゴシエーションをサポートしていますか？再ネゴシエーションはオプション機能ですが、それをサポートすることを強くお勧めします. 

-サーバーがクライアント証明書を要求したが、適切な証明書が利用できない場合、メッセージ全体を省略するのではなく、空の証明書メッセージを正しく送信しますか（セクション7.4.6を参照）. 

暗号化の詳細：

-RSAで暗号化されたプリマスターシークレットで、バージョン番号を正しく送信して確認していますか？エラーが発生した場合、ブライヘンバッハーの攻撃を回避するためにハンドシェイクを続行しますか（セクション7.4.7.1を参照）. 

-RSA復号化および署名操作に対するタイミング攻撃を防ぐためにどのような対策を使用していますか（セクション7.4.7.1を参照）. 

-RSA署名を検証するとき、NULLと欠落しているパラメーターの両方を受け入れますか（セクション4.7を参照）？RSAパディングにハッシュ値の後に追加のデータがないことを確認しますか？[FI06]

--Diffie-Hellman鍵交換を使用する場合、ネゴシエートされた鍵から先行ゼロバイトを正しく削除しますか（セクション8.1.2を参照）. 

-TLSクライアントは、サーバーから送信されたDiffie-Hellmanパラメーターが受け入れ可能であることを確認しますか（セクションF.1.1.3を参照）？

-CBCモード暗号の予測不可能なIVをどのように生成しますか（セクション6.2.3.2を参照）？

-長いCBCモードのパディング（最大255バイト. セクション6.2.3.2を参照）を受け入れますか？

-CBCモードのタイミング攻撃にどのように対処しますか（セクション6.2.3.2）？

-プリマスターシークレット（RSAキー交換用）、Diffie-Hellmanプライベート値、DSA "k"パラメーターなどを生成するために、強力で最も重要な、適切にシードされた乱数ジェネレーター（付録D.1を参照）を使用していますか？セキュリティクリティカルな値？

付録E.下位互換性
E.1. TLS 1.0 /1.1およびSSL3.0との互換性
TLS（1.0、1.1、1.2、および将来のバージョン）とSSL（2.0および3.0）にはさまざまなバージョンがあるため、使用する特定のプロトコルバージョンをネゴシエートする手段が必要です. TLSプロトコルは、バージョン選択の複雑さで他のプロトコルコンポーネントを煩わせないように、バージョンネゴシエーションのための組み込みメカニズムを提供します. 

TLSバージョン1.0、1.1、1.2、およびSSL 3.0は非常に類似しており、互換性のあるClientHelloメッセージを使用します. したがって、それらすべてをサポートするのは比較的簡単です. 同様に、ClientHello形式の互換性が維持され、クライアントがサーバーで利用可能な最高のプロトコルバージョンをサポートしている限り、サーバーはTLSの将来のバージョンを使用しようとするクライアントを簡単に処理できます. 

このような古いサーバーとのネゴシエーションを希望するTLS1.2クライアントは、ClientHello.client_versionに{3、3}（TLS 1.2）を含む通常のTLS 1.2ClientHelloを送信します. サーバーがこのバージョンをサポートしていない場合、サーバーは古いバージョン番号を含むServerHelloで応答します. クライアントがこのバージョンの使用に同意した場合、ネゴシエーションはネゴシエートされたプロトコルに応じて続行されます. 

サーバーによって選択されたバージョンがクライアントによってサポートされていない（または受け入れられない）場合、クライアントは「protocol_version」アラートメッセージを送信して接続を閉じる必要があります. 

TLSサーバーが、サーバーでサポートされている最高バージョンよりも大きいバージョン番号を含むClientHelloを受信した場合、サーバーでサポートされている最高バージョンに従って応答する必要があります. 

TLSサーバーは、サポートされている最高バージョンよりも小さいバージョン番号を含むClientHelloを受信することもできます. サーバーが古いクライアントとのネゴシエーションを希望する場合は、ClientHello.client_version以下のサーバーでサポートされている最高バージョンに応じて適切に続行します. たとえば、サーバーがTLS 1.0、1.1、および1.2をサポートし、client_versionがTLS 1.0の場合、サーバーはTLS 1.0ServerHelloを続行します. サーバーがclient_versionより大きいバージョンのみをサポートする（または使用する意思がある）場合、サーバーは「protocol_version」アラートメッセージを送信して接続を閉じる必要があります. 

クライアントがサーバーに認識されている最高のプロトコルバージョンをすでに知っている場合（たとえば、セッションを再開する場合）、クライアントはそのネイティブプロトコルで接続を開始する必要があります. 

注：一部のサーバー実装は、バージョンネゴシエーションを誤って実装することが知られています. たとえば、クライアントがTLS1.0より新しいバージョンを提供したときに接続を単に閉じるバグのあるTLS1.0サーバーがあります. また、ClientHelloにTLS拡張機能が含まれている場合、一部のサーバーは接続を拒否することが知られています. このようなバグのあるサーバーとの相互運用性は、このドキュメントの範囲を超えた複雑なトピックであり、クライアントによる複数の接続試行が必要になる場合があります. 

以前のバージョンのTLS仕様では、ClientHelloを送信するときに（つまり、どのバージョンのプロトコルが使用されるかがわかる前に）レコードレイヤーのバージョン番号（TLSPlaintext.version）に何を含めるべきかについて完全に明確ではありませんでした. したがって、この仕様に準拠するTLSサーバーは、ClientHelloのレコードレイヤーバージョン番号として任意の値{03、XX}を受け入れる必要があります. 

古いサーバーとのネゴシエーションを希望するTLSクライアントは、レコードレイヤーのバージョン番号として任意の値{03、XX}を送信できます（MAY）. 一般的な値は、クライアントがサポートする最小のバージョン番号である{03,00}、およびClientHello.client_versionの値です. 単一の値ですべての古いサーバーとの相互運用性が保証されるわけではありませんが、これはこのドキュメントの範囲を超える複雑なトピックです. 

E.2. SSL2.0との互換性
SSL2.0サーバーのサポートを希望するTLS1.2クライアントは、[SSL2]で定義されているバージョン2.0CLIENT-HELLOメッセージを送信する必要があります. メッセージには、通常のClientHelloで使用されるものと同じバージョン番号が含まれている必要があり、以下に説明するように、サポートされているTLS暗号スイートをCIPHER-SPECS-DATAフィールドにエンコードする必要があります. 

警告：バージョン2.0のCLIENT-HELLOメッセージを送信する機能は、新しいClientHello形式が新しいバージョンに移行し、拡張機能をネゴシエートするためのより優れたメカニズムを提供するため、すべての急いで段階的に廃止されます. TLS1.2クライアントはSSL2.0をサポートすべきではありません. 

ただし、SSL 2.0をサポートしないTLSサーバーでも、バージョン2.0のCLIENT-HELLOメッセージを受け入れる場合があります. このメッセージは、TLSサーバーの実装者にとって十分に詳細に以下に示されています. 真の定義は依然として[SSL2]であると想定されています. 

ネゴシエーションの目的で、2.0 CLIENT-HELLOは、「null」圧縮メソッドを使用し、拡張機能を使用しないClientHelloと同じように解釈されます. このメッセージは、TLSレコードとしてラップするのではなく、ネットワーク上で直接送信する必要があることに注意してください. FinishedおよびCertificateVerifyを計算するために、msg_lengthフィールドはハンドシェイクメッセージの一部とは見なされません. 

      uint8 V2CipherSpec [3];
      構造体{
          uint16 msg_length;
          uint8 msg_type;
          バージョンバージョン;
          uint16 cipher_spec_length;
          uint16 session_id_length;
          uint16 Challenge_length;
          V2CipherSpec cipher_specs [V2ClientHello.cipher_spec_length];
          不透明なsession_id [V2ClientHello.session_id_length];
          不透明なチャレンジ[V2ClientHello.challenge_length;
      } V2ClientHello;
        
msg_length最上位ビットは1でなければなりません. 残りのビットには、次のデータの長さがバイト単位で含まれています. 

msg_typeこのフィールドは、バージョンフィールドと組み合わせて、バージョン2のClientHelloメッセージを識別します. 値は1でなければなりません. 

versionClientHello.client_versionと同じです. 

cipher_spec_lengthこのフィールドは、フィールドcipher_specsの全長です. ゼロにすることはできず、V2CipherSpecの長さ（3）の倍数でなければなりません. 

session_id_length TLS 1.2をサポートすると主張するクライアントの場合、このフィールドの値はゼロでなければなりません. 

Challenge_lengthサーバーに対して自身を認証するためのクライアントのチャレンジのバイト単位の長さ. 歴史的に、許容値は16〜32バイトです. SSLv2下位互換性のあるハンドシェイクを使用する場合、クライアントは32バイトのチャレンジを使用する必要があります. 

cipher_specsこれは、クライアントが喜んで使用できるすべてのCipherSpecのリストです. [SSL2]で定義されている2.0暗号仕様に加えて、これには通常ClientHello.cipher_suitesで送信されるTLS暗号スイートが含まれます. 各暗号スイートの前にはゼロバイトが付いています. たとえば、TLS暗号スイート{0x00,0x0A}は{0x00,0x00,0x0A}として送信されます. 

session_idこのフィールドは空でなければなりません. 

チャレンジClientHello.randomに対応します. チャレンジの長さが32未満の場合、TLSサーバーはデータを先頭（注：末尾ではない）のゼロバイトで埋めて32バイトの長さにします. 

注：TLSセッションを再開する要求は、TLSクライアントhelloを使用する必要があります. 

E.3. Man-in-the-Middleバージョンのロールバックの回避
TLSクライアントがバージョン2.0互換モードにフォールバックする場合、特別なPKCS＃1ブロックフォーマットを使用する必要があります. これは、TLSサーバーがTLS対応クライアントとのバージョン2.0セッションを拒否するために行われます. 

クライアントがSSL2.0をネゴシエートするが、TLSもサポートする場合、ENCRYPTED-KEY-のRSA暗号化のために、PKCSパディングの右側（最下位）の8ランダムバイト（パディングのターミナルヌルを含まない）を設定する必要があります.  CLIENT-MASTER-KEYのDATAフィールドを0x03に設定します（他のパディングバイトはランダムです）. 

TLS対応サーバーがSSL2.0をネゴシエートする場合、ENCRYPTED-KEY-DATAフィールドを復号化した後、これらの8つのパディングバイトが0x03であることを確認する必要があります. そうでない場合、サーバーはSECRET-KEY-DATAのランダムな値を生成し、ハンドシェイクを続行する必要があります（キーが一致しないため、最終的に失敗します）. エラー状況をクライアントに報告すると、サーバーが[BLEI]で説明されている攻撃に対して脆弱になる可能性があることに注意してください. 

付録F.セキュリティ分析
TLSプロトコルは、安全でないチャネルを介して通信するクライアントとサーバー間の安全な接続を確立するように設計されています. このドキュメントは、攻撃者がかなりの計算リソースを持っており、プロトコル外のソースから秘密情報を取得できないことを含め、いくつかの従来の仮定を行っています. 攻撃者は、通信チャネルを介して送信されたメッセージをキャプチャ、変更、削除、再生、またはその他の方法で改ざんする能力を持っていると見なされます. この付録では、さまざまな攻撃に抵抗するためにTLSがどのように設計されているかについて概説します. 

F.1. ハンドシェイクプロトコル
ハンドシェイクプロトコルは、暗号仕様の選択とマスターシークレットの生成を担当します. マスターシークレットは、セキュアセッションに関連付けられた主要な暗号化パラメーターを一緒に構成します. ハンドシェイクプロトコルは、オプションで、信頼できる認証局によって署名された証明書を持つパーティを認証することもできます. 

F.1.1. 認証と鍵交換
TLSは、両方の当事者の認証、認証されていないクライアントを使用したサーバー認証、および完全な匿名性の3つの認証モードをサポートします. サーバーが認証されるときはいつでも、チャネルはman-in-the-middle攻撃に対して安全ですが、完全に匿名のセッションは本質的にそのような攻撃に対して脆弱です. 匿名サーバーはクライアントを認証できません. サーバーが認証されている場合、その証明書メッセージは、受け入れ可能な認証局につながる有効な証明書チェーンを提供する必要があります. 同様に、認証されたクライアントは、受け入れ可能な証明書をサーバーに提供する必要があります. 各当事者は、相手の証明書が有効であり、有効期限が切れていないか、取り消されていないことを確認する責任があります. 

鍵交換プロセスの一般的な目標は、攻撃者ではなく通信当事者に知られているpre_master_secretを作成することです. pre_master_secretは、master_secretを生成するために使用されます（セクション8.1を参照）. master_secretは、Finishedメッセージ、暗号化キー、およびMACキーを生成するために必要です（セクション7.4.9および6.3を参照）. したがって、正しい終了メッセージを送信することにより、当事者は正しいpre_master_secretを知っていることを証明します. 

F.1.1.1. 匿名鍵交換
完全に匿名のセッションは、キー交換にDiffie-Hellmanを使用して確立できます. サーバーの公開パラメーターはサーバー鍵交換メッセージに含まれ、クライアントの公開パラメーターはクライアント鍵交換メッセージで送信されます. プライベート値を知らない盗聴者は、Diffie-Hellmanの結果（つまり、pre_master_secret）を見つけることができないはずです. 

警告：完全に匿名の接続は、受動的な盗聴に対する保護のみを提供します. 独立した改ざん防止チャネルを使用して、Finishedメッセージが攻撃者によって置き換えられていないことを確認しない限り、アクティブな中間者攻撃が懸念される環境ではサーバー認証が必要です. 

F.1.1.2. RSAキー交換と認証
RSAでは、鍵交換とサーバー認証が組み合わされています. 公開鍵はサーバーの証明書に含まれています. サーバーの静的RSAキーが侵害されると、その静的キーで保護されているすべてのセッションの機密性が失われることに注意してください. Perfect Forward Secrecyを希望するTLSユーザーは、DHE暗号スイートを使用する必要があります. 秘密鍵（および証明書）を頻繁に変更することで、秘密鍵の公開による被害を抑えることができます. 

サーバーの証明書を確認した後、クライアントはサーバーの公開鍵を使用してpre_master_secretを暗号化します. pre_master_secretを正常にデコードし、正しい終了メッセージを生成することにより、サーバーは、サーバー証明書に対応する秘密鍵を認識していることを示します. 

RSAが鍵交換に使用される場合、クライアントは証明書検証メッセージを使用して認証されます（セクション7.4.8を参照）. クライアントは、先行するすべてのハンドシェイクメッセージから派生した値に署名します. これらのハンドシェイクメッセージには、署名をサーバーにバインドするサーバー証明書と、署名を現在のハンドシェイクプロセスにバインドするServerHello.randomが含まれます. 

F.1.1.3. 認証付きのDiffie-Hellman鍵交換
Diffie-Hellman鍵交換を使用する場合、サーバーは固定のDiffie-Hellmanパラメーターを含む証明書を提供するか、サーバー鍵交換メッセージを使用して、DSAまたはRSA証明書で署名された一時的なDiffie-Hellmanパラメーターのセットを送信できます. 一時的なパラメータは、攻撃者が古いパラメータを再生しないように、署名する前にhello.random値でハッシュされます. いずれの場合も、クライアントは証明書または署名を検証して、パラメーターがサーバーに属していることを確認できます. 

クライアントが固定のDiffie-Hellmanパラメーターを含む証明書を持っている場合、その証明書には鍵交換を完了するために必要な情報が含まれています. この場合、クライアントとサーバーは、通信するたびに同じDiffie-Hellman結果（つまり、pre_master_secret）を生成することに注意してください. pre_master_secretが必要以上にメモリに留まらないようにするには、できるだけ早くmaster_secretに変換する必要があります. クライアントDiffie-Hellmanパラメーターは、鍵交換が機能するためにサーバーによって提供されるパラメーターと互換性がある必要があります. 

クライアントが標準のDSAまたはRSA証明書を持っているか、認証されていない場合、クライアントはクライアントキー交換メッセージで一時パラメータのセットをサーバーに送信し、オプションで証明書検証メッセージを使用して自身を認証します. 

クライアントまたはサーバーが固定DHキーペアを含む証明書を持っているため、またはサーバーがDHキーを再利用しているために、同じDHキーペアを複数のハンドシェイクに使用する場合は、小さなサブグループ攻撃を防ぐように注意する必要があります. 実装は、[サブグループ]にあるガイドラインに従う必要があります. 

小さなサブグループ攻撃は、DHE暗号スイートの1つを使用し、ハンドシェイクごとに新しいDH秘密鍵（X）を生成することで最も簡単に回避できます. 適切な塩基（2など）を選択すると、g ^ X modpを非常に迅速に計算できます. したがって、パフォーマンスコストが最小限に抑えられます. さらに、ハンドシェイクごとに新しいキーを使用すると、Perfect ForwardSecrecyが提供されます. 実装は、DHE暗号スイートを使用するときにハンドシェイクごとに新しいXを生成する必要があります. 

TLSを使用すると、サーバーは任意のDHグループを提供できるため、クライアントは、DHグループがローカルポリシーで定義されている適切なサイズであることを確認する必要があります. クライアントは、DHパブリック指数が適切なサイズであるように見えることも確認する必要があります. [KEYSIZ]は、さまざまなグループサイズの強さに関する便利なガイドを提供します. サーバーは、[IKEALG]や[MODP]で定義されているような既知のグループを提供することにより、クライアントを支援することを選択できます（MAY）. これらは簡単な比較で確認できます. 

F.1.2. バージョンのロールバック攻撃
TLSにはSSLバージョン2.0に比べて大幅な改善が含まれているため、攻撃者はTLS対応のクライアントとサーバーをバージョン2.0にフォールバックさせようとする可能性があります. この攻撃は、2つのTLS対応パーティがSSL 2.0ハンドシェイクを使用する場合にのみ発生する可能性があります. 

非ランダムPKCS＃1ブロックタイプ2メッセージパディングを使用するソリューションはエレガントではありませんが、バージョン3.0サーバーが攻撃を検出するための適度に安全な方法を提供します. このソリューションは、アプリケーションで指定された待機しきい値が期限切れになる前に、キーをブルートフォースし、同じキーを含む（ただし通常のパディングを使用する）新しいENCRYPTED-KEY-DATAメッセージを置き換えることができる攻撃者に対して安全ではありません. PKCSパディングの最下位8バイトのパディングを変更しても、プロトコルで使用される署名付きハッシュのサイズとRSAキーの長さのセキュリティには影響しません. これは、入力ブロックサイズを8バイト増やすことと本質的に同じだからです. 

F.1.3. ハンドシェイクプロトコルに対する攻撃の検出
攻撃者は、ハンドシェイク交換に影響を与えて、当事者に通常選択するのとは異なる暗号化アルゴリズムを選択させる可能性があります. 

この攻撃では、攻撃者は1つ以上のハンドシェイクメッセージを積極的に変更する必要があります. これが発生した場合、クライアントとサーバーはハンドシェイクメッセージハッシュに対して異なる値を計算します. その結果、当事者はお互いの終了メッセージを受け入れません. master_secretがないと、攻撃者は完了メッセージを修復できないため、攻撃が発見されます. 

F.1.4. セッションの再開
セッションを再開して接続が確立されると、新しいClientHello.randomとServerHello.randomの値がセッションのmaster_secretでハッシュされます. master_secretが危険にさらされておらず、暗号化キーとMACキーの生成に使用されるセキュアハッシュ操作がセキュアである場合、接続はセキュアであり、以前の接続から効果的に独立している必要があります. 攻撃者は、既知の暗号化キーまたはMACシークレットを使用して、安全なハッシュ操作を中断せずにmaster_secretを侵害することはできません. 

クライアントとサーバーの両方が同意しない限り、セッションを再開することはできません. いずれかの当事者がセッションが侵害された可能性がある、または証明書の有効期限が切れているか取り消されている可能性があると疑われる場合は、完全なハンドシェイクを強制する必要があります. master_secretを取得した攻撃者は、対応するセッションIDがリタイアするまで、侵害されたパーティになりすますことができる可能性があるため、セッションIDの有効期間には24時間の上限が推奨されます. 比較的安全でない環境で実行される可能性のあるアプリケーションは、安定したストレージにセッションIDを書き込むべきではありません. 

F.2. アプリケーションデータの保護
master_secretはClientHello.randomおよびServerHello.randomでハッシュされ、接続ごとに一意のデータ暗号化キーとMACシークレットを生成します. 

送信データは、送信前にMACで保護されます. メッセージの再生または変更攻撃を防ぐために、MACは、MACキー、シーケンス番号、メッセージの長さ、メッセージの内容、および2つの固定文字列から計算されます. メッセージタイプフィールドは、あるTLSレコードレイヤークライアント宛てのメッセージが別のクライアントにリダイレクトされないようにするために必要です. シーケンス番号により、メッセージの削除または並べ替えの試行が確実に検出されます. シーケンス番号は64ビット長であるため、オーバーフローすることはありません. 一方の当事者からのメッセージは、独立したMACキーを使用するため、他方の出力に挿入することはできません. 同様に、サーバーの書き込みキーとクライアントの書き込みキーは独立しているため、ストリーム暗号キーは1回だけ使用されます. 

攻撃者が暗号化キーを破った場合、それで暗号化されたすべてのメッセージを読み取ることができます. 同様に、MACキーの侵害により、メッセージ変更攻撃が可能になる可能性があります. MACも暗号化されているため、メッセージ変更攻撃では通常、MACだけでなく暗号化アルゴリズムも破る必要があります. 

注：MACキーは暗号化キーよりも大きい場合があるため、暗号化キーが壊れていてもメッセージは改ざんされないようにすることができます. 

F.3. 明示的なIV
[CBCATT]は、レコードのIVを知ることに依存する、TLSに対する選択平文攻撃について説明しています. 以前のバージョンのTLS [TLS1.0]は、以前のレコードのCBC残基をIVとして使用していたため、この攻撃を有効にしました. このバージョンは、この攻撃から保護するために明示的なIVを使用します. 

F.4. 複合暗号モードのセキュリティ
TLSは、ネゴシエートされた暗号スイートで定義された対称暗号化および認証機能を使用して、送信されたアプリケーションデータを保護します. 目的は、ネットワーク内のアクティブな攻撃者による悪意のあるアクションから、送信されたデータの整合性と機密性の両方を保護することです. この目標を達成するには、暗号化および認証機能がデータに適用される順序が重要な役割を果たしていることがわかります[ENCAUTH]. 

暗号化してから認証と呼ばれる最も堅牢な方法は、最初にデータに暗号化を適用し、次に暗号文にMACを適用します. この方法では、暗号化とMAC機能の任意のペアで整合性と機密性の目標が確実に得られます. ただし、前者が選択平文攻撃に対して安全であり、MACが選択メッセージ攻撃に対して安全であることが条件です. TLSは、authenticate-then-encryptと呼ばれる別の方法を使用します. この方法では、最初にMACがプレーンテキストで計算され、次にプレーンテキストとMACの連結が暗号化されます. この方法は、暗号化機能とMAC機能の特定の組み合わせに対して安全であることが証明されていますが、一般的に安全であるとは限りません. 

特に、完全に安全な暗号化機能（情報理論的な意味でも安全）が存在し、安全なMAC機能と組み合わせると、アクティブな攻撃に対する機密性の目標を提供できないことが示されています. したがって、TLSに採用された新しい暗号スイートと操作モードは、認証してから暗号化する方法で分析して、指定された整合性と機密性の目標を達成していることを確認する必要があります. 

現在、認証してから暗号化する方法のセキュリティは、いくつかの重要なケースで証明されています. 1つは、メッセージの長さとMACタグの長さの計算上予測できないパッドが疑似ランダムジェネレーターを使用して生成され、このパッドがプレーンテキストとMACタグの連結と排他的ORされるストリーム暗号の場合です. もう1つは、セキュアブロック暗号を使用するCBCモードの場合です. この場合、平文とMACの連結に1つのCBC暗号化パスを適用し、平文とMACの新しいペアごとに、新しい独立した予測不可能なIVを使用すると、セキュリティを示すことができます. 1.1より前のバージョンのTLSでは、前の暗号文の最後のブロックの形式で予測可能なIVを使用したことを除いて、CBCモードが適切に使用されていました. これにより、TLSは選択された平文攻撃に対してオープンになりました. このバージョンのプロトコルは、これらの攻撃の影響を受けません. 安全であることが証明されている暗号化モードの正確な詳細については、[ENCAUTH]を参照してください. 

F.5. サービス拒否
TLSは、多くのサービス拒否（DoS）攻撃の影響を受けやすくなっています. 特に、攻撃者が多数のTCP接続を開始すると、サーバーがRSA復号化を実行するために大量のCPUを消費する可能性があります. ただし、TLSは一般にTCPを介して使用されるため、TCPスタックで適切なTCP SYNランダム化が[SEQNUM]使用されている場合、攻撃者が発信元を隠すことは困難です. 

TLSはTCPを介して実行されるため、個々の接続に対する多数のDoS攻撃の影響も受けやすくなります. 特に、攻撃者はRSTを偽造して接続を終了したり、部分的なTLSレコードを偽造して接続を停止させたりする可能性があります. これらの攻撃は、一般にTCPを使用するプロトコルでは防御できません. このクラスの攻撃に関係する実装者またはユーザーは、IPsec AH [AH]またはESP [ESP]を使用する必要があります. 

F.6. ファイナルノート
TLSが安全な接続を提供できるようにするには、クライアントとサーバーの両方のシステム、キー、およびアプリケーションが安全である必要があります. さらに、実装にはセキュリティエラーがあってはなりません. 

このシステムは、サポートされている最も弱い鍵交換および認証アルゴリズムと同じくらい強力であり、信頼できる暗号化機能のみを使用する必要があります. 短い公開鍵と匿名サーバーは、細心の注意を払って使用する必要があります. 実装とユーザーは、どの証明書と認証局が受け入れられるかを決定する際に注意する必要があります. 不正な認証局は甚大な損害を与える可能性があります. 

規範的参考文献

[AES]米国国立標準技術研究所、「Advanced Encryption Standard（AES）の仕様」FIPS197. 2001年11月26日. 

[3DES]米国国立標準技術研究所、「トリプルデータ暗号化アルゴリズム（TDEA）ブロック暗号の推奨事項」、NIST Special Publication 800-67、2004年5月. 

[DSS] NIST FIPS PUB 186-2、「デジタル署名標準」、米国国立標準技術研究所、米国商務省、2000年. 

[HMAC] Krawczyk、H.、Bellare、M. 、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月. 

[MD5] Rivest、R. 、「MD5メッセージダイジェストアルゴリズム」、RFC 1321、1992年4月. 

[PKCS1] Jonsson、J. およびB. Kaliski、「公開鍵暗号化標準（PKCS）＃1：RSA暗号化仕様バージョン2.1」、RFC 3447、2003年2月. 

[PKIX] Housley、R.、Polk、W.、Ford、W. 、およびD. Solo、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile」、RFC 3280、2002年4月. 

[SCH] B. シュナイアー. 「AppliedCryptography：Protocols、Algorithms、and Source Code in C、2nd ed. 」、John Wiley＆Sons、Inc.1996発行. 

[SHS] NIST FIPS PUB 180-2、「Secure Hash Standard」、米国国立標準技術研究所、米国商務省、2002年8月. 

[REQ] Bradner、S. 、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月. 

[RFC2434] Narten、T. およびH. Alvestrand、「RFCでIANA考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月. 

[X680] ITU-T勧告X.680（2002）| ISO / IEC 8824-1：2002、情報技術-抽象構文表記1（ASN.1）：基本表記の仕様. 

[X690] ITU-T勧告X.690（2002）| ISO / IEC 8825-1：2002、情報技術-ASN.1エンコーディングルール：基本エンコーディングルール（BER）、正規エンコーディングルール（CER）、および識別エンコーディングルール（DER）の仕様. 

有益な参考文献

[AEAD] McGrew、D. 、「認証付き暗号化のためのインターフェイスとアルゴリズム」、RFC 5116、2008年1月. 

[AH] Kent、S. 、「IP Authentication Header」、RFC 4302、2005年12月. 

[BLEI] Bleichenbacher D. 、「Advances in Cryptology-CRYPTO'98、LNCSvol. 1のRSA暗号化標準PKCS＃1に基づくプロトコルに対する選択暗号文攻撃」1462、ページ：1-12、1998. 

[CBCATT] Moeller、B. 、「SSL / TLSにおけるCBC暗号スイートのセキュリティ：問題と対策」、http：//www.openssl.org/~bodo/tls-cbc.txt. 

[CBCTIME] Canvel、B.、Hiltgen、A.、Vaudenay、S.、and M. Vuagnoux、 "Password Interception in a SSL / TLS Channel"、Advances in Cryptology-CRYPTO 2003、LNCSvol. 2729、2003. 

   [CCM]「NIST特別刊行物800-38C：CCMモード
              認証と機密保持」、
              http://csrc.nist.gov/publications/nistpubs/800-38C/
              SP800-38C.pdf
        
[DES]米国国立標準技術研究所、「データ暗号化標準（DES）」、FIPS PUB 46-3、1999年10月. 

[DSS-3] NIST FIPS PUB 186-3ドラフト、「デジタル署名標準」、米国国立標準技術研究所、米国商務省、2006年. 

[ECDSA] American National Standards Institute、「金融サービス業界向けの公開鍵暗号化：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANS X9.62-2005、2005年11月. 

[ENCAUTH] Krawczyk、H. 、「通信を保護するための暗号化と認証の順序（または：SSLはどの程度安全ですか？）」、Crypto2001. 

[ESP] Kent、S. 、「IP Encapsulating Security Payload（ESP）」、RFC 4303、2005年12月. 

[FI06] Hal Finney、「実装エラーに基づくBleichenbacherのRSA署名偽造」、ietf-openpgp @ imc.orgメーリングリスト、2006年8月27日、http：//www.imc.org/ietf-openpgp/ mail-archive / msg14307 .html. 

[GCM] Dworkin、M.、NIST Special Publication 800-38D、「ブロック暗号動作モードの推奨事項：ガロア/カウンターモード（GCM）およびGMAC」、2007年11月. 

[IKEALG] Schiller、J. 、「インターネットキーエクスチェンジバージョン2（IKEv2）で使用するための暗号化アルゴリズム」、RFC 4307、2005年12月. 

[KEYSIZ] Orman、H. およびP. Hoffman、「対称鍵の交換に使用される公開鍵の強度の決定」、BCP 86、RFC 3766、2004年4月. 

[KPR03] Klima、V.、Pokorny、O.、Rosa、T. 、「SSL / TLSでのRSAベースのセッションへの攻撃」、http：//eprint.iacr.org/2003/052/、2003年 3月. 

[MODP] Kivinen、T. and M. Kojo、 "More Modular Exponential（MODP）Diffie-Hellman groups for Internet Key Exchange（IKE）"、RFC 3526、2003年5月. 

[PKCS6] RSA Laboratories、「PKCS＃6：RSA Extended Certificate Syntax Standard」、バージョン1.5、1993年11月. 

[PKCS7] RSA Laboratories、「PKCS＃7：RSA Cryptographic Message Syntax Standard」、バージョン1.5、1993年11月. 

[ランダム] Eastlake、D.、3rd、Schiller、J. 、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、2005年6月. 

[RFC3749] Hollenbeck、S. 、「Transport Layer Security Protocol Compression Methods」、RFC 3749、2004年5月. 

[RFC4366] Blake-Wilson、S.、Nystrom、M.、Hopwood、D.、Mikkelsen、J. 、およびT. Wright、「Transport Layer Security（TLS）Extensions」、RFC 4366、2006年4月. 

[RSA] R. Rivest、A. Shamir、およびLM Adleman、「デジタル署名と公開鍵暗号システムを取得する方法」、Communications of the ACM、v. 21、n. 2、1978年2月、120〜126ページ. 

[SEQNUM] Bellovin、S. 、 "Defending Against Sequence Number Attacks"、RFC 1948、1996年5月. 

[SSL2] Hickman、Kipp、「The SSL Protocol」、Netscape Communications Corp.、1995年2月9日. 

[SSL3] A. Freier、P. Karlton、およびP. Kocher、「The SSL 3.0 Protocol」、Netscape Communications Corp.、1996年11月18日. 

[サブグループ] Zuccherato、R. 、「S / MIMEのDiffie-Hellman鍵共有方法に対する「小サブグループ」攻撃を回避する方法」、RFC 2785、2000年3月. 

[TCP] Postel、J. 、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月. 

[タイミング] Boneh、D.、Brumley、D. 、「リモートタイミング攻撃は実用的」、USENIX Security Symposium2003. 

[TLSAES] Chown、P. 、 "Advanced Encryption Standard（AES）Ciphersuites for Transport Layer Security（TLS）"、RFC 3268、2002年6月. 

[TLSECC] Blake-Wilson、S.、Bolyard、N.、Gupta、V.、Hawk、C. 、およびB. Moeller、「Elliptic Curve Cryptography（ECC）Cipher Suites for Transport Layer Security（TLS）」、RFC 4492 、2006年5月. 

[TLSEXT] Eastlake、D.、3rd、 "Transport Layer Security（TLS）Extensions：Extension Definitions"、Work in Progress、2008年2月. 

[TLSPGP] Mavrogiannopoulos、N. 、「トランスポート層セキュリティ（TLS）認証のためのOpenPGPキーの使用」、RFC 5081、2007年11月. 

[TLSPSK] Eronen、P.、Ed. 、and H. Tschofenig、Ed. 、 "Pre-Shared Key Ciphersuites for Transport Layer Security（TLS）"、RFC 4279、2005年12月. 

[TLS1.0] Dierks、T. およびC. Allen、「The TLS Protocol Version 1.0」、RFC 2246、1999年1月. 

[TLS1.1] Dierks、T. およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.1」、RFC 4346、2006年4月. 

[X501] ITU-T勧告X.501：情報技術-オープンシステム相互接続-ディレクトリ：モデル、1993年. 

[XDR] Eisler、M.、Ed. 、 "XDR：External Data Representation Standard"、STD 67、RFC 4506、2006年5月. 

ワーキンググループ情報

   IETF TLSワーキンググループのディスカッションリストは、
   電子メールアドレス<tls@ietf.org>. グループに関する情報と
   リストを購読する方法についての情報はにあります
   <https://www1.ietf.org/mailman/listinfo/tls>
        
   リストのアーカイブは次の場所にあります. 
   <http://www.ietf.org/mail-archive/web/tls/current/index.html>
        
寄稿者

Christopher Allen（TLS 1.0の共同編集者）Alacrity Ventures ChristopherA@AlacrityManagement.com

カリフォルニア大学マーティンアバディ校、サンタクルスabadi@cs.ucsc.edu

スティーブンM.ベロビンコロンビア大学smb@cs.columbia.edu

Simon Blake-Wilson BCI sblakewilson@bcisse.com Ran Canetti IBM canetti@watson.ibm.com

Pete Chown Skygate Technology Ltd pc@skygate.co.uk

Taher Elgamal taher@s​​ecurify.com Securify

Pasi Eronen pasi.eronen@nokia.com Nokia

アニルガンゴリアンil@busybuddha.org

キップ・ヒックマン

アルフレッド・ホーネス

デビッドホップウッド独立コンサルタントdavid.hopwood@blueyonder.co.uk

Phil Karlton（SSLv3の共著者）

Paul Kocher（SSLv3の共著者）Cryptography Research paul@cryptography.com

Hugo Krawczyk IBM hugo@ee.technion.ac.il

Jan Mikkelsen Transactionware janm@transactionware.com

Magnus NystromRSAセキュリティmagnus@rsasecurity.com

ロバートレリーアネットスケープコミュニケーションズrelyea@netscape.comジムロスキンドネットスケープコミュニケーションズjar@netscape.com

マイケル・サビン

Dan Simon Microsoft、Inc. dansimon@microsoft.com

トム・ウェインスタイン

ティムライトボーダフォンtimothy.wright@vodafone.com

編集者のアドレス

Tim Dierksの独立した電子メール：tim@dierks.org

Eric Rescorla RTFM、Inc. Eメール：ekr@rtfm.com

完全な著作権表示

Copyright（C）IETF Trust（2008）. 

このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、作成者はすべての権利を保持します. 

このドキュメントおよびここに含まれる情報は「現状有姿」で提供され、寄稿者、組織HE / SHEは、（もしあれば）、インターネットソサエティ、IETFトラスト、およびインターネットエンジニアリングタスクフォースの免責事項を表明または後援します. 明示または黙示を問わず、ここに記載されている情報の使用が商品性または特定目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを含むがこれに限定されない保証. 

知的財産

IETFは、このドキュメントに記載されているテクノロジの実装または使用に関連すると主張される可能性のある知的財産権またはその他の権利の有効性または範囲、あるいはそのような権利に基づくライセンスが存在する場合としない場合がある範囲に関して、いかなる立場も取りません. 利用可能である; また、そのような権利を特定するために独自の努力をしたことを表すものでもありません. RFC文書の権利に関する手順に関する情報は、BCP78およびBCP79に記載されています. 

IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような所有権の使用に関する一般的なライセンスまたは許可を取得しようとした結果を取得できます.  http://www.ietf.org/iprのIETFオンラインIPRリポジトリから. 

IETFは、この標準の実装に必要となる可能性のあるテクノロジを対象とする可能性のある著作権、特許、特許出願、またはその他の所有権に関心を持ってもらうよう、関係者に呼びかけています. 情報をIETF（ietf-ipr@ietf.org）に送信してください. 