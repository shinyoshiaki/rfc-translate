RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-26
draft-ietf-rtcweb-jsep-26-JavaScriptセッション確立プロトコル
URL：https://tools.ietf.org/html/rfchttps://tools.ietf.org/html/draft-ietf-rtcweb-jsep-26
タイトル：draft-ietf-rtcweb-jsep-26-JavaScriptセッション確立プロトコル
翻訳編集：自動生成
ネットワークワーキンググループJ. Uberti
Internet-Draft Google
対象ステータス：標準トラックC.ジェニングス
有効期限：2019年8月31日Cisco
                                                        E. Rescorla、Ed. 
                                                                 Mozilla
                                                       2019年2月27日
        
JavaScriptセッション確立プロトコルdraft-ietf-rtcweb-jsep-26

概要

このドキュメントでは、JavaScriptアプリケーションがW3C RTCPeerConnection APIで指定されたインターフェイスを介してマルチメディアセッションのシグナリングプレーンを制御できるようにするメカニズムについて説明し、これが既存のシグナリングプロトコルとどのように関連するかについて説明します. 

このメモのステータス

このインターネットドラフトは、BCP 78およびBCP 79の規定に完全に準拠して提出されます. 

Internet-Draftsは、Internet Engineering Task Force（IETF）の作業文書です. 他のグループも作業文書をインターネットドラフトとして配布する場合があることに注意してください. 現在のインターネットドラフトのリストは、https：//datatracker.ietf.org/drafts/current/にあります. 

Internet-Draftsは、最長6か月間有効なドラフトドキュメントであり、いつでも他のドキュメントによって更新、置き換え、または廃止される可能性があります. インターネットドラフトを参考資料として使用したり、「進行中の作業」以外の方法で引用することは不適切です. 

このインターネットドラフトの有効期限は2019年8月31日です. 

著作権表示

Copyright（c）2019 IETF Trustおよびドキュメントの作成者として識別された人物. 全著作権所有. 

この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、セクション4.eで説明されているように、Simplified BSD Licenseのテキストが含まれている必要があります. 

Trust Legal ProvisionsおよびSimplified BSD Licenseに記載されているように保証なしで提供されます. 

目次

   1.はじめに. . . . . . . . . . . . . . . . . . . . . . . . 4
     1.1. JSEPの一般設計. . . . . . . . . . . . . . . . . 4
     1.2. 検討される他のアプローチ. . . . . . . . . . . . . . . 6
   2.用語. . . . . . . . . . . . . . . . . . . . . . . . . 6
   3.セマンティクスと構文. . . . . . . . . . . . . . . . . . . . 7
     3.1. シグナリングモデル. . . . . . . . . . . . . . . . . . . . . 7
     3.2. セッションの説明と状態機械. . . . . . . . . 7
     3.3. セッション記述形式. . . . . . . . . . . . . . . 11
     3.4. セッション説明コントロール. . . . . . . . . . . . . . . 11
       3.4.1. RtpTransceivers. . . . . . . . . . . . . . . . . . . 11
       3.4.2. RtpSenders. . . . . . . . . . . . . . . . . . . . . 12
       3.4.3. RtpReceivers. . . . . . . . . . . . . . . . . . . . 12
     3.5. ICE . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
       3.5.1. ICE収集の概要 . . . . . . . . . . . . . . 12
       3.5.2. ICE候補トリックリング. . . . . . . . . . . . . . . 13
         3.5.2.1. ICE候補フォーマット. . . . . . . . . . . . . . 13
       3.5.3. ICE候補者ポリシー. . . . . . . . . . . . . . . . 14
       3.5.4. ICE候補プール. . . . . . . . . . . . . . . . . 15
       3.5.5. ICEバージョン. . . . . . . . . . . . . . . . . . . . 16
     3.6. ビデオサイズ交渉. . . . . . . . . . . . . . . . . 16
       3.6.1. imageattr属性の作成. . . . . . . . . . . 16
       3.6.2. imageattr属性の解釈 . . . . . . . . . 17
     3.7. サイマルキャスト. . . . . . . . . . . . . . . . . . . . . . . . 19
     3.8 フォークとの相互作用. . . . . . . . . . . . . . . . 20
       3.8.1. 順次分岐. . . . . . . . . . . . . . . . . 20
       3.8.2. 並列分岐. . . . . . . . . . . . . . . . . . 21
   4.インターフェイス. . . . . . . . . . . . . . . . . . . . . . . . . . 22
     4.1. PeerConnection. . . . . . . . . . . . . . . . . . . . . 22
       4.1.1. コンストラクター. . . . . . . . . . . . . . . . . . . . . 22
       4.1.2. addTrack. . . . . . . . . . . . . . . . . . . . . . 24
       4.1.3. removeTrack. . . . . . . . . . . . . . . . . . . . . 24
       4.1.4. addTransceiver. . . . . . . . . . . . . . . . . . . 25
       4.1.5. createDataChannel. . . . . . . . . . . . . . . . . . 25
       4.1.6. createOffer. . . . . . . . . . . . . . . . . . . . . 25
       4.1.7. createAnswer. . . . . . . . . . . . . . . . . . . . 26日
       4.1.8. SessionDescriptionType. . . . . . . . . . . . . . . 27日
         4.1.8.1. 暫定answerの使用. . . . . . . . . . . 28
         4.1.8.2. ロールバック. . . . . . . . . . . . . . . . . . . . 28
       4.1.9. setLocalDescription. . . . . . . . . . . . . . . . . 29日
       4.1.10. setRemoteDescription. . . . . . . . . . . . . . . . 30
       4.1.11. currentLocalDescription. . . . . . . . . . . . . . . 30
       4.1.12. pendingLocalDescription. . . . . . . . . . . . . . . 30
       4.1.13. currentRemoteDescription. . . . . . . . . . . . . . 30
       4.1.14. pendingRemoteDescription. . . . . . . . . . . . . . 31
       4.1.15. canTrickleIceCandidates. . . . . . . . . . . . . . . 31
       4.1.16. setConfiguration. . . . . . . . . . . . . . . . . . 31
       4.1.17. addIceCandidate. . . . . . . . . . . . . . . . . . . 32
     4.2. RtpTransceiver. . . . . . . . . . . . . . . . . . . . . 33
       4.2.1. やめる . . . . . . . . . . . . . . . . . . . . . . . . 33
       4.2.2. 停止 . . . . . . . . . . . . . . . . . . . . . . . 33
       4.2.3. setDirection. . . . . . . . . . . . . . . . . . . . 33
       4.2.4. 方向性 . . . . . . . . . . . . . . . . . . . . . 34
       4.2.5. currentDirection. . . . . . . . . . . . . . . . . . 34
       4.2.6. setCodecPreferences. . . . . . . . . . . . . . . . . 34
   5. SDP対話手順. . . . . . . . . . . . . . . . . 35
     5.1. 要件の概要 . . . . . . . . . . . . . . . . . 35
       5.1.1. 使用要件. . . . . . . . . . . . . . . . . 35
       5.1.2. プロファイル名と相互運用性. . . . . . . . . 35
     5.2. offerの作成. . . . . . . . . . . . . . . . . . 37
       5.2.1. 最初のoffer. . . . . . . . . . . . . . . . . . . 37
       5.2.2. 後続のoffer. . . . . . . . . . . . . . . . . . 43
       5.2.3. オプション処理. . . . . . . . . . . . . . . . . . 47
         5.2.3.1. IceRestart. . . . . . . . . . . . . . . . . . . 47
         5.2.3.2. VoiceActivityDetection. . . . . . . . . . . . . 47
     5.3. answerの生成. . . . . . . . . . . . . . . . . . 48
       5.3.1. 最初のanswer . . . . . . . . . . . . . . . . . . 48
       5.3.2. 後続のanswer. . . . . . . . . . . . . . . . . 55
       5.3.3. オプション処理. . . . . . . . . . . . . . . . . . 56
         5.3.3.1. VoiceActivityDetection. . . . . . . . . . . . . 56
     5.4. offerまたはanswerの変更. . . . . . . . . . . . . . 57
     5.5. ローカル記述の処理. . . . . . . . . . . . . 57
     5.6. リモートディスクリプションの処理. . . . . . . . . . . . . 58
     5.7. ロールバックの処理. . . . . . . . . . . . . . . . . . 58
     5.8 セッションの説明の解析. . . . . . . . . . . . . . 59
       5.8.1. セッションレベルの解析. . . . . . . . . . . . . . . . 60
       5.8.2. メディアセクション解析. . . . . . . . . . . . . . . . 61
       5.8.3. セマンティクス検証. . . . . . . . . . . . . . . 64
     5.9. ローカルの説明の適用. . . . . . . . . . . . . . 65
     5.10. リモートディスクリプションの適用. . . . . . . . . . . . . . 67
     5.11. answerの適用. . . . . . . . . . . . . . . . . . . 71
   6. RTP / RTCPの処理. . . . . . . . . . . . . . . . . . . . . 74
   7.例. . . . . . . . . . . . . . . . . . . . . . . . . . 74
     7.1. 簡単な例. . . . . . . . . . . . . . . . . . . . . 74
     7.2. 詳細な例. . . . . . . . . . . . . . . . . . . . 78
     7.3. 初期輸送ウォームアップの例. . . . . . . . . . . . . 88
   8.セキュリティに関する考慮事項. . . . . . . . . . . . . . . . . . . 95
   9. IANAの考慮事項. . . . . . . . . . . . . . . . . . . . . 96
   10.謝辞. . . . . . . . . . . . . . . . . . . . . . 96
   11.参考文献. . . . . . . . . . . . . . . . . . . . . . . . . 96
     11.1 規範的な参照. . . . . . . . . . . . . . . . . . 96
     11.2 有益な参照. . . . . . . . . . . . . . . . . 100
        
   付録A.付録A. . . . . . . . . . . . . . . . . . . . . 103
   付録B.変更ログ. . . . . . . . . . . . . . . . . . . . . 105
   著者のアドレス. . . . . . . . . . . . . . . . . . . . . . . 115
        
1.はじめに
このドキュメントでは、W3C WEBRTC RTCPeerConnectionインターフェイス[W3C.webrtc]を使用して、マルチメディアセッションのセットアップ、管理、および破棄を制御する方法について説明します. 

1.1. JSEPの一般的な設計
WebRTCコールセットアップは、メディアプレーンの制御に重点を置いて、シグナリングプレーンの動作を可能な限りアプリケーションに任せるように設計されています. 理論的根拠は、さまざまなアプリケーションが、既存のSIPコールシグナリングプロトコルなどのさまざまなプロトコルを使用することを好む場合や、特定のアプリケーションにカスタム化されたものを使用する場合があります. このアプローチでは、交換する必要のある重要な情報は、マルチメディアセッションの説明であり、メディアプレーンを確立するために必要なトランスポートおよびメディア構成情報を指定します. 

これらの考慮事項を念頭に置いて、このドキュメントでは、JavaScriptからシグナリングステートマシンを完全に制御できるJavaScriptセッション確立プロトコル（JSEP）について説明します. 上記のように、JSEPは、JavaScriptアプリケーションがWebRTC API（「JSEP実装」）を含むランタイム内で実行されるモデルを想定しています. JSEP実装は、コアシグナリングフローからほぼ完全に分離されています. 代わりに、JavaScriptが2つのインターフェースを使用して処理します. （1）ローカルおよびリモートセッションの説明を渡すことと、（2）ICEステートマシンと対話することです. JSEP実装とJavaScriptアプリケーションの組み合わせは、このドキュメント全体で「JSEPエンドポイント」と呼ばれます. 

このドキュメントでは、JSEPの使用は、2つのJSEPエンドポイント間で常に発生するかのように説明されています. ただし、多くの場合、実際にはJSEPエンドポイントとゲートウェイやMCUなどのある種のサーバーの間にあることに注意してください. この区別はJSEPエンドポイントには見えません. APIを介して与えられる指示に従うだけです. 

JSEPのセッション記述の処理は単純で簡単です. offer/answer交換が必要な場合は常に、開始側がcreateOffer（）APIを呼び出してofferを作成します. 次に、アプリケーションはそのofferを使用して、setLocalDescription（）APIを介してローカル構成をセットアップします. offerは最終的に、その優先シグナリングメカニズム（WebSocketなど）を介してリモート側に送信されます. リモートパーティはそのofferを受信すると、setRemoteDescription（）APIを使用してそれをインストールします. 

リモートパーティは、offer/answer交換を完了するために、createAnswer（）APIを使用して適切なanswerを生成し、setLocalDescription（）APIを使用してそれを適用し、シグナリングチャネルを介してイニシエーターに応答を送り返します. イニシエーターがそのanswerを取得すると、setRemoteDescription（）APIを使用してそれをインストールし、初期セットアップが完了します. このプロセスは、追加のoffer/answer交換のために繰り返すことができます. 

ICE [RFC8445]については、候補とその他のトランスポート情報の必要な知識を持つ実装のみがJSEP実装に残っている必要があるため、ICEPはマシン全体のシグナリングステートマシンから切り離されます. この分離を実行すると、セッションの記述をトランスポートから切り離すプロトコルの柔軟性が向上します. たとえば、従来のSIPでは、各offerまたはanswerは、セッションの説明とトランスポート情報の両方を含む自己完結型です. ただし、[ID.ietf-mmusic-trickle-ice-sip]を使用すると、SIPをトリクルICE [ID.ietf-ice-trickle]で使用できます. この場合、セッションの説明をすぐに送信でき、トランスポート情報を送信できる利用可能です. トランスポート情報を個別に送信すると、ICEとDTLSの起動が速くなり、ICEチェックは、すべてのトランスポート情報が利用可能になるとすぐに開始できるため、すべての情報を待つのではなく、JSEPのICEと信号状態マシンの分離により、どちらのモデルにも対応できます. 

JSEPアプローチでは、シグナリングの抽象化を通じて、アプリケーションがシグナリングプロセスを認識する必要があります. アプリケーションは、呼び出しをセットアップするためにセッションの説明の内容を理解する必要はありませんが、アプリケーションは適切なタイミングで適切なAPIを呼び出し、セッションの説明とICE情報を、選択したシグナリングプロトコルの定義済みメッセージに変換して実行する必要があります. 反対側から受信したメッセージの逆変換. 

アプリケーションをより使いやすくする1つの方法は、開発者からこの複雑さを隠すJavaScriptライブラリを提供することです. このライブラリは、ステートマシンとシリアル化コードと共に所定のシグナリングプロトコルを実装し、アプリケーション開発者に高レベルの呼び出し指向のインターフェイスを提供します. たとえば、JSEP APIをSIPまたはXMPPに適したAPIに適合させるためのライブラリが存在します. したがって、JSEPは、初心者の開発者に追加の複雑さを強いることなく、経験豊富な開発者に優れた制御を提供します. 

1.2. 考慮されるその他のアプローチ
JSEPの代わりに検討されたアプローチの1つは、軽量のシグナリングプロトコルを含めることでした. APIにセッションの説明を提供する代わりに、APIはこのプロトコルからメッセージを生成および消費します. より高レベルのAPIを提供しながら、これによりJSEP実装内でシグナリングの制御が強化され、シグナリンググレアなどの概念を理解して処理する必要が生じます（[RFC3264]、セクション4を参照）. 

検討されたが選択されなかった2番目のアプローチは、メディアコントロールオブジェクトの管理をセッションの説明から切り離し、代わりに各コンポーネントを直接制御するAPIを提供することでした. これは、このレベルの複雑さをアプリケーションプログラマーに公開する必要があることは有益ではないという主張に基づいて拒否されました. 単純な例でさえ、必要なすべてのインタラクションを調整するために大量のコードを必要とするAPIになり、合意と文書化が必要な大きなAPIサーフェスを作成することになります. さらに、これらのAPIポイントは任意の順序で呼び出すことができるため、セッションの説明を評価および適用する方法を指定するJSEPアプローチよりも、メディアサブシステムとの相互作用のセットが複雑になります. 

検討されたJSEPのバリエーションの1つは、基本的なセッション記述指向のAPIを維持することでしたが、JSEP実装からofferとanswerを生成するメカニズムを移動することでした. このアプローチでは、実装内にcreateOffer / createAnswerメソッドを提供する代わりに、独自のセッション記述を生成するために必要な情報をアプリケーションに提供するgetCapabilities APIを公開します. これにより、アプリケーションが実行する必要のある作業量が増加します. 機能からセッションの説明を生成する方法、特に任意のofferとサポートされている機能から正しい答えを生成する方法を知る必要があります. これは確かに上記のようなライブラリを使用することで対処できますが、基本的には単純な例であっても、そのライブラリの使用を強制します. 

2.用語
このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 [RFC2119]で説明されているように解釈されます. 

3.セマンティクスと構文
3.1. シグナリングモデル
JSEPは、セッションの両側がセッションの実施方法を知るために[RFC3264]（offer/answer）で説明されている方法でセッション記述を交換する一般的な必要性を除いて、特定のシグナリングモデルまたは状態マシンを指定しません. JSEPは、offerとanswerを作成し、それらをセッションに適用するメカニズムを提供します. ただし、JSEP実装は、アドレス指定、再送信、分岐、グレア処理など、これらのofferとanswerがリモート側に通信される実際のメカニズムから完全に切り離されています. これらの問題は完全にアプリケーションに任されています. アプリケーションは、どのofferとanswerをいつ、いつ実装に渡すかを完全に制御できます. 

       +-----------+                               +-----------+
       |  Web App  |<--- App-Specific Signaling -->|  Web App  |
       +-----------+                               +-----------+
             ^                                            ^
             |  SDP                                       |  SDP
             V                                            V
       +-----------+                                +-----------+
       |   JSEP    |<----------- Media ------------>|   JSEP    |
       |   Impl.   |                                |   Impl.   |
       +-----------+                                +-----------+


                      Figure 1: JSEP Signaling Model
3.2. セッションの説明とステートマシン
メディアプレーンを確立するために、JSEP実装には、リモート側に何を送信するか、および受信したメディアを処理する方法を示す特定のパラメーターが必要です. これらのパラメーターは、offerとanswerのセッション記述の交換によって決定され、JSEP APIで処理する必要があるこのプロセスには特定の詳細があります. 

セッションの説明がローカル側とリモート側のどちらに適用されるかは、その説明の意味に影響します. たとえば、リモートパーティに送信されるコーデックのリストは、ローカル側が何を受信して​​もよいかを示し、リモート側がサポートするコーデックのセットと交差すると、リモート側が送信するものを指定します. ただし、すべてのパラメーターがこの規則に従うわけではありません. 一部のパラメータは宣言型であり、リモート側はそれらを受け入れるか、完全に拒否する必要があります. そのようなパラメーターの例は、提供されたローカル証明書に基づいて計算され、ネゴシエーションの対象ではないDTLSフィンガープリント[RFC8122]です. 

さらに、さまざまなRFCによって、offerの形式とanswerの形式に異なる条件が設定されています. たとえば、offerは任意の数のm =セクション（つまり、[RFC4566]、セクション5.14で説明されているメディアの説明）をofferできますが、answerにはofferとまったく同じ数が含まれている必要があります. 

最後に、正確なメディアパラメータはofferとanswerが交換された後にのみ知られますが、offerはICEチェックを受け取り、場合によってはメディア（たとえば、接続が確立された後の再offerの場合）を受け取ることがあります. それは答えを受け取ります. この場合に着信メディアを適切に処理するには、提供者のメディアハンドラは、answerが届く前に提供の詳細を認識する必要があります. 

したがって、セッションの説明を適切に処理するために、JSEP実装には次のものが必要です. 

1.セッションの説明がローカル側にあるかリモート側にあるかを知る. 

2.セッションの説明がofferかanswerかを知る. 

3.offerをanswerとは無関係に指定できるようにするため. 

JSEPは、setLocalDescriptionメソッドとsetRemoteDescriptionメソッドの両方を追加し、セッション記述オブジェクトに、提供されるセッション記述のタイプを示すタイプフィールドを含めることで、これに対処します. これは、最初にsetLocalDescription（sdp [offer]）を呼び出し、次にsetRemoteDescription（sdp [answer]）を呼び出す提供者と、最初にsetRemoteDescription（sdp [offer]）を呼び出すanswer者の両方について、上記の要件を満たします. その後、後でsetLocalDescription（sdp [answer]）を使用します. 

offer/answerの交換中、未処理のofferは、受け入れられるか拒否されるかによって、offer側とanswer側で「保留中」と見なされます. これが再提供である場合、各サイドには、最新のoffer/answer交換の結果を反映する「現在の」ローカルおよびリモートの説明も含まれます. セクション4.1.12、セクション4.1.14、セクション4.1.11、およびセクション4.1.13では、保留中および現在の説明について詳しく説明しています. 

JSEPでは、アプリケーションでanswerを暫定として扱うこともできます. 暫定answerは、answer者が最初のセッションパラメータを提供者に伝達する方法を提供します. これにより、セッションを開始しながら、最終answerを後で指定できます. この最終的なanswerの概念は、offer/answerモデルにとって重要です. このような応答を受信すると、正確なセッション構成がわかったので、呼び出し元によって割り当てられた追加のリソースを解放できます. これらの「リソース」には、追加のICEコンポーネント、TURN候補、またはビデオデコーダーなどを含めることができます. 一方、暫定answerでは、このような割り当て解除は行われません. その結果、独自のコーデックの選択、トランスポートパラメータなどを含む、複数の異なる暫定応答を受信して​​、コールのセットアップ中に適用できます. 

[RFC3264]では、シグナリングレベルでの制約は、特定のセッションで未解決にできるofferは1つだけですが、メディアスタックレベルでは、いつでも新しいofferを生成できます. たとえば、シグナリングにSIPを使用しているときに、あるofferが送信された後、SIP CANCELを使用してキャンセルされた場合、最初のofferに対する応答がなかったとしても、別のofferを生成できます. これをサポートするために、JavaScriptアプリケーションがシグナリングに必要な場合はいつでも、JSEPメディアレイヤーはcreateOffer（）メソッドを介してofferを提供できます. answer者は0個以上の暫定的なanswerを送り返し、最後に最終的なanswerを送信することでofferとanswerの交換を終了できます. このためのステートマシンは次のとおりです. 

                       setRemote(OFFER)               setLocal(PRANSWER)
                           /-----\                               /-----\
                           |     |                               |     |
                           v     |                               v     |
            +---------------+    |                +---------------+    |
            |               |----/                |               |----/
            |  have-        | setLocal(PRANSWER)  | have-         |
            |  remote-offer |------------------- >| local-pranswer|
            |               |                     |               |
            |               |                     |               |
            +---------------+                     +---------------+
                 ^   |                                   |
                 |   | setLocal(ANSWER)                  |
   setRemote(OFFER)  |                                   |
                 |   V                  setLocal(ANSWER) |
            +---------------+                            |
            |               |                            |
            |               |<---------------------------+
            |    stable     |
            |               |<---------------------------+
            |               |                            |
            +---------------+          setRemote(ANSWER) |
                 ^   |                                   |
                 |   | setLocal(OFFER)                   |
   setRemote(ANSWER) |                                   |
                 |   V                                   |
            +---------------+                     +---------------+
            |               |                     |               |
            |  have-        | setRemote(PRANSWER) |have-          |
            |  local-offer  |------------------- >|remote-pranswer|
            |               |                     |               |
            |               |----\                |               |----\
            +---------------+    |                +---------------+    |
                           ^     |                               ^     |
                           |     |                               |     |
                           \-----/                               \-----/
                       setLocal(OFFER)               setRemote(PRANSWER)


                       Figure 2: JSEP State Machine

これらの状態遷移は別として、暫定（「pranswer」）answerと最終（「answer」）answerの処理に他の違いはありません. 

3.3. セッション記述形式
JSEPのセッション記述では、内部表現にSDP構文を使用しています. この形式はJavaScriptからの操作には最適ではありませんが、広く受け入れられており、新しい機能で頻繁に更新されます. セッション記述の代替エンコーディングは、少なくともこの新しいエンコーディングがSDPの人気を失ったときまで、SDPへの変更に対応する必要があります. 

ただし、将来の柔軟性を提供するために、SDP構文はSessionDescriptionオブジェクト内にカプセル化されます. SessionDescriptionオブジェクトはSDPから構築でき、SDPにシリアル化できます. 将来の仕様がセッション記述のJSON形式に同意する場合、このオブジェクトがJSONを生成して使用できるようにすることは簡単です. 

以下に詳述するように、ほとんどのアプリケーションは、これらのさまざまなAPI呼び出しによって生成および消費されるSessionDescriptionsを不透明なblobとして扱うことができるはずです. つまり、アプリケーションはそれらを読み取ったり変更したりする必要はありません. 

3.4. セッション記述制御
JSEPは、さまざまな一般的なセッションパラメータをアプリケーションで制御できるようにするために、セッション記述を生成する方法をJSEP実装に伝えるコントロールサーフェイスを提供しています. これにより、ほとんどの場合、JavaScriptがセッションの説明を変更する必要がなくなります. 

これらのオブジェクトを変更すると、後続のcreateOffer / Answer呼び出しによって生成されるセッションの説明が変更されます. 

3.4.1. RtpTransceivers
RtpTransceiversを使用すると、アプリケーションは1つのm =セクションに関連付けられたRTPメディアを制御できます. 各RtpTransceiverにはRtpSenderとRtpReceiverがあり、アプリケーションを使用してRTPメディアの送受信を制御できます. アプリケーションは、RtpTransceiverを停止するなどして、直接変更することもできます. 

RtpTransceiversは通常、m =セクションとの1：1マッピングを持っていますが、RtpTransceiversが作成され、まだam =セクションに関連付けられていない場合、またはRtpTransceiversが停止してm =セクションから関連付けが解除されている場合、m =セクションよりも多くのRtpTransceiversが存在する可能性があります. RtpTransceiverは、midプロパティがnullでない場合、m =セクションに関連付けられていると言われます. それ以外の場合は、関連付けが解除されているといいます. 関連するm =セクションは、offerの作成時またはリモートofferの適用時に形成されるトランシーバーとm =セクションインデックス間のマッピングを使用して決定されます. 

RtpTransceiverが複数のm =セクションに関連付けられることはなく、セッションの説明が適用されると、am =セクションは常に1つのRtpTransceiverに関連付けられます. ただし、以下のセクション5.2.2で説明するように、am =セクションが拒否された特定のケースでは、そのm =セクションは「リサイクル」され、新しい中間値を持つ新しいRtpTransceiverに関連付けられます. 

RtpTransceiversは、アプリケーションによって明示的に作成することも、新しいm =セクションを追加するofferを指定してsetRemoteDescriptionを呼び出すことによって暗黙的に作成することもできます. 

3.4.2. RtpSenders
RtpSendersを使用すると、RTPメディアの送信方法をアプリケーションで制御できます. RtpSenderは、m =セクションで記述される発信RTPストリームを概念的に担当します. これには、添付されたMediaStreamTrackのエンコード、RTPメディアパケットの送信、発信RTPストリームのRTCPの生成/処理が含まれます. 

3.4.3. RtpReceivers
RtpReceiversを使用すると、RTPメディアの受信方法をアプリケーションで検査できます. RtpReceiverは、m =セクションで記述される着信RTPストリームを概念的に担当します. これには、受信したRTPメディアパケットの処理、着信ストリームのデコードによるリモートMediaStreamTrackの生成、着信RTPストリームのRTCPの生成/処理が含まれます. 

3.5. ICE
3.5.1. ICE収集の概要
JSEPは、アプリケーションの必要に応じてICE候補を収集します. ICE候補の収集は収集フェーズと呼ばれ、これは、ローカルセッションの説明に新しいまたはリサイクルされたm =セクションを追加するか、説明に新しいICE資格情報を追加して、ICEの再起動を示します. 新しいICE資格情報の使用は、アプリケーションによって明示的にトリガーすることも、ICE構成の変更に応じてJSEP実装によって暗黙的にトリガーすることもできます. 

新しい収集フェーズを必要とする方法でICE構成が変更されると、「needs-ice-restart」ビットが設定されます. このビットが設定されている場合、createOffer APIを呼び出すと、新しいICE資格情報が生成されます. このビットは、offerまたはanswerからの、つまりローカルまたはリモートで開始されたICE再始動からの新しいICE資格情報を使用したsetLocalDescription APIへの呼び出しによってクリアされます. 

新しい収集フェーズが開始すると、ICEエージェントは、イベントを通じて収集が行われていることをアプリケーションに通知します. 次に、新しいICE候補が利用可能になると、ICEエージェントは追加のイベントを介して候補をアプリケーションに提供します. これらの候補者は、現在または保留中のローカルセッションの説明にも自動的に追加されます. 最後に、すべての候補者が収集されると、収集プロセスが完了したことを通知するイベントがディスパッチされます. 

収集フェーズでは、新規/リサイクル/再起動m =セクションで必要な候補のみが収集されることに注意してください. 他のm =セクションは引き続き既存の候補を使用します. また、m =セクションがバンドルされている場合（バンドルネゴシエーションが成功した場合、またはバンドルのみとしてマークされている場合）、MIDがBUNDLEタグである場合に限り、候補が収集され、そのm =セクションと交換されます.  [ID.ietf-mmusic-sdp-bundle-negotiation]で説明されています. 

3.5.2. ICE Candidate Trickling
候補トリクルは、最初のofferがディスパッチされた後で、呼び出し元が呼び出し先に候補を段階的に提供できるテクニックです. 「Trickle ICE」のセマンティクスは、[ID.ietf-ice-trickle]で定義されています. このプロセスにより、呼び出し先がすべての候補を収集するのを待たずに、呼び出し先が呼び出しに基づいて行動し、ICE（およびおそらくDTLS）接続をセットアップできます. これにより、コールを開始する前に収集が実行されない場合のメディアセットアップが高速になります. 

JSEPは、上記のように、ICE候補の収集プロセスを制御およびフィードバックするAPIを提供することにより、オプションの候補トリクルをサポートします. 候補者のトリックルをサポートするアプリケーションは、最初のofferをすぐに送信し、新しい候補者に通知されたときに個々の候補者を送信できます. この機能をサポートしないアプリケーションは、収集が完了するのを待つだけで、現時点ですべての候補者と共にofferを作成して送信できます. 

だまされた候補者を受け取ると、受信アプリケーションはそれらをICEエージェントに提供します. これにより、ICEエージェントがトリガーされ、接続チェック用の新しいリモート候補の使用が開始されます. 

3.5.2.1. ICE候補フォーマット
JSEPでは、ICE候補はIceCandidateオブジェクトによって抽象化され、セッションの説明と同様に、SDP構文が内部表現に使用されます. 

候補の詳細は、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.1で定義されている「candidate-attribute」フィールドと同じSDP構文を使用して、IceCandidateフィールドで指定されます. 次の例に示すように、このフィールドには「a =」プレフィックスが含まれていないことに注意してください. 

候補：1 1 UDP 1694498815 192.0.2.33 10000 typ host

[ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で定義されているように、IceCandidateオブジェクトには、関連付けられているICE ufragを示すフィールドが含まれています. この値は、このIceCandidateが属するセッションの説明（およびその結果、どの収集フェーズか）を決定するために使用されます. これは、ICEの再起動時のあいまいさを解決するのに役立ちます. 受信したIceCandidateにこのフィールドが存在しない場合（おそらく非JSEPエンドポイントと通信している場合）、最後に受信したセッションの説明が想定されます. 

IceCandidateオブジェクトには、関連付けられているm =セクションを示すフィールドも含まれています. これは、am =セクションインデックスまたはMIDの2つの方法のいずれかで識別できます. m =セクションインデックスはゼロベースのインデックスであり、インデックスNは、このIceCandidateが参照するセッション記述のN + 1番目のm =セクションを指します. [RFC5888]のセクション4で定義されているように、MIDは「メディアストリーム識別」値であり、関連するRtpTransceiverオブジェクトのMIDを使用して、セッションの説明でm =セクションを識別するためのより堅牢な方法を提供します. 以下のセクション5.10で説明されているように、MID属性をサポートしない非JSEPエンドポイントと対話するときに、answer者によってローカルに生成されます. 受信したIceCandidateにMIDフィールドが存在する場合、それを識別に使用する必要があります. さもないと、

IceCandidateオブジェクトを作成するとき、JSEP実装は、候補、ufrag、m =セクションインデックス、およびMIDフィールドのそれぞれに入力する必要があります. 上記のように、実装では、一部のフィールドが欠落しているオブジェクトを受信できるように準備する必要があります. 

3.5.3. ICE候補ポリシー
通常、ICE候補を収集する場合、JSEP実装は、ホスト、サーバー再帰、およびリレーなど、すべての可能な初期候補の形式を収集します. ただし、特定のケースでは、プライバシーまたは関連する懸念事項のために、アプリケーションが収集プロセスをより具体的に制御したい場合があります. たとえば、リレー候補のみを使用して、位置情報をできるだけ少なく漏らしたい場合があります（この選択には対応する運用コストが伴うことに注意してください）. これを実現するために、JSEPはアプリケーションがセッションで使用されるICE候補を制限することを許可します. このフィルタリングは、[ID.ietf-rtcweb-ip-handling]で説明されているように、アプリケーションが許可するIPアドレスに関して実装が適用することを選択した制限に加えて適用されることに注意してください. 

アプリケーションが、セッションがアクティブな間に使用される候補のタイプを変更したい場合もあります. 主な例は、最初にリレー候補のみを使用して、任意の発信者への位置情報の漏えいを回避し、その後、ユーザーが電話に出る意思を示したらすべての候補を使用するように変更する（運用コストを下げる）場合です.  . このシナリオの場合、JSEP実装では、前述のローカルポリシーとの相互作用に従って、セッションの途中で候補ポリシーを変更できるようにする必要があります. 

ICE候補ポリシーを管理するために、JSEP実装は、各収集フェーズの開始時に現在の設定を決定します. 次に、収集フェーズでは、実装は現在のポリシーで許可されていない候補をアプリケーションに公開してはならず、それらを接続性チェックのソースとして使用するか、他のICE候補のraddr / rport属性などの他のフィールドを介して間接的に公開してはなりません. その後、アプリケーションで別のポリシーが指定されている場合、アプリケーションは、ICEの再起動を介して新しい収集フェーズを開始することにより、ポリシーを適用できます. 

3.5.4. ICE候補プール
JSEPアプリケーションは、ローカルの説明が必要であり、候補を収集する必要のあるICEコンポーネントの数を示すため、通常、setLocalDescriptionに提供される情報を介してICE収集を開始するようにJSEP実装に通知します. ただし、アプリケーションが事前に使用するICEコンポーネントの数を知っている場合を加速するために、迅速なメディアセットアップを確実にするために、ICE候補のプールを収集するよう実装に要求する場合があります. 

最終的にsetLocalDescriptionが呼び出され、JSEP実装が必要なICE候補を収集するとき、候補がプールで利用可能かどうかを確認することから始めるべきです（SHOULD）. プールに候補者がいる場合、候補者はICE候補イベントを介してすぐにアプリケーションに渡される必要があります. 予想を超える数のICEコンポーネントが使用されているか、プールに候補を収集するための十分な時間がなかったためにプールが使い果たされた場合、残りの候補は通常どおりに収集されます. これは最初のoffer/answer交換でのみ発生し、その後候補者プールは空になり、使用されなくなります. 

この概念が役立つ例の1つは、将来のある時点で着信を予期し、接続の確立にかかる時間を最小限に抑えて、初期メディアのクリッピングを回避したいアプリケーションです. 候補者を事前にプールに収集することにより、コールを受信するとすぐに、これらの候補者から接続チェックを交換して送信を開始できます. ただし、これらの事前に収集された候補を保持することで、必要な限り存続するため、アプリケーションは使用しているSTUN / TURNサーバーのリソースを消費します. 

3.5.5. ICEバージョン
この仕様は正式に[RFC8445]に依存していますが、その公開時点では、WebRTC実装の大部分は[RFC5245]で説明されているICEのバージョンをサポートしています. [RFC8445]で定義されている「ice2」属性を使用すると、リモートエンドポイントで使用されているバージョンを検出し、古い仕様から新しい仕様へのスムーズな移行を提供できます. 実装は、「ice2」属性を持たないリモート記述を受け入れることができる必要があります. 

3.6. ビデオサイズ交渉
ビデオサイズネゴシエーションは、受信者が「a = imageattr」SDP属性[RFC6236]を使用して、受信可能なビデオフレームサイズを示すプロセスです. レシーバーは、ビデオデコーダーが処理できるものにハードリミットがある場合や、ポリシーによって最大値が設定されている場合があります. 「a = imageattr」属性でこれらの制限を指定することにより、JSEPエンドポイントは、リモート送信者が許容可能な解像度でビデオを送信することを確実にすることができます. ただし、この属性を理解しない非JSEPエンドポイントと通信する場合は、通知された制限を超える可能性があり、JSEP実装は、たとえばビデオを破棄するなどして、これを適切に処理する必要があります. 

特定のコーデックは、1.0以外のアスペクト比（つまり、非正方形ピクセル）のサンプルの送信をサポートしていることに注意してください. JSEP実装は非正方形ピクセルを送信しませんが、正しいアスペクト比でそのようなビデオを受信して​​レンダリングする必要があります（SHOULD）. ただし、サンプルのアスペクト比は、以下で説明するサイズのネゴシエーションには影響しません. 正方形かどうかに関係なく、すべての寸法はピクセルで測定されます. 

3.6.1. imageattr属性の作成
受信機は、最初に既知のローカル制限（ハードウェアデコーダーの機能、ローカルポリシーなど）と交差して、受信可能な絶対最小サイズと最大サイズを決定します. 既知のローカル制限がない場合は、「a = imageattr」属性を省略してください. 

これらのローカル制限がビデオの受信を妨げる場合、つまり、許可された解像度がない場合は、「a = imageattr」属性を省略し、必要に応じてm =セクションをsendonly / inactiveとしてマークする必要があります. 

それ以外の場合は、「a = imageattr」属性が「recv」方向で作成され、前述の交差から形成される結果の解像度空間を使用して、最小値と最大値のx =とy =が指定されます. 

ここでのルールは単一の設定を表すため、 "a = imageattr" q =値は重要ではありません. 1.0に設定する必要があります. 

「a = imageattr」フィールドはペイロードタイプ固有です. サポートされているすべてのビデオコーデックに同じ機能がある場合、ワイルドカードペイロードタイプ（*）を使用した単一の属性の使用が推奨されます. ただし、サポートされているビデオコーデックに異なる制限がある場合、特定の「a = imageattr」属性をペイロードタイプごとに挿入する必要があります. 

例として、48x48から720pまでの解像度をデコードできるマルチフォーマットビデオデコーダーを備えたシステムを考えます. この場合、実装はこの属性を生成します. 

   a = imageattr：* recv [x = [48：1280]、y = [48：720]、q = 1.0]
        
この宣言は、受信機が48x48から1280x720ピクセルまでの画像解像度をデコードできることを示しています. 

3.6.2. imageattr属性の解釈
[RFC6236]は、「a = imageattr」を助言フィールドとして定義しています. これは、送信者が使用できるビデオ形式を完全に制限するのではなく、推奨値を示します. 

この仕様は、より具体的な動作を規定しています. 特定の解像度（「トラック解像度」）のビデオを生成しているMediaStreamTrackが、同じまたはより低い解像度（「エンコーダー解像度」）でトラックビデオをエンコードしているRtpSenderに接続されている場合. 送信者を参照し、有効な「a = imageattr recv」属性を含むリモート記述が適用されます. 属性で指定されたサイズ基準を超える解像度を送信者が送信しないようにするために、以下のルールに従う必要があります. トラックが解像度を変更したり、別のトラックに置き換えられたりする場合を含め、属性がリモート記述に存在している限り、これらのルールに従う必要があります. 

RtpSenderの構成方法に応じて、特定の解像度で単一のエンコーディングを生成するか、またはサイマルキャストセクション3.7がネゴシエートされている場合、それぞれ独自の特定の解像度で複数のエンコーディングを生成する場合があります. さらに、構成に応じて、各エンコーディングは必要に応じて解像度を下げる柔軟性を備えている場合や、特定の出力解像度にロックされている場合があります. 

RtpSenderによって生成されるエンコードごとに、リモート記述の対応するm =セクションの "a = imageattr recv"属性のセットが処理され、何を送信する必要があるかが決定されます. エンコード用に選択されたメディア形式を参照する属性のみが考慮されます. そのような各属性は、「q =」の値が最も高い属性から個別に評価されます. 複数の属性が同じ「q =」値を持っている場合、それらはそれらを含むm =セクションに現れる順序で評価されます. JSEPエンドポイントにはメディアフォーマットごとに最大で1つの「a = imageattr recv」属性が含まれますが、JSEPエンドポイントは、複数のそのような属性を含むm =セクションを持つ非JSEPエンドポイントからセッションの説明を受け取る場合があります. 

「a = imageattr recv」属性ごとに、次のルールが適用されます. この処理が成功した場合、それに応じてエンコードが送信され、そのエンコードについてそれ以上の属性は考慮されません. それ以外の場合は、前述の順序で次の属性が評価されます. 指定された属性のいずれも正常に処理できない場合は、エンコーディングを送信してはならず（MUST NOT）、エラーがアプリケーションに発生する必要があります（SHOULD）. 

o属性の制限は、エンコーダーの解像度と比較されます. 下記の特定の制限のみが考慮されます. 画像のアスペクト比など、その他の値はすべて無視する必要があります. 回転したビデオを生成しているMediaStreamTrackを検討するときは、回転していない解像度をチェックに使用する必要があります. これは、マッチングロジックを大幅に簡略化するため、レシーバーが受信側ローテーションの実行をサポートしているかどうかに関係なく（たとえば、CVO [TS26.114]を介して）必要です. 

o属性に「sar = "（サンプルアスペクト比）の値が「1.0」以外に設定されていて、レシーバーが非正方形ピクセルを受信したいことを示している場合、これは満足できないため、属性を使用してはなりません. 

oエンコーダーの解像度が属性で許可されている最大サイズを超え、エンコーダーが解像度を調整できる場合、エンコーダーは制限を満たすためにダウンスケーリングを適用する必要があります（SHOULD）. ダウンスケーリングは、エンコーディングの画像のアスペクト比を変更してはならず、丸めによる些細な違いは無視してください. たとえば、エンコーダの解像度が1280x720で、属性に最大640x480が指定されている場合、予想される出力解像度は640x360になります. ダウンスケーリングを適用できない場合、属性を使用してはなりません（MUST NOT）. 

oエンコーダの解像度が属性で許可されている最小サイズよりも小さい場合、属性を使用してはなりません（MUST NOT）. エンコーダーはアップスケーリングを適用してはなりません（MUST NOT）. JSEP実装は、おそらくソフトウェアデコーダーへのフォールバックを介して、任意の小さな解像度の受信を許可することにより、この状況を回避する必要があります（SHOULD）. 

oエンコーダの解像度が最大サイズと最小サイズの範囲内にある場合、アクションは不要です. 

3.7. サイマルキャスト
JSEPは、MediaStreamTrackの同時送信をサポートします. この場合、単一のm =セクションのコンテキスト内でソースメディアの複数のエンコーディングを送信できます. 現在のJSEP APIは、アプリケーションが同時配信メディアを送信できるように設計されていますが、単一のエンコーディングのみを受信します. これにより、各送信クライアントがサーバーに複数のエンコーディングを送信するマルチユーザーシナリオが可能になり、サーバーは受信クライアントごとに適切なエンコーディングを選択して転送します. 

アプリケーションは、RtpSenderで複数のエンコーディングを構成することにより、サイマルキャストのサポートを要求します. offerまたはanswerが生成されると、これらのエンコーディングは、以下で説明するように、対応するm =セクションのSDPマーキングによって示されます. サイマルキャストを理解し、それを受信する意思がある受信者には、サポートを示すSDPマーキングも含まれます. JSEPエンドポイントは、これらのマーキングを使用して、特定のRtpSenderに対してサイマルキャストが許可されているかどうかを判断します. サイマルキャストのサポートがネゴシエートされない場合、RtpSenderは最初に構成されたエンコードのみを使用します. 

正確な同時放送パラメータは送信アプリケーション次第であることに注意してください. 前述のSDPマーキングは、リモート側が複数のサイマルキャストエンコーディングを受信して​​デマルチプレクサできるようにするために提供されていますが、各エンコーディングに使用される特定の解像度とビットレートは、JSEPでの送信側の決定にすぎません. 

JSEPは現在、サイマルキャストの受信を設定するメカニズムを提供していません. つまり、リモートエンドポイントがサイマルキャストを提供している場合、JSEPエンドポイントが生成する応答は、サイマルキャストの受信のサポートを示さないため、リモートエンドポイントはm =セクションごとに1つのエンコーディングのみを送信します. 

さらに、JSEPは、JSEPエンドポイントからのサイマルキャストを要求する着信offerを処理するメカニズムを提供しません. つまり、JSEPエンドポイントが最初のofferを受信した場合にサイマルキャストを設定するには、帯域外シグナリングまたはSDP検査が必要です. ただし、JSEPエンドポイントが最初のofferでサイマルキャストをセットアップする場合、確立されたサイマルキャストストリームは、着信する再offerの受信時に引き続き機能します. この仕様の将来のバージョンでは、追加のAPIを追加して、最初のofferのシナリオを処理する可能性があります. 

JSEPを使用してRtpSenderから複数のエンコーディングを送信する場合、[ID.ietf-mmusic-sdp-simulcast]および[ID.ietf-mmusic-rid]の手法が使用されます. 具体的には、RtpSenderに複数のエンコーディングが構成されている場合、RtpSenderのm =セクションには、[ID.ietf-mmusic-sdp-simulcast]のセクション6.2で定義されている「a = simulcast」属性が含まれ、「必要な各エンコーディングをリストした「送信」サイマルキャストストリームの説明. 「recv」サイマルキャストストリームの説明はありません. [ID.ietf-mmusic-rid]のセクション4で指定されているように、m =セクションには、各エンコーディングの「a = rid」属性も含まれます. RID識別子を使用すると、個々のエンコーディングがすべて同じm =セクションの一部であっても、それらを明確にすることができます. 

3.8 フォークとの相互作用
一部のコールシグナリングシステムでは、SDPofferが複数のデバイスに提供されるさまざまなタイプの分岐が可能です. たとえば、SIP [RFC3261]は「並列検索」と「順次検索」の両方を定義しています. これらは主にJSEPの範囲外のシグナリングレベルの問題ですが、関連するメディアプレーンの構成に影響を与えます. シグナリング層で分岐が発生した場合、シグナリングを担当するJavaScriptアプリケーションは、どのメディアをいつ送信または受信するか、およびどのリモートエンドポイントと通信するかを決定する必要があります. JSEPは、メディアエンジンがRTPおよびメディアをアプリケーションの必要に応じて実行できるようにするために使用されます. アプリケーションがメディアエンジンに実行できる基本的な操作は次のとおりです. 

o特定のリモートピアとのメディア交換を開始しますが、offerで予約されているすべてのリソースを保持します. 

o特定のリモートピアとのメディア交換を開始し、offer内で使用されていないリソースを解放します. 

3.8.1. 順次分岐
シーケンシャルフォーキングでは、コールが複数のリモート呼び出し先にディスパッチされ、各呼び出し先は呼び出しを受け入れることができますが、一度にアクティブなセッションは1つしか存在しません. 受信したメディアの混合は実行されません. 

JSEPは順次フォークを適切に処理し、アプリケーションが目的のリモートエンドポイントを選択するためのポリシーを簡単に制御できるようにします. 呼び出し先の1つからanswerが届いた場合、アプリケーションはそれを暫定answerとして適用して、将来別のanswerを使用する可能性を残しておくか、最終answerとして適用してセットアップフローを終了するかを選択できます. 

「先勝者」の状況では、最初のanswerが最終answerとして適用され、アプリケーションは後続のanswerをすべて拒否します. SIP用語では、これはACK + BYEになります. 

「最後の勝ち」の状況では、すべてのanswerが暫定answerとして適用され、以前のコールレッグはすべて終了します. ある時点で、アプリケーションはおそらくタイマーでセットアッププロセスを終了します. この時点で、アプリケーションは保留中のリモートの説明を最終的なanswerとして再適用できます. 

3.8.2. 並列フォーク
並列分岐では、複数のリモート呼び出し先に呼び出しがディスパッチされ、各呼び出し先が呼び出しを受け入れることができ、結果として複数の同時アクティブシグナリングセッションを確立できます. 複数の呼び出し先が同時にメディアを送信する場合、これを処理する可能性は[RFC3960]、セクション3.1で説明されています. 今日のほとんどのSIPデバイスは、一度に1つのデバイスとのメディア交換のみをサポートしており、混乱を招く可能性があるため、複数の初期メディアオーディオソースを混在させようとはしていません. たとえば、ヨーロッパのリングバックトーンと北アメリカのリングバックトーンを混ぜることを検討してください. 結果のサウンドはどちらのトーンとも似ておらず、ユーザーを混乱させます. シグナリングアプリケーションが一度に1つのリモートエンドポイントとのみメディアを交換する場合は、メディアエンジンの観点から、

JavaScriptアプリケーションが複数のピアと同時にメディアを交換することを望む並列分岐の場合、フローは少し複雑ですが、JavaScriptアプリケーションは[RFC3960]がUPDATEを使用して説明する戦略に従うことができます. UPDATEアプローチにより、シグナリングは、メディアを交換するピアごとに個別のメディアフローをセットアップできます. JSEPでは、UPDATEで使用されるこのofferは、新しいPeerConnection（セクション4.1を参照）を作成し、同じローカルメディアストリームがこの新しいPeerConnectionに追加されたことを確認することで形成されます. 次に、新しいPeerConnectionオブジェクトは、[RFC3960]で説明されているUPDATE戦略を実行するためにシグナリングで使用できるSDPofferを生成します. 

メディアストリームを共有した結果、アプリケーションはN個の並列PeerConnectionセッションで終了し、それぞれにローカルおよびリモートの説明と独自のローカルおよびリモートアドレスがあります. これらのセッションからのメディアフローは、setDirection（セクション4.2.3を参照）を使用して管理できます. または、アプリケーションは、混合されたすべてのセッションからメディアを再生することを選択できます. もちろん、アプリケーションが単一のセッションのみを保持したい場合は、不要になったセッションを単に終了することができます. 

4.インターフェース
このセクションでは、JSEP機能を実装するために必要な基本操作について詳しく説明します. W3C APIで公開されている実際のAPIの構文は多少異なる場合がありますが、これらの概念に簡単に対応するはずです. 

4.1. PeerConnection
4.1.1. コンストラクタ
アプリケーションは、PeerConnectionコンストラクターを使用して、候補を収集するときに使用するSTUN / TURNサーバーや資格情報などのメディアセッションのグローバルパラメーター、および使用する初期ICE候補ポリシーとプールサイズ、およびバンドルポリシーを指定できます. 

ICE候補ポリシーが指定されている場合、それはセクション3.5.3で説明されているように機能し、JSEP実装は許可された候補（実装内部フィルタリングを含む）のみをアプリケーションに表示し、それらの候補のみを接続性チェックに使用します. 利用可能なポリシーのセットは次のとおりです. 

all：実装ポリシーで許可されているすべての候補者が収集され、使用されます. 

リレー：リレー候補を除くすべての候補が除外されます. これにより、受信した候補からリモートピアによって確認される可能性のある位置情報が難読化されます. アプリケーションがリレーサーバーを展開して選択する方法に応じて、これは場所をメトロレベルまたは場合によってはグローバルレベルに難読化する可能性があります. 

デフォルトのICE候補ポリシーは「すべて」に設定する必要があります. これは一般的に望ましいポリシーであり、通常はアプリケーションのTURNサーバーリソースの使用を大幅に削減するためです. 

ICE候補プールのサイズが指定されている場合、これは候補を事前に収集するICEコンポーネントの数を示します. 事前収集により、STUN / TURNサーバーリソースが潜在的に長期間利用されるため、これはアプリケーションリクエストでのみ発生する必要があるため、デフォルトの候補プールサイズはゼロでなければなりません（MUST）. 

アプリケーションは、バンドルの使用に関する優先ポリシー、[ID.ietf-mmusic-sdp-bundle-negotiation]で定義された多重化メカニズムを指定できます. ポリシーに関係なく、アプリケーションは常に単一のトランスポート上でバンドルをネゴシエートしようとし、すべてのm =セクションにわたって単一のバンドルグループを提供します. この単一のトランスポートの使用は、バンドルを受け入れる応答者に依存します. ただし、以下のリストからポリシーを指定することにより、アプリケーションは、メディアストリームを一緒にバンドルしようとする積極性を正確に制御できます. これは、非バンドル対応エンドポイントとの相互運用方法に影響します. バンドル非対応エンドポイントとネゴシエートする場合、バンドルのみのストリームとしてマークされていないストリームのみが確立されます. 

利用可能なポリシーのセットは次のとおりです. 

バランス：各タイプ（オーディオ、ビデオ、またはアプリケーション）の最初のm =セクションには、トランスポートパラメータが含まれます. これにより、応答者はそのセクションをバンドル解除できます. 各タイプの2番目以降のm =セクションは、バンドルのみとマークされます. その結果、N個の異なるメディアタイプがある場合、N個のメディアストリームの候補が収集されます. このポリシーは、従来のケースでも基本的なオーディオとビデオを確実にネゴシエートできるようにする必要性と、多重化の要望のバランスをとっています. answer者として機能する場合、offerにバンドルグループがない場合、実装は各タイプの最初のm =セクション以外をすべて拒否します. 

max-compat：すべてのm =セクションにはトランスポートパラメータが含まれます. バンドルのみとしてマークされるものはありません. このポリシーでは、すべてのストリームをバンドル非対応のエンドポイントで受信できますが、メディアストリームごとに個別の候補を収集する必要があります. 

max-bundle：最初のm =セクションのみにトランスポートパラメータが含まれます. 最初以外のすべてのストリームはバンドルのみとしてマークされます. このポリシーの目的は、レガシーエンドポイントとの互換性を犠牲にして、候補の収集を最小限に抑え、多重化を最大化することです. answerとして機能する場合、実装は、最初のm =セクション以外のすべてのm =セクションを拒否します. ただし、それらがそのm =セクションと同じバンドルグループ内にある場合を除きます. 

パフォーマンスとレガシーエンドポイントとの互換性の間の最良のトレードオフを提供するため、デフォルトのバンドルポリシーは「バランス」に設定する必要があります. 

アプリケーションは、次のポリシーのいずれかを使用して、RTP / RTCP多重化[RFC5761]の使用に関する優先ポリシーを指定できます. 

ネゴシエート：JSEP実装はRTPとRTCPの両方の候補を収集しますが、「a = rtcp-mux」も提供するため、多重化エンドポイントまたは非多重化エンドポイントとの互換性が可能になります. 

require：JSEP実装はRTP候補のみを収集し、生成するofferの新しいm =セクションに "a = rtcp-mux-only"指示を挿入します. これにより、提供者が収集する必要のある候補者の数が半分になります. 「a = rtcp-mux」属性を含まないm =セクションの説明を適用すると、エラーが返されます. 

デフォルトの多重化ポリシーは、「必須」に設定する必要があります. 実装は、多重化ポリシーを「ネゴシエーション」に設定するためのアプリケーションによる試行を拒否することを選択できます. 

4.1.2. addTrack
addTrackメソッドは、MediaStream引数を使用してMediaStreamTrackをPeerConnectionに追加し、トラックを同じMediaStream内の他のトラックに関連付けます. これにより、offerまたはanswerを作成するときに、それらを同じ「LS」グループに追加できます. [RFC5888]のセクション7で説明されているように、同じ「LS」グループにトラックを追加すると、これらのトラックの再生は適切なリップシンクのために同期する必要があります. addTrackは、トランシーバーの数を次のように最小化しようとします.  「have-remote-offer」状態では、トラックは、setRemoteDescription（）への最新の呼び出しによって作成され、ローカルトラックを持たない最初の互換性のあるトランシーバーに接続されます. それ以外の場合は、セクション4.1.4で説明するように、新しいトランシーバーが作成されます. 

4.1.3. removeTrack
removeTrackメソッドは、RtpSender引数を使用してMediaStreamTrackをPeerConnectionから削除し、トラックを削除する送信者を指定します. 送信者のトラックがクリアされ、送信者は送信を停止します. createOfferへの今後の呼び出しは、送信者に関連付けられたm =セクションをrecvonly（transceiver.directionがsendrecvの場合）または非アクティブ（transceiver.directionがsendonlyの場合）としてマークします. 

4.1.4. addTransceiver
addTransceiverメソッドは、新しいRtpTransceiverをPeerConnectionに追加します. MediaStreamTrack引数が指定されている場合、トランシーバーはそのメディアタイプで構成され、トラックはトランシーバーに接続されます. それ以外の場合、アプリケーションはタイプを明示的に指定する必要があります. このモードは、recvonlyトランシーバーを作成する場合や、後でトラックを接続できるトランシーバーを作成する場合に便利です. 

作成時に、アプリケーションはトランシーバー方向属性、トランシーバーが関連付けられているMediaStreamsのセット（LSグループの割り当てを許可）、およびメディアのエンコーディングセット（セクション3.7で説明されているように同時放送に使用）も指定できます.  ）. 

4.1.5. createDataChannel
createDataChannelメソッドは、新しいデータチャネルを作成し、それをPeerConnectionにアタッチします. このPeerConnectionのデータチャネルが現在存在しない場合は、新しいoffer/answer交換が必要です. 特定のPeerConnectionのすべてのデータチャネルは同じSCTP / DTLSアソシエーションを共有するため、同じm =セクションを共有するため、その後のデータチャネルの作成はJSEP状態に影響を与えません. 

createDataChannelメソッドには、PeerConnectionによって使用される多数の引数（maxPacketLifetimeなど）も含まれますが、SDPには反映されず、JSEPの状態には影響しません. 

4.1.6. createOffer
createOfferメソッドは、このPeerConnectionに追加されたメディアの説明、この実装でサポートされているコーデック/ RTP / RTCPオプション、およびICEエージェントによって収集されました. オプションパラメータを指定して、生成されたofferをさらに制御できます. このオプションパラメータを使用すると、接続を再確立するために、アプリケーションでICEの再起動をトリガーできます. 

最初のofferでは、生成されたSDPにはセッションに必要なすべての機能が含まれます（サポートされているが、デフォルトでは不要な機能は省略できます）. SDPラインごとに、SDPの生成は、所定のSDPラインを指定するドキュメントから最初のofferを生成するために定義されたプロセスに従います. 初期offer生成の正確な処理については、以下のセクション5.2.1で詳しく説明します. 

セッションの確立後にcreateOfferが呼び出されると、createOfferは、RtpTransceiversの追加や停止、ICEの再起動の要求など、セッションに加えられた変更に基づいて現在のセッションを変更するofferを生成します. 既存のストリームごとに、各SDPラインの生成は、所定のSDPラインを指定するRFCから更新されたofferを生成するために定義されたプロセスに従う必要があります. 新しいストリームごとに、SDPの生成は、前述のように、最初のofferを生成するプロセスに従う必要があります. 変更が加えられていない場合、または要求された変更の影響を受けないSDP回線の場合、offerには最後のofferとanswerの交換で交渉されたパラメーターのみが含まれます. 以降のoffer生成の正確な処理については、セクション5.2.2で詳しく説明します. 未満. 

createOfferによって生成されたセッションの説明は、setLocalDescriptionですぐに使用できる必要があります. システムのリソースが限られている場合（デコーダーの数が有限など）、createOfferはシステムの現在の状態を反映するofferを返す必要があります. これにより、setLocalDescriptionがそれらのリソースを取得しようとしたときに成功します. 

このメソッドを呼び出すと、新しいICE資格情報の生成などの処理が行われますが、PeerConnectionの状態の変更、候補の収集のトリガー、またはメディアのフローの開始や停止は行われません. 具体的には、setLocalDescriptionが呼び出されるまで、offerは適用されず、保留中のローカル説明にはなりません. 

4.1.7. createAnswer
createAnswerメソッドは、[RFC3264] SDPanswerを含むSDPのblobを生成します. このセッションのサポートされている構成は、createAnswerを呼び出す前に呼び出す必要があるsetRemoteDescriptionへの最新の呼び出しで提供されるパラメーターと互換性があります. createOfferと同様に、返されたblobには、このPeerConnectionに追加されたメディアの説明、このセッション用にネゴシエートされたコーデック/ RTP / RTCPオプション、およびICEエージェントによって収集された候補が含まれます. オプションパラメータを指定して、生成されたanswerをさらに制御できます. 

答えとして、生成されたSDPには、メディアプレーンを確立する方法を指定する特定の構成が含まれます. 各SDPラインについて、SDPの生成は、所定のSDPラインを指定するドキュメントからanswerを生成するために定義されたプロセスに従う必要があります. answer生成の正確な処理については、セクション5.3で詳しく説明します. 未満. 

createAnswerで生成されたセッションの説明は、setLocalDescriptionですぐに使用できる必要があります. createOfferと同様に、返される説明はシステムの現在の状態を反映している必要があります. 

このメソッドを呼び出すと、新しいICEクレデンシャルの生成などが実行されますが、PeerConnectionの状態の変更、候補の収集のトリガー、またはメディアの状態の変更は行われません. 具体的には、setLocalDescriptionが呼び出されるまで、answerは適用されず、現在のローカルの説明にはなりません. 

4.1.8. SessionDescriptionType
セッション記述オブジェクト（RTCSessionDescription）のタイプは、「offer」、「pranswer」、「answer」、または「rollback」です. これらのタイプは、説明パラメーターの解析方法、およびメディア状態の変更方法に関する情報を提供します. 

「offer」は、説明をofferとして解析する必要があることを示します. この説明には、多くの可能なメディア構成が含まれる場合があります. 「offer」として使用される説明は、PeerConnectionが安定した状態にあるときはいつでも、または以前に提供されたが未answerの「offer」の更新として適用できます. 

「pranswer」は、説明を最終的なanswerではなくanswerとして解析する必要があるため、割り当てられたリソースが解放されないことを示します. answerで非アクティブなメディア方向が指定されていない場合、メディア送信が開始される可能性があります. 「answer」として使用される説明は、「offer」への応答として、または以前に送信された「answer」への更新として適用できます. 

"answer"は、説明をanswerとして解析し、offerとanswerの交換を完全であると見なし、不要になったリソース（デコーダー、候補）を解放できることを示します. 「answer」として使用される説明は、「offer」への応答、または以前に送信された「answer」への更新として適用できます. 

暫定answerと最終answerの唯一の違いは、最終answerでは、offerの結果として割り当てられた未使用のリソースが解放されることです. そのため、アプリケーションは、answerを暫定的なものと最終的なもののどちらとして適用するかについて何らかの裁量を使用し、必要に応じてセッションの説明のタイプを変更できます. たとえば、シリアルフォーキングシナリオでは、アプリケーションは複数の「最終」answerを各リモートエンドポイントから1つずつ受け取ることがあります. アプリケーションは、最初のanswerを暫定的なanswerとして受け入れることを選択でき、基準を満たすanswer（ボイスメールではなくライブユーザーなど）を受け取ったときにのみanswerを最終的なanswerとして適用できます. 

「ロールバック」は、セクション4.1.8.2で説明されているように、ステートマシンを以前の安定した状態にロールバックする必要があることを意味する特別なセッション記述タイプです. 内容は空でなければなりません. 

4.1.8.1. 暫定answerの使用
ほとんどのアプリケーションでは、「pranswer」タイプを使用してanswerを作成する必要はありません. offerへの即時応答を送信することをお勧めしますが、セッショントランスポートをウォームアップしてメディアクリッピングを防ぐために、JSEPアプリケーションの推奨される処理は、null MediaStreamTrackを使用して「sendonly」最終応答をすぐに作成して送信することです. offerを受信した後. これにより、発信者によるメディアの送信が防止され、着信者が応答するとすぐにメディアが送信されます. その後、呼び出し先が実際に呼び出しを受け入れると、アプリケーションは実際のMediaStreamTrackをプラグインし、新しい「sendrecv」offerを作成して、以前のoffer/answerペアを更新し、双方向メディアフローを開始できます. これは、 "sendonly"応答とそれに続く "sendrecv"応答でも実行できますが、

例として、オーディオとビデオをできるだけ迅速にセットアップしたい典型的なJSEPアプリケーションを考えてみましょう. 呼び出し先がオーディオとビデオのMediaStreamTracksを含むofferを受信すると、これらのトラックをsendonlyとして受け入れて即時応答を送信します（つまり、呼び出し元は呼び出し先にメディアをまだ送信しないため、呼び出し先はまだ独自のMediaStreamTracksを追加していないため、呼び出し先もメディアを送信しません）. 次に、呼び出しを受け入れて必要なローカルトラックを取得するようにユーザーに要求します. ユーザーが承認すると、アプリケーションは取得したトラックをプラグインします. この時点までにICEおよびDTLSハンドシェイクが完了している可能性があるため、すぐに送信を開始できます. また、アプリケーションはリモート側に新しいofferを送信し、通話の受け入れを示し、オーディオとビデオを双方向メディアに移動します. 

もちろん、一部のアプリケーション、特にレガシーシグナリングプロトコルへのゲートウェイを試みているアプリケーションは、この二重offer/answer交換を実行できない場合があります. これらの場合でも、pranswerはアプリケーションにトランスポートをウォームアップするメカニズムを提供できます. 

4.1.8.2. ロールバック
特定の状況では、setLocalDescriptionまたはsetRemoteDescriptionに加えられた変更を「取り消す」ことが望ましい場合があります. コールが進行中で、一方がセッションパラメータの一部を変更したい場合を考えます. その側は更新されたofferを生成してから、setLocalDescriptionを呼び出します. ただし、リモート側は、setRemoteDescriptionの前または後のいずれかで、新しいパラメーターを受け入れないことを決定し、拒否メッセージを提供者に送り返します. さて、提供者、そしておそらくはanswer者も、安定した状態と以前のローカル/リモートの説明に戻る必要があります. これをサポートするために、セッションへのofferされた変更を破棄し、状態マシンを安定状態に戻す「ロールバック」の概念を導入します. タイプ「ロールバック」のセッション記述を提供することにより、ロールバックが実行されます

4.1.9. setLocalDescription
setLocalDescriptionメソッドは、指定されたセッションの説明をローカル構成として適用するようにPeerConnectionに指示します. タイプフィールドは、説明をoffer、暫定answer、最終answer、またはロールバックとして処理する必要があるかどうかを示します. offerとanswerは、SDPラインごとに存在するさまざまなルールを使用して、異なる方法でチェックされます. 

このAPIはローカルメディアの状態を変更します. 特に、メディアを受信およびデコードするためのローカルリソースを設定します. アプリケーションが1つのメディア形式から別の互換性のない形式に変更することをofferするシナリオを正常に処理するには、PeerConnectionが現在のローカル記述と保留中のローカル記述の両方の使用を同時にサポートできなければなりません（たとえば、存在するコーデックをサポートします）どちらの説明でも）. この二重処理は、PeerConnectionが「have-local-offer」状態になったときに始まり、setRemoteDescriptionが呼び出されて最終的なanswerが返されるまで続きます. この時点で、PeerConnectionは保留中のローカル説明を完全に採用できるか、結果としてロールバックが行われます. 現在のローカルの説明に戻します. 

このAPIは、候補者の収集プロセスを間接的に制御します. ローカルの説明が提供され、現在使用中のトランスポートの数がローカルの説明に必要なトランスポートの数と一致しない場合、PeerConnectionは必要に応じてトランスポートを作成し、候補プールからのトランスポートを使用して各トランスポートの候補の収集を開始します. 利用可能です. 

setRemoteDescriptionが以前にofferで呼び出され、setLocalDescriptionがanswer（暫定または最終）で呼び出され、メディアの指示に互換性があり、メディアを送信できる場合、これによりメディアの送信が開始されます. 

4.1.10. setRemoteDescription
setRemoteDescriptionメソッドは、提供されたセッションの説明を目的のリモート構成として適用するようにPeerConnectionに指示します. setLocalDescriptionと同様に、説明のtypeフィールドは、その処理方法を示します. 

このAPIはローカルメディアの状態を変更します. 特に、メディアを送信およびエンコードするためのローカルリソースを設定します. 

setLocalDescriptionが以前にofferで呼び出され、setRemoteDescriptionがanswer（暫定または最終）で呼び出され、メディアの指示に互換性があり、メディアを送信できる場合、これによりメディアの送信が開始されます. 

4.1.11. currentLocalDescription
currentLocalDescriptionメソッドは、ローカルの説明が設定されてからICEエージェントによって生成されたローカル候補に加えて、現在ネゴシエートされたローカルの説明（最後に成功したoffer/answer交換からのローカルの説明）を返します. 

offer/answerの交換がまだ完了していない場合は、nullオブジェクトが返されます. 

4.1.12. pendingLocalDescription
pendingLocalDescriptionメソッドは、ローカルの説明が設定されてからICEエージェントによって生成されたローカルの候補に加えて、現在ネゴシエーション中のローカルの説明のコピー、つまり対応するリモートのanswerがないローカルのofferセットを返します. 

PeerConnectionの状態が「安定」または「have-remote-offer」の場合、nullオブジェクトが返されます. 

4.1.13. currentRemoteDescription
currentRemoteDescriptionメソッドは、リモートの説明が設定されてからprocessIceMessageを介して提供されたリモート候補に加えて、現在ネゴシエートされたリモートの説明（つまり、最後に成功したoffer/answer交換からのリモートの説明）のコピーを返します. 

offer/answerの交換がまだ完了していない場合は、nullオブジェクトが返されます. 

4.1.14. pendingRemoteDescription
pendingRemoteDescriptionメソッドは、リモートの説明が設定されてからprocessIceMessageを介して提供されたリモートの候補に加えて、現在ネゴシエーション中のリモートの説明のコピー（つまり、対応するローカルのanswerがないリモートのofferセット）を返します. 

PeerConnectionの状態が「安定」または「have-local-offer」の場合、nullオブジェクトが返されます. 

4.1.15. canTrickleIceCandidates
canTrickleIceCandidatesプロパティは、リモート側が細流候補の受信をサポートするかどうかを示します. 3つの潜在的な値があります. 

null：反対側からSDPが受信されていないため、トリクルを処理できるかどうかは不明です. これは、setRemoteDescription（）が呼び出される前の初期値です. 

true：SDPが反対側から受信され、トリクルをサポートできることを示しています. 

false：反対側からSDPが受信され、トリクルをサポートできないことを示しています. 

セクション3.5.2で説明したように、JSEP実装は常に、Trickle ICEに必要なものと一致して、アプリケーションの候補を個別に提供します. ただし、アプリケーションはcanTrickleIceCandidatesプロパティを使用して、ピアが実際にTrickle ICEを実行できるかどうか、つまり、候補者が集まったときに最初のofferまたはanswerを後で送信しても安全かどうかを判断できます. 「True」はリモートのTrickle ICEサポートを明確に示す唯一の値であるため、canTrickleIceCandidatesを「True」と比較するアプリケーションは、デフォルトで、初期offerでHalf Trickleを試行し、Trickle ICE互換エージェントとのその後のやり取りでFull Trickleを試行します. 

4.1.16. setConfiguration
setConfigurationメソッドを使用すると、コンストラクターパラメーターによって最初に設定されたPeerConnectionのグローバル構成をセッション中に変更できます. このメソッド呼び出しの効果は、それが呼び出されるタイミングによって異なり、変更される特定のパラメーターによって異なります. o使用するSTUN / TURNサーバーへの変更は、次の収集フェーズに影響します. ICE収集フェーズがすでに開始または完了している場合は、セクション3.5.1で説明した「needs-ice-restart」ビットが設定されます. これにより、次のcreateOfferの呼び出しにより、ICEの再起動を強制し、新しいサーバーが使用される新しい収集フェーズを開始するために、新しいICE資格情報が生成されます. ICE候補プールのサイズがゼロではなく、ローカルの説明がまだ適用されていない場合、既存の候補は破棄されます. 

o ICE候補ポリシーへの変更は、次の収集フェーズに影響します. ICE収集フェーズがすでに開始または完了している場合、「needs-ice-restart」ビットが設定されます. どちらの方法でも、プールされた候補は収集フェーズが発生するまでアプリケーションで利用できず、プールされた候補に対して必要なフィルタリングを実行できるため、ポリシーの変更は候補プールに影響を与えません. 

oローカルの説明を適用した後、ICE候補プールのサイズを変更してはなりません. ローカルの説明がまだ適用されていない場合、ICE候補プールサイズへの変更はすぐに有効になります. 増加した場合、追加の候補者が事前に収集されます. 減少すると、不要になった候補は破棄されます. 

oバンドルおよびRTCP多重化ポリシーは、PeerConnectionの構築後に変更してはなりません. 

この呼び出しにより、ICEエージェントの状態が変化する場合があります. 

4.1.17. addIceCandidate
addIceCandidateメソッドは、IceCandidateオブジェクトを介してICEエージェントを更新します. セクション3.5.2.1. IceCandidateの候補フィールドが入力されている場合、IceCandidateは新しいリモートICE候補として扱われ、Trickle ICEに定義されたルールに従って、現在または保留中のリモートの説明に追加されます. それ以外の場合、[ID.ietf-ice-trickle]で定義されているように、IceCandidateは候補者の終わりを示すものとして扱われます. 

いずれの場合も、上記のセクション3.5.2.1で説明したように、提供されたIceCandidateのm =セクションインデックス、MID、およびufragフィールドを使用して、IceCandidateがどのm =セクションおよびICE候補世代に属するかを決定します. 候補終了の指示の場合、m =セクションインデックスとMIDフィールドの両方がないことは、指示が指定されたICE候補世代のすべてのm =セクションに適用されることを意味すると解釈されます. ただし、新しいリモート候補の両方のフィールドが存在しない場合は、以下に示すように、これを無効な条件として扱う必要があります. 

IceCandidateフィールドに無効な値が含まれている場合、またはIceCandidateオブジェクトの処理中にエラーが発生した場合、指定されたIceCandidateを無視し、エラーを返す必要があります. 

それ以外の場合は、新しいリモート候補または候補終了の通知がICEエージェントに提供されます. 新しいリモート候補者の場合、接続性チェックが新しい候補者に送信されます. 

4.2. RtpTransceiver
4.2.1. やめる
stopメソッドは、RtpTransceiverを停止します. これにより、今後createOfferが呼び出され、関連するm =セクションにゼロポートが生成されます. 詳細については、以下を参照してください. 

4.2.2. 停止
Stoppedプロパティは、stopTransceiverの呼び出しによって、または関連するm =セクションを拒否する応答を適用することによって、トランシーバーが停止されたかどうかを示します. これらのいずれの場合も、「true」に設定され、それ以外の場合は「false」に設定されます. 

停止したRtpTransceiverは、発信RTPまたはRTCPを送信したり、着信RTPまたはRTCPを処理したりしません. 再起動できません. 

4.2.3. setDirection
setDirectionメソッドは、トランシーバーの方向を設定します. これは、createOfferおよびcreateAnswerの今後の呼び出しで、関連するm =セクションのdirectionプロパティに影響します. 方向に許可される値は「recvonly」、「sendrecv」、「sendonly」、および「inactive」であり、[RFC4566]のセクション6で定義されている同じ名前の方向属性を反映しています. 

offerを作成する場合、トランシーバーの方向は、再offerの場合でも、出力に直接反映されます. answerを作成するとき、トランシーバーの方向は、セクション5.3で説明するように、提供された方向と交差します. 

setDirectionはトランシーバーの方向プロパティをすぐに設定しますが（セクション4.2.4）、このプロパティはトランシーバーのRtpSenderが送信するか、RtpReceiverが受信するかにはすぐには影響しないことに注意してください. 有効な方向はcurrentDirectionプロパティで表され、answerが適用されたときにのみ更新されます. 

4.2.4. 方向
directionプロパティは、setDirectionに渡された最後の値を示します. setDirectionが呼び出されたことがない場合は、トランシーバーが初期化された方向に設定されます. 

4.2.5. currentDirection
currentDirectionプロパティは、トランシーバーに関連付けられたm =セクションの最後にネゴシエートされた方向を示します. より具体的には、最後に適用されたanswer（暫定answerを含む）の関連するm =セクションの[RFC3264]方向属性を示します. リモートanswerの場合は、「送信」と「受信」の方向が逆になります. たとえば、リモートanswerの関連するm =セクションの方向属性が「recvonly」の場合、currentDirectionは「sendonly」に設定されます. 

このトランシーバーを参照するanswerがまだ適用されていない場合、またはトランシーバーが停止している場合、currentDirectionはnullに設定されます. 

4.2.6. setCodecPreferences
setCodecPreferencesメソッドは、トランシーバーのコーデック設定を設定します. これは、createOfferおよびcreateAnswerへの今後の呼び出しで、関連するm =セクションのコーデックの存在と順序に影響を与えます. setCodecPreferencesは、実装が送信することを決定したコーデックに直接影響しないことに注意してください. offerまたはanswerを介して、実装が受信を好むことを示すコーデックにのみ影響します. コーデックがsetCodecPreferencesによって除外されている場合でも、次のoffer/answer交換がそれを破棄するまで、コーデックを使用して送信することができます. 

RtpTransceiverのコーデック設定により、createOfferおよびcreateAnswerへの後続の呼び出しによってコーデックが除外される可能性があります. その場合、関連するm =セクションの対応するメディア形式が除外されます. コーデックプリファレンスは、他の方法では存在しないメディアフォーマットを追加できません. 

RtpTransceiverのコーデックプリファレンスは、createOfferおよびcreateAnswerへの後続の呼び出しでコーデックの順序を決定することもできます. その場合、関連するm =セクションのメディアフォーマットの順序は、指定されたプリファレンスに従います. 

5. SDP相互作用手順
このセクションでは、SDPオブジェクトを作成および解析する際に従う特定の手順について説明します. 

5.1. 要件の概要
JSEP実装は、offerとanswerの作成と処理を管理する以下にリストされている仕様に準拠する必要があります. 

5.1.1. 使用要件
JSEP実装によって処理されるすべてのセッション記述は、ローカルとリモートの両方で、次の仕様のサポートを示している必要があります. これらのいずれかがない場合、この省略はエラーとして扱われる必要があります. 

o [RFC8445]で指定されているICEを使用する必要があります. リモートエンドポイントはLite実装を使用する場合があることに注意してください. 実装は、ICE-Liteを実行するリモートエンドポイントを適切に処理する必要があります. 

o [ID.ietf-rtcweb-security-arch]で指定されているように、メディアタイプに応じて、DTLS [RFC6347]またはDTLS-SRTP [RFC5763]を使用する必要があります. 

[ID.ietf-rtcweb-security-arch]で説明されているように、[RFC4568]のSDES SRTPキーイングメカニズムを使用してはなりません（MUST NOT）. 

5.1.2. プロファイル名と相互運用性
メディアm =セクションの場合、JSEP実装は、[RFC5764]で指定された "UDP / TLS / RTP / SAVPF"プロファイルと、[RFC7850]で指定された "TCP / DTLS / RTP / SAVPF"プロファイルをサポートしなければなりません. 各メディアのこれらのプロファイルのm =ラインがofferで生成します. データm =セクションの場合、実装は「UDP / DTLS / SCTP」プロファイルと「TCP / DTLS / SCTP」プロファイルをサポートする必要があり、offerで生成する各データm =行に対してこれらのプロファイルの1つを示す必要があります. 使用する正確なプロファイルは、[ID.ietf-mmusic-ice-sip-sdp]のセクション3.2.1.2で説明されているように、現在のデフォルトまたは選択されたICE候補に関連付けられているプロトコルによって決定されます. 

残念ながら、互換性を確保するために、一部のエンドポイントは、これらのプロファイルの1つをサポートするつもりでも、他のプロファイル文字列を生成します. たとえば、エンドポイントは「RTP / AVP」を生成しますが、「a = fingerprint」および「a = rtcp-fb」属性を提供し、「UDP / TLS / RTP / SAVPF」または「TCP / DTLS / RTPをサポートする意思があることを示します.  / SAVPF」. そのようなエンドポイントとの互換性を簡素化するために、JSEP実装は、受信したofferのメディアm =セクションを処理するとき、次のルールに従う必要があります. 

o次のいずれかに一致するoffer内のプロファイルはすべて受け入れる必要があります. 

      *「RTP / AVP」（[RFC4566]、セクション8.2.2で定義）
        
      * "RTP / AVPF"（[RFC4585]、セクション9で定義）
        
      *「RTP / SAVP」（[RFC3711]、セクション12で定義）
        
      * "RTP / SAVPF"（[RFC5124]、セクション6で定義）
        
      *「TCP / DTLS / RTP / SAVP」（[RFC7850]、セクション3.4で定義）
        
      * "TCP / DTLS / RTP / SAVPF"（[RFC7850]、セクション3.5で定義）
        
      *「UDP / TLS / RTP / SAVP」（[RFC5764]、セクション9で定義）
        
      *「UDP / TLS / RTP / SAVPF」（[RFC5764]、セクション9で定義）
        
o生成されたanswerの「m =」行のプロファイルは、offerで提供されるプロファイルと完全に一致する必要があります. 

o DTLS-SRTPが必須であるため、SAVPまたはAVPを選択しても効果はありません. DTLS-SRTPのサポートは、1つ以上の「a = fingerprint」属性の存在によって決定されます. 「a = fingerprint」属性がないと、交渉が失敗することに注意してください. 

o AVPFまたはAVPの使用は、RTCPフィードバックに使用されるタイミングルールを制御するだけです. AVPFが指定されている場合、または「a = rtcp-fb」属性が存在する場合は、AVPFタイミング、つまり「trr-int = 0」のデフォルト値を想定します. それ以外の場合は、AVPFがAVP互換モードで使用されていると想定し、「trr-int = 4000」の値を使用します. 

oデータm =セクションの場合、実装は "UDP / DTLS / SCTP"、 "TCP / DTLS / SCTP"、または "DTLS / SCTP"（下位互換性のため）プロファイルの受信をサポートする必要があります. 

JSEP実装による再提供では、最初のoffer/answer交換で古い（不適切な）プロファイル文字列を使用した場合でも、正しいプロファイル文字列を使用する必要があることに注意してください. このような再提供の処理に失敗したリモートエンドポイントもJSEPエンドポイントの最初のofferの処理に失敗するため、これによりJSEPの動作が簡素化され、マイナス面が最小限になります. 

5.2. offerの作成
createOfferが呼び出されると、[ID.ietf-rtcweb-rtp-usage]で指定された機能を含む新しいSDP記述を作成する必要があります. このプロセスの正確な詳細を以下に説明します. 

5.2.1. 最初のoffer
createOfferが初めて呼び出されたときの結果は、初期offerと呼ばれます. 

[RFC4566]のセクション5で指定されているように、初期offerを生成する最初のステップは、セッションレベルの属性を生成することです. 具体的には、次のとおりです. 

o最初のSDP行は、[RFC4566]のセクション5.1で指定されているように、「v = 0」である必要があります. 

o 2番目のSDP行は、[RFC4566]のセクション5.2で指定されている「o =」行でなければなりません. <username>フィールドの値は「-」にする必要があります. sess-idは64ビットの符号付き整数で表現できなければならず、値は（2 ** 63）-1未満でなければなりません. sess-idは、最高ビットをゼロに設定し、残りの63ビットを暗号的にランダムにした64ビット量を生成することによって構築することをお勧めします. <nettype> <addrtype> <unicast-address>タプルの値は、このフィールドのローカルIPアドレスのリークを防ぐために、IN IP4 0.0.0.0などの意味のないアドレスに設定する必要があります（SHOULD）. この問題は[ID.ietf-rtcweb-ip-handling]で説明されています. [RFC4566]で述べたように、o =行全体が一意である必要がありますが、これを行うには<sess-id>に乱数を選択するだけで十分です. 

o 3番目のSDP行は、[RFC4566]のセクション5.3で指定されている「s =」行でなければなりません. 「o =」行に一致させるには、単一のダッシュをセッション名として使用する必要があります（例：「s =-」）. これは単一のスペースをofferする[RFC4566]のアドバイスとは異なりますが、JSEPでは "o ="と "s ="の両方が無意味であるため、同じ無意味な値を持つことはより明確に見えるようです. 

oセッション情報（ "i ="）、URI（ "u ="）、電子メールアドレス（ "e ="）、電話番号（ "p ="）、繰り返し時間（ "r ="）、およびタイムゾーン（ " z = "）行はこのコンテキストでは役に立たないため、含めないでください. 

o暗号化キー（ "k ="）行は十分なセキュリティを提供しないため、含めることはできません. 

o [RFC4566]のセクション5.9で指定されているように、「t =」行を追加する必要があります. <start-time>と<stop-time>の両方をゼロに設定する必要があります（例： "t = 0 0"）. 

o [ID.ietf-ice-trickle]、セクション3および[RFC8445]、セクション10で指定されているように、「trickle」および「ice2」オプションを含む「a = ice-options」行を追加する必要があります. 

o WebRTC IDが使用されている場合、[ID.ietf-rtcweb-security-arch]のセクション5で説明されている「a = identity」行. 

次のステップは、[RFC4566]のセクション5.14で指定されているように、m =セクションを生成することです. 停止したRtpTransceiversを除いて、PeerConnectionに追加された各RtpTransceiverに対してm =セクションが生成されます. これは、RtpTransceiversがPeerConnectionに追加された順序で行われます. そのようなRtpTransceiversがない場合、m =セクションは生成されません. [RFC3264]、セクション5で説明されているように、後でさらに追加できます. 

RtpTransceiverに対して生成されたm =セクションごとに、トランシーバーと生成されたm =セクションのインデックス間のマッピングを確立します. 

バンドルのみとしてマークされていない場合、各m =セクションは、一意のICE資格情報のセットを生成し、独自の一意のICE候補セットを収集する必要があります. バンドルのみのm =セクションには、ICE資格情報を含めてはならず、候補を収集してはなりません. 

DTLSの場合、すべてのm =セクションは、PeerConnectionに指定されているすべての証明書を使用する必要があります. 結果として、それらはすべて同じ[RFC8122]フィンガープリント値を持つ必要があります. そうでない場合、これらの値はセッションレベルの属性である必要があります. 

各m =セクションは、[RFC4566]のセクション5.14で指定されているように生成する必要があります. m =行自体については、次の規則に従う必要があります. 

o m =セクションがバンドルのみとしてマークされている場合、ポート値は0に設定する必要があります. それ以外の場合、ポート値はこのm =セクションのデフォルトICE候補のポートに設定されますが、候補はありません.  [ID.ietf-ice-trickle]のセクション5.1に示されているように、まだ使用可能な「ダミー」ポート値9（破棄）を使用する必要があります. 

o DTLSの使用を適切に示すには、[RFC5764]のセクション8で指定されているように、<proto>フィールドを "UDP / TLS / RTP / SAVPF"に設定する必要があります. 

oコーデックの設定が関連するトランシーバーに設定されている場合、メディアフォーマットは対応する順序で生成されなければならず、コーデックの設定に存在しないコーデックを除外しなければなりません（MUST）. 

o上記の制限によって除外されない限り、メディア形式には、[RFC7874]、セクション3、および[RFC7742]、セクション5で指定されている必須のオーディオ/ビデオコーデックを含める必要があります. 

[RFC4566]のセクション5.7で指定されているように、m =行の直後には "c ="行が続く必要があります. 繰り返しになりますが、まだ候補はありません. [ID.ietf-ice-trickle]のセクション5.1で定義されているように、「c =」行には「IN IP4 0.0.0.0」の「ダミー」値を含める必要があります. 

[ID.ietf-mmusic-sdp-mux-attributes]は、SDP属性をさまざまなカテゴリにグループ化します. バンドル時に不要な重複を避けるために、カテゴリIDENTICALまたはTRANSPORTの属性は、バンドルされたm =セクションで繰り返さないでください. [ID.ietf-mmusic-sdp-bundle-negotiation]のガイダンスをセクション8.1で繰り返します. これには、バンドルがネゴシエートされており、まだ望ましいm =セクションと、バンドルのみとしてマークされたm =セクションが含まれます. 

IDENTICALまたはTRANSPORT以外のカテゴリの次の属性は、各m =セクションに含める必要があります. 

o [RFC5888]のセクション4で指定されている「a = mid」行. すべてのMID値は、ユーザー情報を漏らさない方法で生成する必要があります. たとえば、ランダムに、またはPeerConnectionカウンターごとに使用し、3にする必要があります.  [ID.ietf-mmusic-sdp-bundle-negotiation]のセクション14で定義されているRTPヘッダー拡張に効率的に適合できるようにするため、バイト数以下. これは、RtpTransceiver midプロパティを設定しないことに注意してください. 説明が適用されます. 生成されたMID値は、この時点で「offerされた」MIDと見なすことができます. 

o関連するトランシーバーの方向属性と同じ方向属性. 

o [RFC4566]、セクション6、および[RFC3264]、セクション5.1で指定されているように、m =行、「a = rtpmap」および「a = fmtp」行の各メディア形式. 

o RTP再送信を使用する各プライマリコーデックについて、プライマリコーデックのクロックレートで「rtx」を示す対応する「a = rtpmap」行と、プライマリコーデックのペイロードタイプを参照する「a = fmtp」行、 [RFC4588]、セクション8.1で指定されているとおり. 

oサポートされているFECメカニズムごとに、[RFC4566]のセクション6で指定されている「a = rtpmap」および「a = fmtp」行. サポートされなければならないFECメカニズムは、[ID.ietf-rtcweb-fec]で指定されます. セクション6、および各メディアタイプの具体的な使用方法については、セクション4および5で概説しています. 

oこのm =セクションが、オーディオなど、パケットごとに構成可能なメディアの継続時間を持つメディア用である場合、「a = maxptime」行は、指定されたように各パケットにカプセル化できる、ミリ秒で指定されたメディアの最大量を示します.  [RFC4566]のセクション6に記載されています. この値は、m =セクションに含まれるすべてのコーデックの最大期間値の最小値に設定されます. 

oこのm =セクションがビデオメディア用であり、デコードできる画像のサイズに既知の制限がある場合、セクション3.6で指定されている「a = imageattr」行. 

oサポートされているRTPヘッダー拡張ごとに、[RFC5285]のセクション5で指定されている「a = extmap」行. サポートする必要があるヘッダー拡張のリストは、[ID.ietf-rtcweb-rtp-usage ]、セクション5.2. [RFC6904]のセクション4に示すように、暗号化を必要とするヘッダー拡張を指定する必要があります. 

oサポートされている各RTCPフィードバックメカニズムについて、[RFC4585]のセクション4.2で指定されている「a = rtcp-fb」行. サポートする必要がある/サポートする必要があるRTCPフィードバックメカニズムのリストは、[ID.ietf-rtcweb-rtp-usage]のセクション5.1で指定されています. 

o RtpTransceiverにsendrecvまたはsendonlyの方向がある場合：

* addTrackまたはaddTransceiverを介して作成されたときにトランシーバーに関連付けられた各MediaStreamについて、[a.msid]行. [ID.ietf-mmusic-msid]のセクション2で指定されていますが、「appdata」フィールドは省略されています. 

o RtpTransceiverにsendrecvまたはsendonlyの方向があり、アプリケーションがRID値を指定しているか、RtpSendersのパラメーターで複数のエンコードを指定している場合、指定された各エンコードの「a = rid」行. 「a = rid」行は[ID.ietf-mmusic-rid]で指定されており、その方向は「送信」でなければなりません. アプリケーションがRID値を選択した場合、それをrid-identifierとして使用する必要があります. それ以外の場合は、実装によってRID値を生成する必要があります. [ID. で定義されたRTPヘッダー拡張に効率的に適合できるように、RID値は、ランダムに、またはピア接続ごとのカウンターを使用するなど、ユーザー情報をリークしない方法で生成する必要があり、3バイト以下にする必要があります.  ietf-avtext-rid]、セクション3. エンコーディングがされていない場合

指定するか、エンコードを1つだけ指定してRID値を指定しないと、「a = rid」行は生成されません. 

o RtpTransceiverにsendrecvまたはsendonlyの方向があり、複数の "a = rid"行が生成されている場合、[ID.ietf-mmusic-sdp- simulcast]、セクション6.2. RIDのリストには、このm =セクションの「a = rid」行で使用されるすべてのRID識別子を含める必要があります. 

oこのPeerConnectionのバンドルポリシーが「max-bundle」に設定されていて、これが最初のm =セクションでない場合、またはバンドルポリシーが「balanced」に設定されており、これがこのメディアの最初のm =セクションでない場合「a =バンドルのみ」の行を入力します. 

IDENTICALまたはTRANSPORTカテゴリの次の属性は、一意のアドレスを持っているか、bundle-tagに関連付けられている "m ="セクションにのみ出現する必要があります. （最初のofferでは、これは「a = bundle-only」属性を含まない「m =」セクションを意味します. ）

o [ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で指定されている「a = ice-ufrag」および「a = ice-pwd」行. 

[RFC8122]のセクション5で指定されているように、目的のダイジェストアルゴリズムごとに、エンドポイントの証明書ごとに1つ以上の「a = fingerprint」行. 

o [RFC4145]のセクション4で指定され、[RFC5763]のセクション5のDTLS-SRTPシナリオでの使用が明確化されている「a = setup」行. offerのロール値は「actpass」である必要があります. 

o [ID.ietf-mmusic-dtls-sdp]の5.2項で指定されている「a = tls-id」行. 

o [RFC3605]、セクション2.1で指定されているように、候補がまだ収集されていないため、ダミー値「9 IN IP4 0.0.0.0」を含む「a = rtcp」行. 

o [RFC5761]のセクション5.1.3で指定されている「a = rtcp-mux」行. 

o RTP / RTCP多重化ポリシーが「必須」の場合、[ID.ietf-mmusic-mux-exclusive]のセクション4で指定されている「a = rtcp-mux-only」行. 

[a = rtcp-rsize]行. [RFC5506]のセクション5で指定されています. 

最後に、データチャネルが作成されている場合、データ用にam =セクションを生成する必要があります. <media>フィールドは "application"に設定する必要があり、<proto>フィールドは "UDP / DTLS / SCTP" [ID.ietf-mmusic-sctp-sdp]に設定する必要があります. [ID.ietf-mmusic-sctp-sdp]のセクション4.1で指定されているように、「fmt」値は「webrtc-datachannel」に設定する必要があります. 

[ID.ietf-mmusic-]で定義されているように、データm =セクション内で、「a = mid」行を生成して、上記のようにSCTPポート番号を参照する「a = sctp-port」行とともに含める必要があります.  [ID.ietf-mmusic-sctp-sdp]、セクション6.1で定義されているように、sctp-sdp]、セクション5.1、および適切な場合は「a = max-message-size」行. 

上記のように、IDENTICALまたはTRANSPORTカテゴリの次の属性は、データm =セクションが一意のアドレスを持っているか、バンドルタグに関連付けられている場合にのみ含まれます（たとえば、唯一のm =セクションの場合）. 

o「a = ice-ufrag」

o「a = ice-pwd」

o「a = fingerprint」

o「a = setup」

o「a = tls-id」

すべてのm =セクションが生成されたら、[RFC5888]で指定されているように、セッションレベルの「a = group」属性を追加する必要があります. この属性はセマンティクス「BUNDLE」を持たなければならず（MUST）、各m =セクションの中間識別子を含まなければなりません（MUST）. これの効果は、JSEP実装がすべてのm =セクションを1つのバンドルグループとして提供することです. ただし、m =セクションがバンドルのみであるかどうかは、バンドルポリシーによって異なります. 

次のステップは、[RFC5888]のセクション7で定義されているように、セッションレベルのリップシンクグループを生成することです. 複数のRtpTransceiverによって参照される各MediaStream（addStreamおよびaddTransceiverメソッドへの引数としてこれらのMediaStreamsを渡すことにより）、タイプのグループ各RtpTransceiverの中間値を含む「LS」を追加する必要があります. 

SDPがセッションレベルまたはメディアレベルのいずれかであることを許可する属性は、それらが同一であっても、通常はメディアレベルにある必要があります. これは、特に最初に同一の属性のセットの1つが後で変更された場合に特に、個々のメディアセクションを理解しやすくすることにより、開発とデバッグを支援します. ただし、実装はセッションレベルで属性を集約することを選択できます. JSEP実装は、いずれかの場所で属性を受信できるように準備する必要があります. 

[ID.ietf-rtcweb-rtp-usage]の要件と特に互換性がない次の属性を除いて、上記で指定されたもの以外の属性を含めることができます（MUST NOT）. 

o「a = crypto」

o「a = key-mgmt」

o「a = ice-lite」

バンドルが使用される場合、追加される追加の属性は、それらの属性がバンドルと相互作用する方法に関する[ID.ietf-mmusic-sdp-mux-attributes]のアドバイスに従う必要があることに注意してください. 

これらの要件は、SDPの要件よりも厳しい場合があることに注意してください. この仕様でSDPを生成するための要件に適合しない場合でも、実装は準拠SDPを受け入れる準備ができていなければなりません. 

5.2.2. 後続のoffer
createOfferが2回目（またはそれ以降）に呼び出される場合、またはローカルの説明が既にインストールされた後に呼び出される場合、処理は最初のofferの場合とは多少異なります. 

以前のofferがsetLocalDescriptionを使用して適用されなかった場合、つまり、PeerConnectionがまだ「安定」状態にある場合は、次の制限に従って、最初のofferを生成する手順に従う必要があります. 

o「o =」行のフィールドは、<session-version>フィールドを除いて同じである必要があります. offerがcreateOfferへの以前の呼び出しの出力と異なる場合は、createOfferへの呼び出しごとに1ずつ増加する必要があります. 実装は、すべての呼び出しで<session-version>をインクリメントすることを選択できます. 生成された<session-version>の値は、現在のローカル記述の<session-version>とは無関係です. 特に、現在のバージョンがNである場合、offerが作成され、バージョンN + 1で適用されます. その後、そのofferがロールバックされ、現在のバージョンが再びNになります. 次に生成されるofferは、バージョンNのままです.  +2. 

アプリケーションがcreateOfferを呼び出すのではなくcurrentLocalDescriptionを読み取ることによってofferを作成する場合、収集されたICE候補が追加されるため、返されるSDPはsetLocalDescriptionが最初に呼び出されたときと異なる場合がありますが、<session-version>は変更されません. これにより問題が発生する既知のシナリオはありませんが、これが問題になる場合の解決策は、createOfferを使用して一意の<session-version>を確保することです. 

以前のofferがsetLocalDescriptionを使用して適用されたが、リモート側からの対応するanswerがまだ適用されていない場合、つまり、PeerConnectionがまだ「have-local-offer」状態にある場合、offerは「」の手順に従って生成されます. 上記の安定した状態、およびこれらの例外：

o "s ="と "t ="の行は同じでなければなりません. 

o RtpTransceiverが追加されていて、現在のローカルの説明または現在のリモートの説明にポートが0のm =セクションが存在する場合、追加されたRtpTransceiverのm =セクションを生成することにより、そのm =セクションをリサイクルする必要があります.  m =セクションがセッションの説明（新しいMID値を含む）に追加され、ゼロポートを持つm =セクションと同じインデックスに配置されていました. 

o RtpTransceiverが停止していて、m =セクションに関連付けられていない場合、そのためにm =セクションを生成してはなりません（MUST NOT）. これにより、前述のように、m =セクションがリサイクルされ、以前のoffer/answer交換で新しいRtpTransceiverに使用されたRtpTransceiversが再び追加されるのを防ぎます. 

o RtpTransceiverが停止し、m =セクションに関連付けられていて、m =セクションが上記のようにリサイクルされていない場合、ポートをゼロに設定してすべての "a = msid"でm =セクションを生成する必要があります.  "行が削除されました. 

o停止していないRtpTransceiversの場合、「a = msid」行は、トランシーバーの方向またはトラックへの変更に関係なく、現在の説明に存在する場合、同じままである必要があります. 「a = msid」行が現在の説明に存在しない場合、「a = msid」行は、最初のofferと同じ規則に従って生成されなければなりません. 

o [ID.ietf-mmusic-ice-sip-sdpで説明されているように、各 "m ="およびc = "行には、ポート、関連するRTPプロファイル、およびm =セクションのデフォルト候補のアドレスを入力する必要があります.  ]、セクション3.2.1.2、およびセクション5.1.2で明確化RTP候補がまだ収集されていない場合でも、上記のようにダミー値を使用する必要があります. 

o「a = mid」の各行は同じでなければなりません. 

o「a = ice-ufrag」および「a = ice-pwd」の各行は、ICE構成が変更されていない限り（サポートされているSTUN / TURNサーバーへの変更、またはICE候補ポリシー）、または「 IceRestart "オプション（セクション5.2.3.1が指定されました. m=セクションが別のm =セクションにバンドルされている場合でも、ICE資格情報を含めることはできません. 

o m =セクションが別のm =セクションにバンドルされていない場合、[RFC5761]のセクション5.1.3に示すように、その "a = rtcp"属性行にデフォルトのRTCP候補のポートとアドレスを入力する必要があります. 上記の最初のofferのセクションで説明したように、RTCP候補がまだ収集されていない場合は、ダミー値を使用する必要があります. 

o m =セクションが別のm =セクションにバンドルされていない場合、最新の収集フェーズ（セクション3.5.1を参照）で収集された候補ごとに、「a = candidate」行を追加する必要があります.  [ID.ietf-mmusic-ice-sip-sdp]、セクション4.1. [ID.ietf-ice-trickle]のセクション9.3で説明されているように、セクションの候補者の収集が完了した場合は、「a = end-of-candidates」属性を追加する必要があります. m =セクションが別のm =セクションにバンドルされている場合、「a = candidate」と「a = end-of-candidates」の両方を省略しなければなりません. 

oまだ存在するRtpTransceiversの場合、「a = rid」行は同じままである必要があります. 

oまだ存在しているRtpTransceiversの場合、「a = simulcast」行は同じままにする必要があります. 

以前のofferがsetLocalDescriptionを使用して適用され、リモート側からの対応するanswerがsetRemoteDescriptionを使用して適用されている場合、つまり、PeerConnectionが「have-remote-pranswer」または「stable」状態である場合、交渉に基づいてofferが生成されます. 上記の「have-local-offer」状態で説明した手順に従うことによるセッションの説明. 

さらに、新しいofferの既存の、リサイクルされず、拒否されないm =セクションごとに、現在のローカルまたはリモートの説明の対応するm =セクションの内容に基づいて、以下の調整が適宜行われます. 

o m =行と対応する「a = rtpmap」および「a = fmtp」行には、関連するトランシーバーのコーデック設定で除外されていないメディア形式のみを含めなければならず、現在利用可能なすべての形式を含めなければなりません. 以前は提供されていたが利用できなくなったメディア形式（共有ハードウェアコーデックなど）は除外される場合があります. 

oコーデックの優先順位が関連するトランシーバーに設定されていない限り、m =行のメディア形式は、最新のanswerと同じ順序で生成する必要があります. 最新のanswerに含まれていないメディア形式は、既存のすべての形式の後に追加する必要があります. 

o RTPヘッダー拡張には、最新のanswerに存在するもののみを含める必要があります. 

o RTCPフィードバックメカニズムは、新しく追加されたメディアフォーマットを参照するフォーマット固有のメカニズムの場合を除いて、最新のanswerに存在するもののみを含める必要があります. 

o最新のanswerに「a = rtcp-mux」行が含まれていた場合、「a = rtcp」行を追加してはなりません. 

o「a = rtcp-mux」の行は、最新のanswerの行と同じである必要があります. 

o「a = rtcp-mux-only」行を追加してはなりません. 

o「a = rtcp-rsize」行は、最新のanswerに存在しない限り、追加してはなりません. 

[ID.ietf-mmusic-sdp-bundle-negotiation]のセクション6に示されているように、「a = bundle-only」行を追加してはなりません（MUST）. 代わりに、JSEP実装は、IDENTICALおよびTRANSPORTカテゴリのパラメーターを単に省略しなければなりません[ID.ietf-mmusic-sdp-bundle-negotiation]で説明されているように、バンドルされたm =セクション、セクション8.1. 

oメディアm =セクションがデータm =セクションにバンドルされている場合、特定のTRANSPORT属性とIDENTICAL属性がデータm =セクションに表示される場合があります.  = rtcp-mux」）. 初期offerでは、JSEP実装は常にデータm =セクション（存在する場合）の前にメディアm =セクションをリストし、それらのメディアm =セクションの少なくとも1つに "a = bundle-only "属性. したがって、最初のofferでは、「a = bundle-only」のm =セクションは、先行する非バンドルのみのメディアm =セクションにバンドルされます. 

「a = group：BUNDLE」属性には、最新のanswerのバンドルグループで指定されたMID識別子、拒否としてマークされたm =セクション、および新しく追加された、または再度有効にされたm =セクションを含める必要があります. 言い換えると、バンドル属性には、それらがまだ存続している限り、以前にバンドルされていたすべてのm =セクションと、新しいm =セクションが含まれている必要があります. 

「a = group：LS」属性は、最初のofferの場合と同じ方法で生成され、最新のanswerに存在したリップシンクグループは引き続き存在しなければならず、以前に存在していたMID識別子を含まなければならないという追加の規定があります. 識別されたm =セクションがまだ存在し、拒否されておらず、グループに少なくとも2つのMID識別子が含まれている限り. これにより、同期された「recvonly」のm =セクションが新しいofferでも引き続き同期されます. 

5.2.3. オプションの取り扱い
createOfferメソッドは、RTCOfferOptionsオブジェクトをパラメーターとして受け取ります. 次のオプションが存在する場合、SDP記述の生成時に特別な処理が実行されます. 

5.2.3.1. IceRestart
「IceRestart」オプションが「true」の値で指定されている場合、offerは、[ID.ietf-mmusic-ice-sip-sdp]で指定されているように、新しいICE ufrag属性とpwd属性を生成してICEの再起動を示す必要があります. セクション3.4.1.1.1. このオプションが最初のofferで指定されている場合、効果はありません（新しいICE ufragおよびpwdがすでに生成されているため）. 同様に、ICE設定が変更された場合、新しいufrag属性とpwd属性が自動的に生成されるため、このオプションは効果がありません. このオプションは、アプリケーションによって障害が検出された場合に、接続を再確立するために主に役立ちます. 

5.2.3.2. VoiceActivityDetection
不連続送信（ "DTX"）とも呼ばれる無音圧縮は、音声アクティビティが検出されない場合に忠実性を犠牲にして、特別なエンコーディングに切り替えることにより、オーディオに使用される帯域幅を削減できます. 

「VoiceActivityDetection」オプションが「true」の値で指定されている場合、offerは、[で指定されているように、提供される各オーディオコーデックにコンフォートノイズ（「CN」）コーデックを含めることにより、受信するオーディオの無音抑制のサポートを示す必要があります.  RFC3389]、セクション5.1. ただし、独自の内部サイレンス抑制サポートを備えたコーデックを除きます. 独自の内部無音圧縮サポートを備えたコーデックの場合、そのコーデックに適切なfmtpパラメータを指定して、受信したオーディオの無音圧縮が必要であることを示す必要があります. たとえば、Opusコーデック[RFC6716]を使用する場合、

[RFC7587]で指定されている "usedtx = 1"パラメータがofferで使用されます. 

「VoiceActivityDetection」オプションが「false」の値で指定されている場合、JSEP実装は「CN」コーデックを発行してはなりません（MUST NOT）. 独自の内部無音圧縮サポートを備えたコーデックの場合、そのコーデックに適切なfmtpパラメータを指定して、受信したオーディオの無音圧縮が望ましくないことを示す必要があります. たとえば、Opusコーデックを使用する場合、「usedtx = 0」パラメーターがofferで指定されます. さらに、「CN」コーデックまたは関連するfmtpパラメータがピアの説明に表示されているかどうかに関係なく、実装は、生成するメディアに無音圧縮を使用してはなりません（MUST NOT）. これらのルールの影響は、JSEPでの無音抑止が両側の相互の合意に依存することであり、使用されるコーデックに関係なく、一貫した処理が保証されます. 

[VoiceActivityDetection]オプションは、[RFC6464]のセクション4で説明されているクライアントからミキサーへのオーディオレベルヘッダー拡張のシグナリングでの "vad"値の設定に影響を与えません. 

5.3. answerの生成
createAnswerが呼び出されると、提供されたリモート記述および[ID.ietf-rtcweb-rtp-usage]で指定された要件と互換性のある新しいSDP記述を作成する必要があります. このプロセスの正確な詳細を以下に説明します. 

5.3.1. 最初のanswer
リモートの説明が提供された後で初めてcreateAnswerが呼び出されたときの結果は、初期answerと呼ばれます. リモートの説明がインストールされていない場合、answerを生成することはできず、エラーを返す必要があります. 

リモート記述SDPはJSEPエンドポイントによって作成されていない可能性があり、セクション5.2にリストされているすべての要件に準拠していない可能性があることに注意してください. 多くの場合、これは問題ではありません. ただし、必須のSDP属性が欠落している場合、または上記の使用に必須としてリストされている機能が存在しない場合は、これをエラーとして扱い、影響を受けるm =セクションを拒否としてマークする必要があります. 

初期answerを生成する最初のステップは、セッションレベルの属性を生成することです. ここでのプロセスは、[ID.ietf-ice-trickle]のセクション3で指定されている "trickle"オプションを含む "a = ice-options"行を除いて、上記の最初のofferセクションで示したプロセスと同じです. 指定された「ice2」オプション

[RFC8445]のセクション10は、そのようなオプションがofferに存在する場合にのみ含まれます. 

次のステップは、[RFC5888]のセクション7で定義されているように、セッションレベルのリップシンクグループを生成することです. offerに存在する「LS」タイプの各グループについて、指定されたMID値によって参照されるローカルRtpTransceiversを選択しますグループ化し、共通のローカルMediaStream（それらを作成するために使用されるaddTrack / addTransceiverの呼び出しで指定）を参照するか、addTrack / addTransceiverによって作成されなかったために参照するMediaStreamを持たないかを決定します. そのようなRtpTransceiversが少なくとも2つ存在する場合、これらのRtpTransceiversの中間値を持つタイプ「LS」のグループを追加する必要があります. それ以外の場合、提供された「LS」グループは無視する必要があり、対応するグループはanswerで生成されません. 

簡単な例として、同じMediaStreamに含まれる単一のオーディオトラックと単一のビデオトラックの次のofferを検討してください. この例に関係のないSDP行は、明確にするために削除されています. セクション5.2で説明したように、各トラックのRtpTransceiverを参照する「LS」タイプのグループが追加されました. 

             a=group:LS a1 v1
             m=audio 10000 UDP/TLS/RTP/SAVPF 0
             a=mid:a1
             a=msid:ms1
             m=video 10001 UDP/TLS/RTP/SAVPF 96
             a=mid:v1
             a=msid:ms1

answer者がトラックを追加するときに単一のMediaStreamを使用する場合、その両方のトランシーバーがこのストリームを参照するため、次のanswerには、以下に示すように、offerのグループと同じ「LS」グループが含まれます. 

             a=group:LS a1 v1
             m=audio 20000 UDP/TLS/RTP/SAVPF 0
             a=mid:a1
             a=msid:ms2
             m=video 20001 UDP/TLS/RTP/SAVPF 96
             a=mid:v1
             a=msid:ms2
        
ただし、answerがそのトラックを個別のMediaStreamにグループ化すると、そのトランシーバーは異なるストリームを参照するため、後続のanswerには「LS」グループが含まれません. 

             m=audio 20000 UDP/TLS/RTP/SAVPF 0
             a=mid:a1
             a=msid:ms2a
             m=video 20001 UDP/TLS/RTP/SAVPF 96
             a=mid:v1
             a=msid:ms2b
        
最後に、answer者がトラックを追加しない場合、そのトランシーバーはMediaStreamsを参照しないため、提供者の設定が維持されるため、後続のanswerには同一の「LS」グループが含まれます. 

             a=group:LS a1 v1
             m=audio 20000 UDP/TLS/RTP/SAVPF 0
             a=mid:a1
             a=recvonly
             m=video 20001 UDP/TLS/RTP/SAVPF 96
             a=mid:v1
             a=recvonly

このドキュメントの後半のセクション7.2の例は、「LS」グループ生成のより複雑なケースを示しています. 

次のステップは、[RFC3264]のセクション6で指定されているように、リモートofferに存在する各m =セクションに対してm =セクションを生成することです. この説明の目的のために、offerのセッションレベル属性もメディアレベルの属性は各m =セクションに存在すると見なされるため、有効です. セクション5.10で説明されているように、提供される各m =セクションには、関連するRtpTransceiverがあります. m =セクションよりも多くのRtpTransceiversがある場合、一致しないRtpTransceiversを後続のofferで関連付ける必要があります. 

[RFC3264]のセクション6に示すように、提供される各m =セクションについて、以下の条件のいずれかに該当する場合、m =行のポートをゼロに設定することにより、answerの対応するm =セクションを拒否としてマークする必要があります.  、およびこのm =セクションの以降の処理はスキップできます. 

o関連するRtpTransceiverが停止されました. 

o提供されているメディア形式はいずれもサポートされておらず、該当する場合、コーデック設定で許可されています. 

oバンドルポリシーは「max-bundle」であり、これは最初のm =セクションまたは最初のm =セクションと同じバンドルグループ内ではありません. 

oバンドルポリシーは「バランス」であり、これはこのメディアタイプの最初のm =セクションまたはこのメディアタイプの最初のm =セクションと同じバンドルグループではありません. 

oこのm =セクションはバンドルグループにあり、グループの提供者のタグが付けられたm =セクションは、上記のいずれかの理由により拒否されています. これには、[ID.ietf-mmusic-sdp-bundle-negotiation]のセクション7.3.3で指定されているように、バンドルグループのすべてのm =セクションを拒否する必要があります. 

それ以外の場合、[RFC3264]のセクション6.1で指定されているように、answerの各m =セクションを生成する必要があります. m =行自体については、次の規則に従う必要があります. 

oポート値は通常、このm =セクションのデフォルトICE候補のポートに設定されますが、候補がまだ利用できない場合は、[に示すように、「ダミー」ポート値9（破棄）を使用する必要があります.  ID.ietf-ice-trickle]、セクション5.1. 

o <proto>フィールドは、offer内の対応するm =行の<proto>フィールドと完全に一致するように設定する必要があります. 

oコーデックの優先順位が関連するトランシーバーに設定されている場合、提供される内容に関係なく、対応する順序でメディアフォーマットを生成し、コーデックの優先順位にないコーデックを除外する必要があります. 

それ以外の場合、m =行のメディア形式は、現在サポートされていない形式を除いて、現在のリモート記述で提供されているものと同じ順序で生成する必要があります. 現在のリモート記述に存在しない現在利用可能なメディア形式は、すべての既存の形式の後に追加する必要があります. 

oどちらの場合も、answerのメディアフォーマットには、offerに存在するフォーマットを少なくとも1つ含める必要がありますが、[RFC3264]のセクション6.1で説明されているように、ローカルではサポートされているがofferには存在しないフォーマットを含めることができます. 共通フォーマットが存在しない場合、上記のようにm =セクションは拒否されます. 

[RFC4566]のセクション5.7で指定されているように、m =行の直後には "c ="行が続く必要があります. 繰り返しますが、候補者がいないため

[c. ]行には、[ID.ietf-ice-trickle]のセクション5.1で定義されている「ダミー」値「IN IP4 0.0.0.0」が含まれている必要があります. 

offerがバンドルをサポートしている場合、バンドルされるすべてのm =セクションは、同じICE資格情報と候補を使用する必要があります. バンドルされていないすべてのm =セクションは、一意のICE資格情報と候補を使用する必要があります. 各m =セクションには、次の属性が含まれている必要があります（IDENTICALおよびTRANSPORT以外の属性タイプです）. 

oofferに存在する場合に限り、[RFC5888]のセクション9.1で指定されている「a = mid」行. 「中間」の値は、offerで指定された値と一致する必要があります. 

o方向属性. [RFC3264]のセクション6.1で指定された提供方向に関するルールを適用し、関連するRtpTransceiverの方向と交差することによって決定されます. たとえば、m =セクションが「sendonly」として提供され、ローカルトランシーバーが「sendrecv」に設定されている場合、answerの結果は「recvonly」の方向になります. 

o [RFC4566]、セクション6、および[RFC3264]、セクション6.1で指定されている、m =行、「a = rtpmap」および「a = fmtp」行の各メディア形式. 

o「rtx」がofferに存在する場合、RTP再送信を使用する必要がある各プライマリコーデックについて、プライマリコーデックのクロックレートと「rtx」を示す対応する「a = rtpmap」行と「a = fmtp」行[RFC4588]のセクション8.1で指定されているように、プライマリコーデックのペイロードタイプを参照します. 

oサポートされているFECメカニズムごとに、[RFC4566]のセクション6で指定されている「a = rtpmap」および「a = fmtp」行. サポートされなければならないFECメカニズムは、[ID.ietf-rtcweb-fec]で指定されます. セクション6、および各メディアタイプの具体的な使用方法については、セクション4および5で概説しています. 

oこのm =セクションが、オーディオなど、パケットごとに構成可能なメディアの持続時間を持つメディア用である場合、セクション5.2で説明されているように、「a = maxptime」行. 

oこのm =セクションがビデオメディア用であり、デコードできる画像のサイズに既知の制限がある場合、セクション3.6で指定されている「a = imageattr」行. 

oofferに存在するサポートされている各RTPヘッダー拡張について、[RFC5285]のセクション5で指定されている「a = extmap」行. サポートされる必要があるヘッダー拡張のリストは、[ID.ietf -rtcweb-rtp-usage]、セクション5.2. ヘッダー

暗号化を必要とする拡張は、[RFC6904]、セクション4に示されているように指定する必要があります. 

oofferに含まれるサポートされているRTCPフィードバックメカニズムごとに、[a = rtcp-fb]行（[RFC4585]、セクション4.2で指定）. サポートする必要のあるRTCPフィードバックメカニズムのリストは、[ID.ietf-rtcweb-rtp-usage]のセクション5.1で指定されています. 

o RtpTransceiverにsendrecvまたはsendonlyの方向がある場合：

* addTrackまたはaddTransceiverを介して作成されたときにトランシーバーに関連付けられた各MediaStreamについて、[a.msid]行. [ID.ietf-mmusic-msid]のセクション2で指定されていますが、「appdata」フィールドは省略されています. 

別のm =セクションにバンドルされていない各m =セクションには、次の属性（IDENTICALまたはTRANSPORTカテゴリの属性）を含める必要があります. 

o [ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で指定されている「a = ice-ufrag」および「a = ice-pwd」行. 

[RFC8122]のセクション5で指定されているように、目的のダイジェストアルゴリズムごとに、エンドポイントの証明書ごとに1つ以上の「a = fingerprint」行. 

o [RFC4145]のセクション4で指定され、[RFC5763]のセクション5のDTLS-SRTPシナリオで使用するために明確化された「a = setup」行. answerの役割値は「アクティブ」または「パッシブ」である必要があります」JSEPエンドポイントで常にそうであるように、offerに「actpass」値が含まれている場合、answer者は「アクティブ」ロールを使用する必要があります（SHOULD）. 非JSEPエンドポイントからのofferは、「a = setup」の他の値を送信してもよい（MAY）. その場合、answerではoffer内の値と一致する値を使用する必要があります. 

o [ID.ietf-mmusic-dtls-sdp]のセクション5.3で指定されている「a = tls-id」行. 

oofferに存在する場合、[RFC5761]のセクション5.1.3で指定されている「a = rtcp-mux」行. それ以外の場合は、[RFC3605]のセクション2.1で指定されている「a = rtcp」行にダミー値「9 IN IP4 0.0.0.0」が含まれています（候補がまだ収集されていないため）. 

oofferに存在する場合、[RFC5506]のセクション5で指定されている「a = rtcp-rsize」行. 

データチャネルm =セクションが提供されている場合、am =セクションもデータ用に生成する必要があります. <media>フィールドは "application"に設定する必要があり、<proto>および<fmt>フィールドはoffer内のフィールドと完全に一致するように設定する必要があります. 

[ID.ietf-mmusic-]で定義されているように、データm =セクション内で、「a = mid」行を生成して、上記のようにSCTPポート番号を参照する「a = sctp-port」行とともに含める必要があります.  [ID.ietf-mmusic-sctp-sdp]、セクション6.1で定義されているように、sctp-sdp]、セクション5.1、および適切な場合は「a = max-message-size」行. 

上で説明したように、データID =セクションが別のm =セクションにバンドルされていない場合にのみ、カテゴリIDENTICALまたはTRANSPORTの次の属性が含まれます. 

o「a = ice-ufrag」

o「a = ice-pwd」

o「a = fingerprint」

o「a = setup」

o「a = tls-id」

メディアm =セクションがデータm =セクションにバンドルされている場合、特定のTRANSPORTおよびIDENTICAL属性は、メディアm =セクションにのみ適切である場合でも、データm =セクションに表示される場合があります（例： "a = rtcp-mux」）. 

「BUNDLE」のセマンティクスを持つ「a = group」属性が提供される場合、対応するセッションレベルの「a = group」属性を[RFC5888]で指定されているとおりに追加する必要があります. これらの属性はセマンティクス「BUNDLE」を持つ必要があり、拒否されていない、提供されたバンドルグループからのすべての中間識別子を含める必要があります. offerに「a = bundle-only」が存在するかどうかに関係なく、answerのm =セクションに「a = bundle-only」の行があってはならないことに注意してください. 

すべてのm =セクション間で共通の属性は、セッションレベルで有効であると明示的に定義されている場合、セッションレベルに移動できます. 

offerの作成で禁止されている属性は、answerの作成でも禁止されています. 

5.3.2. 後続のanswer
createAnswerが2回目（またはそれ以降）に呼び出される場合、またはローカルの説明が既にインストールされた後に呼び出される場合、処理は最初のanswerの場合とは多少異なります. 

以前のanswerがsetLocalDescriptionを使用して適用されなかった場合、つまりPeerConnectionがまだ「have-remote-offer」状態にある場合、次の制限に従って、最初のanswerを生成する手順に従う必要があります. 

o「o =」行のフィールドは、<session-version>フィールドを除いて同じままにする必要があります. これは、セッションの説明が以前に生成されたanswerから何らかの方法で変更された場合に増加する必要があります. 

以前にsetLocalDescriptionにセッションの説明が提供されていた場合、上記の「have-remote-offer」状態の手順に従って、以下の例外とともにanswerが生成されます. 

o "s ="と "t ="の行は同じでなければなりません. 

o [ID.ietf-mmusic-ice-sip-sdp]のセクション3.2で説明されているように、各 "m ="およびc = "行には、m =セクションのデフォルト候補のポートとアドレスを入力する必要があります.  1.2. 上記のように、m =ラインプロトコル値はofferで提供された値と一致する必要があるため、特定のケースでは、m =ラインプロトコルがデフォルト候補のプロトコルと一致しない場合があることに注意してください. 

o「a = ice-ufrag」および「a = ice-pwd」の各行は、m =セクションが再起動しない限り同じままにする必要があります. その場合、[ID.ietf-mmusic- ice-sip-sdp]、セクション3.4.1.1.1. m =セクションが別のm =セクションにバンドルされている場合でも、ICE資格情報を含めることはできません. 

o各「a = tls-id」行は、提供者の「a = tls-id」行が変更されない限り同じままにする必要があります. その場合、[ID. で説明されているように、新しい「a = tls-id」値を作成する必要があります.  ietf-mmusic-dtls-sdp]、セクション5.2. 

o各「a = setup」行は、関連付けが提供者によって継続されている場合、既存のDTLS関連付けと一致する「アクティブ」または「パッシブ」の役割値を使用する必要があります. 

o RTCP多重化を使用する必要があり、m =セクションが以前にRTCP多重化を使用した場合にのみ、「a = rtcp-mux」行を挿入します. 

o m =セクションが別のm =セクションにバンドルされておらず、RTCP多重化がアクティブでない場合、「a = rtcp」属性行にデフォルトのRTCP候補のポートとアドレスを入力する必要があります. 上記の最初のanswerセクションで説明したように、RTCP候補がまだ収集されていない場合は、ダミー値を使用する必要があります. 

o m =セクションが別のm =セクションにバンドルされていない場合、最新の収集フェーズ（セクション3.5.1を参照）で収集された候補ごとに、「a = candidate」行を追加する必要があります.  [ID.ietf-mmusic-ice-sip-sdp]、セクション4.1. [ID.ietf-ice-trickle]のセクション9.3で説明されているように、セクションの候補者の収集が完了した場合は、「a = end-of-candidates」属性を追加する必要があります. m =セクションが別のm =セクションにバンドルされている場合、「a = candidate」と「a = end-of-candidates」の両方を省略しなければなりません. 

o停止されていないRtpTransceiversの場合、トランシーバーの方向またはトラックの変更に関係なく、「a = msid」行は同じままである必要があります. 「a = msid」行が現在の説明に存在しない場合、「a = msid」行は、最初のanswerと同じ規則に従って生成される必要があります. 

5.3.3. オプションの取り扱い
createAnswerメソッドは、RTCAnswerOptionsオブジェクトをパラメーターとして受け取ります. RTCAnswerOptionsのパラメータセットは、RTCOfferOptionsでサポートされているものとは異なります. 提供者がICEの再起動を選択したすべてのm =セクションのICE資格情報が自動的に変更されるため、IceRestartオプションは不要です. 

RTCAnswerOptionsでは、次のオプションがサポートされています. 

5.3.3.1. VoiceActivityDetection
answerの無音抑止はセクション5.2.3.2で説明されているように処理されますが、1つの例外があります. 無音抑止のサポートがofferに示されていない場合、VoiceActivityDetectionパラメータは効果がなく、VoiceActivityDetectionが次のように設定されているかのように応答が生成されます. 偽. これはコーデックごとに行われます（たとえば、提供者が何らかの方法でCNのサポートを提供したがOpusに "usedtx = 0"を設定した場合、VoiceActivityDetectionをtrueに設定すると、CNコーデックと "usedtx = 0"で応答が返されます）. このルールの影響は、応答者が無音抑制を提供しないエンドポイントで無音抑制を使用しようとしないことです. JSEP以外のエンドポイントでも、無音抑制が双方向でサポートされます. 

5.4. offerまたはanswerの変更
createOfferまたはcreateAnswerから返されたSDPは、setLocalDescriptionに渡す前に変更してはなりません. SDPを正確に制御する必要がある場合は、前述のcreateOffer / createAnswerオプションまたはRtpTransceiver APIを使用する必要があります. 

offerまたはanswerを使用してsetLocalDescriptionを呼び出した後、有効なJSEPofferまたはanswerを定義する上記のルールに従う限り、アプリケーションはSDPを変更して機能を削減してから、相手側に送信することができます. 同様に、ピアからofferまたは応答を受け取ったアプリケーションは、setRemoteDescriptionを呼び出す前に、同じ制約に従って、受信したSDPを変更できます（MAY）. 

いつものように、アプリケーションは相手に送信するものに対して単独で責任があり、すべての着信SDPはJSEP実装によってその機能の範囲で処理されます. すべてのSDPが整形式であると想定するのは誤りです. ただし、この仕様の実装では、リモートofferまたはanswerとして、この仕様の他の実装からの未変更のSDPを処理できると想定できるはずです. 

5.5. ローカル記述の処理
SessionDescriptionがsetLocalDescriptionに提供される場合、次の手順を実行する必要があります. 

o説明が「ロールバック」タイプの場合は、セクション5.7で定義されている処理に従い、このセクションの残りの部分で説明されている処理をスキップします. 

それ以外の場合、SessionDescriptionのタイプは、PeerConnectionの現在の状態に対してチェックされます. 

*タイプが「offer」の場合、PeerConnectionの状態は「stable」または「have-local-offer」でなければなりません. 

*タイプが「pranswer」または「answer」の場合、PeerConnection状態は「have-remote-offer」または「have-local-pranswer」である必要があります. 

oタイプが現在の状態に対して正しくない場合、処理を停止し、エラーを返す必要があります. 

o次に、SessionDescriptionがチェックされ、その内容が最後のcreateOffer / createAnswerの呼び出しで生成されたものと同一であることが確認されます. 

セクション5.4; それ以外の場合、処理は停止する必要があり、エラーが返される必要があります. 

o次に、以下のセクション5.8で説明するように、SessionDescriptionがデータ構造に解析されます. 

o最後に、解析されたSessionDescriptionがセクション5.9で説明されているように適用されます. 

5.6. リモート記述の処理
SessionDescriptionがsetRemoteDescriptionに提供される場合、次の手順を実行する必要があります. 

o説明が「ロールバック」タイプの場合は、セクション5.7で定義されている処理に従い、このセクションの残りの部分で説明されている処理をスキップします. 

それ以外の場合、SessionDescriptionのタイプは、PeerConnectionの現在の状態に対してチェックされます. 

*タイプが「offer」の場合、PeerConnectionの状態は「stable」または「have-remote-offer」でなければなりません. 

*タイプが「pranswer」または「answer」の場合、PeerConnection状態は「have-local-offer」または「have-remote-pranswer」である必要があります. 

oタイプが現在の状態に対して正しくない場合、処理を停止し、エラーを返す必要があります. 

o次に、以下のセクション5.8で説明するように、SessionDescriptionがデータ構造に解析されます. 何らかの理由で解析が失敗した場合は、処理を停止し、エラーを返す必要があります. 

o最後に、以下のセクション5.10で説明されているように、解析されたSessionDescriptionが適用されます. 

5.7. ロールバックの処理
PeerConnectionが「安定」以外の状態の場合、ロールバックが実行される可能性があります. これは、fersと暫定answerの両方をロールバックできることを意味します. ロールバックは、offerされた変更をキャンセルするためにのみ使用できます. 安定状態から以前の安定状態へのロールバックはサポートされていません. 「安定」状態でロールバックが試行された場合、処理は停止しなければならず、エラーが返されなければなりません（MUST）. これは、answer者が自分のanswerでsetLocalDescriptionを実行すると、ロールバックできないことを意味することに注意してください. 

ロールバックの効果は、setLocalDescriptionとsetRemoteDescriptionのどちらが呼び出されたかに関係なく同じでなければなりません. 

JSEP実装は、ロールバックを処理するために、現在のoffer/answerトランザクションを破棄し、シグナリング状態を「安定」に設定し、保留中のローカルまたはリモートの説明（あるいはセクション4.1.12およびセクション4.1.14を参照）をnullに設定します.  . 放棄されたローカル記述によって割り当てられたリソースまたは候補は破棄されます. 受信したメディアはすべて、以前のローカルおよびリモートの説明に従って処理されます. 

ロールバックは、ロールバックされたセッション記述の適用によってm =セクションに関連付けられたRtpTransceiversの関連付けを解除します（セクション5.10およびセクション5.9を参照）. これは、以前関連付けられていた一部のRtpTransceiversがm =セクションに関連付けられなくなることを意味します. このような場合、RtpTransceiverのmidプロパティの値をnullに設定する必要があり、トランシーバーとそのm =セクションインデックス間のマッピングを破棄する必要があります. その後ロールバックされたリモートofferを適用して作成されたRtpTransceiversを停止し、PeerConnectionから削除する必要があります. ただし、トラックがaddTrackメソッドを介してRtpTransceiverに接続されている場合は、RtpTransceiverを削除してはなりません（MUST NOT）. これは、アプリケーションがaddTrackを呼び出し、次にofferを指定してsetRemoteDescriptionを呼び出し、そのofferをロールバックするためです. 

5.8 セッションの説明の解析
セッション記述オブジェクトに含まれるSDPは、[RFC4566]のセクション5で説明されているように、それぞれがKey-Value論理式を含む一連のテキスト行で構成されています. SDPが1行ずつ読み込まれ、データに変換されます. 逆シリアル化された情報を含む構造. ただし、SDPは多くのタイプの回線を許可しますが、そのすべてがJSEPアプリケーションに関連しているわけではありません. 各行について、実装はまず、定義するABNFに従って構文的に正しいことを確認し、[RFC4566]および[RFC3264]セマンティクスに準拠していることを確認してから、以下に説明するように、提供された値を解析して保存または破棄します. 

いずれかの行が整形式でない場合、または説明されているように解析できない場合、値が破棄される場合でも、パーサーはエラーで停止し、セッションの説明を拒否する必要があります. これにより、実装があいまいなSDPを誤って誤って解釈することがなくなります. 

5.8.1. セッションレベルの解析
まず、セッションレベルの行がチェックされ、解析されます. これらの行は、[RFC4566]のセクション5で定義されているように、特定の順序で、特定の構文で発生する必要があります. ただし、特定の行タイプ（例： "v ="、 "c ="）は定義された順序で発生する必要があります.  、同じタイプの行（通常は "a ="）は任意の順序で出現できます. 

次の非属性行はJSEPコンテキストでは意味がなく、一度チェックされると破棄される場合があります. 

「c =」行の構文をチェックする必要がありますが、その値は、[RFC8445]のセクション5.4で定義されているように、ICEの不一致検出にのみ使用されます. WebRTCにはICEが必要なため、JSEPの実装ではこの条件が発生することはありません. 

"i ="、 "u ="、 "e ="、 "p ="、 "t ="、 "r ="、 "z ="、および "k ="行は、この仕様では使用されません. 構文をチェックする必要がありますが、値は使用されません. 

残りの非属性行は次のように処理されます. 

[RFC4566]のセクション5.1で指定されているように、「v =」行にはバージョン0が必要です. 

「o =」行は、[RFC4566]のセクション5.2で指定されているように解析する必要があります. 

「b =」行が存在する場合は、[RFC4566]のセクション5.8で指定されているとおりに解析し、保存されているbwtypeと帯域幅の値を指定する必要があります. 

最後に、属性行が処理されます. 次のセッションレベルの属性（ "a ="）行には、特定の処理を適用する必要があります. 

o [a = group]行は、[RFC5888]、セクション5で指定されているように解析され、グループのセマンティクスとmidが保存されます. 

o存在する場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.3で指定されているように1つの「a = ice-lite」行が解析され、ice-liteの存在を示す値が格納されます. 

o存在する場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で指定されているように単一の「a = ice-ufrag」行が解析され、ufrag値が保存されます. 

o存在する場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で指定されているように単一の「a = ice-pwd」行が解析され、パスワード値が保存されます. 

o存在する場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.6で指定されているように単一の「a = ice-options」行が解析され、指定されたオプションのセットが保存されます. 

o [a = fingerprint]行は、[RFC8122]、セクション5で指定されているように解析され、フィンガープリントとアルゴリズム値のセットが保存されます. 

o存在する場合、単一の「a = setup」行が[RFC4145]、セクション4で指定されているように解析され、設定値が保存されます. 

o存在する場合、[ID.ietf-mmusic-dtls-sdp]セクション5で指定されているように単一の「a = tls-id」行が解析され、tls-id値が保存されます. 

o「a = identity」行が解析され、指定された[ID.ietf-rtcweb-security-arch]のセクション5に示すように、ID値が後続の検証のために保存されます. 

o「a = extmap」行は、[RFC5285]、セクション5で指定されているように解析され、それらの値が保存されます. 

JSEPに関連しない他の属性も存在する可能性があり、実装はそれらが認識するものを処理する必要があります（SHOULD）. [RFC4566]のセクション5.13で要求されているように、不明な属性行は無視する必要があります. 

すべてのセッションレベルの行が解析されると、処理はm =セクションの行から続行されます. 

5.8.2. メディアセクションの解析
セッションレベルの行と同様に、メディアセクションの行は特定の順序で、[RFC4566]のセクション5で定義されている特定の構文で発生する必要があります. 

「m =」行自体は、[RFC4566]のセクション5.14で説明されているように解析されなければならず、メディア、ポート、プロト、およびfmtの値が格納されます. 

「m =」行に続いて、次の非属性行に特定の処理を適用する必要があります. o「c =」行と同様に、「c =」行は[RFC4566]に従って解析する必要があります. セクション5.7. ただし、その値は使用されません. 

o「b =」行が存在する場合は、[RFC4566]のセクション5.8で指定されているとおりに解析し、bwtypeと帯域幅の値を保存する必要があります. 

以下の属性行にも特定の処理を適用する必要があります. 

o存在する場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で指定されているように単一の「a = ice-ufrag」行が解析され、ufrag値が保存されます. 

o存在する場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で指定されているように単一の「a = ice-pwd」行が解析され、パスワード値が保存されます. 

o存在する場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.6で指定されているように単一の「a = ice-options」行が解析され、指定されたオプションのセットが保存されます. 

o「a = candidate」属性は、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.1で指定されているとおりに解析し、それらの値を保存する必要があります. 

o「a = remote-candidates」属性は、[ID.ietf-mmusic-ice-sip-sdp]のセクション4.2で指定されているように解析する必要がありますが、それらの値は無視されます. 

o存在する場合、単一の「a = end-of-candidates」属性は、[ID.ietf-ice-trickle]、セクション8.2で指定されているように解析し、その存在または不在にフラグを立てて保存する必要があります. 

o [a = fingerprint]行は、[RFC8122]、セクション5で指定されているように解析され、フィンガープリントとアルゴリズム値のセットが保存されます. 

上記のセクション5.1.2で説明されているように、「m = proto値がRTPの使用を示している場合、次の属性行を処理する必要があります. 

o "m =" fmt値は、[RFC4566]のセクション5.14で指定されているように解析され、保存されている個々の値でなければなりません. 

o「a = rtpmap」または「a = fmtp」行は、[RFC4566]、セクション6で指定されているように解析し、それらの値を保存する必要があります. 

o存在する場合、[RFC4566]のセクション6で説明されているように、単一の「a = ptime」行を解析し、その値を格納する必要があります. 

o存在する場合、[RFC4566]、セクション6で説明されているように、単一の「a = maxptime」行を解析し、その値を格納する必要があります. 

o存在する場合、[RFC4566]、セクション6で説明されているように、単一の方向属性行（「a = sendrecv」など）を解析し、その値を保存する必要があります. 

o [a = ssrc]属性は、[RFC5576]、セクション4.1で指定されているように解析し、それらの値を格納する必要があります. 

o [a = extmap]属性は、[RFC5285]のセクション5に指定されているとおりに解析し、それらの値を保存する必要があります. 

o「a = rtcp-fb」属性は、[RFC4585]、セクション4.2で指定されているように解析し、それらの値を保存する必要があります. 

o存在する場合、単一の「a = rtcp-mux」属性は、[RFC5761]のセクション5.1.3で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります. 

o存在する場合、単一の「a = rtcp-mux-only」属性は、[ID.ietf-mmusic-mux-exclusive]、セクション3で指定されているように解析し、その存在または不在にフラグを付けて保存する必要があります. 

o存在する場合、単一の「a = rtcp-rsize」属性は、[RFC5506]、セクション5で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります. 

o存在する場合、単一の「a = rtcp」属性は、[RFC3605]、セクション2.1で指定されているように解析する必要がありますが、ICEを使用する場合、この情報は不要であるため、その値は無視されます. 

o存在する場合、「a = msid」属性は、[ID.ietf-mmusic-msid]、セクション3.2で指定されているように解析され、その値が格納され、「appdata」フィールドは無視されます. 「a = msid」属性が存在しない場合、セッションの「デフォルト」のMediaStreamに対してランダムなmsid-id値が生成されます（まだ存在しない場合）. この値は保存されます. 

o [a = imageattr]属性は、[RFC6236]、セクション3で指定されているように解析し、それらの値を保存する必要があります. 

o「a = rid」行は、[ID.ietf-mmusic-rid]、セクション10に指定されているとおりに解析し、それらの値を保存する必要があります. 

o存在する場合、[ID.ietf-mmusic-sdp-simulcast]で指定されているように単一の「a = simulcast」行を解析し、その値を保存する必要があります. 

それ以外の場合、「m = proto値がSCTPの使用を示している場合、次の属性行を処理する必要があります. 

o "m =" fmt値は、[ID.ietf-mmusic-sctp-sdp]のセクション4.3で指定されているように解析し、アプリケーションプロトコル値を格納する必要があります. 

o「a = sctp-port」属性が存在する必要があり、[ID.ietf-mmusic-sctp-sdp]、セクション5.2、および格納されている値で指定されているように解析する必要があります. 

o存在する場合、単一の「a = max-message-size」属性は、[ID.ietf-mmusic-sctp-sdp]、セクション6、および格納された値で指定されているように解析する必要があります. それ以外の場合は、指定されたデフォルトを使用します. 

JSEPに関連しない他の属性も存在する可能性があり、実装はそれらが認識するものを処理する必要があります（SHOULD）. [RFC4566]のセクション5.13で要求されているように、不明な属性行は無視する必要があります. 

5.8.3. セマンティクス検証
解析が正常に完了したと仮定すると、解析された記述が評価され、内部の整合性と必須機能の適切なサポートが保証されます. 具体的には、次のチェックが実行されます. 

o各m =セクションに対して、セクション5.1.1に列挙されている各使用必須機能の有効な値が存在している必要があります. これらの値は、メディアレベルで存在するか、セッションレベルから継承される場合があります. 

* ICE ufragとパスワードの値. [ID.ietf-mmusic-ice-sip-sdp]のセクション4.4で指定されたサイズ制限に準拠する必要があります. 

* tls-id値. [ID.ietf-mmusic-dtls-sdp]のセクション5に従って設定する必要があります. これが再提供者または再提供者への応答であり、tls-id値が異なる場合現在使用されているものから、DTLS接続は継続されておらず、リモートの説明は、新しいufragとパスワードの値とともに、ICEの再起動の一部である必要があります. 

* DTLS設定値. これは、[RFC5763]、セクション5で指定されたルールに従って設定する必要があり、一貫している必要があります. 

現在のDTLS接続の選択された役割（存在し、継続されている場合）. 

* DTLSフィンガープリント値. 少なくとも1つのフィンガープリントが存在する必要があります. 

o「a = simulcast」行で参照されるすべてのRID値は、「a = rid」行として存在する必要があります. 

o各m =セクションもチェックされ、禁止されている機能が使用されていないことを確認します. 

o RTP / RTCP多重化ポリシーが「必須」の場合、各m =セクションに「a = rtcp-mux」属性を含める必要があります. m =セクションに「a = rtcp-mux-only」属性が含まれている場合、そのセクションには「a = rtcp-mux」属性も含まれている必要があります. 

o前のanswerにm =セクションが存在した場合、RTP / RTCP多重化の状態は、以前にネゴシエートされたものと一致する必要があります. 

このセッションの説明のタイプが「pranswer」または「answer」の場合、次の追加のチェックが適用されます. 

oセッションの説明は、[RFC3264]のセクション6で定義されているルールに従う必要があります. これには、m =セクションの数が、関連するofferのm =セクションの数と正確に一致する必要があるという要件が含まれます. 

o m =セクションごとに、メディアタイプとプロトコル値は、関連するofferの対応するm =セクションのメディアタイプとプロトコル値と正確に一致する必要があります. 

上記のチェックのいずれかが失敗した場合、処理を停止し、エラーを返す必要があります. 

5.9. ローカルの説明の適用
次の手順は、メディアエンジンレベルで実行され、ローカルの説明を適用します. エラーが返された場合、セッションはこれらの手順を実行する前の状態に復元する必要があります. 

最初に、m =セクションが処理されます. 各m =セクションについて、次の手順を実行する必要があります. パラメータが範囲外の場合、または適用できない場合は、処理を停止し、エラーを返す必要があります. 

oこのm =セクションが新しい場合は、[RFC8445]、セクション5.1.1で定義されているように、セクションの候補の収集を開始します. 

バンドルされている（これはofferであり、m =セクションはバンドルのみとマークされているか、answerであり、m =セクションは別のm =セクションにバンドルされています. ）

oまたは、ICE ufragとパスワードの値が変更された場合は、ICEエージェントをトリガーして、[RFC8445]のセクション9の説明に従ってICEの再起動を開始し、m =セクションの新しい候補の収集を開始します. この説明が答えである場合は、そのメディアセクションのチェックも開始します. 

o m =セクションのプロト値がRTPの使用を示している場合：

*このm =セクションに関連付けられているRtpTransceiverがない場合は、RtpTransceiverを見つけて、次の手順に従ってこのm =セクションに関連付けます. この状況は、offerを適用するときにのみ発生することに注意してください. 

+offerの作成時に確立されたトランシーバーとm =セクションインデックス間のマッピングを使用して、このm =セクションに対応するRtpTransceiverを見つけます. 

+このRtpTransceiverのmidプロパティの値をm =セクションのMIDに設定します. 

* RTCP muxが示されている場合は、[RFC5761]のセクション5.1.3で指定されているように、RTP ICEコンポーネントからRTPおよびRTCPをデマルチプレクサする準備をします. 

*指定された各RTPヘッダー拡張について、[RFC5285]のセクション6で説明されているように、拡張IDとURIの間のマッピングを確立します. 

* MIDヘッダー拡張がサポートされている場合、[ID.ietf-mmusic-sdp-bundle-negotiation]のセクション15で説明されているように、MIDヘッダー拡張に基づいて、このm =セクション向けのRTPストリームをデマルチプレクサする準備をします. 

*指定された各メディア形式について、[RFC3264]、セクション6.1で説明されているように、ペイロードタイプと実際のメディア形式の間のマッピングを確立します. さらに、[ID.ietf-mmusic-sdp-bundle-negotiation]のセクション10.2で説明されているように、このm =セクションでサポートされているメディアフォーマットに基づいて、このm =セクション向けのRTPストリームをデマルチプレクサする準備をします. 

* [RFC4588]のセクション8.6および8.7で説明されているように、指定された「rtx」メディアフォーマットごとに、RTXペイロードタイプとそれに関連付けられたプライマリペイロードタイプ間のマッピングを確立します. 

*方向属性が「sendrecv」または「recvonly」タイプの場合、メディアの受信とデコードを有効にします. 

最後に、この説明のタイプが「pranswer」または「answer」の場合、以下のセクション5.11で定義されている処理に従います. 

5.10. リモート説明の適用
リモートの説明を適用するには、次の手順を実行します. エラーが返された場合、セッションはこれらの手順を実行する前の状態に復元する必要があります. 

answerに「trickle」が属性としてリストされている「a = ice-options」属性が含まれている場合は、PeerConnection canTrickleプロパティをtrueに更新します. それ以外の場合は、このプロパティをfalseに設定します. 

次の手順は、セッションレベルの属性に対して実行する必要があります. パラメータが範囲外の場合、または適用できない場合は、処理を停止し、エラーを返す必要があります. 

o [RFC4566]のセクション5.8で指定されているように、指定された「CT」帯域幅値に対して、これをすべてのm =セクションの最大合計ビットレートの制限として設定します. この全体的な制限内で、実装は、個々のm =セクションに指定されている特定の制限を考慮して、m =セクション間で利用可能な帯域幅を最適に割り当てる方法を動的に決定できます. 

o指定された「RR」または「RS」の帯域幅値については、[RFC3556]、セクション2で指定されているように処理します. 

o「AS」帯域幅の値は、セッションレベルでのこの構成の意味が十分に定義されていないため、無視する必要があります. 

各m =セクションについて、次の手順を実行する必要があります. パラメータが範囲外の場合、または適用できない場合は、処理を停止し、エラーを返す必要があります. 

o ICE ufragまたはパスワードが以前のリモート記述から変更された場合：

*説明が「offer」タイプの場合、[ID.ietf-mmusic-ice-sip-sdp]のセクション3.4.1.1.1で説明されているように、実装はICEの再起動が必要であることを注記する必要があります. 

*説明のタイプが「answer」または「pranswer」の場合、現在のローカルの説明がICEの再起動であるかどうかを確認し、そうでない場合はエラーを生成します. PeerConnection状態が「have-remote-pranswer」で、ICE ufragまたはパスワードが以前の暫定answerから変更された場合、m =セクションの以前のICEチェックリスト状態を破棄するようにICEエージェントに通知します. 最後に、チェックを開始するようにICEエージェントに通知します. 

o現在のローカルの説明がICEの再起動を示し、ICE ufragまたはパスワードが以前のリモートの説明から変更されていない場合、[RFC8445]のセクション9で規定されているように、エラーが生成されます. 

oこのメディアセクションに関連付けられているICEコンポーネントを構成して、提供されているICEリモートufragとパスワードを使用して接続を確認します. 

o [RFC8445]、セクション6.1.2で説明されているように、提供されたICE候補と収集されたローカル候補をペアリングし、適切な資格情報で接続チェックを開始します. 

o「a = end-of-candidates」属性が存在する場合は、[ID.ietf-ice-trickle]のセクション11で説明されているように、候補の終わりの表示を処理します. 

o m =セクションのプロト値がRTPの使用を示している場合：

* m =セクションがリサイクルされている場合（セクション5.2.2を参照）、midプロパティをnullに設定して現在関連付けられているRtpTransceiverの関連付けを解除し、トランシーバーとそのm =セクションインデックス間のマッピングを破棄します. 

* m =セクションがRtpTransceiverに関連付けられていない場合（おそらく前のステップで関連付けが解除されたため）、RtpTransceiverを見つけるか、次の手順に従って作成します. 

+ m =セクションがsendrecvまたはrecvonlyであり、addTrackによってPeerConnectionに追加され、どのm =セクションにも関連付けられておらず、停止されていない同じタイプのRtpTransceiversがある場合、最初を見つけます（正規の順序に従って）セクション5.2.1で説明）このようなRtpTransceiver. 

+前の手順でRtpTransceiverが見つからなかった場合は、recvonly方向のRtpTransceiverを作成します. 

+ RtpTransceiverのmidプロパティの値をm =セクションのMIDに設定して、検出または作成したRtpTransceiverをm =セクションに関連付け、トランシーバーとm =セクションのインデックス間のマッピングを確立します. m =セクションにMIDが含まれていない場合（つまり、リモートエンドポイントがMID拡張をサポートしていない場合）、セクション5.2.1で説明されている "a = mid"のガイダンスに従って、RtpTransceiver midプロパティの値を生成します. 

*ローカル実装でもサポートされている指定されたメディア形式ごとに、[RFC3264]のセクション6.1で説明されているように、指定されたペイロードタイプとメディア形式の間のマッピングを確立します. 具体的には、これは、指定された各メディアフォーマットを送信するときに発信RTPパケットで使用されるペイロードタイプと、順序で示される各フォーマットの相対的な優先度を実装が記録することを意味します. 指定されたメディア形式がローカル実装でサポートされていない場合は、無視する必要があります. 

* [RFC4588]のセクション4で説明されているように、指定された「rtx」メディアフォーマットごとに、RTXペイロードタイプとそれに関連付けられたプライマリペイロードタイプ間のマッピングを確立します. 参照されるプライマリペイロードタイプが存在しない場合、これにより、エラー. RTXペイロードタイプは、ローカルメディア実装でサポートされていないプライマリペイロードタイプを参照する場合があることに注意してください. この場合、RTXペイロードタイプも無視する必要があります. 

*ローカル実装でサポートされている指定されたfmtpパラメータごとに、関連するメディア形式でそれらを有効にします. 

* [ID.ietf-mmusic-sdp-bundle-negotiation]のセクション10.2で説明されているように、m =セクションで通知される指定された各SSRCについて、そのSSRCを使用してこのm =セクション向けのRTPストリームをデマルチプレクサする準備をします. 

*ローカル実装でもサポートされている指定された各RTPヘッダー拡張について、[RFC5285]のセクション5で説明されているように、拡張IDとURIの間のマッピングを確立します. 具体的には、実装は使用する拡張IDを記録します指定された各ヘッダー拡張を送信するときの発信RTPパケット. 示されたRTPヘッダー拡張がローカル実装でサポートされていない場合は、無視する必要があります. 

*ローカル実装でサポートされている指定された各RTCPフィードバックメカニズムについて、関連するメディアフォーマットで有効にします. 

*指定された「TIAS」帯域幅値の場合、この値を、[RFC3890]で指定されているように、メディアの送信時に使用される最大RTPビットレートの制約として設定します. 「TIAS」値は存在しないが「AS」値が指定されている場合は、次の式を使用して「TIAS」値を生成します. 

         TIAS = AS * 1000 * 0.95-（50 * 40 * 8）
        
50は1秒あたりの50パケットに基づいており、40は合計ヘッダーサイズの推定に基づいており、1000は単位をkbpsからbpsに変更し（TIASでの必要に応じて）、0.95は5％をRTCPに割り当てることです. 「TIAS」は帯域幅をより正確に制御できるため、「AS」よりも優先的に使用されます. 

*「RR」または「RS」の帯域幅値については、[RFC3556]、セクション2で指定されているとおりに処理します. 

*メディアレベルでのこの構成の意味が十分に定義されていないため、指定された「CT」帯域幅値は無視する必要があります. 

* m =セクションがオーディオタイプの場合：

+指定された「CN」メディアフォーマットごとに、[RFC3389]のセクション5で説明されているように、サポートされているすべてのメディアフォーマットに対して同じクロックレートで無音圧縮を設定します. ただし、独自の内部無音圧縮メカニズムを持つフォーマットは除きます. セクション5.2.3.2で説明されているように、このようなフォーマット（Opusなど）の無音圧縮は、fmtpパラメータを介して制御されます. 

+ [RFC4733]のセクション2.5.1.2で説明されているように、指定された「telephone-event」メディアフォーマットごとに、サポートされているすべてのメディアフォーマットで同じクロックレートのDTMF送信を有効にします. 対応する電話イベント形式がないサポートされているメディア形式がある場合は、それらの形式のDTMF送信を無効にします. 

+指定された「ptime」値の場合、送信時に指定されたパケットサイズを使用するように利用可能なメディアフォーマットを設定します. 指定したサイズがメディア形式でサポートされていない場合は、代わりに次に近い値を使用してください. 

最後に、この説明のタイプが「pranswer」または「answer」の場合、以下のセクション5.11で定義されている処理に従います. 

5.11. answerの適用
ローカルまたはリモートの説明を処理するための上記のステップに加えて、タイプ「pranswer」または「answer」の説明を処理するときに、次のステップが実行されます. 

各m =セクションについて、次の手順を実行する必要があります. 

o m =セクションが拒否された場合（つまり、応答でポートがゼロに設定されている場合）、このセクションのメディアの受信または送信を停止し、拒否されなかったm =セクションがこのm =セクションにバンドルされていない限り、 [ID.ietf-mmusic-ice-sip-sdp]のセクション3.4.3.1で説明されているように、関連するICEコンポーネントを破棄します. 

oリモートDTLSフィンガープリントが変更された場合、またはtls-idが変更された場合は、DTLS接続を切断します. これには、PeerConnection状態が「have-remote-pranswer」である場合が含まれます. DTLS接続を切断する必要があるが、answerがICEの再起動を示していない場合、または「have-remote-pranswer」の場合は新しいICE資格情報の場合、エラーを生成する必要があります. tls-idまたはフィンガープリントを変更せずにICEの再起動を実行すると、同じDTLS接続が新しいICEチャネルで継続されます. JSEPは、offer提供者が変更した場合に限り、answer者がtls-id値を変更することを要求しますが、JSEP以外のanswer者は、offerにICE再起動が含まれている限り、tls-idを変更できます. したがって、

o有効なDTLS接続が存在しない場合は、基盤となるICEコンポーネントがアクティブになると、指定されたロールとフィンガープリントを使用して、DTLS接続を開始する準備をします. 

o m =セクションのプロト値がRTPの使用を示している場合：

* m =セクションがofferの対応するm =セクションに存在しなかったRTCPフィードバックメカニズムを参照している場合、これはネゴシエーションの問題を示し、エラーが発生する必要があります. ただし、[RFC3264]、セクション7、および[RFC5285]、セクション6で説明されているように、新しいメディアフォーマットと新しいRTPヘッダー拡張値はanswerで許可されます. 

* m =セクションでRTCPマルチプレクサが有効になっている場合、RTCP ICEコンポーネントが存在する場合は破棄し、[RFC5761]のセクション5.1.3で指定されているように、RTP ICEコンポーネントを介してRTCPのマルチプレクサ化を開始または続行します. それ以外の場合は、RTCPを

RTCP ICEコンポーネント. RTCPマルチプレクサが以前に有効にされていたため、RTCP ICEコンポーネントが存在しない場合、これはエラーになる必要があります. 

* m =セクションで縮小サイズのRTCPが有効になっている場合、[RFC5506]で指定されているように、このm =セクションのRTCP送信が縮小サイズのRTCPを使用するように構成します. 

* JSEP実装がメディアを送信する必要があることをanswerの方向属性が示す場合（ローカルanswerの場合は「sendonly」、リモートanswerの場合は「recvonly」、どちらのタイプのanswerの場合も「sendrecv」）、送信するメディア形式を選択します[RFC3264]のセクション6.1と7で説明されているように、ローカルでサポートされているリモート記述からの最も好ましいメディアフォーマット. 基盤となるトランスポート層が確立されると、そのフォーマットを使用してRTPメディアの送信を開始します. この発信RTPストリームにSSRCがまだ選択されていない場合は、ランダムに選択してください. メディアがすでに送信されている場合は、新しいコーデックのクロックレートが異なる場合を除いて同じSSRCを使用する必要があります. この場合、[RFC7160]のセクション3.1で指定されているように、新しいSSRCを選択する必要があります. 

*リモート記述からのペイロードタイプマッピングは、上で選択した送信メディアフォーマットのペイロードタイプを含む、発信RTPストリームのペイロードタイプを決定するために使用されます. リモートの説明からの拡張マッピングを使用して、ネゴシエートされたすべてのRTPヘッダー拡張を発信RTPストリームに含める必要があります. [ID.ietf-mmusic-rid]のセクション4に示すように、RIDヘッダー拡張がネゴシエートされ、RID値が指定されている場合は、RIDヘッダー拡張を発信RTPストリームに含めます. 

* m =セクションが音声タイプであり、リモート記述の処理の結果として送信メディア形式に対して無音圧縮が構成され、ローカル形式でその形式に対しても有効になっている場合、発信メディアに対して無音圧縮を使用します. セクション5.2.3.2のガイダンスに従って. これらの条件が満たされていない場合、発信メディアに無音圧縮を使用してはなりません. 

*サイマルキャストがネゴシエートされている場合は、[ID.ietf-mmusic-sdp-simulcast]のセクション6.2.2で指定されている数のソースRTPストリームを送信します. 

*上記で選択した送信メディアフォーマットに対応する「rtx」メディアフォーマットがある場合、またはFECメカニズムがネゴシエートされている場合は、各ソースRTPストリームに対してランダムなSSRCで冗長RTPストリームを確立し、RTX / FECパケットの送信を開始または続行します. 必要. 

*上記で選択した送信メディア形式に同じクロックレートの対応する「赤い」メディア形式がある場合、[ID.ietf-rtcweb-fec]のセクション3.2で説明するように、復元目的で指定された形式を使用して冗長エンコーディングを許可します. RTXまたはFECメディア形式とは異なり、「赤」形式は冗長RTPストリームではなく、ソースRTPストリームで送信されることに注意してください. 

*指定されたメディア形式を使用するすべてのソースRTPストリームに対して、メディアセクションで参照されるRTCPフィードバックメカニズムを有効にします. 具体的には、[RFC4585]のセクション4.2で指定されているように、要求されたフィードバックタイプの送信を開始し、受信したフィードバックに対応します. RTCPフィードバックを送信するときは、[RFC8108]セクション5.4.1のルールと推奨事項に従って、使用するSSRCを選択します. 

*answerの方向属性がJSEP実装がメディアを送信してはならないことを示している場合（ローカルanswerの場合は「recvonly」、リモートanswerの場合は「sendonly」、どちらのタイプのanswerも「非アクティブ」）すべてのRTPメディアの送信を停止しますが、 [RFC3264]、セクション5.1で説明されているように、RTCPの送信を続行します. 

o m =セクションのプロト値がSCTPの使用を示している場合：

* SCTPアソシエーションが存在し、リモートSCTPポートが変更された場合、既存のSCTPアソシエーションを破棄します. これには、PeerConnection状態が「have-remote-pranswer」である場合が含まれます. 

*有効なSCTPアソシエーションが存在しない場合は、[IDで説明されているように、ローカル説明のローカルSCTPポート値とリモート説明のリモートSCTPポート値を使用して、関連付けられたICEコンポーネントとDTLS接続を介してSCTPアソシエーションを開始する準備をします.  .ietf-mmusic-sctp-sdp]、セクション10.2

answerに有効なバンドルグループが含まれている場合は、[ID.ietf-mmusic-sdp]で説明されているように、各バンドルのプライマリICEコンポーネントにバンドルされるm =セクションのICEコンポーネントを破棄し、これらのm =セクションの多重化を開始します.  -bundle-negotiation]、セクション8.2. 

説明のタイプが「answer」であり、ICE候補プールにまだ候補が残っている場合は、それらを破棄します. 

6. RTP / RTCPの処理
バンドルする場合、着信RTP / RTCPを適切なm =セクションに関連付けることは、[ID.ietf-mmusic-sdp-bundle-negotiation]のセクション10.2で定義されています. バンドルしない場合、RTP / RTCPを受信するICEコンポーネントから適切なm =セクションが明確になります. 

適切なm =セクションがわかると、RTP / RTCPはm =セクションに関連付けられたRtpTransceiverに配信され、RTP / RTCPのさらなる処理はRtpTransceiverレベルで行われます. これには、RID [ID.ietf-mmusic-rid]を使用して複数のエンコードされたストリームを区別し、特定の冗長RTPストリームで修復する必要のあるソースRTPストリームを決定することが含まれます. 

7.例
この例のセクションは、いくつかのSDPフラグメントを示していることに注意してください. 72列でフォーマットするために、SDPの一部の行は複数の行に分割されています. 先頭の空白は、その行が前の行の続きであることを示しています. さらに、読みやすくするために空白行がいくつか追加されていますが、SDPでは無効です. 

IPv6アドレスを使用した例を含む、SDP for WebRTCコールフローのその他の例は、[ID.ietf-rtcweb-sdp]にあります. 

7.1. 簡単な例
このセクションでは、トリクルICEを使用せずに2つのJSEPエンドポイント間で最小限のオーディオ/ビデオコールを設定する非常に簡単な例を示します. 次のセクションの例は、JSEPセッションで発生する可能性があることのより詳細な例を示しています. 

以下のコードフローは、アリスのエンドポイントがボブのエンドポイントへのセッションを開始することを示しています. AliceのブラウザーのJavaScriptアプリケーションからBobのブラウザーのJavaScriptへのメッセージ（それぞれAliceJSおよびBobJSと略される）は、Webサーバーを介していくつかのシグナリングプロトコル上を流れると想定されます. アリス側とボブ側の両方のJavaScriptは、すべての候補者を待ってからofferまたはanswerを送信するため、offerとanswerは完了します. トリクルICEは使用されません. AliceとBobのブラウザのユーザーエージェント（JSEP実装）は、それぞれAliceUAとBobUAと省略され、デフォルトのバンドルポリシー「balanced」とデフォルトのRTCP muxポリシー「require」を使用しています. 

//                  set up local media state
AliceJS->AliceUA:   create new PeerConnection
AliceJS->AliceUA:   addTrack with two tracks: audio and video
AliceJS->AliceUA:   createOffer to get offer
AliceJS->AliceUA:   setLocalDescription with offer
AliceUA->AliceJS:   multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
AliceUA->AliceJS:   onicecandidate event with null candidate
AliceJS->AliceUA:   get |offer-A1| from pendingLocalDescription

//                  |offer-A1| is sent over signaling protocol to Bob
AliceJS->WebServer: signaling with |offer-A1|
WebServer->BobJS:   signaling with |offer-A1|

//                  |offer-A1| arrives at Bob
BobJS->BobUA:       create a PeerConnection
BobJS->BobUA:       setRemoteDescription with |offer-A1|
BobUA->BobJS:       ontrack events for audio and video tracks

//                  Bob accepts call
BobJS->BobUA:       addTrack with local tracks
BobJS->BobUA:       createAnswer
BobJS->BobUA:       setLocalDescription with answer
BobUA->BobJS:       multiple onicecandidate events with candidates

//                  wait for ICE gathering to complete
BobUA->BobJS:       onicecandidate event with null candidate
BobJS->BobUA:       get |answer-A1| from currentLocalDescription

//                  |answer-A1| is sent over signaling protocol to Alice
BobJS->WebServer:   signaling with |answer-A1|
WebServer->AliceJS: signaling with |answer-A1|

//                  |answer-A1| arrives at Alice
AliceJS->AliceUA:   setRemoteDescription with |answer-A1|
AliceUA->AliceJS:   ontrack events for audio and video tracks

//                  media flows
BobUA->AliceUA:     media sent from Bob to Alice
AliceUA->BobUA:     media sent from Alice to Bob


| offer-A1 |のSDP 次のようになります. 

   v = 0
   o =-4962303333179871722 1 IN IP4 0.0.0.0 s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 10100 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 203.0.113.100
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：47017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：ETEn
   a = ice-pwd：OtSK0WpNtpUjkY4 + 86js7ZQl
   a = fingerprint：sha-256
                 19：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：actpass
   a = tls-id：91bbf309c0990a6bec11e38ba2933cee
   a = rtcp：10101 IN IP4 203.0.113.100
   a = rtcp-mux
   a = rtcp-rsize
   a = candidate：1 1 udp 2113929471 203.0.113.100 10100 typ host
   a = candidate：1 2 udp 2113929470 203.0.113.100 10101 typ host
   a =候補者の終わり
        
   m =ビデオ10102 UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 203.0.113.100
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：47017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：BGKk
   a = ice-pwd：mqyWsAjvtKwTGnvhPztQ9mIf
   a = fingerprint：sha-256
                 19：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：actpass
   a = tls-id：91bbf309c0990a6bec11e38ba2933cee
   a = rtcp：10103 IN IP4 203.0.113.100
   a = rtcp-mux
   a = rtcp-rsize
   a = candidate：1 1 udp 2113929471 203.0.113.100 10102 typ host
   a = candidate：1 2 udp 2113929470 203.0.113.100 10103 typ host
   a =候補者の終わり
        
| answer-A1 |のSDP 次のようになります. 

   v = 0
   o =-6729291447651054566 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 10200 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 203.0.113.200
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：61317484-2ed4-49d7-9eb7-1414322a7aae
   a = ice-ufrag：6sFv
   a = ice-pwd：cOTZKZNVlO9RSGsEGM63JXT2
   a = fingerprint：sha-256
        
                 6B：8B：F0：65：5F：78：E2：51：3B：AC：6F：F3：3F：46：1B：35：
                 DC：B8：5F：64：1A：24：C2：43：F0：A1：58：D0：A1：2C：19：08
   a = setup：active
   a = tls-id：eec3392ab83e11ceb6a0990c903fbb19
   a = rtcp-mux
   a = rtcp-rsize
   a = candidate：1 1 udp 2113929471 203.0.113.200 10200 typ host
   a =候補者の終わり
        
   m =ビデオ10200 UDP / TLS / RTP / SAVPF 100 101 102 103
   c = IN IP4 203.0.113.200
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：61317484-2ed4-49d7-9eb7-1414322a7aae
        
7.2. 詳細な例
このセクションでは、2つのJSEPエンドポイント間のセッションのより複雑な例を示します. トリクルICEはフルトリクルモードで使用され、「max-bundle」のバンドルポリシー、「require」のRTCP muxポリシー、および単一のTURNサーバーで使用されます. 最初は、アリスとボブの両方がオーディオチャネルとデータチャネルを確立します. その後、ボブは2つのビデオフローを追加します. 1つはビデオフィード用、もう1つは画面共有用で、どちらもFECをサポートし、ビデオフィードはサイマルキャスト用に構成されています. アリスはこれらのビデオフローを受け入れますが、独自のビデオフローを追加しないため、recvonlyとして処理されます. アリスは、ビデオデコーダの最大解像度も指定します. 

  //ローカルメディアの状態を設定します
  AliceJS-> AliceUA：新しいPeerConnectionを作成する
  AliceJS-> AliceUA：オーディオトラックを含むaddTrack
  AliceJS-> AliceUA：データチャネルを取得するcreateDataChannel
  AliceJS-> AliceUA：createOfferを取得する| offer-B1 |
  AliceJS-> AliceUA：| offer-B1 |を含むsetLocalDescription
        
  // | offer-B1 | シグナリングプロトコルを介してボブに送信されます
  AliceJS-> WebServer：| offer-B1 |によるシグナリング
  WebServer-> BobJS：| offer-B1 |によるシグナリング
        
  // | offer-B1 | ボブに到着
  BobJS-> BobUA：PeerConnectionを作成する
  BobJS-> BobUA：| offer-B1 |を指定したsetRemoteDescription
  BobUA-> BobJS：アリスからのオーディオトラックを含むオントラック
        
  //候補者はボブに送信されます
  AliceUA-> AliceJS：onicecandidate（ホスト）| offer-B1-candidate-1 |
  AliceJS-> WebServer：| offer-B1-candidate-1 |によるシグナリング
  AliceUA-> AliceJS：onicecandidate（srflx）| offer-B1-candidate-2 |
  AliceJS-> WebServer：| offer-B1-candidate-2 |によるシグナリング
  AliceUA-> AliceJS：onicecandidate（relay）| offer-B1-candidate-3 |
  AliceJS-> WebServer：| offer-B1-candidate-3 |によるシグナリング
        
  WebServer-> BobJS：| offer-B1-candidate-1 |によるシグナリング
  BobJS-> BobUA：| offer-B1-candidate-1 |を指定したaddIceCandidate
  WebServer-> BobJS：| offer-B1-candidate-2 |によるシグナリング
  BobJS-> BobUA：| offer-B1-candidate-2 |を指定したaddIceCandidate
  WebServer-> BobJS：| offer-B1-candidate-3 |によるシグナリング
  BobJS-> BobUA：| offer-B1-candidate-3 |を指定したaddIceCandidate
        
  //ボブは通話を受け付けます
  BobJS-> BobUA：ローカルオーディオを含むaddTrack
  BobJS-> BobUA：データチャネルを取得するcreateDataChannel
  BobJS-> BobUA：取得するcreateAnswer | answer-B1 |
  BobJS-> BobUA：| answer-B1 |を指定したsetLocalDescription
        
  // | answer-B1 | アリスに送られる
  BobJS-> WebServer：| answer-B1 |によるシグナリング
  WebServer-> AliceJS：| answer-B1 |によるシグナリング
  AliceJS-> AliceUA：| answer-B1 |のあるsetRemoteDescription
  AliceUA-> AliceJS：ボブからのオーディオトラックを含むontrackイベント
        
  //候補者はアリスに送信されます
  BobUA-> BobJS：onicecandidate（ホスト）| answer-B1-candidate-1 |
  BobJS-> WebServer：| answer-B1-candidate-1 |によるシグナリング
  BobUA-> BobJS：onicecandidate（srflx）| answer-B1-candidate-2 |
  BobJS-> WebServer：| answer-B1-candidate-2 |によるシグナリング
  BobUA-> BobJS：onicecandidate（relay）| answer-B1-candidate-3 |
  BobJS-> WebServer：| answer-B1-candidate-3 |によるシグナリング
        
  WebServer-> AliceJS：| answer-B1-candidate-1 |によるシグナリング
  AliceJS-> AliceUA：| answer-B1-candidate-1 |を指定したaddIceCandidate
  WebServer-> AliceJS：| answer-B1-candidate-2 |によるシグナリング
  AliceJS-> AliceUA：| answer-B1-candidate-2 |を指定したaddIceCandidate WebServer-> AliceJS：| answer-B1-candidate-3 |によるシグナリング
  AliceJS-> AliceUA：| answer-B1-candidate-3 |を指定したaddIceCandidate
        
  //データチャネルが開きます
  BobUA-> BobJS：ondatachannelイベント
  AliceUA-> AliceJS：ondatachannelイベント
  BobUA-> BobJS：onopen
  AliceUA-> AliceJS：onopen
        
  //エンドポイント間でメディアが流れています
  BobUA-> AliceUA：ボブからアリスに送信されたオーディオ+データ
  AliceUA-> BobUA：AliceからBobに送信されるオーディオ+データ
        
  //しばらくして、Bobは2つのビデオストリームを追加します
  //バンドルのため、候補者は交換されていません
  BobJS-> BobUA：最初のビデオストリームを含むaddTrack
  BobJS-> BobUA：2番目のビデオストリームを含むaddTrack
  BobJS-> BobUA：| offer-B2 |を取得するためのcreateOffer
  BobJS-> BobUA：| offer-B2 |を指定したsetLocalDescription
        
  // | offer-B2 | アリスに送られる
  BobJS-> WebServer：| offer-B2 |によるシグナリング
  WebServer-> AliceJS：| offer-B2 |によるシグナリング
  AliceJS-> AliceUA：| offer-B2 |を指定したsetRemoteDescription
  AliceUA-> AliceJS：最初のビデオトラックを含むontrackイベント
  AliceUA-> AliceJS：2番目のビデオトラックを含むontrackイベント
  AliceJS-> AliceUA：取得するcreateAnswer | answer-B2 |
  AliceJS-> AliceUA：| Local-Description with | answer-B2 |
        
  // | answer-B2 | シグナリングプロトコルを介してボブに送信されます
  AliceJS-> WebServer：| answer-B2 |によるシグナリング
  WebServer-> BobJS：| answer-B2 |によるシグナリング
  BobJS-> BobUA：| answer-B2 |を指定したsetRemoteDescription
        
  //エンドポイント間でメディアが流れています
  BobUA-> AliceUA：ボブからアリスに送信されたオーディオ+ビデオ+データ
  AliceUA-> BobUA：AliceからBobに送信されるaudio + video + data
        
   | offer-B1 |のSDP 次のようになります：v = 0
   o =-4962303333179871723 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1
        
   m =オーディオ9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：57017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：ATEn
   a = ice-pwd：AtSK0WpNtpUjkY4 + 86js7ZQl
   a = fingerprint：sha-256
                 29：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：actpass
   a = tls-id：17f0f4ba8a5f1213faca591b58ba52a7
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize
        
   m =アプリケーション0 UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 0.0.0.0
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
   a =バンドルのみ
        
| offer-B1-candidate-1 | 次のようになります：ufrag ATEnインデックス0 mid a1 attr候補：1 1 udp 2113929471 203.0.113.100 10100 typホスト

| offer-B1-candidate-2 | 次のようになります. 

ufrag ATEnインデックス0 mid a1 attr候補：1 1 udp 1845494015 198.51.100.100 11100 typ srflx raddr 203.0.113.100 rport 10100

| offer-B1-candidate-3 | 次のようになります. 

ufrag ATEnインデックス0 mid a1 attr候補：1 1 udp 255 192.0.2.100 12100 typリレーraddr 198.51.100.100 rport 11100

   | answer-B1 |のSDP 次のようになります：v = 0
   o =-7729291447651054566 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1
        
   m =オーディオ9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：71317484-2ed4-49d7-9eb7-1414322a7aae
   a = ice-ufrag：7sFv
   a = ice-pwd：dOTZKZNVlO9RSGsEGM63JXT2
   a = fingerprint：sha-256
                 7B：8B：F0：65：5F：78：E2：51：3B：AC：6F：F3：3F：46：1B：35：
                 DC：B8：5F：64：1A：24：C2：43：F0：A1：58：D0：A1：2C：19：08
   a = setup：active
   a = tls-id：7a25ab85b195acaf3121f5a8ab4f0f71
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize
        
   m =アプリケーション9 UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 0.0.0.0
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
        
| answer-B1-candidate-1 | 次のようになります. 

ufrag 7sFvインデックス0 mid a1 attr候補：1 1 udp 2113929471 203.0.113.200 10200 typホスト

| answer-B1-candidate-2 | 次のようになります. 

ufrag 7sFvインデックス0 mid a1 attr候補：1 1 udp 1845494015 198.51.100.200 11200 typ srflx raddr 203.0.113.200 rport 10200

| answer-B1-candidate-3 | 次のようになります. 

ufrag 7sFvインデックス0 mid a1 attr候補：1 1 udp 255 192.0.2.200 12200 typリレーraddr 198.51.100.200 rport 11200

| offer-B2 |のSDP 以下に示します. ビデオの新しいm =セクションに加えて、どちらもFECを提供しており、一方は同時放送を提供しています. o=行のバージョン番号の増分に注意してください. c=行に変更され、ローカル候補を示します. それが選択され、収集された候補がa = candidate行として含まれます. 

   v = 0
   o =-7729291447651054566 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1 v1 v2
   a = group：LS a1 v1
        
   m = audio 12200 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.200
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120 a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：71317484-2ed4-49d7-9eb7-1414322a7aae
   a = ice-ufrag：7sFv
   a = ice-pwd：dOTZKZNVlO9RSGsEGM63JXT2
   a = fingerprint：sha-256
                 7B：8B：F0：65：5F：78：E2：51：3B：AC：6F：F3：3F：46：1B：35：
                 DC：B8：5F：64：1A：24：C2：43：F0：A1：58：D0：A1：2C：19：08
   a = setup：actpass
   a = tls-id：7a25ab85b195acaf3121f5a8ab4f0f71
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize
   a = candidate：1 1 udp 2113929471 203.0.113.200 10200 typ host
   a = candidate：1 1 udp 1845494015 198.51.100.200 11200 typ srflx
               raddr 203.0.113.200 rport 10200
   a = candidate：1 1 udp 255 192.0.2.200 12200 typ relay
               raddr 198.51.100.200 rport 11200
   a =候補者の終わり
        
   m =アプリケーション12200 UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 192.0.2.200
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
        
   m =ビデオ12200 UDP / TLS / RTP / SAVPF 100 101 102 103 104
   c = IN IP4 192.0.2.200
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = rtpmap：104 flexfec / 90000
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：71317484-2ed4-49d7-9eb7-1414322a7aae
   a = rid：1 send
   a = rid：2 send
   a = rid：3送信
   a = simulcast：send 1; 2; 3 m = video 12200 UDP / TLS / RTP / SAVPF 100 101 102 103 104
   c = IN IP4 192.0.2.200
   a = mid：v2
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = rtpmap：104 flexfec / 90000
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：81317484-2ed4-49d7-9eb7-1414322a7aae
        
| answer-B2 |のSDP 以下に示します. ビデオm =セクションの受け入れに加えて、a = recvonlyを使用して一方向のビデオを示し、a = imageattrを使用して受信解像度を制限します. 既存のDTLSを維持するためのsetup：passiveの使用に注意してください. 役割. 

   v = 0
   o =-4962303333179871723 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1 v1 v2
   a = group：LS a1 v1
        
   m = audio 12100 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.100
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：57017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：ATEn
   a = ice-pwd：AtSK0WpNtpUjkY4 + 86js7ZQl
   a = fingerprint：sha-256
                 29：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：passive
   a = tls-id：17f0f4ba8a5f1213faca591b58ba52a7
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize
   a = candidate：1 1 udp 2113929471 203.0.113.100 10100 typ host
   a = candidate：1 1 udp 1845494015 198.51.100.100 11100 typ srflx
               raddr 203.0.113.100 rport 10100
   a = candidate：1 1 udp 255 192.0.2.100 12100 typ relay
               raddr 198.51.100.100 rport 11100
   a =候補者の終わり
        
   m =アプリケーション12100 UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 192.0.2.100
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
        
   m =ビデオ12100 UDP / TLS / RTP / SAVPF 100 101 102 103
   c = IN IP4 192.0.2.100
   a = mid：v1
   a = recvonly
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = imageattr：100 recv [x = [48：1920]、y = [48：1080]、q = 1.0]
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
        
   m =ビデオ12100 UDP / TLS / RTP / SAVPF 100 101 102 103
   c = IN IP4 192.0.2.100
   a = mid：v2
   a = recvonly
   a = rtpmap：100 VP8 / 90000 a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = imageattr：100 recv [x = [48：1920]、y = [48：1080]、q = 1.0]
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
        
7.3. 初期輸送ウォームアップの例
この例は、セクション4.1.8.1で説明されている早期ウォームアップ手法を示しています. ここでは、アリスのエンドポイントがボブのエンドポイントにofferを送信して、音声/ビデオ通話を開始します. ボブはすぐにオーディオ/ビデオのm =セクションを受け入れる応答で応答しますが、（彼の観点から）それらをsendonlyとしてマークします. つまり、アリスはまだメディアを送信しません. これにより、JSEP実装はICEおよびDTLSのネゴシエーションをすぐに開始できます. 次に、ボブのエンドポイントは、コールに応答するように彼に促し、彼が応答すると、彼のエンドポイントは、オーディオとビデオのm =セクションを有効にする2番目のofferを送信し、それによって双方向メディア伝送を行います. このようなフローの利点は、最初のanswerが受信されるとすぐに、実装がICEおよびDTLSネゴシエーションを続行し、セッション転送を確立できることです. 2番目のofferが送信される前にトランスポートのセットアップが完了した場合、呼び出しに応答するとすぐに、呼び出し先がメディアをすぐに送信できるため、認識されるダイヤル後遅延が最小限に抑えられます. 2番目のoffer/answer交換でも、優先コーデックまたはその他のセッションパラメータを変更できます. 

この例では、セクション3.5.3で説明した「リレー」ICE候補ポリシーを利用して、必要なICEの収集とチェックを最小限に抑えています. 

//ローカルメディアの状態を設定します
AliceJS-> AliceUA：「リレー」ICEポリシーで新しいPeerConnectionを作成する
AliceJS-> AliceUA：オーディオとビデオの2つのトラックを持つaddTrack
AliceJS-> AliceUA：createOfferを取得する| offer-C1 |
AliceJS-> AliceUA：| offer-C1 |を使用したsetLocalDescription
        
// | offer-C1 | シグナリングプロトコルを介してボブに送信されます
AliceJS-> WebServer：| offer-C1 |によるシグナリング
WebServer-> BobJS：| offer-C1 |によるシグナリング
        
// | offer-C1 | ボブに到着
BobJS-> BobUA：「リレー」ICEポリシーで新しいPeerConnectionを作成する
BobJS-> BobUA：| offer-C1 |を使用したsetRemoteDescription
BobUA-> BobJS：オーディオとビデオのオントラックイベント
        
//リレー候補がボブに送信されます
AliceUA-> AliceJS：onicecandidate（relay）| offer-C1-candidate-1 |
AliceJS-> WebServer：| offer-C1-candidate-1 |によるシグナリング
        
WebServer-> BobJS：| offer-C1-candidate-1 |によるシグナリング
BobJS-> BobUA：| offer-C1-candidate-1 |を指定したaddIceCandidate
        
//ボブはトランスポートをウォームアップするための早期のanswerを準備します
BobJS-> BobUA：オーディオとビデオのトラックがnullのaddTransceiver
BobJS-> BobUA：両方のトランシーバー.setDirection（sendonly）
BobJS-> BobUA：createAnswer
BobJS-> BobUA：setLocalDescriptionとanswer
        
// | answer-C1 | 信号プロトコルを介してアリスに送信されます
BobJS-> WebServer：| answer-C1 |によるシグナリング
WebServer-> AliceJS：| answer-C1 |によるシグナリング
        
// | answer-C1 | （送信のみ）アリスに到着
AliceJS-> AliceUA：| answer-C1 |のあるsetRemoteDescription
AliceUA-> AliceJS：オーディオとビデオのオントラックイベント
        
//リレー候補がアリスに送信されます
BobUA-> BobJS：onicecandidate（relay）| answer-B1-candidate-1 |
BobJS-> WebServer：| answer-B1-candidate-1 |によるシグナリング
        
WebServer-> AliceJS：| answer-B1-candidate-1 |によるシグナリング
AliceJS-> AliceUA：| answer-B1-candidate-1 |を指定したaddIceCandidate
        
//コールが鳴っている間にICEとDTLSが確立します

//ボブは通話を受け入れ、メディアを開始し、新しいofferを送信します
BobJS-> BobUA：オーディオトラックとビデオトラックを含むトランシーバー.setTrack
BobUA-> AliceUA：BobからAliceに送信されたメディア
BobJS-> BobUA：両方のトランシーバー.setDirection（sendrecv）
                    トランシーバー
BobJS-> BobUA：createOffer
BobJS-> BobUA：offer付きのsetLocalDescription
        
// | offer-C2 | 信号プロトコルを介してアリスに送信されます
BobJS-> WebServer：| offer-C2 |によるシグナリング
WebServer-> AliceJS：| offer-C2 |によるシグナリング
        
// | offer-C2 | （sendrecv）がAlice AliceJS-> AliceUAに到着：setRemoteDescription || offer-C2 |
AliceJS-> AliceUA：createAnswer
AliceJS-> AliceUA：| Local-Description with | answer-C2 |
AliceUA-> BobUA：アリスからボブに送信されたメディア
        
// | answer-C2 | シグナリングプロトコルを介してボブに送信されます
AliceJS-> WebServer：| answer-C2 |によるシグナリング
WebServer-> BobJS：| answer-C2 |によるシグナリング
BobJS-> BobUA：| answer-C2 |を指定したsetRemoteDescription
        
| offer-C1 |のSDP 次のようになります. 

   v = 0
   o =-1070771854436052752 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m =オーディオ9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
   a = ice-ufrag：4ZcD
   a = ice-pwd：ZaaG6OG7tCn4J / lehAGz + HHD
   a = fingerprint：sha-256
                 C4：68：F8：77：6A：44：F1：98：6D：7C：9F：47：EB：E3：34：A4：
                 0A：AA：2D：49：08：28：70：2E：1F：AE：18：7D：4E：3E：66：BF
   a = setup：actpass
   a = tls-id：9e5b948ade9c3d41de6617b68f769e55
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize m = video 0 UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 0.0.0.0
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
   a =バンドルのみ
        
| offer-C1-candidate-1 | 次のようになります. 

ufrag 4ZcDインデックス0 mid a1 attr候補：1 1 udp 255 192.0.2.100 12100 typリレーraddr 0.0.0.0 rport 0

| answer-C1 |のSDP 次のようになります. 

   v = 0
   o =-6386516489780559513 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m =オーディオ9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendonly
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000 a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
   a = ice-ufrag：TpaA
   a = ice-pwd：t2Ouhc67y8JcCaYZxUUTgKw /
   a = fingerprint：sha-256
                 A2：F3：A5：6D：4C：8C：1E：B2：62：10：4A：F6：70：61：C4：FC：
                 3C：E0：01：D6：F3：24：80：74：DA：7C：3E：50：18：7B：CE：4D
   a = setup：active
   a = tls-id：55e967f86b7166ed14d3c9eda849b5e9
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize
        
   m =ビデオ9 UDP / TLS / RTP / SAVPF 100 101 102 103
   c = IN IP4 0.0.0.0
   a = mid：v1
   a = sendonly
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
        
| answer-C1-candidate-1 | 次のようになります. 

ufrag TpaAインデックス0 mid a1 attr候補：1 1 udp 255 192.0.2.200 12200 typリレーraddr 0.0.0.0 rport 0

| offer-C2 |のSDP 次のようになります. 

   v = 0
   o =-6386516489780559513 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 12200 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.200
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
   a = ice-ufrag：TpaA
   a = ice-pwd：t2Ouhc67y8JcCaYZxUUTgKw /
   a = fingerprint：sha-256
                 A2：F3：A5：6D：4C：8C：1E：B2：62：10：4A：F6：70：61：C4：FC：
                 3C：E0：01：D6：F3：24：80：74：DA：7C：3E：50：18：7B：CE：4D
   a = setup：actpass
   a = tls-id：55e967f86b7166ed14d3c9eda849b5e9
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize
   a = candidate：1 1 udp 255 192.0.2.200 12200 typ relay
               raddr 0.0.0.0 rport 0
   a =候補者の終わり
        
   m =ビデオ12200 UDP / TLS / RTP / SAVPF 100 101 102 103
   c = IN IP4 192.0.2.200
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000 a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
        
| answer-C2 |のSDP 次のようになります. 

   v = 0
   o =-1070771854436052752 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 12100 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.100
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97 telephone-event / 8000
   a = rtpmap：98 telephone-event / 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
   a = ice-ufrag：4ZcD
   a = ice-pwd：ZaaG6OG7tCn4J / lehAGz + HHD
   a = fingerprint：sha-256
                 C4：68：F8：77：6A：44：F1：98：6D：7C：9F：47：EB：E3：34：A4：
                 0A：AA：2D：49：08：28：70：2E：1F：AE：18：7D：4E：3E：66：BF
   a = setup：passive
   a = tls-id：9e5b948ade9c3d41de6617b68f769e55
   a = rtcp-mux
   a = rtcp-mux-only
   a = rtcp-rsize
   a = candidate：1 1 udp 255 192.0.2.100 12100 typ relay
        
raddr 0.0.0.0 rport 0 a = end-of-candidates

   m =ビデオ12100 UDP / TLS / RTP / SAVPF 100 101 102 103
   c = IN IP4 192.0.2.100
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100 nack
   a = rtcp-fb：100 nack pli
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
        
8.セキュリティに関する考慮事項
IETFは、WebRTC全体のセキュリティアーキテクチャを説明する別のドキュメント[ID.ietf-rtcweb-security-arch] [ID.ietf-rtcweb-security]を公開しています. このセクションの残りの部分では、このドキュメントのセキュリティに関する考慮事項について説明します. 

正式にはJSEPインターフェースはAPIですが、アプリケーションのJavaScriptはJSEP実装の観点から信頼できないため、それをインターネットプロトコルと考える方が良いでしょう. したがって、[RFC3552]の脅威モデルが適用されます. 特に、JavaScriptは、悪意のあるものを含め、任意の順序で任意の入力でAPIを呼び出すことができます. これは、setLocalDescription（）に渡されるSDPを検討する場合に特に関係があります. APIを正しく使用するには、アプリケーションがcreateOffer（）またはcreateAnswer（）から派生したSDPを渡す必要がありますが、アプリケーションがそれを保証するわけではありません. JavaScriptが代わりに偽のデータを渡すように、JSEP実装を準備する必要があります. 

逆に、アプリケーションプログラマは、JavaScriptがエンドポイントの動作を完全に制御できないことに注意する必要があります. 特に言及する1つのケースは、SDPからICE候補を編集したり、だまされた候補を抑制したりすると、予期した動作が行われないことです. 実装は、候補が反対側に送信されない場合でも、候補からのチェックを実行します. したがって、たとえば、サーバーの再帰候補を削除してリモートピアがパブリックIPアドレスを学習するのを防ぐことはできません. パブリックIPアドレスを隠したいアプリケーションは、代わりにICEエージェントを構成して、リレー候補のみを使用する必要があります. 

9. IANAに関する考慮事項
このドキュメントは、IANAからのアクションを必要としません. 

10.謝辞
ハラルドアルヴェストランド、テイラーブランドステッター、スハスナンダクマール、ピーターサッチャーがこのドラフトの重要なテキストを提供しました. Bernard Aboba、Adam Bergkvist、Dan Burnett、Ben Campbell、Alissa Cooper、Richard Ejzak、Stefan Hakansson、Ted Hardie、Christer Holmberg Andrew Hutton、Randell Jesup、Matthew Kaufman、Anant Narayanan、Adam Roach、Robert Sparks、Neil Stratford、Martin Thomson、 Sean TurnerとMagnus Westerlundはすべて、このofferについて貴重なフィードバックを提供しました. 

11.リファレンス
11.1 規範的な参考文献
[ID.ietf-avtext-rid] Roach、A.、Nandakumar、S. 、およびP. Thatcher、「RTP Stream Identifier Source Description（SDES）」、d raft-ietf-avtext-rid-09（作業中） 、2016年10月. 

[ID.ietf-ice-trickle] Ivov、E.、Rescorla、E.、Uberti、J. 、およびP. Saint-Andre、「Trickle ICE：Incremental Provisioning of Candidates for the Interactive Connectivity Establishment（ICE）Protocol」、 draft-ietf-ice-trickle-21（作業中）、2018年4月. 

[ID.ietf-mmusic-dtls-sdp] Holmberg、C. およびR. Shpount、「データグラムトランスポート層セキュリティ（DTLS）およびトランスポート層セキュリティ（TLS）に関するセッション記述プロトコル（SDP）offer/answerの考慮事項」、ドラフト- ietf-mmusic-dtls-sdp-32（作業中）、2017年10月. 

[ID.ietf-mmusic-ice-sip-sdp] Petit-Huguenin、M.、Nandakumar、S. 、およびA. Keranen、「インタラクティブ接続確立（ICE）のセッション記述プロトコル（SDP）offer/answer手順」、 draft-ietf-mmusic-ice-sip-sdp-24（作業中）、2018年11月. 

[ID.ietf-mmusic-msid] Alvestrand、H. 、「Session Description ProtocolでのWebRTC MediaStream Identification」、draft-ietf-mmusic-msid-17（進行中）、2018年12月. 

[ID.ietf-mmusic-mux-exclusive] Holmberg、C. 、「SDPを使用したRTP / RTCP多重化の排他的サポートを示す」、draft-ietf-mmusic-mux-exclusive-12（作業中）、2017年5月. 

[ID.ietf-mmusic-rid] Roach、A. 、「RTP Payload Format Restrictions」、draft-ietf-mmusic-rid-15（進行中）、2018年5月. 

[ID.ietf-mmusic-sctp-sdp] Holmberg、C.、Shpount、R.、Loreto、S.、and G. Camarillo、 "Session Description Protocol（SDP）Offer / Answer Procedures for Stream Control Transmission Protocol（SCTP）データグラムトランスポート層セキュリティ（DTLS）トランスポート. 」、draft-ietf-mmusic-sctp-sdp-26（作業中）、2017年4月. 

[ID.ietf-mmusic-sdp-bundle-negotiation] Holmberg、C.、Alvestrand、H. 、およびC. Jennings、「Session Description Protocol（SDP）を使用したメディア多重化のネゴシエーション」、draft-ietf-mmusic-sdp- bundle-negotiation-54（進行中の作業）、2018年12月. 

[ID.ietf-mmusic-sdp-mux-attributes] Nandakumar、S. 、「マルチプレキシング時のSDP属性のフレームワーク」、draft-ietf-mmusic-sdp-mux-attributes-17（進行中）、2018年2月. 

[ID.ietf-mmusic-sdp-simulcast] Burman、B.、Westerlund、M.、Nandakumar、S. 、およびM. Zanaty、「SDPおよびRTPセッションでのSimulcastの使用」、draft-ietf-mmusic-sdp-simulcast -13（作業中）、2018年6月. 

[ID.ietf-rtcweb-fec] Uberti、J. 、「WebRTC Forward Error Correction Requirements」、draft-ietf-rtcweb-fec-08（作業中）、2018年3月. 

[ID.ietf-rtcweb-rtp-usage] Perkins、C.、Westerlund、M.、J. Ott、「Web Real-Time Communication（WebRTC）：Media Transport and Use of RTP」、draft-ietf-rtcweb- rtp-usage-26（作業中）、2016年3月. 

[ID.ietf-rtcweb-security] Rescorla、E. 、「WebRTCのセキュリティに関する考慮事項」、draft-ietf-rtcweb-security-11（作業中）、2019年2月. 

[ID.ietf-rtcweb-security-arch] Rescorla、E. 、「WebRTC Security Architecture」、draft-ietf-rtcweb-security-arch-18（作業中）、2019年2月. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>. 

[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. 、およびE. Schooler、「SIP：Session Initiation Protocol」 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>. 

[RFC3264] Rosenberg、J. およびH. Schulzrinne、「セッション記述プロトコル（SDP）を備えたoffer/answerモデル」、RFC 3264、DOI 10.17487 / RFC3264、2002年6月、<https://www.rfc-editor.org / info / rfc3264>. 

[RFC3552] Rescorla、E. およびB. Korver、「セキュリティに関する考慮事項に関するRFCテキストの記述に関するガイドライン」、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、<https://www.rfc-editor.org/ info / rfc3552>. 

[RFC3605] Huitema、C. 、「Session Description Protocol（SDP）のReal Time Control Protocol（RTCP）属性」、RFC 3605、DOI 10.17487 / RFC3605、2003年10月、<https://www.rfc-editor.org/ info / rfc3605>. 

[RFC3711]バウアー、M. 、マクルー、D. 、ナスルンド、M. 、カララ、E. 、およびK.ノーマン、「セキュアリアルタイムトランスポートプロトコル（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月2004、<https://www.rfc-editor.org/info/rfc3711>. 

[RFC3890] Westerlund、M. 、「Session Description Protocol（SDP）のトランスポート非依存帯域幅修飾子」、RFC 3890、DOI 10.17487 / RFC3890、2004年9月、<https://www.rfc-editor.org/info/ rfc3890>. 

[RFC4145] Yon、D. 、およびG. Camarillo、「セッション記述プロトコル（SDP）におけるTCPベースのメディアトランスポート」、RFC 4145、DOI 10.17487 / RFC4145、2005年9月、<https：//www.rfc-editor.  org / info / rfc4145>. 

[RFC4566] Handley、M.、Jacobson、V. 、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<https://www.rfc-editor.org/ info / rfc4566>. 

[RFC4585] Ott、J.、Wenger、S.、Sato、N.、Burmeister、C. 、およびJ. Rey、「​​リアルタイム転送制御プロトコル（RTCP）ベースのフィードバック用の拡張RTPプロファイル（RTP / AVPF） "、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<https://www.rfc-editor.org/info/rfc4585>. 

[RFC5124] Ott、J. およびE. Carrara、「リアルタイムトランスポートコントロールプロトコル（RTCP）ベースのフィードバック用の拡張セキュアRTPプロファイル（RTP / SAVPF）」、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<https ：//www.rfc-editor.org/info/rfc5124>. 

[RFC5285] Singer、D. およびH. Desineni、「一般的なRTPヘッダー拡張メカニズム」、RFC 5285、DOI 10.17487 / RFC5285、2008年7月、<https://www.rfc-editor.org/info/rfc5285> . 

[RFC5761] Perkins、C. およびM. Westerlund、「Multiplexing RTP Data and Control Packets on a Single Port」、RFC 5761、DOI 10.17487 / RFC5761、2010年4月、<https://www.rfc-editor.org/info / rfc5761>. 

[RFC5888] Camarillo、G.およびH. Schulzrinne、「セッション記述プロトコル（SDP）グループ化フレームワーク」、RFC 5888、DOI 10.17487 / RFC5888、2010年6月、<https://www.rfc-editor.org/info/ rfc5888>. 

[RFC6236] Johansson、I. およびK. Jung、「Session Description Protocol（SDP）における汎用イメージ属性のネゴシエーション」、RFC 6236、DOI 10.17487 / RFC6236、2011年5月、<https：//www.rfc-editor.  org / info / rfc6236>. 

[RFC6347] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>. 

[RFC6716] Valin、JM. 、Vos、K. 、およびT. Terriberry、「Definition of the Opus Audio Codec」、RFC 6716、DOI 10.17487 / RFC6716、2012年9月、<https://www.rfc-editor.org / info / rfc6716>. 

[RFC6904] Lennox、J. 、「Secure Real-time Transport Protocol（SRTP）のヘッダー拡張の暗号化」、RFC 6904、DOI 10.17487 / RFC6904、2013年4月、<https://www.rfc-editor.org/ info / rfc6904>. 

[RFC7160] Petit-Huguenin、M. およびG. Zorn、編、「RTPセッションでの複数のクロックレートのサポート」、RFC 7160、DOI 10.17487 / RFC7160、2014年4月、<https：//www.rfc-editor .org / info / rfc7160>. 

[RFC7587] Spittka、J.、Vos、K. 、およびJM. Valin、「Opus Speech and Audio CodecのRTPペイロード形式」、RFC 7587、DOI 10.17487 / RFC7587、2015年6月、<https://www.rfc-editor.org/info/rfc7587>. 

[RFC7742] Roach、A. 、「WebRTCビデオ処理およびコーデック要件」、RFC 7742、DOI 10.17487 / RFC7742、2016年3月、<https://www.rfc-editor.org/info/rfc7742>. 

[RFC7850] Nandakumar、S. 、「Registering Values of the SDP 'proto' field Transporting TCP over TCP over TCP under various RTP Profiles」、RFC 7850、DOI 10.17487 / RFC7850、2016年4月、<https：//www.rfc- editor.org/info/rfc7850>. 

[RFC7874]バリン、JM. C. Bran、「WebRTCオーディオコーデックと処理の要件」、RFC 7874、DOI 10.17487 / RFC7874、2016年5月、<https://www.rfc-editor.org/info/rfc7874>. 

[RFC8108] Lennox、J.、Westerlund、M.、Wu、Q. 、およびC. Perkins、「単一のRTPセッションでの複数のRTPストリームの送信」、RFC 8108、DOI 10.17487 / RFC8108、2017年3月、<https：/ /www.rfc-editor.org/info/rfc8108>. 

[RFC8122] Lennox、J. およびC. Holmberg、「Session Description Protocol（SDP）のトランスポート層セキュリティ（TLS）プロトコルを介した接続指向のメディアトランスポート」、RFC 8122、DOI 10.17487 / RFC8122、2017年3月、<https ：//www.rfc-editor.org/info/rfc8122>. 

[RFC8445] Keranen、A.、Holmberg、C. 、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、< https://www.rfc-editor.org/info/rfc8445>. 

11.2 参考情報
[ID.ietf-mmusic-trickle-ice-sip] Ivov、E.、Stach、T.、Marocco、E. 、およびC. Holmberg、「インタラクティブのための候補者の増分プロビジョニングのためのセッション開始プロトコル（SIP）の使用法接続確立（Trickle ICE）」、draft-ietf-mmusic-trickle-ice-sip-18（作業中）、2018年6月. 

[ID.ietf-rtcweb-ip-handling] Uberti、J. 、「WebRTC IPアドレスの処理要件」、draft-ietf-rtcweb-ip-handling-11（作業中）、2018年11月. 

[ID.ietf-rtcweb-sdp] Nandakumar、S. およびC. Jennings、「Annotated Example SDP for WebRTC」、draft-ietf-rtcweb-sdp-11（work in progress）、2018年10月. 

[RFC3389] Zopf、R. 、「Real-time Transport Protocol（RTP）Payload for Comfort Noise（CN）」、RFC 3389、DOI 10.17487 / RFC3389、2002年9月、<https://www.rfc-editor.org/ info / rfc3389>. 

[RFC3556] Casner、S. 、「RTP制御プロトコル（RTCP）帯域幅のセッション記述プロトコル（SDP）帯域幅修飾子」、RFC 3556、DOI 10.17487 / RFC3556、2003年7月、<https://www.rfc-editor.org / info / rfc3556>. 

[RFC3960] Camarillo、G. およびH. Schulzrinne、「セッション開始プロトコル（SIP）での初期のメディアと呼び出し音の生成」、RFC 3960、DOI 10.17487 / RFC3960、2004年12月、<https：//www.rfc-editor .org / info / rfc3960>. 

[RFC4568]アンドレアセン、F. 、バウアー、M. 、およびD.ウィング、「メディアストリームのセッション記述プロトコル（SDP）セキュリティ記述」、RFC 4568、DOI 10.17487 / RFC4568、2006年7月、<https：// www.  rfc-editor.org/info/rfc4568>. 

[RFC4588]レイ、J. 、レオン、D. 、宮崎、A. 、ヴァルサ、V. 、およびR.ハケンバーグ、「RTP Retransmission Payload Format」、RFC 4588、DOI 10.17487 / RFC4588、2006年7月、<https：/ /www.rfc-editor.org/info/rfc4588>. 

[RFC4733] Schulzrinne、H. およびT. Taylor、「DTMFディジット、テレフォニートーン、およびテレフォニーシグナルのRTPペイロード」、RFC 4733、DOI 10.17487 / RFC4733、2006年12月、<https://www.rfc-editor.org / info / rfc4733>. 

[RFC5245] Rosenberg、J. 、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal for Offer / Answer Protocols」、RFC 5245、DOI 10.17487 / RFC5245、2010年4月、<https：// www .rfc-editor.org / info / rfc5245>. 

[RFC5506] Johansson、I. およびM. Westerlund、「Reduced-Size Real-Time Transport Control Protocol（RTCP）：Opportunities and Consequences」、RFC 5506、DOI 10.17487 / RFC5506、2009年4月、<https：// www .rfc-editor.org / info / rfc5506>. 

[RFC5576] Lennox、J.、Ott、J. 、およびT. Schierl、「Session Description Protocol（SDP）のソース固有のメディア属性」、RFC 5576、DOI 10.17487 / RFC5576、2009年6月、<https：// www.rfc-editor.org/info/rfc5576>. 

[RFC5763] Fischl、J.、Tschofenig、H. 、およびE. Rescorla、「Datagram Transport Layer Security（DTLS）を使用したセキュアなリアルタイムトランスポートプロトコル（SRTP）セキュリティコンテキストを確立するためのフレームワーク」、RFC 5763、DOI 10.17487 / RFC5763、2010年5月、<https://www.rfc-editor.org/info/rfc5763>. 

[RFC5764] McGrew、D. およびE. Rescorla、「Secure Real-time Transport Protocol（SRTP）のキーを確立するためのデータグラムトランスポート層セキュリティ（DTLS）拡張」、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、<https ：//www.rfc-editor.org/info/rfc5764>. 

[RFC6464] Lennox、J.、Ed. 、Ivov、E. 、およびE. Marocco、「クライアントからミキサーへのオーディオレベル表示のた​​めのリアルタイム転送プロトコル（RTP）ヘッダー拡張」、RFC 6464、DOI 10.17487 / RFC6464、2011年12月、<https://www.rfc-editor.org/info/rfc6464>. 

[RFC6544] Rosenberg、J.、Kerenen、A.、Lowekamp、B. 、およびA. Roach、「インタラクティブ接続確立（ICE）を使用したTCP候補」、RFC 6544、DOI 10.17487 / RFC6544、2012年3月、<https：/ /www.rfc-editor.org/info/rfc6544>. 

[TS26.114] 3GPP TS 26.114 V12.8.0、「第3世代パートナーシッププロジェクト、技術仕様グループサービスとシステムの側面、IPマルチメディアサブシステム（IMS）、マルチメディアテレフォニー、メディアの処理と相互作用（リリース12）」、2014年12月、< http://www.3gpp.org/DynaReport/26114.htm>. 

[W3C.webrtc] Bergkvist、A.、Burnett、D.、Jennings、C.、Narayanan、A.、Aboba、B. 、およびT. Brandstetter、「WebRTC 1.0：ブラウザ間のリアルタイム通信」、World Wide WebコンソーシアムWD WD-webrtc-20170515、2017年5月、<https://www.w3.org/TR/2017/WD-webrtc-20170515/>. 

付録A.付録A
セクション5.8で実行される構文検証では、次のABNF定義のリストが使用されます. 

   +------------------------+------------------------------------------+
   | Attribute              | Reference                                |
   +------------------------+------------------------------------------+
   | ptime                  | [RFC4566] Section 9                      |
   | maxptime               | [RFC4566] Section 9                      |
   | rtpmap                 | [RFC4566] Section 9                      |
   | recvonly               | [RFC4566] Section 9                      |
   | sendrecv               | [RFC4566] Section 9                      |
   | sendonly               | [RFC4566] Section 9                      |
   | inactive               | [RFC4566] Section 9                      |
   | framerate              | [RFC4566] Section 9                      |
   | fmtp                   | [RFC4566] Section 9                      |
   | quality                | [RFC4566] Section 9                      |
   | rtcp                   | [RFC3605] Section 2.1                    |
   | setup                  | [RFC4145] Sections 3, 4, and 5           |
   | connection             | [RFC4145] Sections 3, 4, and 5           |
   | fingerprint            | [RFC8122] Section 5                      |
   | rtcp-fb                | [RFC4585] Section 4.2                    |
   | extmap                 | [RFC5285] Section 7                      |
   | mid                    | [RFC5888] Sections 4 and 5               |
   | group                  | [RFC5888] Sections 4 and 5               |
   | imageattr              | [RFC6236] Section 3.1                    |
   | extmap (encrypt        | [RFC6904] Section 4                      |
   | option)                |                                          |
   | candidate              | [I-D.ietf-mmusic-ice-sip-sdp] Section    |
   |                        | 4.1                                      |
   | remote-candidates      | [I-D.ietf-mmusic-ice-sip-sdp] Section    |
   |                        | 4.2                                      |
   | ice-lite               | [I-D.ietf-mmusic-ice-sip-sdp] Section    |
   |                        | 4.3                                      |
   | ice-ufrag              | [I-D.ietf-mmusic-ice-sip-sdp] Section    |
   |                        | 4.4                                      |
   | ice-pwd                | [I-D.ietf-mmusic-ice-sip-sdp] Section    |
   |                        | 4.4                                      |
   | ice-options            | [I-D.ietf-mmusic-ice-sip-sdp] Section    |
   |                        | 4.6                                      |
   | msid                   | [I-D.ietf-mmusic-msid] Section 2         |
   | rid                    | [I-D.ietf-mmusic-rid] Section 10         |
   | simulcast              | [I-D.ietf-mmusic-sdp-simulcast] Section  |
   |                        | 6.1                                      |
   | tls-id                 | [I-D.ietf-mmusic-dtls-sdp] Section 4     |
   +------------------------+------------------------------------------+

                       Table 1: SDP ABNF References


付録B.変更ログ
RFCエディタへの注意：公開する前にこのセクションを削除してください. 

ドラフト26の変更：

o m = proto値の生成に関するガイダンスを更新して、ice-sip-sdpと一貫性を持たせる. 

ドラフト25の変更：

oofferとanswerからMSIDトラックIDを削除します. 

o BUNDLEグループのすべてのm =セクションを拒否することに関するメモを追加します. 

o ICEの参照をRFC 8445に更新し、ice2に言及します. 

ドラフト24の変更：

oアスペクト比を維持しようとする場合、丸めが許可されることを明確にします. 

o dtls-sdpで指定されたものと一致するようにtls-id処理を更新します. 

ドラフト23の変更：

oロールバック処理を明確にし、他のsetLocal / setRemoteの使用法と同様に扱います. 

o複数のリモートa = imageattr属性を処理するための最初のポリシーを採用します. 

o m =セクションがゼロのセッションの説明が正当であることを明確にします. 

ドラフト22の変更：

o currentDirectionと方向を明確にします. 

oセッションIDテキストを修正して、RFC 3264に合わせます. 

o生成されたICE候補オブジェクトには4つのフィールドがすべて必要であることを明確にします. 

o setLocalDescriptionまたはsetRemoteDescriptionが使用されているかどうかに関係なく、安定状態以外の任意の状態からロールバックを機能させます. 

oofferまたはanswerを送信する前または受信した後にSDPを変更することを許可します（以前は、これはanswerに対して禁止されていました）. 

oいくつかの設計上の選択の根拠を提供します. 

ドラフト21の変更：

o dtls-idをtls-idに変更して、MMUSICドラフトに一致させます. 

o protoフィールドの正規表現をリストに置き換え、answerがofferに正確に一致する必要があることを明確にします. 

oローカルの説明は変更できないため、setLocalのエラーチェック方法に関するテキストを削除します. 

oサイレンス抑制のサポートをやり直して、常に双方がサイレンス抑制に同意するか、何も使用しないようにする. 

o「a = ssrc-group」を解析するための指示を削除します. 

oanswerおよび後続のofferでの新しいコーデックの追加を許可します. 

o imageattr処理を明確にします. [x = 0、y = 0]の使用を方向指示器に置き換えます. 

o初期メディアが発生する可能性がある場合は文書化します. 

oバンドルのみが使用されている場合のICEのデフォルトポート処理を修正しました. 

oバンドルしているときは、IDENTICAL / TRANSPORT属性の重複を禁止します. 

oバンドルが含まれる場合に収集するコンポーネントの数を明確にします. 

o PTおよびSSRCがデマルチプレクサに使用されることを明示的に述べます. 

o「a = setup」行のガイダンスを更新します. これはMMUSICドラフトと一致するはずです. 

o証明書/ダイジェストのマッチングに関するガイダンスをRFC8122に準拠するように更新します. 

o例を更新します. 

ドラフト20の変更：

o付録Bを削除します. 

ドラフト19の変更：

o正確性のために例がマシン生成され、IETF承認の例のIPアドレスを使用します. 

o初期のトランスポートウォームアップの例を追加し、既存の例に不足している属性を追加します. 

o新しいm =セクションでのみ「a = rtcp-mux-only」と「a = bundle-only」を送信します. 

o参照を更新します. 

o a = identityのカバレッジを追加します. 

oリップシンクグループアルゴリズムをより詳しく説明します. 

o MTI仕様の不要なリストを削除します. 

o提供されなかったコーデックをanswerに表示することを許可し、その後のofferに表示するように選択されなかったコーデックを許可します. 

oコーデック設定は、最初とその後のofferとanswerの両方に適用されるようになりました. 

o recvonly m =セクションのa = msid処理を明確化. 

oバンドルのみのデータチャネルの属性の動作を明確にします. 

oすべてのメディアm =セクションがバンドルのみの場合、メディアm =セクションにメディア属性を表示できるようにします. 

o JSEP実装に一貫した用語を使用します. 

o失敗したAPI呼び出しを処理する方法を説明します. 

oルーティングルールのクリーンアップ. 

ドラフト18の変更：

o demuxアルゴリズムを更新し、それをBUNDLEにマージする準備として付録に移動します. 

oサイマルキャストを送信するための着信offerを処理できない理由を明確にします. 

o IceCandidateオブジェクトのテキストを展開します. 

o ICE候補プールの使用に関する文書化. 

o removeTrackドキュメント. 

o要件を更新して、最後に生成されたoffer/answerのみをsetLocalDescriptionの引数として受け入れるようにします. 

o丸いピクセルを許可します. 

o AVPFが指定されていない場合のデフォルトのタイミング周辺のコードを修正します. 

o m =行とm =セクションの前後の用語を整理します. 

o最小限のデコーダー機能のより現実的な例を提供します. 

o rtcp-muxポリシーが必要であるが、rtcp-mux属性が指定されていない場合の動作を文書化します. 

o RtpSenderとRtpReceiverの議論の拡張. 

o RtpTransceiver.currentDirectionとドキュメントsetDirectionを追加します. 

o有効な解像度がないことを示すには、imageattr x = 0、y = 0が必要です. 

oプライバシーを保護するMID / RID構造が必要です. 

o RFC 3556帯域幅修飾子のサポートが必要です. 

o maxptimeの説明を更新します. 

oエンドポイントは、answerおよび非JSEPピアからの後続のofferで追加のコーデックに遭遇する場合があることに注意してください. 

o参照を更新します. 

ドラフト17の変更：

o createOfferセクションとcreateAnswerセクションを分割して、常に表示され、別のm =セクションにバンドルされていない場合にのみ表示される属性を明確に示します. 

o RtpTransceiverメソッドの説明を追加します. 

o RTCPフィードバック属性の処理方法を説明してください. 

oトランシーバーの方向と3264との相互作用を明確にします. 

o setCodecPreferencesについて説明します. 

o RTP demuxアルゴリズムを更新します. RTCPを含めます. 

o a = rtcpが含まれる場合の要件を更新し、下位互換性のために必要な場合に限定します. 

o SAR処理を明確にします. 

o更新されたaddTrackマッチングアルゴリズム. 

o a = ssrc要件を削除します. 

o reoffersでa = setupを処理します. 

o RTX / FECの処理方法について話し合います. 

o電話イベントの処理方法について話し合います. 

o CN / DTXの処理方法について話し合います. 

o欠落している参照をABNFテーブルに追加します. 

ドラフト16の変更：

o addIceCandidateを更新して、ICEの生成を示し、m =セクションごとに候補の終わりを許可します. 

o指紋処理を更新して、draft-ietf-mmusic-4572-updateを使用します. 

o RTPヘッダー拡張とペイロード形式のSDP処理に関するテキストを更新します. 

o simulcast、addTransceiver、およびcreateDataChannelにセクションを追加します. 

oテキストを明確にして、セッションIDが63ビットの正の整数であることを確認します. 

o方向指示のためのSDP処理を明確にします. 

o rtcp-mux-onlyのSDP処理について説明します. 

o SDPセッションのバージョンをo =行で指定します. 

o再提供を行う場合、新しいセッションの機能は、以前にネゴシエートされたセッションのサブセットであることがほとんど必要です. 

oバンドルのみとのICE再起動の相互作用を明確にしました. 

o setLocalDescriptionを呼び出す前に、SDPの変更のサポートを削除します. 

o MID、PT、およびSSRCに基づいてRTPを逆多重化するアルゴリズムを指定します. 

oバンドルポリシーが平衡または最大バンドルの場合にm =行を拒否するためのルールを明確化します. 

ドラフト15の変更：

o交渉された内容を参照するために、後続のトランザクションで提供されるコーデックに関するテキストを明確にします. 

o LSの処理テキストを書き換えて、エッジケースを示し、私たちが一緒に暮らしていることを示します. 

o共通のコーデックがない場合、answer者がm =行を拒否することを要求します. 

ooffer処理に最大バンドルを適用します. 

oビット対キロビットを処理するようにTIAS式を修正します. 

o addTrackアルゴリズムについて説明します. 

o参照をクリーンアップします. 

ドラフト14の変更：

o RtpTransceivers + RtpSenders + RtpReceivers、およびそれらがcreateOffer / createAnswerとどのように相互作用するかについての説明を追加しました. 

o廃止されたOfferToReceiveXオプションを削除しました. 

o addIceCandidateを候補者の終わりに使用する方法を説明しました. 

ドラフト13の変更：

o無視できるSDPラインを明確にしました. 

o受け取ったさまざまな属性の処理方法を明確にしました. 

oバンドルされたm =行の属性を生成する方法を修正しました. 

o未使用の参照を削除します. 

o一方的なPTの使用を支持するテキストを削除します. 

o ICE候補のポリシーがより厳格化されている場合でも、ICEの再起動をトリガーします. 

o「公開」ICE候補ポリシーを削除します. 

o未解決の問題をGitHubの問題に移動します. 

oローカル/リモートの記述アクセサを現在/保留に分割します. 

o a = imageattrの取り扱いを明確化. 

o VoiceActivityDetection処理の詳細を追加します. 

o参照ドラフト-shieh-rtcweb-ip-handling. 

o ICEの再起動が発生するタイミングを明確にします. 

o参照に必要な変更を解決します. 

o MSIDセマンティクスを削除します. 

o ice-optionsがセッションレベルになりました. 

oデフォルトのRTCPマルチプレクサポリシーが「必須」になりました. 

ドラフト12の変更：

oローカルおよびリモートの説明の適用に関するセクションに記入. 

o imageattr要件を満たすためのダウンスケーリングとアップスケーリングについて説明しました. 

oアプリケーションが変更できるSDPを更新しました. 

o最新のデータチャネルSDPに更新されました. 

o複数の指紋線を許可しました. 

oダミー候補のIPv4に切り替えました. 

o ICEのデフォルト候補について、さらに明確化しました. 

ドラフト11の変更：

o RTP CNAMEの取り扱いを明確にしました. 

o処理または無視する必要があるSDPラインを更新しました. 

o a = imageattrの使用方法を指定しました. 

ドラフト10の変更：

o imageattrとのビデオサイズネゴシエーションについて説明しました. 

oマルチプレクサのみを持たないセクションの拒否を明確にしました. 

o LSグループの処理を追加

ドラフト09の変更：

o close（）の後で{local、remote} Descriptionにnullを返さないでください. 

o RTPプロファイル名のTCP / TLSをUDP / DTLSに変更しました. 

oバンドルとマルチプレクサポリシーを分離します. 

o FECメカニズムへの特定の参照を追加しました. 

o canTrickleメカニズムが追加されました. 

o以降のanswerとanswerオプションに関するセクションを追加しました. 

o set {Local、Remote} Descriptionの動作を定義するテキストを追加しました. 

ドラフト08の変更：

o付録の新しい例のセクションを追加し、古い例を削除しました. 

o <proto>フィールドの処理を修正しました. 

o a = rtcp属性を説明するテキストを追加しました. 

o IETF 90でのディスカッションごとに、OfferToReceiveAudioとOfferToReceiveVideoの処理を作り直しました. 

oトリクルICEの処理を再調整し、その間のディスカッションごとのm =およびc =行への影響. 

o max-bundle-and-rtcp-muxポリシーを追加しました. 

o maxptime処理の説明を追加しました. 

o ICE候補プールのデフォルトを0に更新しました. 

o AppID / receiver-IDに関する未解決の問題を解決しました. 

o ICE構成への変更の処理方法を作り直し、拡張しました. 

oいくつかの参照の更新. 

o編集の明確化. 

ドラフト07の変更：

o VADとOpus DTXの拡張された議論. 

oセキュリティに関する考慮事項のセクションを追加しました. 

o SDPの変更に関するセクションを書き直し、特定の変更が許可されているかどうかを明確に示す実装を要求する. 

oローカルoffer状態のIceOffstartがCreateOfferに与える影響を明確にしました. 

o属性をメディアレベルとセッションレベルのどちらで定義するかに関するガイダンス. 

o「デフォルト」バンドルポリシーの名前を「バランス」に変更しました. 

oデフォルトのICE候補プールサイズを削除し、その機能を明確にしました. 

o MSTをm =行に割り当てるための標準的な順序を定義しました. 

o水分補給の説明を削除しました. 

oドラフトエディターとしてEric Rescorlaを追加しました. 

o参照をクリーンアップしました. 

o編集のクリーンアップ

ドラフト-06の変更：

o m =ラインリサイクルの処理を再調整. 

o BUNDLEおよびbundle-onlyの処理が追加されました. 

oロールバックの取り扱いを明確にしました. 

o ICE候補プールとその動作を説明するテキストを追加しました. 

o OfferToReceiveXが複数のrecvonly m =セクションを作成することを許可しました. 

ドラフト05の変更：

oドキュメントのレビュー中にcreateOffer / Answerセクションで特定されたいくつかの問題を修正しました. 

o参照を更新しました. 

ドラフト-04の変更：

o createOfferおよびcreateAnswerのセクションに記入. 

o SDPの例を追加しました. 

o修正された参照. 

ドラフト-03の変更：

o W3C仕様との関係を説明するテキストを追加

ドラフト-02の変更：

o nroffから変換

oワーキンググループによって放棄された古いアプローチとの比較を削除

o W3C仕様に移行したものを削除

o SDP処理をW3Cドラフトに合わせる

oフォークに関するセクションを明確にしました. 

ドラフト-01の変更：

oアーキテクチャとステートマシンの図を追加. 

oフォークと再水和に関するセクションを追加. 

o「pranswer」と「answer」の意味を明確にしました. 

o ICEの再起動とメディアの方向の制御方法を作り直しました. 

o説明で変更できるパラメーターのリストを追加しました. 

o最新の考え方に一致するように、offerされたAPIと例を更新しました. 

o推奨されるAPIと例は付録に移動しました. 

ドラフトの変更-00：

o draft-uberti-rtcweb-jsep-02から移行. 

著者のアドレス

Justin Uberti Google 747 6th St S Kirkland、WA 98033 USA

   メール：justin@uberti.name
        
Cullen Jennings Cisco 400 3rd Avenue SW Calgary、AB T2P 4H2 Canada

   メール：fluffy@iii.ca
        
Eric Rescorla（編集者）Mozilla 331 Evelyn Ave Mountain View、CA 94041 USA

   メール：ekr@rtfm.com
        