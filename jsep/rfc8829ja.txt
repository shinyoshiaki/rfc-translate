RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
8829
RFC 8829-JavaScriptセッション確立プロトコル（JSEP）日本語訳
URL：https：//tools.ietf.org/html/rfc8829
パッケージ：RFC 8829-JavaScriptセッション確立プロトコル（JSEP）
翻訳：自動翻訳
インターネットエンジニアリングタスクフォース（IETF）J. Uberti
コメントのリクエスト：8829 Google
カテゴリ：標準化過程C.ジェニングス
ISSN：2070-1721 Cisco
                                                        E. Rescorla、Ed. 
                                                                 Mozilla
                                                            2021年1月
        
JavaScriptセッション確立プロトコル（JSEP）

概要

このドキュメントでは、JavaScriptアプリケーションがW3C RTCPeerConnection APIで指定されたインターフェイスを介してマルチメディアセッションのシグナリングプレーンを制御できるようにするメカニズムについて説明し、これが既存のシグナリングプロトコルとどのように関連するかについて説明します. 

このメモのステータス

これはインターネット標準化過程の文書です. 

このドキュメントは、インターネット技術特別調査委員会（IETF）の製品です. これは、IETFコミュニティのコンセンサスを表しています. パブリックレビューを受け、Internet Engineering Steering Group（IESG）による公開が承認されました. インターネット標準の詳細については、RFC7841のセクション2を参照してください. 

このドキュメントの現在のステータス、正誤表、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8829で入手できます. 

著作権表示

Copyright（c）2021 IETFTrustおよびドキュメントの作成者として識別された人物. 全著作権所有. 

このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります. これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます. 

目次

   1.  Introduction
     1.1.  General Design of JSEP
     1.2.  Other Approaches Considered
     1.3.  Contradiction regarding bundle-only "m=" sections
   2.  Terminology
   3.  Semantics and Syntax
     3.1.  Signaling Model
     3.2.  Session Descriptions and State Machine
     3.3.  Session Description Format
     3.4.  Session Description Control
       3.4.1.  RtpTransceivers
       3.4.2.  RtpSenders
       3.4.3.  RtpReceivers
     3.5.  ICE
       3.5.1.  ICE Gathering Overview
       3.5.2.  ICE Candidate Trickling
         3.5.2.1.  ICE Candidate Format
       3.5.3.  ICE Candidate Policy
       3.5.4.  ICE Candidate Pool
       3.5.5.  ICE Versions
     3.6.  Video Size Negotiation
       3.6.1.  Creating an imageattr Attribute
       3.6.2.  Interpreting imageattr Attributes
     3.7.  Simulcast
     3.8.  Interactions with Forking
       3.8.1.  Sequential Forking
       3.8.2.  Parallel Forking
   4.  Interface
     4.1.  PeerConnection
       4.1.1.  Constructor
       4.1.2.  addTrack
       4.1.3.  removeTrack
       4.1.4.  addTransceiver
       4.1.5.  onaddtrack Event
       4.1.6.  createDataChannel
       4.1.7.  ondatachannel Event
       4.1.8.  createOffer
       4.1.9.  createAnswer
       4.1.10. SessionDescriptionType
         4.1.10.1.  Use of Provisional Answers
         4.1.10.2.  Rollback
       4.1.11. setLocalDescription
       4.1.12. setRemoteDescription
       4.1.13. currentLocalDescription
       4.1.14. pendingLocalDescription
       4.1.15. currentRemoteDescription
       4.1.16. pendingRemoteDescription
       4.1.17. canTrickleIceCandidates
       4.1.18. setConfiguration
       4.1.19. addIceCandidate
       4.1.20. onicecandidate Event
     4.2.  RtpTransceiver
       4.2.1.  stop
       4.2.2.  stopped
       4.2.3.  setDirection
       4.2.4.  direction
       4.2.5.  currentDirection
       4.2.6.  setCodecPreferences
   5.  SDP Interaction Procedures
     5.1.  Requirements Overview
       5.1.1.  Usage Requirements
       5.1.2.  Profile Names and Interoperability
     5.2.  Constructing an Offer
       5.2.1.  Initial Offers
       5.2.2.  Subsequent Offers
       5.2.3.  Options Handling
         5.2.3.1.  IceRestart
         5.2.3.2.  VoiceActivityDetection
     5.3.  Generating an Answer
       5.3.1.  Initial Answers
       5.3.2.  Subsequent Answers
       5.3.3.  Options Handling
         5.3.3.1.  VoiceActivityDetection
     5.4.  Modifying an Offer or Answer
     5.5.  Processing a Local Description
     5.6.  Processing a Remote Description
     5.7.  Processing a Rollback
     5.8.  Parsing a Session Description
       5.8.1.  Session-Level Parsing
       5.8.2.  Media Section Parsing
       5.8.3.  Semantics Verification
     5.9.  Applying a Local Description
     5.10. Applying a Remote Description
     5.11. Applying an Answer
   6.  Processing RTP/RTCP
   7.  Examples
     7.1.  Simple Example
     7.2.  Detailed Example
     7.3.  Early Transport Warmup Example
   8.  Security Considerations
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  SDP ABNF Syntax
   Acknowledgements
   Authors' Addresses

1.はじめに
このドキュメントでは、W3C Webリアルタイム通信（WebRTC）RTCPeerConnectionインターフェイス[W3C.webrtc]を使用して、マルチメディアセッションのセットアップ、管理、およびティアダウンを制御する方法について説明します. 

1.1. JSEPの一般的な設計
WebRTC呼び出しのセットアップは、メディアプレーンの制御に重点を置いて設計されており、シグナリングプレーンの動作は可能な限りアプリケーションに任せています. 理論的根拠は、異なるアプリケーションが、既存のSIPコールシグナリングプロトコルなどの異なるプロトコル、またはおそらく新しいユースケースのために特定のアプリケーションにカスタムなものを使用することを好む可能性があるということです. このアプローチでは、交換する必要のある重要な情報はマルチメディアセッションの説明です. これは、メディアプレーンを確立するために必要なトランスポートおよびメディア構成情報を指定します. 

これらの考慮事項を念頭に置いて、このドキュメントでは、JavaScriptからシグナリングステートマシンを完全に制御できるJavaScriptセッション確立プロトコル（JSEP）について説明します. 上記のように、JSEPは、JavaScriptアプリケーションがWebRTC APIを含むランタイム内で実行されるモデル（「JSEP実装」）を想定しています. JSEPの実装は、コアシグナリングフローからほぼ完全に切り離されています. コアシグナリングフローは、代わりに2つのインターフェイスを使用するJavaScriptによって処理されます. （1）ローカルおよびリモートセッションの説明を渡すことと、（2）Interactive Connectivity Establishment（ICE）状態と対話することです. マシン[RFC8445]. JSEP実装とJavaScriptアプリケーションの組み合わせは、このドキュメント全体で「JSEPエンドポイント」と呼ばれます. 

このドキュメントでは、JSEPの使用は、2つのJSEPエンドポイント間で常に発生するかのように説明されています. ただし、多くの場合、実際にはJSEPエンドポイントと、ゲートウェイやマルチポイントコントロールユニット（MCU）などのある種のサーバーの間にあることに注意してください. この違いは、JSEPエンドポイントには表示されません. APIを介して与えられた指示に従うだけです. 

JSEPのセッション記述の処理は単純で簡単です. オファー/アンサー交換が必要な場合は常に、開始側がcreateOfferAPIを呼び出してオファーを作成します. 次に、アプリケーションはそのオファーを使用して、setLocalDescriptionAPIを介してローカル構成をセットアップします. オファーは最終的に、優先されるシグナリングメカニズム（WebSocketなど）を介してリモート側に送信されます. そのオファーを受信すると、リモートパーティはsetRemoteDescriptionAPIを使用してオファーをインストールします. 

オファー/アンサー交換を完了するために、リモートパーティはcreateAnswer APIを使用して適切なアンサーを生成し、setLocalDescription APIを使用してそれを適用し、シグナリングチャネルを介してイニシエーターにアンサーを送り返します. イニシエーターがその回答を取得すると、setRemoteDescription APIを使用してインストールし、初期セットアップが完了します. このプロセスは、追加のオファー/アンサー交換のために繰り返すことができます. 

ICE [RFC8445]に関して、JSEPはICEステートマシンをシグナリングステートマシン全体から切り離します. ICEステートマシンは、JSEP実装にとどまる必要があります. これは、実装だけが候補やその他のトランスポート情報について必要な知識を持っているためです. この分離を実行すると、セッションの説明をトランスポートから分離するプロトコルに柔軟性が追加されます. たとえば、従来のSIPでは、各オファーまたはアンサーは、セッションの説明とトランスポート情報の両方を含め、自己完結型です. ただし、[RFC8840]では、SIPをTrickle ICE [RFC8838]で使用できます. この場合、セッションの説明をすぐに送信でき、使用可能な場合はトランスポート情報を送信できます. トランスポート情報を個別に送信すると、ICEとDTLSの起動を高速化できます. ICEチェックは、すべてのトランスポート情報を待つのではなく、トランスポート情報が利用可能になるとすぐに開始できるためです. JSEPのICEとシグナリングステートマシンの分離により、JSEPはどちらのモデルにも対応できます. 

シグナリングを抽象化しますが、JSEPアプローチでは、アプリケーションがシグナリングプロセスを認識している必要があります. アプリケーションは、呼び出しを設定するためにセッションの説明の内容を理解する必要はありませんが、アプリケーションは適切なAPIを適切なタイミングで呼び出し、セッションの説明とICE情報を選択したシグナリングプロトコルの定義済みメッセージに変換して、実行する必要があります. 反対側から受信したメッセージの逆変換. 

アプリケーションの作業を楽にする1つの方法は、この複雑さを開発者から隠すJavaScriptライブラリを提供することです. このライブラリは、ステートマシンとシリアル化コードとともに、特定のシグナリングプロトコルを実装し、アプリケーション開発者に高レベルの呼び出し指向のインターフェイスを提供します. たとえば、ライブラリは、JSEPAPI上にSIP [RFC3261]およびExtensibleMessaging and Presence Protocol（XMPP）[RFC6120]シグナリングプロトコルの実装を提供するために存在します. したがって、JSEPは、初心者の開発者に追加の複雑さを強いることなく、経験豊富な開発者により優れた制御を提供します. 

1.2. 考慮される他のアプローチ
JSEPの代わりに検討された1つのアプローチは、軽量のシグナリングプロトコルを含めることでした. APIにセッションの説明を提供する代わりに、APIはこのプロトコルからメッセージを生成および消費します. より高レベルのAPIを提供する一方で、これによりJSEP実装内のシグナリングの制御が強化され、シグナリンググレアなどの概念を理解して処理する必要があります（[RFC3264]、セクション4を参照）. 

検討されたが選択されなかった2番目のアプローチは、メディア制御オブジェクトの管理をセッション記述から切り離し、代わりに各コンポーネントを直接制御するAPIを提供することでした. これは、このレベルの複雑さをアプリケーションプログラマーに公開することは有益ではないという議論に基づいて却下されました. その結果、（1）単純な例でも必要なすべての対話を調整するために大量のコードが必要になるAPIが生成され、（2）合意して文書化する必要がある大きなAPIサーフェスが作成されます. さらに、これらのAPIポイントは任意の順序で呼び出すことができるため、セッションの説明を評価および適用する方法を指定するJSEPアプローチよりも、メディアサブシステムとの対話のセットが複雑になります. 

検討されたJSEPの1つのバリエーションは、基本的なセッション記述指向のAPIを維持することでしたが、オファーとアンサーを生成するためのメカニズムをJSEP実装から移動することでした. このアプローチでは、実装内でcreateOffer / createAnswerメソッドを提供する代わりに、getCapabilities APIを公開します. これにより、独自のセッション記述を生成するために必要な情報がアプリケーションに提供されます. これにより、アプリケーションが実行する必要のある作業量が増加します. 機能からセッションの説明を生成する方法、特に任意のオファーとサポートされている機能から正しい答えを生成する方法を知る必要があります. これは、上記のようなライブラリを使用することで確実に対処できますが、基本的には、単純な例であっても、前述のライブラリの使用を強制します. 

1.3. バンドルのみの「m =」セクションに関する矛盾
WebRTC仕様文書の承認以来、IETFは、JSEPを指定する文書とBUNDLEを指定する文書（それぞれこのRFCと[RFC8843]）の間の不整合に気づきました. 公開をさらに遅らせて解決するのではなく、ドキュメントは最初に承認されたとおりに公開されています. IETFはこれらのテクノロジの作業を再開する予定であり、これらのドキュメントの改訂版は、解決策が利用可能になり次第公開されます. 

特定の問題には、このRFCのセクション4.1.1で説明されているように、バンドルのみとして指定されている「m =」セクションの処理が含まれます. 現在、JSEPとBUNDLEの間、およびこれらの仕様と既存のブラウザー実装の間には相違があります. 

* JSEPは、「m = "セクションはポート0を使用し、最初のオファーでは「a = bundle-only」属性を追加する必要がありますが、回答や後続のオファーでは追加しないように規定しています. 

* BUNDLEは、これらの「m =」セクションは前のポイントで説明したようにマークする必要があると規定していますが、すべてのオファーと回答でマークする必要があります. 

*現在のほとんどのブラウザは、「m =」セクションにポート0のマークを付けず、代わりに、バンドルされているすべての「m =」セクションに同じポートを使用します. 他のいくつかはJSEPの振る舞いに従います. 

2.用語
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」 「このドキュメントでは、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すように、すべて大文字で表示される場合にのみ解釈されます. 

3.セマンティクスと構文
3.1. シグナリングモデル
JSEPは、セッションの両側がセッションの実行方法を知るために、[RFC3264]（オファー/アンサー）で説明されている方法でセッションの説明を交換する一般的な必要性を除いて、特定のシグナリングモデルまたはステートマシンを指定しません. JSEPは、オファーとアンサーを作成し、それらをセッションに適用するためのメカニズムを提供します. ただし、JSEPの実装は、アドレス指定、再送信、フォーク、グレア処理など、これらのオファーとアンサーがリモート側に伝達される実際のメカニズムから完全に切り離されています. これらの問題は完全にアプリケーションに任されています. アプリケーションは、どのオファーとアンサーがいつ実装に渡されるかを完全に制御できます. 

         + ----------- + + ----------- +
         | Webアプリ| <---アプリ固有のシグナリング-> | Webアプリ|
         + ----------- + + ----------- +
               ^ ^
               | SDP | SDP
               VV
         + ----------- + + ----------- +
         | JSEP | <-----------メディア------------> | JSEP |
         | 実装 | | 実装 |
         + ----------- + + ----------- +
        
図1：JSEPシグナリングモデル

3.2. セッションの説明とステートマシン
メディアプレーンを確立するために、JSEP実装には、リモート側に何を送信するか、および受信したメディアをどのように処理するかを示す特定のパラメーターが必要です. これらのパラメーターは、オファーとアンサーのセッションの説明の交換によって決定されます. このプロセスには、JSEPAPIで処理する必要のある特定の詳細があります. 

セッションの説明がローカル側に適用されるかリモート側に適用されるかは、その説明の意味に影響します. たとえば、リモートパーティに送信されるコーデックのリストは、ローカル側が受信する意思があるものを示し、リモート側がサポートするコーデックのセットと交差する場合、リモート側が送信する必要があるものを指定します. ただし、すべてのパラメーターがこの規則に従うわけではありません. 一部のパラメーターは宣言型であり、リモート側はそれらを受け入れるか、完全に拒否する必要があります. このようなパラメータの例は、DTLS [RFC6347]のコンテキストで使用されるTLSフィンガープリント[RFC8122]です. これらのフィンガープリントは、提供されたローカル証明書に基づいて計算され、ネゴシエーションの対象にはなりません. 

さらに、さまざまなRFCは、オファーとアンサーの形式に異なる条件を設定します. たとえば、オファーは任意の数の「m =」セクション（つまり、[RFC4566]のセクション5.14で説明されているメディアの説明）を提案できますが、回答にはオファーとまったく同じ数が含まれている必要があります. 

最後に、正確なメディアパラメータは、オファーと回答が交換された後にのみわかりますが、オファー側はICEチェックを受け取り、場合によってはメディア（接続が確立された後の再オファーの場合）を受け取る可能性があります. 答えを受け取ります. この場合、着信メディアを適切に処理するには、回答が到着する前に、オファー側のメディアハンドラーがオファーの詳細を認識している必要があります. 

したがって、セッション記述を適切に処理するために、JSEP実装には以下が必要です. 

1.セッションの説明がローカル側に関係するのかリモート側に関係するのかを知るため. 

2.セッションの説明がオファーなのかアンサーなのかを知る. 

3.回答とは関係なくオファーを指定できるようにするため. 

JSEPは、setLocalDescriptionメソッドとsetRemoteDescriptionメソッドの両方を追加し、セッション記述オブジェクトに、提供されているセッション記述のタイプを示すタイプフィールドを含めることで、これに対処します. これは、最初にsetLocalDescription（sdp [offer]）を呼び出してから後でsetRemoteDescription（sdp [answer]）を呼び出す提供者と、最初にsetRemoteDescription（sdp [offer]）を呼び出して後でsetLocalDescriptionを呼び出す回答者の両方について上記の要件を満たします.  （sdp [回答]）. 

オファー/アンサー交換中、未処理のオファーは、受け入れられるか拒否される可能性があるため、オファー側とアンサー側で「保留中」と見なされます. これが再オファーである場合、各サイドには、最後のオファー/アンサー交換の結果を反映する「現在の」ローカルおよびリモートの説明もあります. セクション4.1.14、4.1.16、4.1.13、および4.1.15は、保留中および現在の説明の詳細を提供します. 

JSEPでは、回答をアプリケーションによって暫定的なものとして扱うこともできます. 暫定回答は、セッションを開始できるようにすると同時に、最終回答を後で指定できるようにするために、回答者が最初のセッションパラメータを提供者に通知する方法を提供します. 最終回答のこの概念は、オファー/回答モデルにとって重要です. このような応答を受信すると、正確なセッション構成がわかったので、呼び出し元によって割り当てられた追加のリソースを解放できます. これらの「リソース」には、追加のICEコンポーネント、NAT（TURN）候補の周りのリレーを使用したトラバーサル、またはビデオデコーダーなどが含まれます. 一方、暫定的な回答では、そのような割り当て解除は行われません. その結果、独自のコーデックの選択、トランスポートパラメータなどを使用した、複数の異なる暫定的な回答が得られます. 通話のセットアップ中に受信して適用できます. 最終的な回答自体は、受け取った暫定的な回答とは異なる場合があることに注意してください. 

[RFC3264]では、シグナリングレベルでの制約は、特定のセッションで未処理のオファーは1つだけですが、JSEPレベルでは、いつでも新しいオファーを生成できます. たとえば、シグナリングにSIPを使用している場合、1つのオファーが送信され、SIP CANCELを使用してキャンセルされると、最初のオファーに対する応答が受信されなくても、別のオファーが生成される可能性があります. これをサポートするために、JSEPメディアレイヤーは、JavaScriptアプリケーションがシグナリング用にオファーを必要とするときはいつでもcreateOfferメソッドを介してオファーを提供できます. 回答者は、0個以上の暫定的な回答を送り返し、最終的な回答を送信することで、最終的にオファー/回答の交換を終了できます. このためのステートマシンは次のとおりです. 

                       setRemote（OFFER）setLocal（PRANSWER）
                           / ----- \ / ----- \
                           | | | |
                           v | v |
            + --------------- + | + --------------- + |
            | | ---- / | | ---- /
            | 持っている-| setLocal（PRANSWER）| 持っている-|
            | リモートオファー| -------------------> | local-pranswer |
            | | | |
            | | | |
            + --------------- + + --------------- +
                 ^ | |
                 | | setLocal（ANSWER）|
   setRemote（OFFER）| |
                 | V setLocal（ANSWER）|
            + --------------- + |
            | | |
            | | <--------------------------- +
            | 安定|
            | | <--------------------------- +
            | | |
            + --------------- + setRemote（ANSWER）|
                 ^ | |
                 | | setLocal（OFFER）|
   setRemote（ANSWER）| |
                 | V |
            + --------------- + + --------------- +
            | | | |
            | 持っている-| setRemote（PRANSWER）| have- |
            | ローカルオファー| -------------------> | remote-pranswer |
            | | | |
            | | ---- \ | | ---- \
            + --------------- + | + --------------- + |
                           ^ | ^ |
                           | | | |
                           \ ----- / \ ----- /
                       setLocal（OFFER）setRemote（PRANSWER）
        
図2：JSEPステートマシン

これらの状態遷移を除けば、暫定（ "pranswer"）回答と最終（ "answer"）回答の処理に違いはありません. 

3.3. セッションの説明形式
JSEPのセッション記述は、内部表現にSession Description Protocol（SDP）構文を使用します. この形式はJavaScriptからの操作には最適ではありませんが、広く受け入れられており、新しい機能で頻繁に更新されます. セッション記述の代替エンコーディングは、少なくともこの新しいエンコーディングがSDPの人気を上回ったときまで、SDPの変更に対応する必要があります. 

ただし、将来の柔軟性を提供するために、SDP構文はSessionDescriptionオブジェクト内にカプセル化されます. このオブジェクトは、SDPから構築し、SDPにシリアル化できます. 将来の仕様でセッション記述のJSON形式が合意された場合、このオブジェクトがそのJSONを生成して使用できるようにすることが簡単にできます. 

以下で詳しく説明するように、ほとんどのアプリケーションは、これらのさまざまなAPI呼び出しによって生成および消費されるSessionDescriptionsを不透明なblobとして扱うことができるはずです. つまり、アプリケーションはそれらを読み取ったり変更したりする必要はありません. 

3.4. セッション記述制御
さまざまな一般的なセッションパラメータをアプリケーションが制御できるようにするために、JSEPは、セッション記述の生成方法をJSEP実装に指示するコントロールサーフェスを提供します. これにより、ほとんどの場合、JavaScriptがセッションの説明を変更する必要がなくなります. 

これらのオブジェクトを変更すると、後続のcreateOffer / createAnswer呼び出しによって生成されるセッションの説明が変更されます. 

3.4.1. RtpTransceivers
RtpTransceiversを使用すると、アプリケーションは1つの「m =」セクションに関連付けられたRTPメディアを制御できます. 各RtpTransceiverにはRtpSenderとRtpReceiverがあり、アプリケーションはこれらを使用してRTPメディアの送受信を制御できます. アプリケーションは、RtpTransceiverを停止するなどして、直接変更することもできます. 

RtpTransceiversは通常、「m=」セクションと1対1の対応関係にありますが、RtpTransceiversが作成されてもまだ「m=」セクションに関連付けられていない場合や、RtpTransceiversが停止して「m=」セクションとの関連付けが解除されている場合には、「m=」セクションよりも多くのRtpTransceiversが存在する可能性があります。 RtpTransceiversは、そのメディア識別(mid)プロパティが非nullの場合、「m=」セクションに関連付けられているといい、そうでない場合は、関連付けられていないといいます。 Rtpトランシーバーは、そのメディア識別（mid）プロパティが非NULLの場合には、「m=」セクションと関連しているといい、そうでない場合には、関連していないといいます。

RtpTransceiverが複数の「m =」セクションに関連付けられることはありません. セッションの説明が適用されると、「m =」セクションは常に1つのRtpTransceiverにのみ関連付けられます. ただし、以下のセクション5.2.2で説明するように、「m =」セクションが拒否された特定のケースでは、その「m =」セクションは「リサイクル」され、新しいMID値を持つ新しいRtpTransceiverに関連付けられます. 

RtpTransceiversは、アプリケーションによって明示的に作成することも、新しい「m =」セクションを追加するオファーでsetRemoteDescriptionを呼び出すことによって暗黙的に作成することもできます. 

3.4.2. RtpSenders
RtpSendersを使用すると、アプリケーションはRTPメディアの送信方法を制御できます. RtpSenderは、「m =」セクションで記述された発信RTPストリームに対して概念的に責任があります. これには、接続されたMediaStreamTrackのエンコード、RTPメディアパケットの送信、および発信RTPストリームのRTP制御プロトコル（RTCP）の生成/処理が含まれます. 

3.4.3. RtpReceivers
RtpReceiversを使用すると、アプリケーションはRTPメディアの受信方法を検査できます. RtpReceiverは、「m =」セクションで記述された着信RTPストリームに対して概念的に責任があります. これには、受信したRTPメディアパケットの処理、着信ストリームをデコードしてリモートMediaStreamTrackを生成すること、および着信RTPストリームのRTCPを生成/処理することが含まれます. 

3.5. 氷
3.5.1. ICE収集の概要
JSEPは、アプリケーションの必要に応じてICE候補を収集します. ICE候補の収集は収集フェーズと呼ばれ、これは、ローカルセッションの説明に新しいまたはリサイクルされた「m =」セクションが追加されるか、説明に新しいICE資格情報が追加され、ICEの再起動を示すことによってトリガーされます. 新しいICE資格情報の使用は、アプリケーションによって明示的にトリガーすることも、ICE構成の変更に応じてJSEP実装によって暗黙的にトリガーすることもできます. 

新しい収集フェーズを必要とする方法でICE構成が変更されると、「needs-ice-restart」ビットが設定されます. このビットが設定されている場合、createOfferAPIを呼び出すと新しいICE資格情報が生成されます. このビットは、オファーまたはアンサーのいずれかから、つまりローカルまたはリモートで開始されたICE再起動からの新しいICE資格情報を使用したsetLocalDescriptionAPIの呼び出しによってクリアされます. 

新しい収集フェーズが開始されると、ICEエージェントは、状態変更イベントを通じて収集が行われていることをアプリケーションに通知します. 次に、新しいICE候補がそれぞれ利用可能になると、ICEエージェントはonicecandidateイベントを介してそれをアプリケーションに提供します. これらの候補は、現在および/または保留中のローカルセッションの説明にも自動的に追加されます. 最後に、すべての候補者が収集されると、最終的な候補者イベントがディスパッチされ、収集プロセスが完了したことを通知します. 

収集フェーズでは、「m =」セクションの新規/リサイクル/再開に必要な候補のみが収集されることに注意してください. 他の「m =」セクションは、引き続き既存の候補を使用します. また、「m =」セクションがバンドルされている場合（バンドルネゴシエーションの成功またはバンドルのみとしてマークされている場合）、候補が収集され、そのMIDアイテムが「m =」セクションである場合にのみ交換されます.  [RFC8843]で説明されているBUNDLEタグ. 

3.5.2. ICE候補のトリックリング
候補者の細流化は、最初のオファーがディスパッチされた後、発信者が着信者に候補者を段階的に提供するための手法です. 「TrickleICE」のセマンティクスは[RFC8838]で定義されています. このプロセスにより、呼び出し元がすべての可能な候補を収集するのを待たずに、呼び出し先が呼び出しに対応し、ICE（およびおそらくDTLS）接続をすぐにセットアップできるようになります. これにより、通話を開始する前に収集が実行されない場合に、メディアのセットアップが高速になります. 

JSEPは、上記のように、ICE候補収集プロセスの制御とフィードバックを提供するAPIを提供することにより、オプションの候補トリクルをサポートします. 候補者の細流化をサポートするアプリケーションは、最初のオファーをすぐに送信し、新しい候補者の通知を受け取ったときに個々の候補者を送信できます. この機能をサポートしていないアプリケーションは、収集が完了したという表示を待つだけで、その時点ですべての候補者とともにオファーを作成して送信できます. 

騙された候補者を受け取ると、受け取ったアプリケーションはそれらをICEエージェントに提供します. これにより、ICEエージェントは接続チェックに新しいリモート候補の使用を開始します. 

3.5.2.1. ICE候補フォーマット
JSEPでは、ICE候補はIceCandidateオブジェクトによって抽象化され、セッションの説明と同様に、SDP構文が内部表現に使用されます. 

候補の詳細は、[RFC8839]のセクション5.1で定義されている「candidate-attribute」フィールドと同じSDP構文を使用して、IceCandidateフィールドで指定されます. 次の例に示すように、このフィールドには「a =」プレフィックスが含まれていないことに注意してください. 

候補：1 1 UDP 1694498815 192.0.2.33 10000typホスト

IceCandidateオブジェクトには、[RFC8839]のセクション5.4で定義されているように、関連付けられているICEユーザー名フラグメント（ufrag）を示すフィールドが含まれています. この値は、このIceCandidateが属するセッションの説明（およびそれによってどの収集フェーズ）を決定するために使用され、ICEの再起動中のあいまいさを解決するのに役立ちます. 受信したIceCandidateにこのフィールドがない場合（おそらく、JSEP以外のエンドポイントと通信している場合）、最後に受信したセッションの説明が想定されます. 

IceCandidateオブジェクトには、関連付けられている「m =」セクションを示すフィールドも含まれています. これは、「m =」セクションインデックスまたはMIDのいずれかで識別できます. 「m =」セクションインデックスはゼロベースのインデックスであり、インデックスNはこのIceCandidateによって参照されるセッション記述のN +1番目の「m =」セクションを参照します. MIDは、[RFC5888]のセクション4で定義されている「メディアストリーム識別」値であり、関連付けられたRtpTransceiverオブジェクトのMIDを使用して、セッション記述の「m =」セクションを識別するためのより堅牢な方法を提供します. 以下のセクション5.10で説明するように、MID属性をサポートしない非JSEPエンドポイントと対話するときに、アンサーによってローカルに生成された可能性があります. 受信したIceCandidateにMIDフィールドが存在する場合は、識別に使用する必要があります. それ以外の場合は、代わりに「m =」セクションインデックスが使用されます. 

上記のように、いくつかのフィールドが欠落しているオブジェクトを受け取るように実装を準備する必要があります. 

3.5.3. ICE候補ポリシー
通常、ICE候補を収集する場合、JSEP実装は、ホスト、サーバー再帰、およびリレーなど、考えられるすべての形式の初期候補を収集します. ただし、場合によっては、プライバシーまたは関連する懸念事項のために、アプリケーションが収集プロセスをより具体的に制御したい場合があります. たとえば、リレー候補のみを使用して、位置情報の漏洩をできるだけ少なくしたい場合があります（この選択には対応する運用コストが伴うことに注意してください）. これを実現するために、JSEPを使用すると、アプリケーションはセッションで使用されるICE候補を制限できます. [RFC8828]で説明されているように、このフィルタリングは、アプリケーションで許可されるIPアドレスに関して実装が適用することを選択した制限に加えて適用されることに注意してください. 

また、セッションがアクティブなときに、アプリケーションが使用する候補のタイプを変更したい場合もあります. 代表的な例は、発信者が任意の発信者に位置情報を漏らさないように、最初は中継候補のみを使用したいが、ユーザーが取得したいことを示したら、すべての候補を使用するように変更する場合です（運用コストを削減するため）. コール. このシナリオでは、JSEP実装は、前述のローカルポリシーとの相互作用を条件として、セッションの途中で候補ポリシーを変更できるようにする必要があります. 

ICE候補ポリシーを管理するために、JSEP実装は、各収集フェーズの開始時に現在の設定を決定します. 次に、収集フェーズ中に、実装は、現在のポリシーで許可されていない候補をアプリケーションに公開したり、接続チェックのソースとして使用したり、他のICE候補のraddr / rport属性などの他のフィールドを介して間接的に公開したりしてはなりません.  . 後で、アプリケーションによって別のポリシーが指定された場合、アプリケーションは、ICEの再起動を介して新しい収集フェーズを開始することによってそれを適用できます. 

3.5.4. ICE候補プール
JSEPアプリケーションは通常、setLocalDescriptionに提供された情報を介してICE収集を開始するようにJSEP実装に通知します. これは、ローカル記述が必要で候補を収集する必要があるICEコンポーネントの数を示しているためです. ただし、アプリケーションが事前に使用するICEコンポーネントの数を知っている場合を加速するために、迅速なメディアセットアップを保証するために、潜在的なICE候補のプールを収集するように実装に要求する場合があります. 

setLocalDescriptionが最終的に呼び出され、JSEP実装が必要なICE候補を収集する準備をするとき、プールで利用可能な候補があるかどうかを確認することから開始する必要があります. プールに候補者がいる場合は、ICE候補者イベントを介してすぐにアプリケーションに渡す必要があります. 予想よりも多くのICEコンポーネントが使用されているか、プールに候補を収集するのに十分な時間がないためにプールが使い果たされた場合、残りの候補は通常どおり収集されます. これは、最初のオファー/アンサー交換でのみ発生し、その後、候補プールは空になり、使用されなくなります. 

この概念が役立つ一例は、将来のある時点で着信コールを予期し、接続の確立にかかる時間を最小限に抑えて、初期メディアのクリッピングを回避したいアプリケーションです. 候補をプールに事前に収集することにより、コールを受信するとすぐに、これらの候補からの接続チェックを交換して送信を開始できます. ただし、これらの事前に収集された候補を保持することにより、必要な限り存続するため、アプリケーションは使用しているSTUN / TURNサーバー上のリソースを消費することに注意してください. （「STUN」は「NATのセッショントラバーサルユーティリティ」の略です. ）

3.5.5. ICEバージョン
この仕様は正式には[RFC8445]に依存していますが、公開時点では、WebRTC実装の大部分は[RFC5245]で説明されているバージョンのICEをサポートしています. [RFC8445]で定義されている「ice2」属性を使用して、リモートエンドポイントで使用されているバージョンを検出し、古い仕様から新しい仕様へのスムーズな移行を提供できます. 実装は、「ice2」属性を持たないリモート記述を受け入れることができなければなりません. 

3.6. ビデオサイズの交渉
ビデオサイズネゴシエーションは、受信者が「a = imageattr」SDP属性[RFC6236]を使用して、受信可能なビデオフレームサイズを示すことができるプロセスです. 受信機には、ビデオデコーダーが処理できるものに厳しい制限がある場合や、ポリシーによって設定された最大値がある場合があります. 「a = imageattr」属性でこれらの制限を指定することにより、JSEPエンドポイントは、リモート送信者が許容可能な解像度でビデオを送信することを保証しようと試みることができます. ただし、この属性を理解しない非JSEPエンドポイントと通信する場合、通知された制限を超える可能性があり、JSEP実装は、たとえばビデオを破棄することによって、これを適切に処理する必要があります. 

特定のコーデックは、アスペクト比が1.0以外のサンプル（つまり、非正方形ピクセル）の送信をサポートしていることに注意してください. JSEP実装は非正方形ピクセルを送信しませんが、正しいアスペクト比でそのようなビデオを受信して​​レンダリングする必要があります. ただし、サンプルのアスペクト比は、以下で説明するサイズネゴシエーションには影響しません. 正方形かどうかに関係なく、すべての寸法はピクセル単位で測定されます. 

3.6.1. imageattr属性の作成
受信者は、最初に既知のローカル制限（ハードウェアデコーダー機能やローカルポリシーなど）を組み合わせて、受信できる絶対最小サイズと最大サイズを決定します. 既知のローカル制限がない場合は、「a = imageattr」属性を省略する必要があります. これらのローカル制限によってビデオの受信が妨げられる場合、つまり、解像度が許可されていない縮退した場合は、「a = imageattr」属性を省略し、「m =」セクションを必要に応じてsendonly / inactiveとしてマークする必要があります. 

それ以外の場合は、「a = imageattr」属性が「recv」directionで作成され、前述の交点から形成された結果の解像度空間を使用して、最小および最大の「x =」および「y =」値を指定します. 

ここでのルールは単一の設定セットを表すため、「a = imageattr」「q =」の値は重要ではありません. 「1.0」に設定する必要があります. 

「a = imageattr」フィールドはペイロードタイプ固有です. サポートされているすべてのビデオコーデックが同じ機能を備えている場合は、ワイルドカードペイロードタイプ（*）を使用した単一の属性の使用をお勧めします. ただし、サポートされているビデオコーデックに異なる制限がある場合は、ペイロードタイプごとに特定の「a = imageattr」属性を挿入する必要があります. 

例として、48x48から720pまでの任意の解像度をデコードできるマルチフォーマットビデオデコーダーを備えたシステムを考えてみましょう. この場合、実装は次の属性を生成します. 

             a = imageattr：* recv [x = [48：1280]、y = [48：720]、q = 1.0]
        
この宣言は、受信機が48x48から1280x720ピクセルまでの任意の画像解像度をデコードできることを示しています. 

3.6.2. imageattr属性の解釈
[RFC6236]は、「a = imageattr」をアドバイザリフィールドとして定義しています. これは、送信者が使用できるビデオ形式を完全に制限するのではなく、優先値を示すことを意味します. 

この仕様は、より具体的な動作を規定しています. 特定の解像度（「トラック解像度」）のビデオを生成しているMediaStreamTrackが、同じまたはより低い解像度（「エンコーダー解像度」）でトラックビデオをエンコードしているRtpSenderに接続されている場合. 送信者を参照し、有効な「a = imageattr recv」属性を含むリモート記述が適用されます. 送信者が属性で指定されたサイズ基準を超える解像度を送信しないように、以下のルールに従う必要があります. トラックの解像度が変更されたり、別のトラックに置き換えられたりする場合を含め、属性がリモートディスクリプションに存在する限り、これらのルールに従う必要があります. 

RtpSenderの構成方法に応じて、特定の解像度で単一のエンコーディングを生成する場合もあれば、サイマルキャスト（セクション3.7）がネゴシエートされている場合は、それぞれが固有の解像度で複数のエンコーディングを生成する場合もあります. さらに、構成に応じて、各エンコーディングには、必要に応じて解像度を下げる柔軟性がある場合や、特定の出力解像度にロックされる場合があります. 

RtpSenderによって生成されるエンコーディングごとに、リモート記述の対応する「m =」セクションの「a = imageattr recv」属性のセットが処理され、何を送信するかが決定されます. エンコーディング用に選択されたメディアフォーマットを参照する属性のみが考慮されます. このような各属性は、「q =」の値が最も高い属性から始めて個別に評価されます. 複数の属性が同じ「q =」値を持っている場合、それらは含まれている「m =」セクションに表示される順序で評価されます. JSEPエンドポイントには、メディア形式ごとに最大1つの「a = imageattrrecv」属性が含まれますが、JSEPエンドポイントは、複数のそのような属性を含む「m =」セクションを持つ非JSEPエンドポイントからセッションの説明を受け取る場合があることに注意してください. 

「a = imageattrrecv」属性ごとに、次のルールが適用されます. この処理が成功すると、それに応じてエンコーディングが送信され、そのエンコーディングについてそれ以上の属性は考慮されません. それ以外の場合は、次の属性が前述の順序で評価されます. 指定された属性のいずれも正常に処理できない場合は、エンコーディングを送信してはならず、アプリケーションにエラーを発生させる必要があります. 

*属性からの制限は、エンコーダーの解像度と比較されます. 以下に記載されている特定の制限のみが考慮されます. 画像のアスペクト比など、その他の値はすべて無視する必要があります. 回転したビデオを生成しているMediaStreamTrackを検討する場合、チェックには回転していない解像度を使用する必要があります. これは、受信側が受信側の回転の実行をサポートしているかどうかに関係なく（たとえば、ビデオdirectionの調整（CVO）[TS26.114]を介して）、マッチングロジックを大幅に簡素化するために必要です. 

*属性に「1.0」以外に設定された「sar =」（サンプルアスペクト比）値が含まれている場合、受信者が非正方形ピクセルを受信したいことを示します. これは満たすことができず、属性を使用してはなりません. 

*エンコーダの解像度が属性で許可されている最大サイズを超え、エンコーダがその解像度を調整できる場合、エンコーダは制限を満たすためにダウンスケーリングを適用する必要があります. ダウンスケーリングは、丸めによる些細な違いを無視して、エンコーディングの画像のアスペクト比を変更してはなりません（MUSTNOT）. たとえば、エンコーダの解像度が1280x720で、属性が最大640x480を指定している場合、期待される出力解像度は640x360になります. ダウンスケーリングを適用できない場合は、属性を使用しないでください. 

*エンコーダの解像度が属性で許可されている最小サイズよりも小さい場合、属性を使用してはなりません. エンコーダーはアップスケーリングを適用してはなりません（MUSTNOT）. JSEP実装は、おそらくソフトウェアデコーダーへのフォールバックを介して、任意の小さな解像度の受信を許可することにより、この状況を回避する必要があります. 

*エンコーダの解像度が最大サイズと最小サイズの範囲内である場合、アクションは不要です. 

3.7. サイマルキャスト
JSEPは、MediaStreamTrackの同時送信をサポートします. この場合、ソースメディアの複数のエンコーディングを単一の「m =」セクションのコンテキスト内で送信できます. 現在のJSEPAPIは、アプリケーションが同時放送されたメディアを送信できるように設計されていますが、単一のエンコーディングのみを受信できます. これにより、各送信クライアントが複数のエンコーディングをサーバーに送信し、サーバーが受信クライアントごとに適切なエンコーディングを選択して転送するマルチユーザーシナリオが可能になります. 

アプリケーションは、RtpSenderで複数のエンコーディングを構成することにより、サイマルキャストのサポートを要求します. オファーまたはアンサーが生成されると、これらのエンコーディングは、以下で説明するように、対応する「m =」セクションのSDPマーキングを介して示されます. サイマルキャストを理解し、それを受信する意思のある受信者には、サポートを示すSDPマーキングも含まれ、JSEPエンドポイントはこれらのマーキングを使用して、特定のRtpSenderでサイマルキャストが許可されているかどうかを判断します. サイマルキャストのサポートがネゴシエートされていない場合、RtpSenderは最初に構成されたエンコーディングのみを使用します. 

正確なサイマルキャストパラメータは送信アプリケーション次第であることに注意してください. 前述のSDPマーキングは、リモート側が複数のサイマルキャストエンコーディングを受信およびデマルチプレクサできるようにするために提供されていますが、各エンコーディングに使用される特定の解像度とビットレートは、JSEPでは純粋に送信側の決定です. 

JSEPは現在、サイマルキャストの受信を構成するメカニズムを提供していません. つまり、リモートエンドポイントによってサイマルキャストが提供されている場合、JSEPエンドポイントによって生成された応答は、サイマルキャストの受信のサポートを示さないため、リモートエンドポイントは「m =」セクションごとに1つのエンコーディングのみを送信します. 

さらに、JSEPは、JSEPエンドポイントからの同時放送を要求する着信オファーを処理するメカニズムを提供していません. これは、JSEPエンドポイントが最初のオファーを受信した場合にサイマルキャストを設定するには、帯域外シグナリングまたはSDP検査が必要であることを意味します. ただし、JSEPエンドポイントが最初のオファーでサイマルキャストを設定した場合、確立されたサイマルキャストストリームは、着信再オファーを受信して​​も引き続き機能します. この仕様の将来のバージョンでは、着信初期オファーシナリオを処理するためのAPIが追加される可能性があります. 

JSEPを使用してRtpSenderから複数のエンコーディングを送信する場合、[RFC8853]および[RFC8851]の手法が使用されます. 具体的には、RtpSenderに複数のエンコーディングが構成されている場合、RtpSenderの「m =」セクションには、[RFC8853]のセクション5.1で定義されているように、「送信」サイマルキャストストリームの説明とともに「a = simulcast」属性が含まれます. 必要な各エンコーディングをリストし、「recv」サイマルキャストストリームの説明はリストしません. 「m =」セクションには、[RFC8851]のセクション4で指定されているように、各エンコーディングの「a = rid」属性も含まれます. 制限識別子（RID、rid-idsまたはRtpStreamIdsとも呼ばれます）を使用すると、すべて同じ「m =」セクションの一部であっても、個々のエンコーディングを明確にすることができます. 

3.8. フォークとの相互作用
一部のコールシグナリングシステムでは、SDPオファーが複数のデバイスに提供される可能性があるさまざまなタイプの分岐が可能です. たとえば、SIP [RFC3261]は、「並列検索」と「順次検索」の両方を定義します. これらは主にJSEPの範囲外のシグナリングレベルの問題ですが、関連するメディアプレーンの構成にある程度の影響を及ぼします. シグナリングレイヤーでフォークが発生した場合、シグナリングを担当するJavaScriptアプリケーションは、任意の時点で送信または受信するメディアと、通信するリモートエンドポイントを決定する必要があります. JSEPは、メディアエンジンがアプリケーションの要求に応じてRTPとメディアを実行できるようにするために使用されます. アプリケーションがメディアエンジンに実行できる基本的な操作は次のとおりです. 

*特定のリモートピアとのメディア交換を開始しますが、すべてのリソースをオファーで予約したままにします. 

*特定のリモートピアとのメディア交換を開始し、使用されていないオファー内のリソースを解放します. 

3.8.1. シーケンシャルフォーク
シーケンシャルフォークでは、複数のリモート呼び出し先にコールがディスパッチされます. 各呼び出し先はコールを受け入れることができますが、アクティブなセッションは一度に1つしか存在しません. 受信したメディアのミキシングは実行されません. 

JSEPはシーケンシャルフォークを適切に処理するため、アプリケーションは目的のリモートエンドポイントを選択するためのポリシーを簡単に制御できます. 呼び出し先の1人から回答が到着すると、アプリケーションはそれを（1）暫定的な回答として適用するか、将来別の回答を使用する可能性を残しておくか、（2）最終的な回答としてセットアップフローを終了するかを選択できます.  . 

「first-one-wins」の状況では、最初の回答が最終回答として適用され、アプリケーションはそれ以降の回答を拒否します. SIP用語では、これはACK + BYEになります. 

「ラストワンウィン」の状況では、すべての回答が暫定回答として適用され、以前のコールレッグはすべて終了します. ある時点で、アプリケーションはおそらくタイマーを使用してセットアッププロセスを終了します. この時点で、アプリケーションは保留中のリモート記述を最終的な回答として再適用できます. 

3.8.2. Parallel Forking
パラレルフォークでは、複数のリモート呼び出し先にコールがディスパッチされ、各呼び出し先がコールを受け入れることができ、その結果、複数のアクティブなシグナリングセッションを同時に確立できます. 複数の呼び出し先が同時にメディアを送信する場合、これを処理する可能性については、[RFC3960]のセクション3.1で説明されています. 今日のほとんどのSIPデバイスは、一度に1つのデバイスとのメディア交換のみをサポートし、混乱を招く可能性があるため、複数の初期メディアオーディオソースをミキシングしようとはしません. たとえば、ヨーロッパのリングバックトーンを北米のリングバックトーンと混合することを検討してください. 結果として得られるサウンドはどちらのトーンにも似ておらず、ユーザーを混乱させます. シグナリングアプリケーションが一度に1つのリモートエンドポイントとのみメディアを交換することを望む場合、メディアエンジンの観点から、

JavaScriptアプリケーションが複数のピアと同時にメディアを交換したい並列フォークの場合、フローは少し複雑ですが、JavaScriptアプリケーションはUPDATEを使用して[RFC3960]が説明する戦略に従うことができます. UPDATEアプローチにより、シグナリングは、メディアを交換するピアごとに個別のメディアフローを設定できます. JSEPでは、UPDATEで使用されるこのオファーは、新しいPeerConnectionを作成し（セクション4.1を参照）、同じローカルメディアストリームがこの新しいPeerConnectionに追加されていることを確認するだけで形成されます. 次に、新しいPeerConnectionオブジェクトは、[RFC3960]で説明されているUPDATE戦略を実行するためにシグナリングで使用できるSDPオファーを生成します. 

メディアストリームを共有した結果、アプリケーションはN個の並列PeerConnectionセッションになり、それぞれにローカルとリモートの説明、および独自のローカルアドレスとリモートアドレスが含まれます. これらのセッションからのメディアフローは、setDirection（セクション4.2.3を参照）を使用して管理できます. または、アプリケーションは、一緒に混合されたすべてのセッションからメディアを再生することを選択できます. もちろん、アプリケーションが単一のセッションのみを保持したい場合は、不要になったセッションを単に終了することができます. 

4.インターフェース
このセクションでは、JSEP機能を実装するために存在しなければならない基本的な操作について詳しく説明します. W3C APIで公開されている実際のAPIの構文は多少異なる場合がありますが、これらの概念に簡単にマッピングできるはずです. 

4.1. PeerConnection
4.1.1. コンストラクタ
PeerConnectionコンストラクターを使用すると、アプリケーションは、候補を収集するときに使用するSTUN / TURNサーバーと資格情報、初期ICE候補ポリシーとプールサイズ、使用するバンドルポリシーなど、メディアセッションのグローバルパラメーターを指定できます. 

ICE候補ポリシーが指定されている場合、セクション3.5.3で説明されているように機能し、JSEP実装は、許可された候補（実装内部フィルタリングを含む）のみをアプリケーションに表示し、それらの候補のみを接続チェックに使用します. 使用可能なポリシーのセットは次のとおりです. 

all：実装ポリシーで許可されているすべての候補者が収集されて使用されます. 

リレー：リレー候補を除くすべての候補が除外されます. これにより、受信した候補からリモートピアによって確認される可能性のあるロケーション情報が難読化されます. アプリケーションがリレーサーバーを展開および選択する方法によっては、これにより場所がメトロレベルまたは場合によってはグローバルレベルにまでわかりにくくなる可能性があります. 

デフォルトのICE候補ポリシーは「all」に設定する必要があります. これは一般的に望ましいポリシーであり、通常、アプリケーションのTURNサーバーリソースの使用を大幅に削減するためです. 

ICE候補プールにサイズが指定されている場合、これは候補を事前に収集するICEコンポーネントの数を示します. 事前収集の結果、STUN / TURNサーバーのリソースが長期間使用される可能性があるため、これはアプリケーションの要求時にのみ発生する必要があります. したがって、デフォルトの候補プールサイズはゼロである必要があります. 

アプリケーションは、[RFC8843]で定義されている多重化メカニズムであるバンドルの使用に関する優先ポリシーを指定できます. ポリシーに関係なく、アプリケーションは常にバンドルを単一のトランスポートにネゴシエートしようとし、すべての「m =」セクションに単一のバンドルグループを提供します. この単一のトランスポートの使用は、アンサーがバンドルを受け入れることを条件とします. ただし、以下のリストからポリシーを指定することにより、アプリケーションはメディアストリームをバンドルしようとする積極的な方法を正確に制御できます. これは、バンドルに対応していないエンドポイントとの相互運用方法に影響します. バンドルに対応していないエンドポイントとネゴシエートする場合、バンドルのみのストリームとしてマークされていないストリームのみが確立されます. 

使用可能なポリシーのセットは次のとおりです. 

バランス：各タイプ（オーディオ、ビデオ、またはアプリケーション）の最初の「m =」セクションにはトランスポートパラメーターが含まれ、回答者がそのセクションをバンドル解除できるようにします. 各タイプの2番目以降の「m =」セクションは、バンドルのみとしてマークされます. その結果、N個の異なるメディアタイプがある場合、N個のメディアストリームの候補が収集されます. このポリシーは、マルチプレックスへの要望と、従来のケースでも基本的なオーディオとビデオをネゴシエートできるようにする必要性とのバランスを取ります. 回答者として機能するときに、オファーにバンドルグループがない場合、実装は各タイプの最初の「m =」セクションを除くすべてを拒否します. 

max-compat：すべての「m =」セクションにはトランスポートパラメータが含まれます. バンドルのみとしてマークされるものはありません. このポリシーでは、バンドルを認識しないエンドポイントがすべてのストリームを受信できるようにしますが、メディアストリームごとに個別の候補を収集する必要があります. 

max-bundle：最初の「m =」セクションのみにトランスポートパラメータが含まれます. 最初のストリーム以外のすべてのストリームは、バンドルのみとしてマークされます. このポリシーは、レガシーエンドポイントとの互換性を低下させながら、候補の収集を最小限に抑え、多重化を最大化することを目的としています. 回答者として機能する場合、実装は、最初の「m =」セクション以外の「m =」セクションが「m =」セクションと同じバンドルグループにない限り、それらを拒否します. 

パフォーマンスとレガシーエンドポイントとの互換性の間で最良のトレードオフを提供するため、デフォルトのバンドルポリシーを「バランス」に設定する必要があります. 

アプリケーションは、次のいずれかのポリシーを使用して、RTP / RTCP多重化[RFC5761]の使用に関する優先ポリシーを指定できます. 

ネゴシエート：JSEP実装は、RTPとRTCPの両方の候補を収集しますが、「a = rtcp-mux」も提供するため、多重化または非多重化エンドポイントとの互換性が可能になります. 

require：JSEP実装は、RTP候補のみを収集し、生成するオファーの新しい「m =」セクションに「a = rtcp-mux-only」表示を挿入します. これにより、提供者が収集する必要のある候補者の数が半分になります. 「a = rtcp-mux」属性を含まない「m =」セクションを含む説明を適用すると、エラーが返されます. 

デフォルトの多重化ポリシーは「require」に設定する必要があります. 実装は、多重化ポリシーを「ネゴシエート」に設定するアプリケーションによる試行を拒否することを選択できます（MAY）. 

4.1.2. addTrack
addTrackメソッドはMediaStreamTrackをPeerConnectionに追加し、MediaStream引数を使用してトラックを同じMediaStream内の他のトラックに関連付け、オファーまたはアンサーを作成するときに同じ「LS」（リップ同期）グループに追加できるようにします. 同じ「LS」グループにトラックを追加すると、[RFC5888]のセクション7で説明されているように、これらのトラックの再生を同期して適切なリップシンクを行う必要があることを示します. addTrackは、次のようにトランシーバーの数を最小限に抑えようとします.  「have-remote-offer」状態の場合、トラックは、setRemoteDescriptionへの最新の呼び出しによって作成され、ローカルトラックを持たない最初の互換性のあるトランシーバーに接続されます. それ以外の場合は、セクション4.1.4で説明されているように、新しいトランシーバーが作成されます. 

4.1.3. removeTrack
removeTrackメソッドは、RtpSender引数を使用してPeerConnectionからMediaStreamTrackを削除し、トラックを削除する必要がある送信者を示します. 送信者のトラックがクリアされ、送信者は送信を停止します. createOfferを今後呼び出すと、送信者に関連付けられた「m =」セクションがrecvonly（transceiver.directionがsendrecvの場合）またはinactive（transceiver.directionがsendonlyの場合）としてマークされます. 

4.1.4. addTransceiver
addTransceiverメソッドは、新しいRtpTransceiverをPeerConnectionに追加します. MediaStreamTrack引数が指定されている場合、トランシーバーはそのメディアタイプで構成され、トラックはトランシーバーに接続されます. それ以外の場合、アプリケーションはタイプを明示的に指定する必要があります. このモードは、recvonlyトランシーバーを作成する場合や、後でトラックを接続できるトランシーバーを作成する場合に役立ちます. 

作成時に、アプリケーションは、トランシーバーのdirection属性、トランシーバーが関連付けられているMediaStreamのセット（「LS」グループの割り当てを許可）、およびメディアのエンコーディングのセット（で説明されているようにサイマルキャストに使用）を指定することもできます. セクション3.7）. 

4.1.5. onaddtrackイベント
onaddtrackイベントは、setRemoteDescription呼び出しの結果として新しいリモートトラックが通知されたときにアプリケーションにディスパッチされます. 新しいトラックは、トラックが含まれているMediaStreamとともに、イベントのMediaStreamTrackオブジェクトとして提供されます. 

4.1.6. createDataChannel
createDataChannelメソッドは、新しいデータチャネルを作成し、それをPeerConnectionにアタッチします. このPeerConnectionのデータチャネルが現在存在しない場合は、新しいオファー/アンサー交換が必要です. 特定のPeerConnection上のすべてのデータチャネルは同じSCTP / DTLSアソシエーション（「SCTP」は「StreamControl Transmission Protocol」の略）を共有するため、同じ「m =」セクションを共有するため、その後のデータチャネルの作成はJSEP状態. 

createDataChannelメソッドには、PeerConnectionで使用される引数（maxPacketLifetimeなど）もいくつか含まれていますが、SDPには反映されず、JSEPの状態には影響しません. 

4.1.7. ondatachannelイベント
ondatachannelイベントは、新しいデータチャネルがリモート側によってネゴシエートされたときにアプリケーションにディスパッチされます. これは、基になるSCTP / DTLSアソシエーションが確立された後いつでも発生する可能性があります. 新しいデータチャネルオブジェクトがイベントで提供されます. 

4.1.8. createOffer
createOfferメソッドは、[RFC3264]ごとに、このPeerConnectionに追加されたメディアの説明、この実装でサポートされているコーデック、RTP、RTCPオプション、および候補を含む、セッションでサポートされている構成を含むオファーを含むSDPのblobを生成します.  ICEエージェントによって収集されたもの. 生成されたオファーをさらに制御するために、オプションパラメータを指定できます. このオプションパラメータを使用すると、接続を再確立する目的で、アプリケーションがICEの再起動をトリガーできます. 

最初のオファーでは、生成されたSDPには、セッションに必要なすべての機能が含まれます（サポートされているが、デフォルトでは不要な機能は省略できます）. SDPラインごとに、SDPの生成は、指定されたSDPラインを定義する仕様から初期オファーを生成するために定義されたプロセスに従います. 最初のオファー生成の正確な処理については、以下のセクション5.2.1で詳しく説明します. 

セッションの確立後にcreateOfferが呼び出された場合、createOfferは、RtpTransceiversの追加や停止、ICEの再起動の要求など、セッションに加えられた変更に基づいて現在のセッションを変更するオファーを生成します. 既存のストリームごとに、各SDPラインの生成は、指定されたSDPラインを指定するRFCから更新されたオファーを生成するために定義されたプロセスに従う必要があります. SDPの生成は、前述のように、新しいストリームごとに、最初のオファーを生成するプロセスに従う必要があります. 変更が行われていない場合、または要求された変更の影響を受けないSDP回線の場合、オファーには、最後のオファー/アンサー交換によってネゴシエートされたパラメーターのみが含まれます. その後のオファー生成の正確な処理については、以下のセクション5.2.2で詳しく説明します. 

createOfferによって生成されたセッションの説明は、setLocalDescriptionですぐに使用できる必要があります. システムのリソースが限られている場合（たとえば、デコーダーの数が限られている場合）、createOfferはシステムの現在の状態を反映するオファーを返す必要があります. これにより、setLocalDescriptionはそれらのリソースを取得しようとしたときに成功します. 

このメソッドを呼び出すと、新しいICE資格情報の生成などが行われる場合がありますが、PeerConnectionの状態が変更されたり、候補の収集がトリガーされたり、メディアのフローが開始または停止したりすることはありません. 具体的には、setLocalDescriptionが呼び出されるまで、オファーは適用されず、保留中のローカルの説明にはなりません. 

4.1.9. createAnswer
createAnswerメソッドは、setRemoteDescriptionへの最新の呼び出しで提供されたパラメーターと互換性のあるセッションでサポートされている構成で[RFC3264]ごとのSDP回答を含むSDPのblobを生成します. createAnswerを呼び出す前に、setRemoteDescriptionを呼び出す必要があります. createOfferと同様に、返されるblobには、このPeerConnectionに追加されたメディアの説明、このセッションでネゴシエートされたコーデック/ RTP / RTCPオプション、およびICEエージェントによって収集された候補が含まれます. 生成された回答をさらに制御するために、オプションパラメータを指定できます. 

答えとして、生成されたSDPには、メディアプレーンを確立する方法を指定する特定の構成が含まれます. SDPラインごとに、SDPの生成は、指定されたSDPラインを定義する仕様から回答を生成するために定義されたプロセスに従う必要があります. 回答生成の正確な処理については、以下のセクション5.3で詳しく説明します. 

createAnswerによって生成されたセッションの説明は、setLocalDescriptionですぐに使用できる必要があります. createOfferと同様に、返される説明はシステムの現在の状態を反映する必要があります. 

このメソッドを呼び出すと、新しいICE資格情報の生成などが行われる場合がありますが、PeerConnectionの状態が変更されたり、候補の収集がトリガーされたり、メディアの状態が変更されたりすることはありません. 具体的には、setLocalDescriptionが呼び出されるまで、回答は適用されず、現在のローカルの説明にはなりません. 

4.1.10. SessionDescriptionType
セッション記述オブジェクト（RTCSessionDescription）は、「offer」、「pranswer」、「answer」、または「rollback」タイプの場合があります. これらのタイプは、descriptionパラメーターを解析する方法とメディアの状態を変更する方法に関する情報を提供します. 

「オファー」は、説明をオファーとして解析する必要があることを示します. 上記の説明は、多くの可能なメディア構成を含み得る. 「オファー」として使用される説明は、PeerConnectionが「安定」状態にあるときはいつでも適用できます. または、以前に提供されたが未回答の「オファー」の更新として適用できます. 

「pranswer」は、説明を回答として解析する必要があるが、最終的な回答として解析する必要がないことを示します. したがって、割り当てられたリソースが解放されてはなりません. 回答でinactiveなメディアのdirectionが指定されていない場合、メディア送信が開始される可能性があります. 「pranswer」として使用される説明は、「offer」への応答として、または以前に送信された「pranswer」への更新として適用できます. 

「回答」は、説明を回答として解析する必要があり、オファー/回答の交換が完了したと見なす必要があり、不要になったリソース（デコーダー、候補）を解放する必要があることを示します. 「回答」として使用される説明は、「オファー」への応答として、または以前に送信された「pranswer」への更新として適用される場合があります. 

暫定回答と最終回答の唯一の違いは、最終回答により、オファーの結果として割り当てられた未使用のリソースが解放されることです. そのため、アプリケーションは、回答を暫定として適用するか最終として適用するかについてある程度の裁量を使用し、必要に応じてセッションの説明のタイプを変更できます. たとえば、シリアルフォークのシナリオでは、アプリケーションは、各リモートエンドポイントから1つずつ、複数の「最終的な」回答を受け取る場合があります. アプリケーションは、最初の回答を暫定的な回答として受け入れ、基準を満たす回答（ボイスメールではなくライブユーザーなど）を受け取った場合にのみ最終的な回答として適用することを選択できます. 

「ロールバック」は、セクション4.1.10.2で説明されているように、ステートマシンを以前の「安定した」状態にロールバックする必要があることを示す特別なセッション記述タイプです. 内容は空でなければなりません. 

4.1.10.1. 暫定回答の使用
ほとんどのアプリケーションは、「pranswer」タイプを使用して回答を作成する必要はありません. オファーへの即時応答を送信することは良い習慣ですが、セッショントランスポートをウォームアップし、メディアクリッピングを防ぐために、JSEPアプリケーションの推奨される処理は、nullMediaStreamTrackを使用して「送信専用」の最終応答を作成して送信することです. オファーを受信した後. これにより、発信者がメディアを送信できなくなり、着信者が応答するとすぐにメディアを送信できるようになります. 後で、呼び出し先が実際に呼び出しを受け入れると、アプリケーションは実際のMediaStreamTrackをプラグインし、新しい「sendrecv」オファーを作成して、前のオファーと応答のペアを更新し、双directionのメディアフローを開始できます. これは、「sendonly」pranswerの後に「sendrecv」回答を続けることでも実行できますが、

例として、オーディオとビデオをできるだけ早くセットアップしたい典型的なJSEPアプリケーションを考えてみましょう. 呼び出し先がオーディオとビデオのMediaStreamTracksでオファーを受信すると、これらのトラックをsendonlyとして受け入れる即時応答を送信します（つまり、呼び出し元はまだ呼び出し先にメディアを送信せず、呼び出し先はまだ独自のMediaStreamTracksを追加していないため、呼び出し先もメディアを送信しません）. 次に、ユーザーに通話を受け入れて必要なローカルトラックを取得するように求めます. 承認時にアプリケーションは、ユーザーが取得したトラックをプラグインします. これは、ICEハンドシェイクとDTLSハンドシェイクがこの時点で完了している可能性が高いため、すぐに送信を開始できます. アプリケーションはまた、通話の受け入れを示し、オーディオとビデオを双directionメディアに移動することを示す新しいオファーをリモート側に送信します. これらの線に沿った詳細なフローの例は、セクション7.3に示されています. 

もちろん、一部のアプリケーション、特にレガシーシグナリングプロトコルへのゲートウェイを試みているアプリケーションでは、この二重のオファー/アンサー交換を実行できない場合があります. このような場合でも、pranswerは、トランスポートをウォームアップするメカニズムをアプリケーションに提供できます. 

4.1.10.2. ロールバック
特定の状況では、setLocalDescriptionまたはsetRemoteDescriptionに加えられた変更を「元に戻す」ことが望ましい場合があります. 通話が進行中で、一方がセッションパラメータの一部を変更したい場合を考えてみます. その側は更新されたオファーを生成してから、setLocalDescriptionを呼び出します. ただし、リモート側は、setRemoteDescriptionの前または後のいずれかで、新しいパラメーターを受け入れたくないと判断し、拒否メッセージを提供者に送り返します. ここで、提供者、場合によっては回答者も、「安定した」状態と以前のローカル/リモートの説明に戻る必要があります. これをサポートするために、セッションに対して提案された変更を破棄し、ステートマシンを「安定した」状態に戻す「ロールバック」の概念を導入します. 

4.1.11. setLocalDescription
setLocalDescriptionメソッドは、指定されたセッションの説明をローカル構成として適用するようにPeerConnectionに指示します. タイプフィールドは、説明をオファー、暫定回答、最終回答、またはロールバックとして処理する必要があるかどうかを示します. 各SDPラインに存在するさまざまなルールを使用して、オファーとアンサーのチェック方法が異なります. 

このAPIは、ローカルメディアの状態を変更します. 特に、メディアを受信およびデコードするためのローカルリソースを設定します. アプリケーションが1つのメディア形式から別の互換性のない形式への変更を提案するシナリオを正常に処理するには、PeerConnectionは、現在のローカル記述と保留中のローカル記述の両方の使用を同時にサポートできる必要があります（たとえば、存在するコーデックをサポートする）. どちらの説明でも）. この二重処理は、PeerConnectionが「have-local-offer」状態に入ると開始され、setRemoteDescriptionが（1）最終応答で呼び出されるまで続きます. 最終応答で、PeerConnectionは保留中のローカル記述を完全に採用できます. ロールバック. これにより、現在のローカル記述に戻ります. 

このAPIは、候補者の収集プロセスを間接的に制御します. ローカル記述が提供され、現在使用されているトランスポートの数がローカル記述に必要なトランスポートの数と一致しない場合、PeerConnectionは必要に応じてトランスポートを作成し、可能な場合は候補プールからの候補を使用して、各トランスポートの候補の収集を開始します.  . 

（1）setRemoteDescriptionが以前にオファーで呼び出された場合、（2）setLocalDescriptionが応答（暫定または最終）で呼び出された場合、（3）メディアのdirection性に互換性があり、（4）メディアを送信できる場合、次のようになります. メディア送信の開始. 

4.1.12. setRemoteDescription
setRemoteDescriptionメソッドは、指定されたセッションの説明を目的のリモート構成として適用するようにPeerConnectionに指示します. setLocalDescriptionと同様に、説明のタイプフィールドは、その処理方法を示します. 

このAPIは、ローカルメディアの状態を変更します. 特に、メディアを送信およびエンコードするためのローカルリソースを設定します. 

（1）setLocalDescriptionが以前にオファーで呼び出された場合、（2）setRemoteDescriptionが応答（暫定または最終）で呼び出された場合、（3）メディアのdirection性に互換性があり、（4）メディアを送信できる場合、次のようになります. メディア送信の開始. 

4.1.13. currentLocalDescription
currentLocalDescriptionメソッドは、ローカル記述が設定されてからICEエージェントによって生成されたローカル候補に加えて、現在ネゴシエートされたローカル記述（つまり、最後に成功したオファー/アンサー交換からのローカル記述）を返します. 

オファー/アンサー交換がまだ完了していない場合は、nullオブジェクトが返されます. 

4.1.14. 保留中のローカル説明
保留中のLocalDescriptionメソッドは、ローカルディスクリプションが設定されてからICEエージェントによって生成されたローカル候補に加えて、現在ネゴシエーション中のローカルディスクリプションのコピー（つまり、対応するリモート応答のないローカルオファーセット）を返します. 

PeerConnectionの状態が「stable」または「have-remote-offer」の場合、nullオブジェクトが返されます. 

4.1.15. currentRemoteDescription
currentRemoteDescriptionメソッドは、リモート記述が設定されてからprocessIceMessageを介して提供されたリモート候補に加えて、現在ネゴシエートされたリモート記述のコピー（つまり、最後に成功したオファー/アンサー交換からのリモート記述）を返します. 

オファー/アンサー交換がまだ完了していない場合は、nullオブジェクトが返されます. 

4.1.16. 保留中のRemoteDescription
保留中のRemoteDescriptionメソッドは、リモート記述が設定されてからprocessIceMessageを介して提供されたリモート候補に加えて、現在ネゴシエーション中のリモート記述のコピー（つまり、対応するローカル応答のないリモートオファーセット）を返します. 

PeerConnectionの状態が「stable」または「have-local-offer」の場合、nullオブジェクトが返されます. 

4.1.17. canTrickleIceCandidates
canTrickleIceCandidatesプロパティは、リモート側がトリクル候補の受信をサポートするかどうかを示します. 3つの潜在的な値があります. 

null：反対側からSDPを受信して​​いないため、トリクルを処理できるかどうかは不明です. これは、setRemoteDescriptionが呼び出される前の初期値です. 

true：SDPが反対側から受信され、トリクルをサポートできることを示しています. 

false：SDPが反対側から受信され、トリクルをサポートできないことを示しています. 

セクション3.5.2で説明されているように、JSEP実装は常に、Trickle ICEに必要なものと一致して、アプリケーションに個別に候補を提供します. ただし、アプリケーションはcanTrickleIceCandidatesプロパティを使用して、ピアが実際にTrickle ICEを実行できるかどうか、つまり、最初のオファーまたは回答を送信し、後で候補者が集まったときに安全かどうかを判断できます. 「true」はリモートTrickleICEサポートを明確に示す唯一の値であるため、canTrickleIceCandidatesを「true」と比較するアプリケーションは、デフォルトで、最初のオファーでHalf Trickleを試行し、その後のTrickleICE互換エージェントとの対話でFullTrickleを試行します. 

4.1.18. setConfiguration
setConfigurationメソッドを使用すると、コンストラクターパラメーターによって最初に設定されたPeerConnectionのグローバル構成をセッション中に変更できます. このメソッドを呼び出すことの効果は、呼び出されるタイミングによって異なり、変更される特定のパラメーターによって異なります. 

*使用するSTUN / TURNサーバーへの変更は、次の収集フェーズに影響します. ICE収集フェーズがすでに開始または完了している場合は、セクション3.5.1に記載されている「needs-ice-restart」ビットが設定されます. これにより、次のcreateOfferの呼び出しで、ICEの再起動を強制し、新しいサーバーが使用される新しい収集フェーズを開始する目的で、新しいICE資格情報が生成されます. ICE候補プールのサイズがゼロ以外で、ローカル記述がまだ適用されていない場合、既存の候補はすべて破棄され、新しい候補が新しいサーバーから収集されます. 

* ICE候補ポリシーへの変更は、次の収集フェーズに影響します. ICE収集フェーズがすでに開始または完了している場合は、「needs-ice-restart」ビットが設定されます. いずれにせよ、ポリシーの変更は候補プールに影響を与えません. これは、プールされた候補は収集フェーズが発生するまでアプリケーションで使用できないため、プールされた候補に対して必要なフィルタリングを実行できるためです. 

*ローカル記述を適用した後にICE候補プールサイズを変更してはなりません（MUSTNOT）. ローカル記述がまだ適用されていない場合、ICE候補プールサイズへの変更はすぐに有効になります. 増加した場合、追加の候補者が事前に収集されます. 減少した場合、現在は不要な候補は破棄されます. 

*バンドルおよびRTCP多重化ポリシーは、PeerConnectionの構築後に変更してはなりません（MUSTNOT）. 

このメソッドを呼び出すと、ICEエージェントの状態が変わる可能性があります. 

4.1.19. addIceCandidate
addIceCandidateメソッドは、IceCandidateオブジェクトを介してICEエージェントに更新を提供します（セクション3.5.2.1）. IceCandidateの候補フィールドがnullでない場合、IceCandidateは新しいリモートICE候補として扱われ、Trickle ICEに定義されたルールに従って、現在および/または保留中のリモート記述に追加されます. それ以外の場合、IceCandidateは、[RFC8838]のセクション14で定義されているように、候補の終了を示すものとして扱われます. 

いずれの場合も、上記のセクション3.5.2.1で説明したように、提供されたIceCandidateの "m ="セクションインデックス、MID、およびufragフィールドを使用して、IceCandidateが属する "m ="セクションおよびICE候補世代を決定します. 候補の終わりの表示の場合、「m =」セクションインデックスおよびMIDフィールドのnull値は、指定されたICE候補世代のすべての「m =」セクションに表示が適用されることを意味すると解釈されます. ただし、新しいリモート候補に対して両方のフィールドがnullの場合、以下に指定するように、これは無効な条件として扱われる必要があります. 

IceCandidateフィールドに無効な値が含まれている場合、またはIceCandidateオブジェクトの処理中にエラーが発生した場合は、指定されたIceCandidateを無視し、エラーを返す必要があります. 

それ以外の場合は、新しいリモート候補または候補の終了の表示がICEエージェントに提供されます. 新しいリモート候補の場合、ICE収集プロセスを初期化するためにsetLocalDescriptionがすでに呼び出されていると想定して、接続チェックが新しい候補に送信されます. 

4.1.20. onicecandidateイベント
onicecandidateイベントは、次の2つの状況でアプリケーションにディスパッチされます. （1）セクション3.5.1で概説され、セクション3.5.3で説明されている制限に従って、ICEエージェントがICE収集中に新しい許可されたローカルICE候補を検出した場合. または（2）ICE収集フェーズが完了したとき. セクション3.5.2.1で定義されているように、イベントには単一のIceCandidateオブジェクトが含まれています. 

最初のケースでは、新しく検出された候補がIceCandidateオブジェクトに反映され、そのすべてのフィールドがnull以外である必要があります. この候補は、Trickle ICEに定義されたルールに従って、現在および/または保留中のローカル記述にも追加されます. 

2番目のケースでは、イベントのIceCandidateオブジェクトの候補フィールドをnullに設定して、現在の収集フェーズが完了したことを示す必要があります. つまり、このフェーズではこれ以上onicecandidateイベントが発生しません. ただし、IceCandidateのufragフィールドは、どのICE候補生成が終了するかを示すために指定する必要があります. IceCandidateの「m =」セクションインデックスおよびMIDフィールドは、イベントが特定の「m =」セクションに適用されることを示すために指定するか、nullに設定して現在のICE候補世代のすべての「m =」セクションに適用することを示すことができます.  . [RFC8838]のセクション13で定義されているように、このイベントをアプリケーションで使用して、候補の終了を示すことができます. 

4.2. RtpTransceiver
4.2.1. stop
stopメソッドはRtpTransceiverを停止します. これにより、createOfferを今後呼び出すと、関連する「m =」セクションのゼロポートが生成されます. 詳細については、以下を参照してください. 

4.2.2. 停止
停止プロパティは、stopの呼び出しによって、または関連する「m =」セクションを拒否する応答を適用することによって、トランシーバーが停止したかどうかを示します. いずれの場合も「true」に設定され、それ以外の場合は「false」に設定されます. 

停止したRtpTransceiverは、発信RTPまたはRTCPを送信したり、着信RTPまたはRTCPを処理したりしません. 再起動できません. 

4.2.3. setDirection
setDirectionメソッドは、トランシーバーのdirectionを設定します. これは、createOfferおよびcreateAnswerへの今後の呼び出しで関連する「m =」セクションのdirectionプロパティに影響します. directionに許可される値は、「recvonly」、「sendrecv」、「sendonly」、および「inactive」であり、[RFC4566]のセクション6で定義されている同じ名前のdirection属性を反映しています. 

オファーを作成するとき、トランシーバーのdirectionは、再オファーの場合でも、出力に直接反映されます. 回答を作成するとき、以下のセクション5.3で説明するように、トランシーバーのdirectionは提供されたdirectionと交差します. 

setDirectionはトランシーバーのdirectionプロパティをすぐに設定しますが（セクション4.2.4）、このプロパティはトランシーバーのRtpSenderが送信するか受信するかにはすぐには影響しません. 有効なdirectionはcurrentDirectionプロパティで表され、answerが適用されたときにのみ更新されます. 

4.2.4. direction
directionプロパティは、setDirectionに渡された最後の値を示します. setDirectionが呼び出されたことがない場合は、トランシーバーが初期化されたdirectionに設定されます. 

4.2.5. currentDirection
currentDirectionプロパティは、トランシーバーに関連付けられた「m =」セクションの最後にネゴシエートされたdirectionを示します. 具体的には、最後に適用された回答（暫定回答を含む）の関連する「m =」セクションのdirection属性[RFC3264]を示し、リモート回答の場合は「送信」と「受信」のdirectionが逆になります. たとえば、リモート回答の関連する「m =」セクションのdirection属性が「recvonly」の場合、currentDirectionは「sendonly」に設定されます. 

このトランシーバーを参照する回答がまだ適用されていない場合、またはトランシーバーが停止している場合、currentDirectionは「null」に設定されます. 

4.2.6. setCodecPreferences
setCodecPreferencesメソッドは、トランシーバーのコーデックプリファレンスを設定します. これは、createOfferおよびcreateAnswerへの今後の呼び出しで関連する「m =」セクションのコーデックの存在と順序に影響します. setCodecPreferencesは、実装が送信することを決定したコーデックに直接影響しないことに注意してください. これは、実装がオファーまたはアンサーを介して受信することを好むことを示すコーデックにのみ影響します. コーデックがsetCodecPreferencesによって除外されている場合でも、次のオファー/アンサー交換でコーデックが破棄されるまで、コーデックを使用して送信できます. 

RtpTransceiverのコーデック設定により、createOfferおよびcreateAnswerの後続の呼び出しによってコーデックが除外される可能性があります. その場合、関連する「m =」セクションの対応するメディア形式が除外されます. コーデック設定では、他の方法では存在しないメディア形式を追加できません. 

RtpTransceiverのコーデック設定では、createOfferおよびcreateAnswerの後続の呼び出しでコーデックの順序を決定することもできます. この場合、関連する「m =」セクションのメディア形式の順序は指定された設定に従います. 

5.SDP相互作用手順
このセクションでは、SDPオブジェクトを作成および解析するときに従うべき特定の手順について説明します. 

5.1. 要件の概要
JSEPの実装は、オファーとアンサーの作成と処理を管理する以下の仕様に準拠する必要があります. 

5.1.1. 使用要件
ローカルとリモートの両方のJSEP実装によって処理されるすべてのセッション記述は、以下の仕様のサポートを示さなければなりません. これらのいずれかが存在しない場合、この省略はエラーとして扱われなければなりません. 

* [RFC8445]で指定されているICEを使用する必要があります. リモートエンドポイントはライト実装を使用する場合があることに注意してください. 実装は、ICE-liteを使用するリモートエンドポイントを適切に処理する必要があります. リモートエンドポイントは、古いバージョンのICEを使用する場合もあります. 実装は、[RFC5245]で指定されているようにICEを使用するリモートエンドポイントを適切に処理する必要があります. 

* [RFC8827]で指定されているように、メディアタイプに応じて、DTLS [RFC6347]またはDTLS-SRTP [RFC5763]を使用する必要があります. 

[RFC8827]で説明されているように、SRTPキーイング[RFC4568]のSDPセキュリティ記述メカニズムを使用してはなりません（MUSTNOT）. 

5.1.2. プロファイル名と相互運用性
メディア「m =」セクションの場合、JSEP実装は、[RFC5764]で指定された「UDP / TLS / RTP / SAVPF」プロファイルと[RFC7850]で指定された「TCP / DTLS / RTP / SAVPF」プロファイルをサポートする必要があります. オファーで作成する各メディア「m =」行のこれらのプロファイルの1つ. データ「m =」セクションの場合、実装は「UDP / DTLS / SCTP」プロファイルと「TCP / DTLS / SCTP」プロファイルをサポートする必要があり、データ「m =」行ごとにこれらのプロファイルの1つを示す必要があります. 提案. 使用する正確なプロファイルは、[RFC8839]のセクション4.2.1.2で説明されているように、現在のデフォルトまたは選択されたICE候補に関連付けられたプロトコルによって決定されます. 

残念ながら、互換性を確保するために、一部のエンドポイントは、これらのプロファイルの1つをサポートすることを意図している場合でも、他のプロファイル文字列を生成します. たとえば、エンドポイントは「RTP / AVP」を生成しますが、「a = fingerprint」および「a = rtcp-fb」属性を提供し、「UDP / TLS / RTP / SAVPF」または「TCP / DTLS / RTP」をサポートする意思があることを示します.  / SAVPF」. このようなエンドポイントとの互換性を簡素化するために、JSEP実装は、受信したオファーのメディア「m =」セクションを処理するときに次のルールに従う必要があります. 

*次のいずれかに一致するオファー内のプロファイルを受け入れる必要があります. 

-「RTP / AVP」（[RFC4566]、セクション8.2.2で定義）

-「RTP / AVPF」（[RFC4585]、セクション9で定義）

-「RTP / SAVP」（[RFC3711]、セクション12で定義）

-「RTP / SAVPF」（[RFC5124]、セクション6で定義）

      -「TCP / DTLS / RTP / SAVP」（[RFC7850]、セクション3.4で定義）
        
      -「TCP / DTLS / RTP / SAVPF」（[RFC7850]、セクション3.5で定義）
        
      -「UDP / TLS / RTP / SAVP」（[RFC5764]、セクション9で定義）
        
      -「UDP / TLS / RTP / SAVPF」（[RFC5764]、セクション9で定義）
        
*生成された回答の「m =」行のプロファイルは、オファーで提供されたプロファイルと正確に一致する必要があります. 

* DTLS-SRTPが必要なため、SAVPまたはAVPを選択しても効果はありません. DTLS-SRTPのサポートは、1つ以上の「a = fingerprint」属性の存在によって決定されます. 「a = fingerprint」属性がないと、ネゴシエーションが失敗することに注意してください. 

* AVPFまたはAVPの使用は、RTCPフィードバックに使用されるタイミングルールを制御するだけです. AVPFが提供されている場合、または「a = rtcp-fb」属性が存在する場合は、AVPFタイミング、つまりデフォルト値の「trr-int = 0」を想定します. それ以外の場合は、AVPFがAVP互換モードで使用されていると想定し、「trr-int = 4000」の値を使用します. 

*データ「m =」セクションの場合、実装は「UDP / DTLS / SCTP」、「TCP / DTLS / SCTP」、または「DTLS / SCTP」（下位互換性のため）プロファイルの受信をサポートする必要があります. 

JSEP実装による再オファーでは、最初のオファー/アンサー交換で（誤った）古いプロファイル文字列が使用されていたとしても、正しいプロファイル文字列を使用する必要があることに注意してください. これにより、JSEPの動作が簡素化され、欠点は最小限に抑えられます. このような再オファーの処理に失敗したリモートエンドポイントは、JSEPエンドポイントの最初のオファーの処理にも失敗するためです. 

5.2. オファーの作成
createOfferが呼び出されると、[RFC8834]で指定された機能を含む新しいSDP記述を作成する必要があります. このプロセスの正確な詳細を以下に説明します. 

5.2.1. 最初のオファー
createOfferが初めて呼び出されたとき、その結果は最初のオファーと呼ばれます. 

最初のオファーを生成する最初のステップは、[RFC4566]のセクション5で指定されているように、セッションレベルの属性を生成することです. 具体的には次のとおりです. 

*最初のSDP行は、[RFC4566]のセクション5.1で定義されているように「v = 0」でなければなりません. 

* 2番目のSDP行は、[RFC4566]のセクション5.2で定義されている「o =」行である必要があります. <username>フィールドの値は「-」である必要があります. <sess-id>は、64ビットの符号付き整数で表現できる必要があり、値は2 ^（63）-1未満である必要があります. <sess-id>は、最高ビットがゼロに設定され、残りの63ビットが暗号的にランダムである64ビット量を生成することによって構築されることをお勧めします. <nettype> <addrtype> <unicast-address>タプルの値は、このフィールドのローカルIPアドレスのリークを防ぐために、IN IP40.0.0.0などの意味のないアドレスに設定する必要があります. この問題は[RFC8828]で説明されています. [RFC4566]で説明されているように、「o =」行全体が一意である必要がありますが、これを実現するには<sess-id>に乱数を選択するだけで十分です. 

* 3番目のSDP行は、[RFC4566]のセクション5.3で定義されている「s =」行である必要があります. 「o =」行と一致させるには、セッション名として1つのダッシュを使用する必要があります（例：「s =-」）. これは、単一のスペースを提案する[RFC4566]のアドバイスとは異なりますが、JSEPでは「o =」と「s =」の両方が無意味であるため、同じ無意味な値を持つ方が明確に見えることに注意してください. 

*セッション情報（ "i ="）、URI（ "u ="）、電子メールアドレス（ "e ="）、電話番号（ "p ="）、繰り返し時間（ "r ="）、およびタイムゾーン（ " z = "）行はこのコンテキストでは役に立たないため、含めないでください. 

*暗号化キー（ "k ="）行は十分なセキュリティを提供しないため、含めないでください. 

* [RFC4566]のセクション5.9で指定されているように、「t =」行を追加する必要があります. <start-time>と<stop-time>の両方をゼロに設定する必要があります（例： "t = 0 0"）. 

* [RFC8840]のセクション4.1.1および[RFC8445]のセクション10で指定されているように、「trickle」および「ice2」オプションを含む「a = ice-options」行を追加する必要があります. 

* WebRTC IDを使用している場合は、[RFC8827]のセクション5で説明されているように、「a = identity」行を追加する必要があります. 

次のステップは、[RFC4566]のセクション5.14で指定されているように、「m =」セクションを生成することです. 「m =」セクションは、停止したRtpTransceiversを除き、PeerConnectionに追加されたRtpTransceiverごとに生成されます. これは、RtpTransceiversがPeerConnectionに追加された順序で実行されます. そのようなRtpTransceiversがない場合、「m =」セクションは生成されません. [RFC3264]のセクション5で説明されているように、後でさらに追加できます. 

RtpTransceiver用に生成された「m =」セクションごとに、トランシーバーと生成された「m =」セクションのインデックスとの間のマッピングを確立します. 

各「m =」セクションには、バンドルのみとしてマークされていない場合、一意のICE資格情報のセットと一意のICE候補のセットが含まれている必要があります. バンドルのみの「m =」セクションには、ICE資格情報を含めたり、候補を収集したりしてはなりません. 

DTLSの場合、すべての「m =」セクションは、PeerConnectionに指定されているすべての証明書を使用する必要があります. 結果として、それらはすべて同じフィンガープリント値を持っている必要があります[RFC8122]、またはこれらの値はセッションレベルの属性でなければなりません. 

各「m =」セクションは、[RFC4566]のセクション5.14で指定されているように生成する必要があります. 「m =」行自体については、次のルールに従う必要があります. 

*「m =」セクションがバンドルのみとしてマークされている場合、<port>値はゼロに設定する必要があります. それ以外の場合、<port>値はこの「m =」セクションのデフォルトICE候補のポートに設定されますが、候補がまだ利用できない場合は、に示すように、デフォルトのポート値9（破棄）を使用する必要があります.  [RFC8840]、セクション4.1.1. 

* DTLSの使用を適切に示すには、[RFC5764]のセクション8で指定されているように、<proto>フィールドを「UDP / TLS / RTP / SAVPF」に設定する必要があります. 

*関連するトランシーバーにコーデックプリファレンスが設定されている場合、メディアフォーマットは対応する順序で生成する必要があり、コーデックプリファレンスに存在しないコーデックを除外する必要があります. 

*上記の制限によって除外されない限り、メディア形式には、[RFC7874]のセクション3および[RFC7742]のセクション5で指定されている必須のオーディオ/ビデオコーデックが含まれている必要があります. 

[RFC4566]のセクション5.7で指定されているように、「m =」行の直後に「c =」行が続く必要があります. 繰り返しになりますが、まだ候補がないため、[RFC8840]のセクション4.1.1で定義されているように、「c =」行にはデフォルト値「INIP40.0.0.0」が含まれている必要があります. 

[RFC8859]は、SDP属性をさまざまなカテゴリにグループ化します. バンドル時に不要な重複を避けるために、カテゴリIDENTICALまたはTRANSPORTの属性は、バンドルされた「m =」セクションで繰り返されてはならず、[RFC8843]のセクション7.1.3のガイダンスを繰り返します. これには、バンドルがネゴシエートされてまだ必要な「m =」セクションと、バンドルのみとしてマークされた「m =」セクションが含まれます. 

IDENTICALまたはTRANSPORT以外のカテゴリの次の属性は、各「m =」セクションに含める必要があります. 

* [RFC5888]のセクション4で指定されている「a = mid」行. すべてのMID値は、ユーザー情報を漏らさない方法で生成する必要があります. たとえば、ランダムに、またはPeerConnectionカウンターごとに使用し、3にする必要があります.  [RFC8843]のセクション15.2で定義されているRTPヘッダー拡張に効率的に適合できるようにするためのバイト以下. 説明が適用された場合にのみ発生するため、これはRtpTransceivermidプロパティを設定しないことに注意してください. 生成されたMID値は、この時点で「提案された」MIDと見なすことができます. 

*関連するトランシーバーのdirection属性と同じdirection属性. 

* [RFC4566]のセクション6および[RFC3264]のセクション5.1で指定されているように、「m =」行、「a = rtpmap」および「a = fmtp」行の各メディア形式について. 

* RTP再送信を使用する必要がある各プライマリコーデックについて、プライマリコーデックのクロックレートで「rtx」を示す対応する「a = rtpmap」行と、プライマリコーデックのペイロードタイプを参照する「a = fmtp」行.  [RFC4588]のセクション8.1で指定されているとおり. 

*サポートされている前方誤り訂正（FEC）メカニズムごとに、[RFC4566]のセクション6で指定されている「a = rtpmap」および「a = fmtp」行. サポートされなければならないFECメカニズムは[RFC8854]のセクションで指定されています.  7、および各メディアタイプの特定の使用法はセクション4および5に概説されています. 

*この「m =」セクションがパケットあたりのメディアの期間を構成可能なメディア用である場合（オーディオなど）、「a = maxptime」行は、ミリ秒単位で指定され、各パケットにカプセル化できるメディアの最大量を示します.  [RFC4566]のセクション6で指定されているように、この値は、「m =」セクションに含まれるすべてのコーデックの最大継続時間値の最小値に設定されます. 

*この「m =」セクションがビデオメディア用であり、デコードできる画像のサイズに既知の制限がある場合は、セクション3.6で指定されている「a = imageattr」行. 

*サポートされているRTPヘッダー拡張ごとに、[RFC5285]のセクション5で指定されている「a = extmap」行. サポートされるべき/サポートされなければならないヘッダー拡張のリストは、[RFC8834]のセクション5.2で指定されています. 暗号化が必要なヘッダー拡張は、[RFC6904]のセクション4に示されているように指定する必要があります. 

*サポートされているRTCPフィードバックメカニズムごとに、[RFC4585]のセクション4.2で指定されている「a = rtcp-fb」行. サポートされるべき/サポートされなければならないRTCPフィードバックメカニズムのリストは、[RFC8834]のセクション5.1で指定されています. 

* RtpTransceiverにsendrecvまたはsendonlydirectionがある場合：

-addTrackまたはaddTransceiverを介して作成されたときにトランシーバーに関連付けられたMediaStreamごとに、[RFC8830]のセクション2で指定されているように、「appdata」フィールドを省略した「a = msid」行. 

* RtpTransceiverにsendrecvまたはsendonlydirectionがあり、アプリケーションがエンコーディングにrid-idを指定した場合、またはRtpSendersのパラメータに複数のエンコーディングを指定した場合、指定されたエンコーディングごとに「a = rid」行. 「a = rid」行は[RFC8851]で指定されており、そのdirectionは「送信」でなければなりません. アプリケーションがrid-idを選択した場合は、それを使用する必要があります. それ以外の場合は、実装によってrid-idを生成する必要があります. rid-idは、ユーザー情報を漏らさない方法で生成する必要があります. たとえば、ランダムに、またはPeerConnectionごとのカウンターを使用して（[RFC8852]の最後のセクション3.3を参照）、3バイト以下にする必要があります.  [RFC8852]のセクション3.3で定義されているRTPヘッダー拡張に効率的に適合できるようにします. エンコーディングが指定されていない場合は、

* RtpTransceiverにsendrecvまたはsendonlydirectionがあり、複数の「a = rid」行が生成されている場合、[RFC8853]のセクション5.1で定義されているように、directionが「send」の「a = simulcast」行. 関連するrid-idのセットには、この「m =」セクションの「a = rid」行で使用されるすべてのrid-idを含める必要があります. 

*（1）このPeerConnectionのバンドルポリシーが「max-bundle」に設定されており、これが最初の「m =」セクションではない場合、または（2）バンドルポリシーが「balanced」に設定されており、これが最初の「このメディアタイプのm = "セクション、「a = bundle-only」行. 

カテゴリIDENTICALまたはTRANSPORTの次の属性は、一意のアドレスを持つか、BUNDLEタグに関連付けられている「m =」セクションにのみ表示する必要があります. （最初のオファーでは、これは「a = bundle-only」属性を含まない「m =」セクションを意味します. ）

* [RFC8839]のセクション5.4で指定されている「a = ice-ufrag」および「a = ice-pwd」行. 

* [RFC8122]のセクション5で指定されているように、必要なダイジェストアルゴリズムごとに、エンドポイントの証明書ごとに1つ以上の「a = fingerprint」行. 

* [RFC4145]のセクション4で指定され、[RFC5763]のセクション5でDTLS-SRTPシナリオで使用するために明確化された、「a = setup」行. オファーのロール値は「actpass」である必要があります. 

* [RFC8842]のセクション5.2で指定されている「a = tls-id」行. 

*候補がまだ収集されていないため、[RFC3605]のセクション2.1で指定されている「a = rtcp」行. デフォルト値「9INIP40.0.0.0」が含まれています. 

* [RFC5761]のセクション5.1.3で指定されている「a = rtcp-mux」行. 

* RTP / RTCP多重化ポリシーが「require」の場合、[RFC8858]のセクション4で指定されているように、「a = rtcp-mux-only」行. 

* [RFC5506]のセクション5で指定されている「a = rtcp-rsize」行. 

最後に、データチャネルが作成されている場合は、データ用に「m =」セクションを生成する必要があります. <media>フィールドは「application」に設定する必要があり、<proto>フィールドは「UDP / DTLS / SCTP」に設定する必要があります[RFC8841]. <fmt>値は、[RFC8841]のセクション4.2.2で指定されているように、「webrtc-datachannel」に設定する必要があります. 

データ「m =」セクション内で、「a = mid」行を生成し、上記のように含める必要があります. また、[RFC8841]のセクションで定義されているように、SCTPポート番号を参照する「a = sctp-port」行も含める必要があります.  5.1; また、必要に応じて、[RFC8841]のセクション6.1で定義されている「a = max-message-size」行. 

上記のように、カテゴリIDENTICALまたはTRANSPORTの次の属性は、データ「m =」セクションに一意のアドレスがあるか、BUNDLEタグに関連付けられている場合にのみ含まれます（たとえば、それが唯一の「m =」セクションである場合）.  ：

*「a = ice-ufrag」

*「a = ice-pwd」

*「a =指紋」

*「a = setup」

* "a = tls-id"

すべての「m =」セクションが生成されたら、[RFC5888]で指定されているようにセッションレベルの「a = group」属性を追加する必要があります. この属性には、セマンティクス「BUNDLE」が必要であり、各「m =」セクションの中間識別子が含まれている必要があります. この効果は、JSEP実装がすべての「m =」セクションを1つのバンドルグループとして提供することです. ただし、「m =」セクションがバンドルのみであるかどうかは、バンドルポリシーによって異なります. 

次のステップは、[RFC5888]のセクション7で定義されているセッションレベルのリップシンクグループを生成することです. 複数のRtpTransceiverによって参照されるMediaStreamごとに（これらのMediaStreamを引数としてaddTrackメソッドとaddTransceiverメソッドに渡すことにより）、タイプのグループ各RtpTransceiverのMID値を含む「LS」を追加する必要があります. 

SDPがセッションレベルまたはメディアレベルのいずれかで許可する属性は、それらが同一であっても、通常はメディアレベルである必要があります. これは、特に最初は同一の属性のセットの1つが後で変更された場合に、個々のメディアセクションを理解しやすくすることで、開発とデバッグを支援します. ただし、実装はセッションレベルで属性を集約することを選択でき、JSEP実装はいずれかの場所で属性を受け取るように準備する必要があります. 

[RFC8834]の要件と特に互換性がなく、含めてはならない次の属性を除いて、上記で指定されたもの以外の属性を含めることができます. 

*「a = crypto」

* "a = key-mgmt"

*「a = ice-lite」

バンドルを使用する場合、追加される追加の属性は、それらの属性がバンドルとどのように相互作用するかについての[RFC8859]のアドバイスに従わなければならないことに注意してください. 

これらの要件は、SDPの要件よりも厳しい場合があることに注意してください. 実装は、この仕様でSDPを生成するための要件に準拠しない場合でも、準拠するSDPを受け入れるように準備する必要があります. 

5.2.2. 後続のオファー
createOfferが2回目（またはそれ以降）に呼び出された場合、またはローカル記述がすでにインストールされた後に呼び出された場合、処理は最初のオファーの場合とは多少異なります. 

以前のオファーがsetLocalDescriptionを使用して適用されなかった場合、つまりPeerConnectionがまだ「安定」状態である場合は、次の制限に従って、最初のオファーを生成する手順に従う必要があります. 

*「o =」行のフィールドは、<session-version>フィールドを除いて同じままである必要があります. <session-version>フィールドは、オファーがcreateOfferの前の呼び出しの出力と異なる可能性がある場合、createOfferの呼び出しごとに1ずつインクリメントする必要があります. 実装は、呼び出しごとに<session-version>をインクリメントすることを選択できます（MAY）. 生成された<session-version>の値は、現在のローカル記述の<session-version>とは無関係です. 特に、現在のバージョンがNの場合、オファーはバージョンN + 1で作成および適用され、そのオファーはロールバックされて現在のバージョンが再びNになり、次に生成されるオファーのバージョンはNのままになります.  +2. 

アプリケーションがcreateOfferを呼び出す代わりにcurrentLocalDescriptionを読み取ってオファーを作成する場合、収集されたICE候補が追加されるため、返されるSDPはsetLocalDescriptionが最初に呼び出されたときとは異なる場合がありますが、<session-version>は変更されません. これが問題を引き起こす既知のシナリオはありませんが、これが懸念される場合の解決策は、createOfferを使用して一意の<session-version>を確保することです. 

以前のオファーがsetLocalDescriptionを使用して適用されたが、リモート側からの対応する回答がまだ適用されていない場合、つまりPeerConnectionがまだ「ローカルオファーを持っている」状態である場合、オファーは「」の手順に従って生成されます. これらの例外とともに、上記の「安定した」状態：

*「s =」と「t =」の行は同じでなければなりません. 

* RtpTransceiverが追加されていて、現在のローカルの説明または現在のリモートの説明にポートがゼロの「m =」セクションが存在する場合、その「m =」セクションは、「m =」セクションを生成してリサイクルする必要があります.  「m =」セクションがセッションの説明（新しいMID値を含む）に追加されているかのようにRtpTransceiverを追加し、ポートがゼロの「m =」セクションと同じインデックスに配置しました. 

* RtpTransceiverが停止していて、「m =」セクションに関連付けられていない場合、「m =」セクションを生成してはなりません（MUSTNOT）. これにより、上記のように、「m =」セクションがリサイクルされ、以前のオファー/アンサー交換で新しいRtpTransceiverに使用されたRtpTransceiverが追加されなくなります. 

* RtpTransceiverが停止され、「m =」セクションに関連付けられていて、「m =」セクションが上記のようにリサイクルされていない場合、ポートをゼロに設定して「m =」セクションを生成する必要があります. そして、すべての「a = msid」行が削除されました. 

*停止していないRtpTransceiversの場合、「a = msid」ラインは、トランシーバーのdirectionまたはトラックの変更に関係なく、現在の説明に存在する場合は同じままである必要があります. 現在の説明に「a = msid」行が存在しない場合、「a = msid」行は、最初のオファーと同じルールに従って生成する必要があります. 

* [RFC8839]のセクション4.2.1.2およびで説明されているように、各「m =」および「c =」行には、ポート、関連するRTPプロファイル、および「m =」セクションのデフォルト候補のアドレスを入力する必要があります. セクション5.1.2で明確にされています. RTP候補がまだ収集されていない場合でも、上記のようにデフォルト値を使用する必要があります. 

*各「a = mid」行は同じままでなければなりません. 

*「a = ice-ufrag」と「a = ice-pwd」の各行は、ICE構成が変更されていない限り（たとえば、サポートされているSTUN / TURNサーバーまたはICE候補ポリシーのいずれかに変更されていない限り）、同じままである必要があります. オプション（セクション5.2.3.1）が指定されました. 「m =」セクションが別の「m =」セクションにバンドルされている場合でも、ICE資格情報を含めてはなりません（MUSTNOT）. 

*「m =」セクションが別の「m =」セクションにバンドルされていない場合、[RFC5761]のセクションに示されているように、その「a = rtcp」属性行にデフォルトのRTCP候補のポートとアドレスを入力する必要があります.  5.1.3. RTCP候補がまだ収集されていない場合は、上記のセクション5.2.1で説明されているように、デフォルト値を使用する必要があります. 

*「m =」セクションが別の「m =」セクションにバンドルされていない場合、最新の収集フェーズで収集された候補ごとに（セクション3.5.1を参照）、「a = candidate」行を追加する必要があります.  、[RFC8839]のセクション5.1で定義されているとおり. セクションの候補者の収集が完了した場合、[RFC8840]のセクション8.2で説明されているように、「a = end-of-candidates」属性を追加する必要があります. 「m =」セクションが別の「m =」セクションにバンドルされている場合は、「a = candidate」と「a = end-of-candidates」の両方を省略しなければなりません. 

*まだ存在しているRtpTransceiversの場合、「a = rid」行は同じままである必要があります. 

*まだ存在しているRtpTransceiversの場合、「a = simulcast」行は同じままである必要があります. 

以前のオファーがsetLocalDescriptionを使用して適用され、リモート側からの対応する回答がsetRemoteDescriptionを使用して適用された場合、つまりPeerConnectionが「have-remote-pranswer」状態または「stable」状態にある場合、オファーはに基づいて生成されます. 上記の「have-local-offer」状態について説明した手順に従って、ネゴシエートされたセッションの説明. 

さらに、新しいオファーの既存の、リサイクルされていない、拒否されていない「m =」セクションごとに、現在のローカルまたはリモートの説明の対応する「m =」セクションの内容に基づいて、次の調整が行われます. 適切な：

*「m =」行と対応する「a = rtpmap」および「a = fmtp」行には、関連するトランシーバーのコーデック設定によって除外されていないメディア形式のみを含める必要があり、現在使用可能なすべての形式も含める必要があります. 以前に提供されていたが現在は使用できないメディア形式（共有ハードウェアコーデックなど）は除外される場合があります. 

*関連するトランシーバーにコーデック設定が設定されていない限り、「m =」行のメディア形式は、最新の回答と同じ順序で生成する必要があります. 最新の回答に存在しなかったメディアフォーマットは、既存のすべてのフォーマットの後に追加する必要があります. 

* RTPヘッダー拡張には、最新の回答に存在するもののみを含める必要があります. 

* RTCPフィードバックメカニズムには、新しく追加されたメディアフォーマットを参照するフォーマット固有のメカニズムの場合を除いて、最新の回答に存在するもののみを含める必要があります. 

*最新の回答に「a = rtcp-mux」行が含まれている場合は、「a = rtcp」行を追加しないでください. 

*「a = rtcp-mux」の行は、最新の回答の行と同じである必要があります. 

*「a = rtcp-mux-only」行を追加してはなりません. 

*「a = rtcp-rsize」行は、最新の回答に存在しない限り追加してはなりません. 

* [RFC8843]のセクション6で定義されている「a = bundle-only」行を追加してはなりません. 代わりに、JSEP実装は、[RFC8843]のセクション7.1.3で説明されているように、バンドルされた「m =」セクションのIDENTICALおよびTRANSPORTカテゴリのパラメータを単に省略しなければなりません. 

*メディア "m ="セクションがデータ "m ="セクションにバンドルされている場合、特定のTRANSPORTおよびIDENTICAL属性は、メディア "mにのみ適切である場合でも、データ" m = "セクションに表示される場合があることに注意してください.  = "セクション（例：" a = rtcp-mux "）. 最初のオファーでは、JSEP実装は常に、データ "m ="セクション（存在する場合）の前にメディア "m ="セクション（存在する場合）をリストし、それらのメディア "m ="セクションの少なくとも1つをリストするため、これは最初のオファーでは発生しません.  「a = bundle-only」属性はありません. したがって、最初のオファーでは、「a = bundle-only」「m =」セクションは、先行する非バンドルのみのメディア「m =」セクションにバンドルされます. 

「a = group：BUNDLE」属性には、最新の回答のバンドルグループで指定されたMID識別子から、拒否としてマークされた「m =」セクションと、新しく追加または再度有効化された「m =」を除いたものを含める必要があります.  "セクション. つまり、bundle属性には、以前にバンドルされたすべての「m =」セクションと、新しい「m =」セクションが含まれている必要があります. 

「a = group：LS」属性は、最初のオファーと同じ方法で生成されますが、最新の回答に存在したリップシンクグループは引き続き存在し、既存のMID識別子を含む必要があるという追加の規定があります. 識別された「m =」セクションがまだ存在し、拒否されず、グループに少なくとも2つのMID識別子が含まれている限り. これにより、同期された「recvonly」「m =」セクションは、新しいオファーで引き続き同期されます. 

5.2.3. オプションの取り扱い
createOfferメソッドは、RTCOfferOptionsオブジェクトをパラメーターとして受け取ります. 次のオプションが存在する場合、SDP記述を生成するときに特別な処理が実行されます. 

5.2.3.1. IceRestart
IceRestartオプションが指定され、値が「true」の場合、オファーは、[RFC8839]のセクション4.4.3.1.1で指定されているように、新しいICEufragおよびpwd属性を生成することによってICEの再起動を示さなければなりません. このオプションが最初のオファーで指定されている場合、効果はありません（新しいICE ufragとpwdがすでに生成されているため）. 同様に、ICE構成が変更された場合、新しいufragおよびpwd属性が自動的に生成されるため、このオプションは効果がありません. このオプションは主に、アプリケーションによって障害が検出された場合に接続を再確立するのに役立ちます. 

5.2.3.2. VoiceActivityDetection
不連続送信（「DTX」）とも呼ばれる無音抑制は、音声アクティビティが検出されないときに特別なエンコーディングに切り替えることで、オーディオに使用される帯域幅を減らすことができますが、ある程度の忠実度が犠牲になります. 

「VoiceActivityDetection」オプションが指定され、値が「true」の場合、オファーは、[で指定されているように、提供されるオーディオコーデックごとにコンフォートノイズ（「CN」）コーデックを含めることにより、受信するオーディオの無音抑制のサポートを示さなければなりません.  RFC3389]、セクション5.1. ただし、独自の内部無音抑制サポートがあるコーデックは除きます. 独自の内部無音抑制をサポートするコーデックの場合、受信したオーディオの無音抑制が必要であることを示すために、そのコーデックに適切なfmtpパラメータを指定する必要があります. たとえば、Opusコーデック[RFC6716]を使用する場合、[RFC7587]で指定された「usedtx = 1」パラメーターがオファーで使用されます. 

「VoiceActivityDetection」オプションが指定され、値が「false」の場合、JSEP実装は「CN」コーデックを発行してはなりません（MUSTNOT）. 独自の内部無音抑制をサポートするコーデックの場合、受信したオーディオの無音抑制が望ましくないことを示すために、そのコーデックに適切なfmtpパラメータを指定する必要があります. たとえば、Opusコーデックを使用する場合、「usedtx = 0」パラメーターがオファーで指定されます. さらに、実装は、「CN」コーデックまたは関連するfmtpパラメータがピアの説明に表示されているかどうかに関係なく、生成するメディアに無音抑制を使用してはなりません（MUSTNOT）. これらのルールの影響は、JSEPでの無音の抑制が双方の相互合意に依存していることです. これにより、使用されているコーデックに関係なく、一貫した処理が保証されます. 

「VoiceActivityDetection」オプションは、[RFC6464]のセクション4で説明されているクライアントからミキサーへのオーディオレベルヘッダー拡張のシグナリングの「vad」値の設定に影響を与えません. 

5.3. 回答の生成
createAnswerが呼び出されると、提供されたリモート記述および[RFC8834]で指定された要件と互換性のある新しいSDP記述を作成する必要があります. このプロセスの正確な詳細を以下に説明します. 

5.3.1. 最初の回答
リモート記述が提供された後にcreateAnswerが初めて呼び出されたとき、その結果は初期応答と呼ばれます. リモート記述がインストールされていない場合、回答を生成できず、エラーを返す必要があります. 

リモート記述SDPはJSEPエンドポイントによって作成されていない可能性があり、セクション5.2にリストされているすべての要件に準拠していない可能性があることに注意してください. 多くの場合、これは問題ではありません. ただし、必須のSDP属性が欠落している場合、または上記で必須としてリストされている機能が存在しない場合、これはエラーとして扱われ、影響を受ける「m =」セクションが拒否としてマークされる必要があります. 

最初の回答を生成する最初のステップは、セッションレベルの属性を生成することです. ここでのプロセスは、[RFC8840]のセクション4.1.3で指定されている「trickle」オプションと「ice2」オプションを含む「a = ice-options」行を除いて、上記のセクション5.2.1で示したプロセスと同じです.  [RFC8445]のセクション10で指定されているように、そのようなオプションがオファーに存在する場合にのみ含まれます. 

次のステップは、[RFC5888]のセクション7で定義されているように、セッションレベルのリップシンクグループを生成することです. オファーに存在するタイプ「LS」のグループごとに、指定されたMID値によって参照されるローカルRtpTransceiversを選択します. グループ化し、共通のローカルMediaStream（それらの作成に使用されたaddTrack / addTransceiverの呼び出しで指定）を参照するか、addTrack / addTransceiverによって作成されなかったために参照するMediaStreamがないかを判別します. そのようなRtpTransceiverが少なくとも2つ存在する場合は、これらのRtpTransceiversのMID値を持つタイプ「LS」のグループを追加する必要があります. それ以外の場合、提供された「LS」グループは無視されなければならず、対応するグループは回答で生成されません. 

簡単な例として、同じMediaStreamに含まれる単一のオーディオトラックと単一のビデオトラックの次のオファーについて考えてみます. この例に関係のないSDP行は、わかりやすくするために削除されています. セクション5.2で説明したように、各トラックのRtpTransceiverを参照するタイプ「LS」のグループが追加されました. 

             a = group：LS a1 v1
             m = audio 10000 UDP / TLS / RTP / SAVPF 0
             a = mid：a1
             a = msid：ms1
             m =ビデオ10001UDP / TLS / RTP / SAVPF 96
             a = mid：v1
             a = msid：ms1
        
回答者がトラックを追加するときに単一のMediaStreamを使用する場合、そのトランシーバーの両方がこのストリームを参照するため、次の回答には、以下に示すように、オファーと同じ「LS」グループが含まれます. 

             a = group：LS a1 v1
             m = audio 20000 UDP / TLS / RTP / SAVPF 0
             a = mid：a1
             a = msid：ms2
             m =ビデオ20001UDP / TLS / RTP / SAVPF 96
             a = mid：v1
             a = msid：ms2
        
ただし、回答者がトラックを個別のMediaStreamにグループ化すると、トランシーバーは異なるストリームを参照するため、後続の回答には「LS」グループは含まれません. 

             m = audio 20000 UDP / TLS / RTP / SAVPF 0
             a = mid：a1
             a = msid：ms2a
             m =ビデオ20001UDP / TLS / RTP / SAVPF 96
             a = mid：v1
             a = msid：ms2b
        
最後に、回答者がトラックを追加しない場合、そのトランシーバーはMediaStreamを参照しないため、提供者の設定が維持されるため、後続の回答には同一の「LS」グループが含まれます. 

             a = group：LS a1 v1
             m = audio 20000 UDP / TLS / RTP / SAVPF 0
             a = mid：a1
             a = recvonly
             m =ビデオ20001UDP / TLS / RTP / SAVPF 96
             a = mid：v1
             a = recvonly
        
セクション7.2の例は、「LS」グループ生成のより複雑なケースを示しています. 

次のステップは、[RFC3264]のセクション6で指定されているように、リモートオファーに存在する「m =」セクションごとに「m =」セクションを生成することです. この説明の目的上、セッションレベルの属性はメディアレベルの属性としても有効なオファーは、各「m =」セクションに存在すると見なされます. セクション5.10で説明されているように、提供される各「m =」セクションには、関連付けられたRtpTransceiverがあります. 「m =」セクションよりも多くのRtpTransceiversがある場合、一致しないRtpTransceiversを後続のオファーに関連付ける必要があります. 

提供された「m =」セクションごとに、次の条件のいずれかが当てはまる場合、「m =」行の<port>をゼロに設定して、回答の対応する「m =」セクションを拒否としてマークする必要があります.  [RFC3264]のセクション6に示されているように、この「m =」セクションの以降の処理はスキップできます. 

*関連するRtpTransceiverが停止しました. 

*サポートされており、該当する場合はコーデック設定で許可されているメディア形式は提供されていません. 

*バンドルポリシーは「max-bundle」であり、これは最初の「m =」セクションでも、最初の「m =」セクションと同じバンドルグループ内でもありません. 

*バンドルポリシーは「バランス」であり、これはこのメディアタイプの最初の「m =」セクションではなく、このメディアタイプの最初の「m =」セクションと同じバンドルグループ内でもありません. 

*この「m =」セクションはバンドルグループに含まれており、「m =」セクションとタグ付けされたグループの提供者は、上記のいずれかの理由により拒否されています. これには、[RFC8843]のセクション7.3.3で指定されているように、バンドルグループ内のすべての「m =」セクションを拒否する必要があります. 

それ以外の場合、回答の各「m =」セクションは、[RFC3264]のセクション6.1で指定されているように生成する必要があります. 「m =」行自体については、次のルールに従う必要があります. 

* <port>値は通常、この「m =」セクションのデフォルトのICE候補のポートに設定されますが、候補がまだ利用できない場合は、デフォルトの<port>値9（破棄）を使用する必要があります.  [RFC8840]のセクション4.1.1に示されているように. 

* <proto>フィールドは、オファー内の対応する「m =」行の<proto>フィールドと完全に一致するように設定する必要があります. 

*関連するトランシーバーにコーデックプリファレンスが設定されている場合、メディアフォーマットは、提供されたものに関係なく、対応する順序で生成する必要があり、コーデックプリファレンスに存在しないコーデックを除外する必要があります. 

*それ以外の場合、「m =」行のメディア形式は、現在サポートされていない形式を除いて、現在のリモート記述で提供されているものと同じ順序で生成する必要があります. 現在のリモートディスクリプションに存在しない現在利用可能なメディアフォーマットは、既存のすべてのフォーマットの後に追加する必要があります. 

*いずれの場合も、回答のメディア形式には、オファーに存在するフォーマットを少なくとも1つ含める必要がありますが、[RFC3264]のセクション6.1に記載されているように、ローカルでサポートされているがオファーには存在しないフォーマットを含めることができます. 一般的な形式が存在しない場合、「m =」セクションは上記のように拒否されます. 

[RFC4566]のセクション5.7で指定されているように、「m =」行の直後に「c =」行が続く必要があります. 繰り返しになりますが、まだ候補がないため、[RFC8840]のセクション4.1.3で定義されているように、「c =」行にはデフォルト値「INIP40.0.0.0」が含まれている必要があります. 

オファーがバンドルをサポートしている場合、バンドルされるすべての「m =」セクションは、同じICE資格情報と候補を使用する必要があります. バンドルされていないすべての「m =」セクションは、一意のICE資格情報と候補を使用する必要があります. 各「m =」セクションには、次の属性（IDENTICALまたはTRANSPORT以外の属性タイプ）が含まれている必要があります. 

*オファーに存在する場合に限り、[RFC5888]のセクション9.1で指定されている「a = mid」行. MID値は、オファーで指定された値と一致する必要があります. 

* [RFC3264]のセクション6.1で指定された提供されたdirectionに関するルールを適用し、関連するRtpTransceiverのdirectionと交差することによって決定されるdirection属性. たとえば、「m =」セクションが「sendonly」として提供され、ローカルトランシーバーが「sendrecv」に設定されている場合、回答の結果は「recvonly」directionになります. 

* [RFC4566]のセクション6および[RFC3264]のセクション6.1で指定されているように、「m =」行、「a = rtpmap」および「a = fmtp」行の各メディア形式について. 

*オファーに「rtx」が存在する場合、RTP再送信を使用する必要があるプライマリコーデックごとに、プライマリコーデックのクロックレートで「rtx」を示す対応する「a = rtpmap」行と「a = fmtp」行[RFC4588]のセクション8.1で指定されているように、プライマリコーデックのペイロードタイプを参照します. 

*サポートされているFECメカニズムごとに、[RFC4566]のセクション6で指定されている「a = rtpmap」および「a = fmtp」行. サポートされなければならないFECメカニズムは、[RFC8854]のセクション7および特定の使用法で指定されています. 各メディアタイプについては、セクション4および5で概説されています. 

*この「m =」セクションがパケットあたりのメディアの期間を構成可能なメディア用である場合（オーディオなど）、セクション5.2で説明されているように「a = maxptime」行. 

*この「m =」セクションがビデオメディア用であり、デコードできる画像のサイズに既知の制限がある場合は、セクション3.6で指定されている「a = imageattr」行. 

*オファーに存在するサポートされているRTPヘッダー拡張ごとに、[RFC5285]のセクション5で指定されている「a = extmap」行. サポートされるべき/サポートされなければならないヘッダー拡張のリストは[RFC8834]で指定されています. セクション5.2. 暗号化が必要なヘッダー拡張は、[RFC6904]のセクション4に示されているように指定する必要があります. 

*オファーに存在するサポートされているRTCPフィードバックメカニズムごとに、[RFC4585]のセクション4.2で指定されている「a = rtcp-fb」行. サポートされるべき/サポートされなければならないRTCPフィードバックメカニズムのリストは、[RFC8834]のセクション5.1で指定されています. 

* RtpTransceiverにsendrecvまたはsendonlydirectionがある場合：

-addTrackまたはaddTransceiverを介して作成されたときにトランシーバーに関連付けられたMediaStreamごとに、[RFC8830]のセクション2で指定されているように、「appdata」フィールドを省略した「a = msid」行. 

別の「m =」セクションにバンドルされていない各「m =」セクションには、次の属性が含まれている必要があります（カテゴリIDENTICALまたはTRANSPORT）. 

* [RFC8839]のセクション5.4で指定されている「a = ice-ufrag」および「a = ice-pwd」行. 

* [RFC8122]のセクション5で指定されているように、必要なダイジェストアルゴリズムごとに、エンドポイントの証明書ごとに1つ以上の「a = fingerprint」行. 

* [RFC4145]のセクション4で指定され、[RFC5763]のセクション5でDTLS-SRTPシナリオで使用するために明確化された、「a = setup」行. 回答の役割値は「アクティブ」または「パッシブ」である必要があります.  . JSEPエンドポイントの場合に常にそうであるように、オファーに「actpass」値が含まれている場合、回答者は「アクティブ」ロールを使用する必要があります. 非JSEPエンドポイントからのオファーは、「a = setup」に他の値を送信する場合があります. その場合、回答はオファーの値と一致する値を使用する必要があります. 

* [RFC8842]のセクション5.3で指定されている「a = tls-id」行. 

*オファーに存在する場合は、[RFC5761]のセクション5.1.3で指定されている「a = rtcp-mux」行. それ以外の場合は、[RFC3605]のセクション2.1で指定されているように、デフォルト値「9 IN IP40.0.0.0」を含む「a = rtcp」行（候補がまだ収集されていないため）. 

*オファーに存在する場合は、[RFC5506]のセクション5で指定されている「a = rtcp-rsize」行. 

データチャネル「m =」セクションが提供されている場合、「m =」セクションもデータ用に生成する必要があります. <media>フィールドは「application」に設定する必要があり、<proto>フィールドと<fmt>フィールドはオファーのフィールドと完全に一致するように設定する必要があります. 

データ「m =」セクション内で、「a = mid」行を生成し、上記のように含める必要があります. また、[RFC8841]のセクションで定義されているように、SCTPポート番号を参照する「a = sctp-port」行も含める必要があります.  5.1; また、必要に応じて、[RFC8841]のセクション6.1で定義されている「a = max-message-size」行. 

上で説明したように、カテゴリIDENTICALまたはTRANSPORTの次の属性は、データ「m =」セクションが別の「m =」セクションにバンドルされていない場合にのみ含まれます. 

*「a = ice-ufrag」

*「a = ice-pwd」

*「a =指紋」

*「a = setup」

* "a = tls-id"

メディア「m =」セクションがデータ「m =」セクションにバンドルされている場合、特定のTRANSPORTおよびIDENTICAL属性は、メディア「m」にのみ適切である場合でも、データ「m =」セクションに表示される場合があることに注意してください.  = "セクション（例：" a = rtcp-mux "）. 

「BUNDLE」のセマンティクスを持つ「a = group」属性が提供される場合、[RFC5888]で指定されているように、対応するセッションレベルの「a = group」属性を追加する必要があります. これらの属性は、セマンティクス「BUNDLE」を持たなければならず、拒否されていない提供されたバンドルグループからのすべての中間識別子を含まなければなりません. オファーに「a = bundle-only」が含まれているかどうかに関係なく、回答のすべての「m =」セクションに「a = bundle-only」行を含めてはならないことに注意してください. 

すべての「m =」セクションに共通の属性は、セッションレベルで有効であると明示的に定義されている場合、セッションレベルに移動できます. 

オファーの作成で禁止されている属性は、回答の作成でも禁止されています. 

5.3.2. 後続の回答
createAnswerが2回目（またはそれ以降）に呼び出された場合、またはローカル記述がすでにインストールされた後に呼び出された場合、処理は最初の応答の場合とは多少異なります. 

以前の回答がsetLocalDescriptionを使用して適用されなかった場合、つまりPeerConnectionがまだ「have-remote-offer」状態にある場合は、次の制限に従って、最初の回答を生成する手順に従う必要があります. 

*「o =」行のフィールドは、<session-version>フィールドを除いて同じままである必要があります. ただし、セッションの説明が以前に生成された回答から何らかの方法で変更された場合は増分する必要があります. 

以前にsetLocalDescriptionにセッションの説明が指定されていた場合は、上記の「have-remote-offer」状態の手順に従って、次の例外とともに回答が生成されます. 

*「s =」と「t =」の行は同じでなければなりません. 

* [RFC8839]のセクション4.2.1.2で説明されているように、各「m =」および「c =」行には「m =」セクションのデフォルト候補のポートとアドレスを入力する必要があります. 上記のように、「m =」ラインプロトコル値はオファーで提供されたものと一致する必要があるため、「m =」ラインプロトコルがデフォルト候補の値と一致しない場合があることに注意してください. 

*「m =」セクションが再起動しない限り、「a = ice-ufrag」と「a = ice-pwd」の各行は同じままである必要があります. 再起動する場合は、[RFC8839]のセクションで指定されているように新しいICE資格情報を作成する必要があります.  4.4.1.1.1. 「m =」セクションが別の「m =」セクションにバンドルされている場合でも、ICE資格情報を含めてはなりません（MUSTNOT）. 

*各「a = tls-id」行は、提供者の「a = tls-id」行が変更されない限り、同じままである必要があります. 変更された場合、[RFC8842]のセクション5.2で説明されているように、新しいtls-id値を作成する必要があります.  . 

*各「a = setup」行は、アソシエーションが提供者によって継続されている場合、既存のDTLSアソシエーションと一致する「アクティブ」または「パッシブ」ロール値を使用する必要があります. 

* RTCP多重化を使用する必要があり、「m =」セクションが以前にRTCP多重化を使用した場合にのみ、「a = rtcp-mux」行を挿入します. 

*「m =」セクションが別の「m =」セクションにバンドルされておらず、RTCP多重化がアクティブでない場合、「a = rtcp」属性行にデフォルトのRTCP候補のポートとアドレスを入力する必要があります. RTCP候補がまだ収集されていない場合は、上記のセクション5.3.1で説明されているように、デフォルト値を使用する必要があります. 

*「m =」セクションが別の「m =」セクションにバンドルされていない場合、最新の収集フェーズで収集された候補ごとに（セクション3.5.1を参照）、「a = candidate」行を追加する必要があります.  、[RFC8839]のセクション5.1で定義されているとおり. セクションの候補者の収集が完了した場合、[RFC8840]のセクション8.2で説明されているように、「a = end-of-candidates」属性を追加する必要があります. 「m =」セクションが別の「m =」セクションにバンドルされている場合は、「a = candidate」と「a = end-of-candidates」の両方を省略しなければなりません. 

*停止していないRtpTransceiversの場合、トランシーバーのdirectionまたはトラックの変更に関係なく、「a = msid」ラインは同じままである必要があります. 現在の説明に「a = msid」行が存在しない場合、「a = msid」行は、最初の回答と同じルールに従って生成する必要があります. 

5.3.3. オプションの取り扱い
createAnswerメソッドは、パラメーターとしてRTCAnswerOptionsオブジェクトを取ります. RTCAnswerOptionsのパラメーターのセットは、RTCOfferOptionsでサポートされているものとは異なります. 提供者がICE再起動の実行を選択したすべての「m =」セクションのICE資格情報が自動的に変更されるため、IceRestartオプションは不要です. 

次のオプションはRTCAnswerOptionsでサポートされています. 

5.3.3.1. VoiceActivityDetection
回答の無音抑制は、セクション5.2.3.2で説明されているように処理されますが、1つの例外があります. オファーで無音抑制のサポートが示されていない場合、VoiceActivityDetectionパラメーターは効果がなく、VoiceActivityDetectionが「false」. これはコーデックごとに行われます（たとえば、提供者が何らかの理由でCNのサポートを提供したが、Opusに「usedtx = 0」を設定した場合、VoiceActivityDetectionを「true」に設定すると、CNコーデックと「usedtx = 0」で応答が返されます.  ）. このルールの影響は、アンサーがそれを提供しないエンドポイントで無音抑制を使用しようとしないことであり、JSEP以外のエンドポイントでも無音抑制サポートを二国間にします. 

5.4. オファーまたはアンサーの変更
createOfferまたはcreateAnswerから返されたSDPは、setLocalDescriptionに渡す前に変更してはなりません（MUSTNOT）. SDPを正確に制御する必要がある場合は、前述のcreateOffer / createAnswerオプションまたはRtpTransceiverAPIを使用する必要があります. 

オファーまたはアンサーを使用してsetLocalDescriptionを呼び出した後、アプリケーションは、有効なJSEPオファーまたはアンサーを定義する上記のルールに従っている限り、SDPを変更して機能を減らしてからファーサイドに送信できます. 同様に、ピアからオファーまたはアンサーを受信したアプリケーションは、setRemoteDescriptionを呼び出す前に、同じ制約に従って、受信したSDPを変更できます（MAY）. 

いつものように、アプリケーションは相手に送信するものに対して単独で責任があり、すべての着信SDPは、その機能の範囲内でJSEP実装によって処理されます. すべてのSDPが適切に形成されていると仮定するのは誤りです. ただし、この仕様の実装は、この仕様の他の実装からの変更されていないSDPをリモートオファーまたはアンサーとして処理できると想定できるはずです. 

5.5. ローカル記述の処理
SessionDescriptionがsetLocalDescriptionに提供される場合、以下のステップを実行する必要があります. 

*説明のタイプが「ロールバック」の場合は、セクション5.7で定義されている処理に従い、このセクションの残りの部分で説明されている処理をスキップします. 

*それ以外の場合、SessionDescriptionのタイプはPeerConnectionの現在の状態と照合されます. 

-タイプが「offer」の場合、PeerConnectionの状態は「stable」または「have-local-offer」のいずれかである必要があります. 

-タイプが「pranswer」または「answer」の場合、PeerConnectionの状態は「have-remote-offer」または「have-local-pranswer」のいずれかである必要があります. 

*タイプが現在の状態に対して正しくない場合、処理を停止し、エラーを返す必要があります. 

*次に、SessionDescriptionをチェックして、その内容がcreateOffer / createAnswerの最後の呼び出しで生成されたものと同じであり、セクション5.4で説明したように変更されていないことを確認します. それ以外の場合は、処理を停止し、エラーを返す必要があります. 

*次に、以下のセクション5.8で説明するように、SessionDescriptionがデータ構造に解析されます. 

*最後に、解析されたSessionDescriptionは、以下のセクション5.9で説明されているように適用されます. 

5.6. リモート記述の処理
SessionDescriptionがsetRemoteDescriptionに提供される場合、以下のステップを実行する必要があります. 

*説明のタイプが「ロールバック」の場合は、セクション5.7で定義されている処理に従い、このセクションの残りの部分で説明されている処理をスキップします. 

*それ以外の場合、SessionDescriptionのタイプはPeerConnectionの現在の状態と照合されます. 

-タイプが「offer」の場合、PeerConnectionの状態は「stable」または「have-remote-offer」のいずれかである必要があります. 

-タイプが「pranswer」または「answer」の場合、PeerConnectionの状態は「have-local-offer」または「have-remote-pranswer」のいずれかである必要があります. 

*タイプが現在の状態に対して正しくない場合、処理を停止し、エラーを返す必要があります. 

*次に、以下のセクション5.8で説明するように、SessionDescriptionがデータ構造に解析されます. 何らかの理由で解析が失敗した場合、処理を停止し、エラーを返す必要があります. 

*最後に、解析されたSessionDescriptionは、以下のセクション5.10で説明されているように適用されます. 

5.7. ロールバックの処理
PeerConnectionが「安定」以外の状態にある場合、ロールバックが実行される可能性があります. これは、オファーと暫定回答の両方をロールバックできることを意味します. ロールバックは、提案された変更をキャンセルするためにのみ使用できます. 「安定」状態から以前の「安定」状態へのロールバックはサポートされていません. 「安定した」状態でロールバックが試行された場合、処理を停止し、エラーを返す必要があります. これは、回答者が回答に対してsetLocalDescriptionを実行すると、これをロールバックできないことを意味することに注意してください. 

setLocalDescriptionまたはsetRemoteDescriptionのどちらが呼び出されたかに関係なく、ロールバックの効果は同じでなければなりません. 

ロールバックを処理するために、JSEP実装は現在のオファー/アンサートランザクションを破棄し、シグナリング状態を「安定」に設定し、保留中のローカルおよび/またはリモートの説明（セクション4.1.14および4.1.16を参照）を「null」に設定します.  ". 放棄されたローカル記述によって割り当てられたリソースまたは候補はすべて破棄されます. 受信したメディアはすべて、以前のローカルおよびリモートの説明に従って処理されます. 

ロールバックは、ロールバックされたセッションの説明を適用することにより、「m =」セクションに関連付けられていたRtpTransceiversの関連付けを解除します（セクション5.10および5.9を参照）. これは、以前はいくつかのRtpTransceiversがあったことを意味します関連付けられているは、「m =」セクションに関連付けられなくなります. このような場合、RtpTransceiverのmidプロパティの値を「null」に設定する必要があり、トランシーバーとその「m =」セクションインデックス間のマッピングを破棄する必要があります. その後ロールバックされたリモートオファーを適用することによって作成されたRtpTransceiversは、停止してPeerConnectionから削除する必要があります. ただし、トラックがaddTrackメソッドを介してRtpTransceiverに接続されている場合は、RtpTransceiverを削除してはなりません（MUSTNOT）. これは、アプリケーションがaddTrackを呼び出し、オファーでsetRemoteDescriptionを呼び出し、そのオファーをロールバックし、createOfferを呼び出して、生成されたオファーに追加されたトラックの「m =」セクションを表示できるようにするためです. 

5.8. セッションの説明の解析
セッション記述オブジェクトに含まれるSDPは、[RFC4566]のセクション5で説明されているように、それぞれがKey-Value式を含む一連のテキスト行で構成されます. SDPは1行ずつ読み取られ、次のようなデータ構造に変換されます. デシリアライズされた情報が含まれています. ただし、SDPでは多くの種類の回線が許可されており、そのすべてがJSEPアプリケーションに関連しているわけではありません. 各行について、実装は最初に、定義するABNFに従って構文的に正しいことを確認し、[RFC4566]および[RFC3264]で使用されるセマンティクスに準拠していることを確認してから、提供された値を解析して保存または破棄します. 以下で説明します. 

いずれかの行が整形式でないか、説明どおりに解析できない場合、値が破棄される場合でも、パーサーはエラーで停止し、セッションの説明を拒否する必要があります. これにより、実装があいまいなSDPを誤って誤解することがなくなります. 

5.8.1. セッションレベルの解析
まず、セッションレベルの行がチェックされ、解析されます. これらの行は、[RFC4566]のセクション5で定義されているように、特定の順序で特定の構文で出現する必要がありますが、特定の線種（ "v ="、 "c ="など）は定義済みで出現する必要があります. 順序、同じタイプの行（通常は「a =」）は任意の順序で発生する可能性があります. 

次の非属性行は、JSEPコンテキストでは意味がなく、チェックされると破棄される場合があります. 

*「c =」行の構文をチェックする必要がありますが、その値は、[RFC8445]のセクション5.4で定義されているように、ICEの不一致の検出にのみ使用されます. WebRTCにはICEが必要であるため、JSEP実装でこの状態が発生することはないことに注意してください. 

* "i ="、 "u ="、 "e ="、 "p ="、 "t ="、 "r ="、 "z ="、および "k ="行の構文をチェックする必要がありますが、それらの値は他の方法では使用されません. 

残りの非属性行は次のように処理されます. 

* [RFC4566]のセクション5.1で指定されているように、「v =」行のバージョンは0でなければなりません. 

*「o =」行は[RFC4566]のセクション5.2で指定されているように解析する必要があります. 

*「b =」行が存在する場合は、[RFC4566]のセクション5.8で指定されているように解析し、bwtypeと帯域幅の値を格納する必要があります. 

最後に、属性行が処理されます. 次のセッションレベルの属性（ "a ="）行には、特定の処理を適用する必要があります. 

*「a = group」行は[RFC5888]のセクション5で指定されているように解析され、グループのセマンティクスとミッドが格納されます. 

*存在する場合、[RFC8839]のセクション5.3で指定されているように、単一の「a = ice-lite」行が解析され、ice-liteの存在を示す値が格納されます. 

*存在する場合、単一の「a = ice-ufrag」行が[RFC8839]のセクション5.4で指定されているように解析され、ufrag値が格納されます. 

*存在する場合、単一の「a = ice-pwd」行が[RFC8839]のセクション5.4で指定されているように解析され、パスワード値が保存されます. 

*存在する場合、単一の「a = ice-options」行が[RFC8839]のセクション5.6で指定されているように解析され、指定されたオプションのセットが格納されます. 

*「a = fingerprint」行は[RFC8122]のセクション5で指定されているように解析され、フィンガープリントとアルゴリズムの値のセットが保存されます. 

*存在する場合、[RFC4145]のセクション4で指定されているように、単一の「a = setup」行が解析され、セットアップ値が格納されます. 

*存在する場合、単一の「a = tls-id」行が[RFC8842]のセクション5で指定されているように解析され、属性値が格納されます. 

* [RFC8827]のセクション5で指定されているように、「a = identity」行はすべて解析され、ID値は後続の検証のために保存されます. 

*「a = extmap」行は[RFC5285]のセクション5で指定されているように解析され、それらの値が格納されます. 

JSEPに関係のない他の属性も存在する可能性があり、実装は認識したものを処理する必要があります. [RFC4566]のセクション5.13で要求されているように、不明な属性行は無視する必要があります. 

すべてのセッションレベルの行が解析されると、処理は「m =」セクションの行から続行されます. 

5.8.2. メディアセクションの解析
セッションレベルの行と同様に、メディアセクションの行は、[RFC4566]のセクション5で定義されている特定の順序で特定の構文で出現する必要があります. 

「m =」行自体は、[RFC4566]のセクション5.14で説明されているように解析され、<media>、<port>、<proto>、および<fmt>の値が格納されている必要があります. 

「m =」行に続いて、次の非属性行に特定の処理を適用する必要があります. 

*セッションレベルの「c =」行と同様に、「c =」行は[RFC4566]のセクション5.7に従って解析する必要がありますが、その値は使用されません. 

*「b =」行が存在する場合は、[RFC4566]のセクション5.8で指定されているように解析し、bwtypeと帯域幅の値を格納する必要があります. 

次の属性行にも特定の処理を適用する必要があります. 

*存在する場合、単一の「a = ice-ufrag」行が[RFC8839]のセクション5.4で指定されているように解析され、ufrag値が格納されます. 

*存在する場合、単一の「a = ice-pwd」行が[RFC8839]のセクション5.4で指定されているように解析され、パスワード値が保存されます. 

*存在する場合、単一の「a = ice-options」行が[RFC8839]のセクション5.6で指定されているように解析され、指定されたオプションのセットが格納されます. 

*「a = candidate」属性は、[RFC8839]のセクション5.1で指定されているように解析し、それらの値を格納する必要があります. 

*「a = remote-candidates」属性は、[RFC8839]のセクション5.2で指定されているように解析する必要がありますが、それらの値は無視されます. 

*存在する場合、単一の「a = end-of-candidates」属性は、[RFC8840]のセクション8.1で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります. 

*「a = fingerprint」行は[RFC8122]のセクション5で指定されているように解析され、フィンガープリントとアルゴリズムの値のセットが保存されます. 

上記のセクション5.1.2で説明したように、「m = "<proto>値がRTPの使用を示している場合は、次の属性行を処理する必要があります. 

* "m =" <fmt>値は、[RFC4566]のセクション5.14で指定されているように解析され、個々の値が格納されている必要があります. 

*「a = rtpmap」または「a = fmtp」の行は、[RFC4566]のセクション6で指定されているように解析し、それらの値を格納する必要があります. 

*存在する場合、[RFC4566]のセクション6で説明されているように、単一の「a = ptime」行を解析し、その値を格納する必要があります. 

*存在する場合、[RFC4566]のセクション6で説明されているように、単一の「a = maxptime」行を解析し、その値を格納する必要があります. 

*存在する場合、[RFC4566]のセクション6で説明されているように、単一directionの属性行（ "a = sendrecv"など）を解析し、その値を格納する必要があります. 

*「a = ssrc」属性は、[RFC5576]のセクション4.1で指定されているように解析し、それらの値を格納する必要があります. 

*「a = extmap」属性は、[RFC5285]のセクション5で指定されているように解析し、それらの値を格納する必要があります. 

*「a = rtcp-fb」属性は、[RFC4585]のセクション4.2で指定されているように解析し、それらの値を格納する必要があります. 

*存在する場合、単一の「a = rtcp-mux」属性は、[RFC5761]のセクション5.1.3で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります. 

*存在する場合、単一の「a = rtcp-mux-only」属性は、[RFC8858]のセクション3で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります. 

*存在する場合、単一の「a = rtcp-rsize」属性は、[RFC5506]のセクション5で指定されているように解析され、その存在または不在にフラグが付けられて保存される必要があります. 

*存在する場合、単一の「a = rtcp」属性は[RFC3605]のセクション2.1で指定されているように解析する必要がありますが、ICEを使用する場合、この情報は不要であるため、その値は無視されます. 

*存在する場合、「a = msid」属性は、[RFC8830]のセクション3.2で指定されているように解析され、それらの値は「appdata」フィールドを無視して保存される必要があります. 「a = msid」属性が存在しない場合、セッションの「デフォルト」MediaStreamに対してランダムなmsid-id値が生成され、まだ存在しない場合は、この値が保存されます. 

*「a = imageattr」属性は、[RFC6236]のセクション3で指定されているように解析し、それらの値を格納する必要があります. 

*「a = rid」行は、[RFC8851]のセクション10で指定されているように解析し、それらの値を格納する必要があります. 

*存在する場合、単一の「a = simulcast」行は、[RFC8853]で指定されているように解析され、その値が格納される必要があります. 

それ以外の場合、「m = "<proto>値がSCTPの使用を示している場合は、次の属性行を処理する必要があります. 

* "m =" <fmt>値は、[RFC8841]のセクション4.3で指定されているように解析され、アプリケーションプロトコル値が格納されている必要があります. 

*「a = sctp-port」属性が存在する必要があり、[RFC8841]のセクション5.2で指定されているように解析され、値が格納されている必要があります. 

*存在する場合、単一の「a = max-message-size」属性は、[RFC8841]のセクション6で指定されているように解析され、値が格納されている必要があります. それ以外の場合は、指定されたデフォルトを使用します. 

JSEPに関係のない他の属性も存在する可能性があり、実装は認識したものを処理する必要があります. [RFC4566]のセクション5.13で要求されているように、不明な属性行は無視する必要があります. 

5.8.3. セマンティクス検証
解析が正常に完了したと仮定すると、解析された記述が評価され、内部の一貫性と必須機能の適切なサポートが保証されます. 具体的には、次のチェックが実行されます. 

*各「m =」セクションには、セクション5.1.1に列挙されている必須の機能のそれぞれに有効な値が存在する必要があります. これらの値は、メディアレベルに存在するか、セッションレベルから継承される場合があります. 

-ICE ufragおよびpassword値. これは、[RFC8839]のセクション5.4で指定されているサイズ制限に準拠する必要があります. 

-tls-id値. [RFC8842]のセクション5に従って設定する必要があります. これが再オファーまたは再オファーへの応答であり、tls-id値が現在使用されている値と異なる場合、 DTLS接続は継続されておらず、リモートの説明は、新しいufragとパスワードの値とともにICE再起動の一部である必要があります. 

-DTLSセットアップ値. [RFC5763]のセクション5で指定されたルールに従って設定する必要があり、現在のDTLS接続の選択された役割と一致している必要があります（存在し、継続されている場合）. 

-DTLSフィンガープリント値. 少なくとも1つのフィンガープリントが存在する必要があります. 

*「a = simulcast」行で参照されるすべてのrid-idは「a = rid」行として存在する必要があります. 

*各「m =」セクションもチェックされ、禁止されている機能が使用されていないことを確認します. 

* RTP / RTCP多重化ポリシーが「require」の場合、各「m =」セクションには「a = rtcp-mux」属性が含まれている必要があります. 「m =」セクションに「a = rtcp-mux-only」属性が含まれている場合、そのセクションには「a = rtcp-mux」属性も含まれている必要があります. 

*「m =」セクションが前の回答に存在した場合、RTP / RTCP多重化の状態は、以前にネゴシエートされたものと一致する必要があります. 

このセッションの説明のタイプが「pranswer」または「answer」の場合、次の追加のチェックが適用されます. 

*セッションの説明は、[RFC3264]のセクション6で定義されているルールに従う必要があります. これには、「m =」セクションの数が関連するオファーの「m =」セクションの数と正確に一致する必要があるという要件が含まれます. 

*各「m =」セクションのメディアタイプとプロトコル値は、関連するオファーの対応する「m =」セクションのメディアタイプとプロトコル値と正確に一致する必要があります. 

上記のチェックのいずれかが失敗した場合、処理を停止し、エラーを返す必要があります. 

5.9. ローカル記述の適用
次の手順は、ローカル記述を適用するためにメディアエンジンレベルで実行されます. エラーが返された場合は、これらの手順を実行する前に、セッションを元の状態に復元する必要があります. 

まず、「m =」セクションが処理されます. 「m =」セクションごとに、次の手順を実行する必要があります. パラメータが範囲外であるか適用できない場合、処理を停止し、エラーを返す必要があります. 

*この「m =」セクションが新しい場合は、[RFC8445]のセクション5.1.1で定義されているように、確実にバンドルされていない限り（（1）これはオファーであり、「m =」セクションはバンドルのみとマークされているか、（2）回答であり、「m =」セクションは別の「m =」セクションにバンドルされています. 

*または、ICE ufragとpasswordの値が変更された場合は、[RFC8445]のセクション9で説明されているように、ICEエージェントをトリガーしてICEの再起動を開始し、「m =」セクションの新しい候補の収集を開始します. この説明が答えである場合は、そのメディアセクションのチェックも開始します. 

*「m =」セクションの<proto>値がRTPの使用を示している場合：

-この「m =」セクションに関連付けられているRtpTransceiverがない場合は、RtpTransceiverを見つけて、次の手順に従ってこの「m =」セクションに関連付けます. この状況は、オファーを適用する場合にのみ発生することに注意してください. 

oトランシーバーとオファーの作成時に確立された「m =」セクションインデックス間のマッピングを使用して、この「m =」セクションに対応するRtpTransceiverを見つけます. 

oこのRtpTransceiverのmidプロパティの値を「m =」セクションのMIDに設定します. 

-RTCPマルチプレクサが示されている場合は、[RFC5761]のセクション5.1.3で指定されているように、RTPICEコンポーネントからRTPおよびRTCPをデマルチプレクサする準備をします. 

-[RFC5285]のセクション6で説明されているように、指定されたRTPヘッダー拡張ごとに、拡張IDとURIの間のマッピングを確立します. 

-MIDヘッダー拡張がサポートされている場合は、[RFC8843]のセクション15で説明されているように、MIDヘッダー拡張に基づいてこの「m =」セクション向けのRTPストリームをデマルチプレクサする準備をします. 

-[RFC3264]のセクション6.1で説明されているように、指定されたメディア形式ごとに、ペイロードタイプと実際のメディア形式の間のマッピングを確立します. さらに、[RFC8843]のセクション9.2で説明されているように、この「m =」セクションでサポートされているメディア形式に基づいて、この「m =」セクション向けのRTPストリームをデマルチプレクサする準備をします. 

-[RFC4588]のセクション8.6および8.7で説明されているように、指定された「rtx」メディア形式ごとに、RTXペイロードタイプとそれに関連するプライマリペイロードタイプの間のマッピングを確立します. 

-direction属性のタイプが「sendrecv」または「recvonly」の場合、メディアの受信とデコードを有効にします. 

最後に、この説明のタイプが「pranswer」または「answer」の場合は、以下のセクション5.11で定義されている処理に従います. 

5.10. リモート記述の適用
リモート記述を適用するには、次の手順を実行します. エラーが返された場合は、これらの手順を実行する前に、セッションを元の状態に復元する必要があります. 

回答に「trickle」が属性としてリストされている「a = ice-options」属性が含まれている場合は、PeerConnectioncanTrickleIceCandidatesプロパティを「true」に更新します. それ以外の場合は、このプロパティを「false」に設定します. 

次の手順は、セッションレベルで属性に対して実行する必要があります. パラメータが範囲外であるか適用できない場合、処理を停止し、エラーを返す必要があります. 

*指定された「CT」帯域幅値については、[RFC4566]のセクション5.8で指定されているように、この値をすべての「m =」セクションの最大合計ビットレートの制限として設定します. この全体的な制限内で、実装は、個々の「m =」セクションに指定された特定の制限を尊重して、「m =」セクション間で使用可能な帯域幅を最適に割り当てる方法を動的に決定できます. 

*指定された「RR」または「RS」帯域幅の値については、[RFC3556]のセクション2で指定されているように処理してください. 

*セッションレベルでのこの構成の意味が明確に定義されていないため、「AS」帯域幅の値（[RFC4566]、セクション5.8）は無視する必要があります. 

「m =」セクションごとに、次の手順を実行する必要があります. パラメータが範囲外であるか適用できない場合、処理を停止し、エラーを返す必要があります. 

* ICE ufragまたはパスワードが以前のリモート記述から変更された場合：

-説明のタイプが「offer」の場合、[RFC8839]のセクション4.4.1.1.1で説明されているように、実装はICEの再起動が必要であることに注意する必要があります. 

-説明のタイプが「answer」または「pranswer」の場合は、現在のローカル説明がICE再起動であるかどうかを確認し、そうでない場合はエラーを生成します. PeerConnectionの状態が「have-remote-pranswer」であり、ICE ufragまたはパスワードが前の暫定回答から変更された場合は、「m =」セクションの以前のICEチェックリスト状態を破棄するようにICEエージェントに通知します. 最後に、ICEエージェントにチェックを開始するように通知します. 

*現在のローカル記述がICEの再起動を示しているが、ICE ufragもパスワードも以前のリモート記述（[RFC8445]、セクション9で規定）から変更されていない場合、エラーが生成されます. 

*接続チェックに提供されたICEリモートufragとパスワードを使用するように、このメディアセクションに関連付けられたICEコンポーネントを構成します. 

* [RFC8445]のセクション6.1.2で説明されているように、提供されたICE候補を収集されたローカル候補とペアリングし、適切な資格情報を使用して接続チェックを開始します. 

*「a = end-of-candidates」属性が存在する場合は、[RFC8838]のセクション14の説明に従って、end-of-candidates表示を処理します. 

*「m =」セクションの<proto>値がRTPの使用を示している場合：

-「m =」セクションがリサイクルされている場合（セクション5.2.2を参照）、現在関連付けられているRtpTransceiverのmidプロパティを「null」に設定して関連付けを解除し、トランシーバーと「m =」セクションインデックス間のマッピングを破棄します. 

-「m =」セクションがどのRtpTransceiverにも関連付けられていない場合（おそらく前の手順で関連付けが解除されたため）、RtpTransceiverを見つけるか、次の手順に従って作成します. 

o「m =」セクションがsendrecvまたはrecvonlyであり、addTrackによってPeerConnectionに追加され、「m =」セクションに関連付けられておらず、停止されていない同じタイプのRtpTransceiversがある場合は、最初のものを見つけます（セクション5.2.1で説明されている正規の順序に）そのようなRtpTransceiver. 

o前の手順でRtpTransceiverが見つからなかった場合は、recvonlydirectionでRtpTransceiverを作成します. 

oRtpTransceiverのmidプロパティの値を "m ="セクションのMIDに設定することにより、検出または作成されたRtpTransceiverを "m ="セクションに関連付け、トランシーバーと "m ="のインデックス間のマッピングを確立します. セクション. 「m =」セクションにMIDが含まれていない場合（つまり、リモートエンドポイントがMID拡張をサポートしていない場合）、セクション5.2.1で説明した「a = mid」のガイダンスに従って、RtpTransceivermidプロパティの値を生成します.  . 

-ローカル実装でもサポートされている指定されたメディア形式ごとに、[RFC3264]のセクション6.1で説明されているように、指定されたペイロードタイプとメディア形式の間のマッピングを確立します. 具体的には、これは、実装が、指定された各メディア形式を送信するときに発信RTPパケットで使用されるペイロードタイプと、順序で示される各形式の相対的な優先順位を記録することを意味します. 示されたメディア形式がローカル実装でサポートされていない場合は、無視する必要があります. 

-[RFC4588]のセクション4で説明されているように、指定された「rtx」メディア形式ごとに、RTXペイロードタイプとそれに関連するプライマリペイロードタイプの間のマッピングを確立します. 参照されるプライマリペイロードタイプが存在しない場合、これは次の結果になる必要があります. エラー. RTXペイロードタイプは、ローカルメディア実装でサポートされていないプライマリペイロードタイプを参照する場合があることに注意してください. その場合、RTXペイロードタイプも無視する必要があります. 

-ローカル実装でサポートされている指定されたfmtpパラメータごとに、関連するメディア形式でそれらを有効にします. 

-[RFC8843]のセクション9.2で説明されているように、「m =」セクションで通知される指定された同期ソース（SSRC）ごとに、そのSSRCを使用してこの「m =」セクション向けのRTPストリームをデマルチプレクサする準備をします. 

-ローカル実装でもサポートされている指定されたRTPヘッダー拡張ごとに、[RFC5285]のセクション5で説明されているように、拡張IDとURIの間のマッピングを確立します. 具体的には、実装が使用される拡張IDを記録することを意味します. 指定された各ヘッダー拡張子を送信するときの発信RTPパケット. 示されたRTPヘッダー拡張がローカル実装でサポートされていない場合は、無視する必要があります. 

-ローカル実装でサポートされている指定されたRTCPフィードバックメカニズムごとに、関連するメディア形式でそれらを有効にします. 

-指定された「TIAS」（「トランスポートに依存しないアプリケーション固有の最大値」）帯域幅値について、[RFC3890]で指定されているように、この値をメディアの送信時に使用される最大RTPビットレートの制約として設定します. 「TIAS」値が存在しないが「AS」値が指定されている場合は、次の式を使用して「TIAS」値を生成します. 

            TIAS = AS * 1000 * 0.95-（50 * 40 * 8）
        
1000は単位をkbpsからbpsに変更し（TIASの要求に応じて）、0.95は5％をRTCPに割り当てます. 次に、ヘッダーオーバーヘッドの見積もりが差し引かれます. ここで、50は1秒あたり50パケットに基づいており、40は一般的なヘッダーサイズ（バイト単位）に基づいており、8はバイトをビットに変換します. 「TIAS」は、帯域幅をより正確に制御できるため、「AS」よりも優先されることに注意してください. 

-「RR」または「RS」帯域幅の値については、[RFC3556]のセクション2で指定されているように処理してください. 

-メディアレベルでのこの構成の意味が明確に定義されていないため、指定された「CT」帯域幅値は無視する必要があります. 

-「m =」セクションのタイプが「audio」の場合：

o指定された「CN」メディアフォーマットごとに、[RFC3389]のセクション5で説明されているように、サポートされているすべてのメディアフォーマットに対して、独自の内部無音抑制メカニズムを持つフォーマットを除いて、無音抑制を設定します. セクション5.2.3.2で説明されているように、このような形式（Opusなど）の無音抑制は、fmtpパラメーターを介して制御されます. 

o [RFC4733]のセクション2.5.1.2で説明されているように、指定された「電話イベント」メディア形式ごとに、サポートされているすべてのメディア形式で同じクロックレートでデュアルトーン多重周波数（DTMF）送信を有効にします. 対応する電話イベント形式を持たないサポートされているメディア形式がある場合は、それらの形式のDTMF送信を無効にします. 

o指定された「ptime」値について、送信時に指定されたパケットサイズを使用するように使用可能なメディア形式を構成します. 指定されたサイズがメディア形式でサポートされていない場合は、代わりに次に近い値を使用してください. 

最後に、この説明のタイプが「pranswer」または「answer」の場合は、以下のセクション5.11で定義されている処理に従います. 

5.11. 回答を適用する
ローカルまたはリモートの説明を処理するための上記のステップに加えて、タイプ「pranswer」または「answer」の説明を処理するときに、以下のステップが実行されます. 

「m =」セクションごとに、次の手順を実行する必要があります. 

*「m =」セクションが拒否された場合（つまり、回答で<port>値がゼロに設定されている場合）、このセクションのメディアの受信または送信を停止し、拒否されていない「m =」でない限りセクションはこの「m =」セクションにバンドルされており、[RFC8839]のセクション4.4.3.1で説明されているように、関連するICEコンポーネントを破棄します. 

*リモートDTLSフィンガープリントが変更された場合、または「a = tls-id」属性の値が変更された場合は、DTLS接続を切断します. これには、PeerConnectionの状態が「have-remote-pranswer」の場合も含まれます. DTLS接続を切断する必要があるが、応答がICEの再起動を示さない場合、または「have-remote-pranswer」の場合は新しいICE資格情報の場合、エラーを生成する必要があります. tls-id値またはフィンガープリントを変更せずにICEの再起動が実行された場合、同じDTLS接続が新しいICEチャネルを介して継続されます. JSEPでは、オファー側が変更する場合にのみ、回答者がtls-id値を変更する必要がありますが、JSEP以外の回答者は、オファーにICE再起動が含まれている限りtls-id値を変更できます. したがって、

*有効なDTLS接続が存在しない場合は、基になるICEコンポーネントがアクティブになったら、指定された役割とフィンガープリントを使用してDTLS接続を開始する準備をします. 

*「m =」セクションの<proto>値がRTPの使用を示している場合：

-「m =」セクションがオファーの対応する「m =」セクションに存在しなかったRTCPフィードバックメカニズムを参照している場合、これはネゴシエーションの問題を示しており、エラーが発生する必要があります. ただし、[RFC3264]のセクション7および[RFC5285]のセクション6で説明されているように、新しいメディア形式と新しいRTPヘッダー拡張値が回答で許可されています. 

-「m =」セクションでRTCPmuxが有効になっている場合は、RTCP ICEコンポーネントが存在する場合はそれを破棄し、[RFC5761]のセクション5.1.3で指定されているように、RTPICEコンポーネントを介してRTCPの多重化を開始または続行します. それ以外の場合は、RTCPICEコンポーネントを介してRTCPを送信する準備をします. RTCPマルチプレクサが以前に有効にされていたためにRTCPICEコンポーネントが存在しない場合、これはエラーにならなければならない[MUST]. 

-「m =」セクションで縮小サイズRTCPが有効になっている場合は、[RFC5506]で指定されているように、この「m =」セクションのRTCP送信を縮小サイズRTCPを使用するように構成します. 

-回答のdirection属性が、JSEP実装がメディアを送信する必要があることを示している場合（ローカル回答の場合は「sendonly」、リモート回答の場合は「recvonly」、いずれかのタイプの回答の場合は「sendrecv」）、送信するメディア形式を選択します.  [RFC3264]のセクション6.1および7で説明されているように、ローカルでもサポートされているリモート記述から最も好ましいメディア形式であり、基盤となるトランスポート層が確立されたら、その形式を使用してRTPメディアの送信を開始します. この発信RTPストリームに対してSSRCがまだ選択されていない場合は、一意のランダムなものを選択してください. メディアがすでに送信されている場合は、新しいコーデックのクロックレートが異なる場合を除き、同じSSRCを使用する必要があります. 異なる場合は、[RFC7160]のセクション4.1で指定されているように、新しいSSRCを選択する必要があります. 

-リモート記述からのペイロードタイプマッピングは、上記で選択した送信メディア形式のペイロードタイプを含む、発信RTPストリームのペイロードタイプを決定するために使用されます. ネゴシエートされたRTPヘッダー拡張は、リモート記述からの拡張マッピングを使用して、発信RTPストリームに含める必要があります. MIDヘッダー拡張がネゴシエートされている場合は、[RFC8843]のセクション15に示されているように、発信RTPストリームに含めます. RtpStreamIdまたはRepairedRtpStreamIdヘッダー拡張がネゴシエートされ、rid-idが確立されている場合は、これらのヘッダー拡張を[RFC8851]のセクション4に示されているように、発信RTPストリーム. 

-「m =」セクションのタイプが「audio」で、（1）リモート記述の処理の結果として送信メディア形式に対して無音抑制が構成され、（2）ローカル記述でその形式に対しても有効にされた場合、セクション5.2.3.2のガイダンスに従って、発信メディアに無音抑制を使用します. これらの条件が満たされない場合、発信メディアに無音抑制を使用してはなりません（MUSTNOT）. 

-サイマルキャストがネゴシエートされている場合は、[RFC8853]のセクション5.3.3で指定されている適切な数のソースRTPストリームを送信します. 

-上記で選択した送信メディア形式に対応する「rtx」メディア形式がある場合、またはFECメカニズムがネゴシエートされている場合は、ソースRTPストリームごとに一意のランダムSSRCを使用して冗長RTPストリームを確立し、RTX / FECパケットの送信を開始または続行します. 必要です. 

-上記で選択した送信メディア形式に、同じクロックレートの対応する「赤」メディア形式がある場合は、[RFC8854]のセクション3.2で説明されているように、復元力の目的で指定された形式を使用した冗長エンコードを許可します. RTXまたはFECメディア形式とは異なり、「赤」形式は、冗長RTPストリームではなく、ソースRTPストリームで送信されることに注意してください. 

-指定されたメディア形式を使用して、すべてのソースRTPストリームのメディアセクションで参照されているRTCPフィードバックメカニズムを有効にします. 具体的には、[RFC4585]のセクション4.2で指定されているように、要求されたフィードバックタイプの送信を開始または継続し、受信したフィードバックに対応します. RTCPフィードバックを送信するときは、[RFC8108]のセクション5.4.1の規則と推奨事項に従って、使用するSSRCを選択してください. 

-回答のdirection属性が、JSEP実装がメディアを送信してはならないことを示している場合（ローカル回答の場合は「recvonly」、リモート回答の場合は「sendonly」、いずれかのタイプの回答の場合は「inactive」）、すべてのRTPメディアの送信を停止します. ただし、[RFC3264]のセクション5.1で説明されているように、RTCPの送信を続行します. 

*「m =」セクションの<proto>値がSCTPの使用を示している場合：

-SCTPアソシエーションが存在し、リモートSCTPポートが変更された場合は、既存のSCTPアソシエーションを破棄します. これには、PeerConnectionの状態が「have-remote-pranswer」の場合も含まれます. 

-有効なSCTPアソシエーションが存在しない場合は、[RFC8841]で説明されているように、ローカル記述のローカルSCTPポート値とリモート記述のリモートSCTPポート値を使用して、関連付けられたICEコンポーネントとDTLS接続を介してSCTPアソシエーションを開始する準備をします.  、セクション10.2. 

回答に有効なバンドルグループが含まれている場合は、[RFC8843]で説明されているように、各バンドルのプライマリICEコンポーネントにバンドルされる「m =」セクションのICEコンポーネントを破棄し、それに応じてこれらの「m =」セクションの多重化を開始します. セクション7.4. 

説明のタイプが「answer」であり、ICE候補プールにまだ候補が残っている場合は、それらを破棄します. 

6. RTP / RTCPの処理
バンドルする場合、着信RTP / RTCPを適切な「m =」セクションに関連付けることは、[RFC8843]のセクション9.2で定義されています. バンドルしていない場合、適切な「m =」セクションは、RTP / RTCPを受信するICEコンポーネントからクリアされます. 

適切な「m =」セクションがわかると、RTP / RTCPが「m =」セクションに関連付けられたRtpTransceiverに配信され、RTP / RTCPのさらなる処理がRtpTransceiverレベルで実行されます. これには、RIDメカニズム[RFC8851]とそれに関連するRtpStreamIdおよびRepairedRtpStreamId識別子を使用して、複数のエンコードされたストリームを区別し、特定の冗長RTPストリームによって修復する必要があるソースRTPストリームを決定することが含まれます. 

7.例
このサンプルセクションは、いくつかのSDPフラグメントを示していることに注意してください. RFCの行の長さの制限に対応するために、一部のSDP行は複数の行に分割されています. 先頭の空白は、行が前の行の続きであることを示しています. さらに、読みやすさを向上させるためにいくつかの空白行が追加されましたが、SDPでは無効です. 

IPv6アドレスを使用した例を含むWebRTCコールフローのSDPのその他の例は、[SDP4WebRTC]にあります. 

7.1. 簡単な例
このセクションでは、TrickleICEを使用せずに2つのJSEPエンドポイント間で最小限のオーディオ/ビデオ通話を設定する非常に簡単な例を示します. 次のセクションの例は、JSEPセッションで発生する可能性のあるより詳細な例を示しています. 

以下のコードフローは、アリスのエンドポイントがボブのエンドポイントへのセッションを開始することを示しています. アリスのブラウザのJavaScriptアプリケーションからボブのブラウザのJavaScriptへのメッセージは、それぞれ「AliceJS」および「BobJS」と省略され、Webサーバーを介して何らかのシグナリングプロトコルを介して流れると想定されています. アリス側とボブ側の両方のJavaScriptは、オファーまたは回答を送信する前にすべての候補者を待機するため、オファーと回答は完了です. TrickleICEは使用されていません. アリスとボブのブラウザのユーザーエージェント（JSEP実装）は、それぞれ「AliceUA」と「BobUA」と略され、どちらもデフォルトのバンドルポリシー「balanced」とデフォルトのRTCPマルチプレクサポリシー「require」を使用しています. 

   //ローカルメディアの状態を設定します
   AliceJS-> AliceUA：新しいPeerConnectionを作成します
   AliceJS-> AliceUA：オーディオとビデオの2つのトラックを持つaddTrack
   AliceJS-> AliceUA：オファーを取得するためのcreateOffer
   AliceJS-> AliceUA：setLocalDescriptionとオファー
   AliceUA-> AliceJS：候補者との複数のonicecandidateイベント
        
   // ICEの収集が完了するのを待ちます
   AliceUA-> AliceJS：候補がnullのonicecandidateイベント
   AliceJS-> AliceUA：|オファーを取得-A1 | からpendingLocalDescriptionから
        
   // |オファー-A1 | シグナリングプロトコルを介してボブに送信されます
   AliceJS-> WebServer：| offer-A1 |によるシグナリング
   WebServer-> BobJS：| offer-A1 |によるシグナリング
        
   // |オファー-A1 | ボブに到着
   BobJS-> BobUA：PeerConnectionを作成します
   BobJS-> BobUA：setRemoteDescription with | offer-A1 |
   BobUA-> BobJS：オーディオおよびビデオトラックのオントラックイベント
        
   //ボブは呼び出しを受け入れます
   BobJS-> BobUA：ローカルトラックを含むaddTrack
   BobJS-> BobUA：createAnswer
   BobJS-> BobUA：回答付きのsetLocalDescription
   BobUA-> BobJS：候補者との複数のonicecandidateイベント
        
   // ICEの収集が完了するのを待ちます
   BobUA-> BobJS：候補がnullのonicecandidateイベント
   BobJS-> BobUA：get | answer-A1 | currentLocalDescriptionから
        
   // | answer-A1 | シグナリングプロトコルを介して送信されます
   //アリスへ
   BobJS-> WebServer：| answer-A1 |によるシグナリング
   WebServer-> AliceJS：| answer-A1 |によるシグナリング
        
   // | answer-A1 | アリスに到着
   AliceJS-> AliceUA：setRemoteDescription with | answer-A1 |
   AliceUA-> AliceJS：オーディオおよびビデオトラックのオントラックイベント
        
   //メディアフロー
   BobUA-> AliceUA：ボブからアリスに送信されたメディア
   AliceUA-> BobUA：アリスからボブに送信されたメディア
        
|オファー-A1 |のSDP 次のようになります：

   v = 0
   o = -4962303333179871722 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 10100 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 203.0.113.100
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：47017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：ETEn
   a = ice-pwd：OtSK0WpNtpUjkY4 + 86js7ZQl
   a = fingerprint：sha-256
                 19：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：actpass
   a = tls-id：91bbf309c0990a6bec11e38ba2933cee
   a = rtcp：10101 IN IP4 203.0.113.100
   a = rtcp-mux
   a = rtcp-rsize
   a =候補：1 1 udp 2113929471 203.0.113.100 10100typホスト
   a =候補：1 2 udp 2113929470 203.0.113.100 10101typホスト
   a =候補の終わり
        
   m =ビデオ10102UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 203.0.113.100
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：47017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：BGKk
   a = ice-pwd：mqyWsAjvtKwTGnvhPztQ9mIf
   a = fingerprint：sha-256
                 19：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：actpass
   a = tls-id：91bbf309c0990a6bec11e38ba2933cee
   a = rtcp：10103 IN IP4 203.0.113.100
   a = rtcp-mux
   a = rtcp-rsize
   a =候補：1 1 udp 2113929471 203.0.113.100 10102typホスト
   a =候補：1 2 udp 2113929470 203.0.113.100 10103typホスト
   a =候補の終わり
        
| answer-A1 |のSDP 次のようになります：

   v = 0
   o = -6729291447651054566 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 10200 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 203.0.113.200
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：61317484-2ed4-49d7-9eb7-1414322a7aae
   a = ice-ufrag：6sFv
   a = ice-pwd：cOTZKZNVlO9RSGsEGM63JXT2
   a = fingerprint：sha-256
                 6B：8B：F0：65：5F：78：E2：51：3B：AC：6F：F3：3F：46：1B：35：
                 DC：B8：5F：64：1A：24：C2：43：F0：A1：58：D0：A1：2C：19：08
   a = setup：active
   a = tls-id：eec3392ab83e11ceb6a0990c903fbb19
   a = rtcp-mux
   a = rtcp-rsize
   a =候補：1 1 udp 2113929471 203.0.113.200 10200typホスト
   a =候補の終わり
        
   m =ビデオ10200UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 203.0.113.200
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：61317484-2ed4-49d7-9eb7-1414322a7aae
        
7.2. 詳細な例
このセクションでは、2つのJSEPエンドポイント間のセッションのより複雑な例を示します. Trickle ICEは、「max-bundle」のバンドルポリシー、「require」のRTCPマルチプレクサポリシー、および単一のTURNサーバーを使用して、フルトリクルモードで使用されます. 最初に、アリスとボブの両方がオーディオチャネルとデータチャネルを確立します. その後、ボブは2つのビデオフローを追加します. 1つはビデオフィード用、もう1つは画面共有用で、どちらもFECをサポートし、ビデオフィードは同時放送用に構成されています. アリスはこれらのビデオフローを受け入れますが、独自のビデオフローを追加しないため、recvonlyとして処理されます. アリスは、ビデオデコーダーの最大解像度も指定します. 

   //ローカルメディアの状態を設定します
   AliceJS-> AliceUA：新しいPeerConnectionを作成します
   AliceJS-> AliceUA：オーディオトラック付きのaddTrack
   AliceJS-> AliceUA：データチャネルを取得するためのcreateDataChannel
   AliceJS-> AliceUA：createOfferで|オファーを取得-B1 |
   AliceJS-> AliceUA：setLocalDescription with | offer-B1 |
        
   // |オファー-B1 | シグナリングプロトコルを介してボブに送信されます
   AliceJS-> WebServer：| offer-B1 |によるシグナリング
   WebServer-> BobJS：| offer-B1 |によるシグナリング
        
   // |オファー-B1 | ボブに到着
   BobJS-> BobUA：PeerConnectionを作成します
   BobJS-> BobUA：setRemoteDescription with | offer-B1 |
   BobUA-> BobJS：アリスのオーディオトラックを使用したオントラックイベント
        
   //候補者はボブに送られます
   AliceUA-> AliceJS：onicecandidate（ホスト）|オファー-B1-候補-1 |
   AliceJS-> WebServer：| offer-B1-candidate-1 |によるシグナリング
   AliceUA-> AliceJS：onicecandidate（srflx）| Offer-B1-candidate-2 |
   AliceJS-> WebServer：| offer-B1-candidate-2 |によるシグナリング
   AliceUA-> AliceJS：onicecandidate（リレー）| offer-B1-candidate-3 |
   AliceJS-> WebServer：| offer-B1-candidate-3 |によるシグナリング
        
   WebServer-> BobJS：| offer-B1-candidate-1 |によるシグナリング
   BobJS-> BobUA：addIceCandidate with | offer-B1-candidate-1 |
   WebServer-> BobJS：| offer-B1-candidate-2 |によるシグナリング
   BobJS-> BobUA：addIceCandidate with | offer-B1-candidate-2 |
   WebServer-> BobJS：| offer-B1-candidate-3 |によるシグナリング
   BobJS-> BobUA：addIceCandidate with | offer-B1-candidate-3 |
        
   //ボブは呼び出しを受け入れます
   BobJS-> BobUA：ローカルオーディオを使用したaddTrack
   BobJS-> BobUA：データチャネルを取得するためのcreateDataChannel
   BobJS-> BobUA：createAnswerで| answer-B1 |を取得します
   BobJS-> BobUA：setLocalDescription with | answer-B1 |
        
   // | answer-B1 | アリスに送られます
   BobJS-> WebServer：| answer-B1 |によるシグナリング
   WebServer-> AliceJS：| answer-B1 |によるシグナリング
   AliceJS-> AliceUA：setRemoteDescription with | answer-B1 |
   AliceUA-> AliceJS：ボブからのオーディオトラックを使用したオントラックイベント
        
   //候補者はアリスに送られます
   BobUA-> BobJS：onicecandidate（ホスト）| answer-B1-candidate-1 |
   BobJS-> WebServer：| answer-B1-candidate-1 |によるシグナリング
   BobUA-> BobJS：onicecandidate（srflx）| answer-B1-candidate-2 |
   BobJS-> WebServer：| answer-B1-candidate-2 |によるシグナリング
   BobUA-> BobJS：onicecandidate（リレー）| answer-B1-candidate-3 |
   BobJS-> WebServer：| answer-B1-candidate-3 |によるシグナリング
        
   WebServer-> AliceJS：| answer-B1-candidate-1 |によるシグナリング
   AliceJS-> AliceUA：addIceCandidate with | answer-B1-candidate-1 |
   WebServer-> AliceJS：| answer-B1-candidate-2 |によるシグナリング
   AliceJS-> AliceUA：addIceCandidate with | answer-B1-candidate-2 |
   WebServer-> AliceJS：| answer-B1-candidate-3 |によるシグナリング
   AliceJS-> AliceUA：addIceCandidate with | answer-B1-candidate-3 |
        
   //データチャネルが開きます
   BobUA-> BobJS：ondatachannelイベント
   AliceUA-> AliceJS：ondatachannelイベント
   BobUA-> BobJS：onopen
   AliceUA-> AliceJS：onopen
        
   //メディアがエンドポイント間を流れています
   BobUA-> AliceUA：ボブからアリスに送信されたオーディオ+データ
   AliceUA-> BobUA：アリスからボブに送信されたオーディオ+データ
        
   //しばらくして、ボブは2つのビデオストリームを追加します
   //注：バンドルのため、候補者は交換されません
   BobJS-> BobUA：最初のビデオストリームを含むaddTrack
   BobJS-> BobUA：2番目のビデオストリームを含むaddTrack
   BobJS-> BobUA：createOfferで|オファー-B2 |を取得します
   BobJS-> BobUA：setLocalDescription with | offer-B2 |
        
   // |オファー-B2 | アリスに送られます
   BobJS-> WebServer：| offer-B2 |によるシグナリング
   WebServer-> AliceJS：| offer-B2 |によるシグナリング
   AliceJS-> AliceUA：setRemoteDescription with | offer-B2 |
   AliceUA-> AliceJS：最初のビデオトラックを含むオントラックイベント
   AliceUA-> AliceJS：2番目のビデオトラックを含むオントラックイベント
   AliceJS-> AliceUA：createAnswerで| answer-B2 |を取得
   AliceJS-> AliceUA：setLocalDescription with | answer-B2 |
        
   // | answer-B2 | シグナリングプロトコルを介して送信されます
   //ボブに
   AliceJS-> WebServer：| answer-B2 |によるシグナリング
   WebServer-> BobJS：| answer-B2 |によるシグナリング
   BobJS-> BobUA：setRemoteDescription with | answer-B2 |
        
   //メディアがエンドポイント間を流れています
   BobUA-> AliceUA：ボブからアリスに送信されるオーディオ+ビデオ+データ
   AliceUA-> BobUA：アリスからボブに送信されるオーディオ+ビデオ+データ
        
|オファー-B1 |のSDP 次のようになります：

   v = 0
   o = -4962303333179871723 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1
        
   m = audio 9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：57017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：ATEn
   a = ice-pwd：AtSK0WpNtpUjkY4 + 86js7ZQl
   a = fingerprint：sha-256
                 29：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：actpass
   a = tls-id：17f0f4ba8a5f1213faca591b58ba52a7
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
        
   m = application 0 UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 0.0.0.0
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
   a =バンドルのみ
        
|オファー-B1-候補-1 | 次のようになります：

ufragATEnインデックス0mid a1 attr候補：1 1 udp 2113929471 203.0.113.100 10100typホスト

|オファー-B1-候補-2 | 次のようになります：

ufragATEnインデックス0mid a1 attr候補：1 1 udp 1845494015 198.51.100.100 11100 typ srflx raddr 203.0.113.100 rport 10100

|オファー-B1-候補-3 | 次のようになります：

ufragATEnインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.100 12100typリレーraddr198.51.100.100 rport 11100

| answer-B1 |のSDP 次のようになります：

   v = 0
   o = -7729291447651054566 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1
        
   m = audio 9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：71317484-2ed4-49d7-9eb7-1414322a7aae
   a = ice-ufrag：7sFv
   a = ice-pwd：dOTZKZNVlO9RSGsEGM63JXT2
   a = fingerprint：sha-256
                 7B：8B：F0：65：5F：78：E2：51：3B：AC：6F：F3：3F：46：1B：35：
                 DC：B8：5F：64：1A：24：C2：43：F0：A1：58：D0：A1：2C：19：08
   a = setup：active
   a = tls-id：7a25ab85b195acaf3121f5a8ab4f0f71
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
        
   m = application 9 UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 0.0.0.0
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
        
| answer-B1-candidate-1 | 次のようになります：

ufrag 7sFv index 0 mid a1 attr Candidate：1 1 udp 2113929471 203.0.113.200 10200 typ host

| answer-B1-candidate-2 | 次のようになります：

ufrag 7sFv index 0 mid a1 attr Candidate：1 1 udp 1845494015 198.51.100.200 11200 typ srflx raddr 203.0.113.200 rport 10200

| answer-B1-candidate-3 | 次のようになります：

ufrag7sFvインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.200 12200typリレーraddr198.51.100.200 rport 11200

|オファー-B2 |のSDP 以下に示します. ビデオ用の新しい「m =」セクションに加えて、どちらもFECを提供し、一方は同時放送を提供しています. 「o =」行のバージョン番号の増分に注意してください. 「c =」行に変更され、選択されたローカル候補を示します. 収集した候補をa =候補行として含める. 

   v = 0
   o = -7729291447651054566 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1 v1 v2
   a = group：LS a1 v1
        
   m = audio 12200 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.200
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：71317484-2ed4-49d7-9eb7-1414322a7aae
   a = ice-ufrag：7sFv
   a = ice-pwd：dOTZKZNVlO9RSGsEGM63JXT2
   a = fingerprint：sha-256
                 7B：8B：F0：65：5F：78：E2：51：3B：AC：6F：F3：3F：46：1B：35：
                 DC：B8：5F：64：1A：24：C2：43：F0：A1：58：D0：A1：2C：19：08
   a = setup：actpass
   a = tls-id：7a25ab85b195acaf3121f5a8ab4f0f71
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
   a =候補：1 1 udp 2113929471 203.0.113.200 10200typホスト
   a =候補：1 1 udp 1845494015 198.51.100.200 11200 typ srflx
               raddr 203.0.113.200 rport 10200
   a =候補：1 1 udp 255 192.0.2.200 12200typリレー
               raddr 198.51.100.200 rport 11200
   a =候補の終わり
        
   m =アプリケーション12200UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 192.0.2.200
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
        
   m =ビデオ12200UDP / TLS / RTP / SAVPF 100101102103104
   c = IN IP4 192.0.2.200
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = rtpmap：104 flexfec / 90000
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：71317484-2ed4-49d7-9eb7-1414322a7aae
   a = rid：1送信
   a = rid：2送信
   a = rid：3送信
   a =サイマルキャスト：送信1; 2; 3
        
   m =ビデオ12200UDP / TLS / RTP / SAVPF 100101102103104
   c = IN IP4 192.0.2.200
   a = mid：v2
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = rtpmap：104 flexfec / 90000
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：81317484-2ed4-49d7-9eb7-1414322a7aae
        
| answer-B2 |のSDP 以下に示します. ビデオ「m =」セクションの受け入れ、一directionビデオを示すためのa = recvonlyの使用、および受信解像度を制限するためのa = imageattrの使用に加えて、setup：passiveを使用して既存のDTLSロール. 

   v = 0
   o = -4962303333179871723 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 d1 v1 v2
   a = group：LS a1 v1
        
   m = audio 12100 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.100
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：57017fee-b6c1-4162-929c-a25110252400
   a = ice-ufrag：ATEn
   a = ice-pwd：AtSK0WpNtpUjkY4 + 86js7ZQl
   a = fingerprint：sha-256
                 29：E2：1C：3B：4B：9F：81：E6：B8：5C：F4：A5：A8：D8：73：04：
                 BB：05：2F：70：9F：04：A9：0E：05：E9：26：33：E8：70：88：A2
   a = setup：passive
   a = tls-id：17f0f4ba8a5f1213faca591b58ba52a7
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
   a =候補：1 1 udp 2113929471 203.0.113.100 10100typホスト
   a =候補：1 1 udp 1845494015 198.51.100.100 11100 typ srflx
               raddr 203.0.113.100 rport 10100
   a =候補：1 1 udp 255 192.0.2.100 12100typリレー
               raddr 198.51.100.100 rport 11100
   a =候補の終わり
        
   m = application 12100 UDP / DTLS / SCTP webrtc-datachannel
   c = IN IP4 192.0.2.100
   a = mid：d1
   a = sctp-port：5000
   a = max-message-size：65536
        
   m =ビデオ12100UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 192.0.2.100
   a = mid：v1
   a = recvonly
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = imageattr：100 recv [x = [48：1920]、y = [48：1080]、q = 1.0]
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
        
   m =ビデオ12100UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 192.0.2.100
   a = mid：v2
   a = recvonly
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = imageattr：100 recv [x = [48：1920]、y = [48：1080]、q = 1.0]
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
        
7.3. 早期輸送ウォームアップの例
この例は、セクション4.1.10.1で説明されている早期ウォームアップ手法を示しています. ここで、アリスのエンドポイントはボブのエンドポイントに音声/ビデオ通話を開始するためのオファーを送信します. ボブはすぐに、オーディオ/ビデオの「m =」セクションを受け入れるが、（彼の観点からは）送信専用としてマークするという回答で応答します. これは、アリスがまだメディアを送信しないことを意味します. これにより、JSEP実装はICEとDTLSのネゴシエーションをすぐに開始できます. 次に、ボブのエンドポイントは電話に応答するように促し、応答すると、エンドポイントは2番目のオファーを送信します. これにより、オーディオとビデオの「m =」セクションが有効になり、双directionのメディア送信が可能になります. このようなフローの利点は、最初の回答を受信するとすぐに、実装がICEおよびDTLSネゴシエーションを続行し、セッショントランスポートを確立できることです. 2番目のオファーが送信される前にトランスポートのセットアップが完了すると、通話に応答するとすぐに受信者がメディアを送信できるため、ダイヤル後の遅延が最小限に抑えられます. 2番目のオファー/アンサー交換でも、優先コーデックまたはその他のセッションパラメータを変更できます. 

この例では、セクション3.5.3で説明されている「リレー」ICE候補ポリシーを利用して、必要なICEの収集とチェックを最小限に抑えています. 

   //ローカルメディアの状態を設定します
   AliceJS-> AliceUA：「リレー」ICEポリシーを使用して新しいPeerConnectionを作成します
   AliceJS-> AliceUA：オーディオとビデオの2つのトラックを持つaddTrack
   AliceJS-> AliceUA：createOfferで|オファーを取得-C1 |
   AliceJS-> AliceUA：setLocalDescription with | offer-C1 |
        
   // |オファー-C1 | シグナリングプロトコルを介してボブに送信されます
   AliceJS-> WebServer：| offer-C1 |によるシグナリング
   WebServer-> BobJS：| offer-C1 |によるシグナリング
        
   // |オファー-C1 | ボブに到着
   BobJS-> BobUA：「リレー」ICEポリシーを使用して新しいPeerConnectionを作成します
   BobJS-> BobUA：| offer-C1 |を使用したsetRemoteDescription
   BobUA-> BobJS：オーディオとビデオのオントラックイベント
        
   //リレー候補がボブに送信されます
   AliceUA-> AliceJS：onicecandidate（リレー）| offer-C1-candidate-1 |
   AliceJS-> WebServer：| offer-C1-candidate-1 |によるシグナリング
        
   WebServer-> BobJS：| offer-C1-candidate-1 |によるシグナリング
   BobJS-> BobUA：addIceCandidate with | offer-C1-candidate-1 |
        
   //ボブはウォームアップするための早期回答を準備します
   //トランスポート
   BobJS-> BobUA：nullオーディオおよびビデオトラックを含むaddTransceiver
   BobJS-> BobUA：両方のトランシーバー.setDirection（sendonly）
   BobJS-> BobUA：createAnswer
   BobJS-> BobUA：回答付きのsetLocalDescription
        
   // | answer-C1 | シグナリングプロトコルを介して送信されます
   //アリスへ
   BobJS-> WebServer：| answer-C1 |によるシグナリング
   WebServer-> AliceJS：| answer-C1 |によるシグナリング
        
   // | answer-C1 | （送信専用）アリスに到着
   AliceJS-> AliceUA：setRemoteDescription with | answer-C1 |
   AliceUA-> AliceJS：オーディオとビデオのオントラックイベント
        
   //リレー候補がアリスに送信されます
   BobUA-> BobJS：onicecandidate（リレー）| answer-B1-candidate-1 |
   BobJS-> WebServer：| answer-B1-candidate-1 |によるシグナリング
        
   WebServer-> AliceJS：| answer-B1-candidate-1 |によるシグナリング
   AliceJS-> AliceUA：addIceCandidate with | answer-B1-candidate-1 |
        
// ICEとDTLSは、通話が鳴っている間に確立します

   //ボブは通話を受け入れ、メディアを開始し、送信します
   //新しいオファー
   BobJS-> BobUA：オーディオおよびビデオトラックを含むトランシーバー.setTrack
   BobUA-> AliceUA：ボブからアリスに送信されたメディア
   BobJS-> BobUA：両方のトランシーバー.setDirection（sendrecv）
                       トランシーバー
   BobJS-> BobUA：createOffer
   BobJS-> BobUA：setLocalDescriptionとオファー
        
   // |オファー-C2 | シグナリングプロトコルを介して送信されます
   //アリスへ
   BobJS-> WebServer：| offer-C2 |によるシグナリング
   WebServer-> AliceJS：| offer-C2 |によるシグナリング
        
   // |オファー-C2 | （sendrecv）アリスに到着
   AliceJS-> AliceUA：setRemoteDescription with | offer-C2 |
   AliceJS-> AliceUA：createAnswer
   AliceJS-> AliceUA：setLocalDescription with | answer-C2 |
   AliceUA-> BobUA：アリスからボブに送信されたメディア
        
   // | answer-C2 | シグナリングプロトコルを介して送信されます
   //ボブに
   AliceJS-> WebServer：| answer-C2 |によるシグナリング
   WebServer-> BobJS：| answer-C2 |によるシグナリング
   BobJS-> BobUA：setRemoteDescription with | answer-C2 |
        
| offer-C1 |のSDP 次のようになります：

   v = 0
   o = -1070771854436052752 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
   a = ice-ufrag：4ZcD
   a = ice-pwd：ZaaG6OG7tCn4J / lehAGz + HHD
   a = fingerprint：sha-256
                 C4：68：F8：77：6A：44：F1：98：6D：7C：9F：47：EB：E3：34：A4：
                 0A：AA：2D：49：08：28：70：2E：1F：AE：18：7D：4E：3E：66：BF
   a = setup：actpass
   a = tls-id：9e5b948ade9c3d41de6617b68f769e55
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
        
   m =ビデオ0UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 0.0.0.0
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
   a =バンドルのみ
        
|オファー-C1-候補-1 | 次のようになります：

ufrag4ZcDインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.100 12100typリレーraddr0.0.0.0 rport 0

| answer-C1 |のSDP 次のようになります：

   v = 0
   o = -6386516489780559513 1 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 9 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 0.0.0.0
   a = mid：a1
   a = sendonly
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
   a = ice-ufrag：TpaA
   a = ice-pwd：t2Ouhc67y8JcCaYZxUUTgKw /
   a = fingerprint：sha-256
                 A2：F3：A5：6D：4C：8C：1E：B2：62：10：4A：F6：70：61：C4：FC：
                 3C：E0：01：D6：F3：24：80：74：DA：7C：3E：50：18：7B：CE：4D
   a = setup：active
   a = tls-id：55e967f86b7166ed14d3c9eda849b5e9
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
        
   m =ビデオ9UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 0.0.0.0
   a = mid：v1
   a = sendonly
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
        
| answer-C1-candidate-1 | 次のようになります：

ufragTpaAインデックス0mid a1 attr候補：1 1 udp 255 192.0.2.200 12200typリレーraddr0.0.0.0 rport 0

| offer-C2 |のSDP 次のようになります：

   v = 0
   o = -6386516489780559513 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 12200 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.200
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
   a = ice-ufrag：TpaA
   a = ice-pwd：t2Ouhc67y8JcCaYZxUUTgKw /
   a = fingerprint：sha-256
                 A2：F3：A5：6D：4C：8C：1E：B2：62：10：4A：F6：70：61：C4：FC：
                 3C：E0：01：D6：F3：24：80：74：DA：7C：3E：50：18：7B：CE：4D
   a = setup：actpass
   a = tls-id：55e967f86b7166ed14d3c9eda849b5e9
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
   a =候補：1 1 udp 255 192.0.2.200 12200typリレー
               raddr 0.0.0.0 rport 0
   a =候補の終わり
        
   m =ビデオ12200UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 192.0.2.200
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：751f239e-4ae0-c549-aa3d-890de772998b
        
| answer-C2 |のSDP 次のようになります：

   v = 0
   o = -1070771854436052752 2 IN IP4 0.0.0.0
   s =-
   t = 0 0
   a = ice-options：trickle ice2
   a = group：BUNDLE a1 v1
   a = group：LS a1 v1
        
   m = audio 12100 UDP / TLS / RTP / SAVPF 96 0 8 97 98
   c = IN IP4 192.0.2.100
   a = mid：a1
   a = sendrecv
   a = rtpmap：96 opus / 48000/2
   a = rtpmap：0 PCMU / 8000
   a = rtpmap：8 PCMA / 8000
   a = rtpmap：97電話イベント/ 8000
   a = rtpmap：98電話イベント/ 48000
   a = fmtp：97 0-15
   a = fmtp：98 0-15
   a = maxptime：120
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：2 urn：ietf：params：rtp-hdrext：ssrc-audio-level
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
   a = ice-ufrag：4ZcD
   a = ice-pwd：ZaaG6OG7tCn4J / lehAGz + HHD
   a = fingerprint：sha-256
                 C4：68：F8：77：6A：44：F1：98：6D：7C：9F：47：EB：E3：34：A4：
                 0A：AA：2D：49：08：28：70：2E：1F：AE：18：7D：4E：3E：66：BF
   a = setup：passive
   a = tls-id：9e5b948ade9c3d41de6617b68f769e55
   a = rtcp-mux
   a = rtcp-muxのみ
   a = rtcp-rsize
   a =候補：1 1 udp 255 192.0.2.100 12100typリレー
               raddr 0.0.0.0 rport 0
   a =候補の終わり
        
   m =ビデオ12100UDP / TLS / RTP / SAVPF 100101102103
   c = IN IP4 192.0.2.100
   a = mid：v1
   a = sendrecv
   a = rtpmap：100 VP8 / 90000
   a = rtpmap：101 H264 / 90000
   a = fmtp：101 packetization-mode = 1; profile-level-id = 42e01f
   a = rtpmap：102 rtx / 90000
   a = fmtp：102 apt = 100
   a = rtpmap：103 rtx / 90000
   a = fmtp：103 apt = 101
   a = extmap：1 urn：ietf：params：rtp-hdrext：sdes：mid
   a = extmap：3 urn：ietf：params：rtp-hdrext：sdes：rtp-stream-id
   a = rtcp-fb：100 ccm fir
   a = rtcp-fb：100ナック
   a = rtcp-fb：100 nack pli
   a = msid：bbce3ba6-abfc-ac63-d00a-e15b286f8fce
        
8.セキュリティに関する考慮事項
IETFは、WebRTC全体のセキュリティアーキテクチャを説明する個別のドキュメント[RFC8827] [RFC8826]を公開しています. このセクションの残りの部分では、このドキュメントのセキュリティに関する考慮事項について説明します. 

正式にはJSEPインターフェースはAPIですが、JSEP実装の観点からは、アプリケーションJavaScriptは信頼できないため、インターネットプロトコルと考えることをお勧めします. したがって、[RFC3552]の脅威モデルが適用されます. 特に、JavaScriptは、悪意のあるものを含め、任意の順序で任意の入力を使用してAPIを呼び出すことができます. これは、setLocalDescriptionに渡されるSDPを検討する場合に特に関係があります. APIを正しく使用するには、createOfferまたはcreateAnswerから派生したSDPをアプリケーションが渡す必要がありますが、アプリケーションがそうするという保証はありません. JSEP実装は、JavaScriptが代わりに偽のデータを渡すように準備する必要があります. 

逆に、アプリケーションプログラマーは、JavaScriptがエンドポイントの動作を完全に制御できないことに注意する必要があります. 特に言及する1つのケースは、SDPからICE候補を編集したり、細流の候補を抑制したりすると、期待される動作が得られないことです. 実装は、反対側に送信されなくても、それらの候補からのチェックを実行します. したがって、たとえば、サーバー再帰候補を削除することによって、リモートピアがパブリックIPアドレスを学習するのを防ぐことはできません. パブリックIPアドレスを隠したいアプリケーションは、代わりにリレー候補のみを使用するようにICEエージェントを構成する必要があります. 

9.IANAの考慮事項
このドキュメントにはIANAアクションはありません. 

10.参考文献
10.1. 規範的参考文献
[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>. 

[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. 、およびE. Schooler、「SIP：SessionInitiationProtocol」 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>. 

[RFC3264] Rosenberg、J. およびH. Schulzrinne、「Session Description Protocol（SDP）を使用したオファー/アンサーモデル」、RFC 3264、DOI 10.17487 / RFC3264、2002年6月、<https://www.rfc-editor.org / info / rfc3264>. 

[RFC3552] Rescorla、E. およびB. Korver、「セキュリティに関する考慮事項に関するRFCテキストの作成に関するガイドライン」、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、<https://www.rfc-editor.org/ info / rfc3552>. 

[RFC3605] Huitema、C. 、「Session Description Protocol（SDP）のReal Time Control Protocol（RTCP）属性」、RFC 3605、DOI 10.17487 / RFC3605、2003年10月、<https://www.rfc-editor.org/ info / rfc3605>. 

[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E. 、およびK. Norrman、「The Secure Real-time Transport Protocol（SRTP）」、RFC 3711、DOI 10.17487 / RFC3711、3月200 4、<https://www.rfc-editor.org/info/rfc3711>. 

[RFC3890] Westerlund、M. 、「A Transport Independent Bandwidth Modifier for the Session Description Protocol（SDP）」、RFC 3890、DOI 10.17487 / RFC3890、2004年9月、<https://www.rfc-editor.org/info/ rfc3890>. 

[RFC4145] Yon、D. およびG. Camarillo、「Session Description Protocol（SDP）におけるTCPベースのメディアトランスポート」、RFC 4145、DOI 10.17487 / RFC4145、2005年9月、<https：//www.rfc-editor.  org / info / rfc4145>. 

[RFC4566] Handley、M.、Jacobson、V. 、およびC. Perkins、「SDP：Session Description Protocol」、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<https://www.rfc-editor.org/ info / rfc4566>. 

[RFC4585] Ott、J.、Wenger、S.、Sato、N.、Burmeister、C. 、およびJ. Rey、「​​リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / AVPF）の拡張RTPプロファイル"、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<https://www.rfc-editor.org/info/rfc4585>. 

[RFC5124] Ott、J. およびE. Carrara、「リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）用の拡張セキュアRTPプロファイル」、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<https ：//www.rfc-editor.org/info/rfc5124>. 

[RFC5285] Singer、D. およびH. Desineni、「RTPヘッダー拡張の一般的なメカニズム」、RFC 5285、DOI 10.17487 / RFC5285、2008年7月、<https://www.rfc-editor.org/info/rfc5285> . 

[RFC5761] Perkins、C. およびM. Westerlund、「単一ポートでのRTPデータと制御パケットの多重化」、RFC 5761、DOI 10.17487 / RFC5761、2010年4月、<https://www.rfc-editor.org/info / rfc5761>. 

[RFC5888] Camarillo、G. およびH. Schulzrinne、「The Session Description Protocol（SDP）Grouping Framework」、RFC 5888、DOI 10.17487 / RFC5888、2010年6月、<https://www.rfc-editor.org/info/ rfc5888>. 

[RFC6236] Johansson、I. およびK. Jung、「Session Description Protocol（SDP）における汎用画像属性のネゴシエーション」、RFC 6236、DOI 10.17487 / RFC6236、2011年5月、<https：//www.rfc-editor.  org / info / rfc6236>. 

[RFC6347] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>. 

[RFC6716] Valin、JM. 、Vos、K. 、およびT. Terriberry、「Definition of the Opus Audio Codec」、RFC 6716、DOI 10.17487 / RFC6716、2012年9月、<https://www.rfc-editor.org / info / rfc6716>. 

[RFC6904] Lennox、J. 、「Secure Real-time Transport Protocol（SRTP）におけるヘッダー拡張の暗号化」、RFC 6904、DOI 10.17487 / RFC6904、2013年4月、<https://www.rfc-editor.org/ info / rfc6904>. 

[RFC7160] Petit-Huguenin、M. and G. Zorn、Ed. 、 "Support for Multiple Clock Rate in a RTP Session"、RFC 7160、DOI 10.17487 / RFC7160、April 2014、<https：//www.rfc-editor .org / info / rfc7160>. 

[RFC7587] Spittka、J.、Vos、K. 、およびJM. Valin、「Opus Speech and Audio CodecのRTPペイロード形式」、RFC 7587、DOI 10.17487 / RFC7587、2015年6月、<https://www.rfc-editor.org/info/rfc7587>. 

[RFC7742] Roach、AB、「WebRTCビデオ処理およびコーデック要件」、RFC 7742、DOI 10.17487 / RFC7742、2016年3月、<https://www.rfc-editor.org/info/rfc7742>. 

[RFC7850] Nandakumar、S. 、「さまざまなRTPプロファイルでTCPを介してRTPメディアを転送するためのSDP「proto」フィールドの値の登録」、RFC 7850、DOI 10.17487 / RFC7850、2016年4月、<https：//www.rfc- editor.org/info/rfc7850>. 

[RFC7874]ヴァリン、JM. およびC.Bran、「WebRTCオーディオコーデックおよび処理要件」、RFC 7874、DOI 10.17487 / RFC7874、2016年5月、<https://www.rfc-editor.org/info/rfc7874>. 

[RFC8108] Lennox、J.、Westerlund、M.、Wu、Q. 、およびC. Perkins、「単一のRTPセッションで複数のRTPストリームを送信する」、RFC 8108、DOI 10.17487 / RFC8108、2017年3月、<https：/ /www.rfc-editor.org/info/rfc8108>. 

[RFC8122] Lennox、J. and C. Holmberg、 "Connection-Oriented Media Transport over the Transport Layer Security（TLS）Protocol in the Session Description Protocol（SDP）"、RFC 8122、DOI 10.17487 / RFC8122、March 2017、<https ：//www.rfc-editor.org/info/rfc8122>. 

[RFC8174] Leiba、B. 、「RFC 2119キーワードにおける大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>. 

[RFC8445] Keranen、A.、Holmberg、C. 、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、< https://www.rfc-editor.org/info/rfc8445>. 

[RFC8826] Rescorla、E. 、「WebRTCのセキュリティに関する考慮事項」、RFC 8826、DOI 10.17487 / RFC8826、2021年1月、<https://www.rfc-editor.org/info/rfc8826>. 

[RFC8827] Rescorla、E. 、「WebRTC Security Architecture」、RFC 8827、DOI 10.17487 / RFC8827、2021年1月、<https://www.rfc-editor.org/info/rfc8827>. 

[RFC8830] Alvestrand、H. 、「Session DescriptionProtocolでのWebRTCMediaStream Identification」、RFC 8830、DOI 10.17487 / RFC8830、2021年1月、<https://www.rfc-editor.org/info/rfc8830>. 

[RFC8834] Perkins、C.、Westerlund、M. 、およびJ. Ott、「Media Transport and Use of RTP in WebRTC」、RFC 8834、DOI 10.17487 / RFC8834、2021年1月、<https：//www.rfc-editor .org / info / rfc8834>. 

[RFC8838] Ivov、E.、Uberti、J. 、およびP. Saint-Andre、「Trickle ICE：Interactive Connectivity Establishment（ICE）プロトコルの候補のインクリメンタルプロビジョニング」、RFC 8838、DOI 10.17487 / RFC8838、2021年1月<https://www.rfc-editor.org/info/rfc8838>. 

[RFC8839] Petit-Huguenin、M.、Nandakumar、S.、Holmberg、C.、Keränen、A. 、およびR. Shpount、「Interactive Connectivity Establishment（ICE）のセッション記述プロトコル（SDP）オファー/アンサー手順」、 RFC 8839、DOI 10.17487 / RFC8839、2021年1月、<https://www.rfc-editor.org/info/rfc8839>. 

[RFC8840] Ivov、E.、Stach、T.、Marocco、E. 、およびC. Holmberg、「Interactive Connectivity Establishment（Trickle ICE）の候補のインクリメンタルプロビジョニングのためのセッション開始プロトコル（SIP）の使用法」、RFC 8840 、DOI 10.17487 / RFC8840、2021年1月、<https://www.rfc-editor.org/info/rfc8840>. 

[RFC8841] Holmberg、C.、Shpount、R.、Loreto、S. 、およびG. Camarillo、「Datagram Transport Layer Security（DTLS）を介したStream Control Transmission Protocol（SCTP）のセッション記述プロトコル（SDP）オファー/アンサー手順トランスポート」、RFC 8841、DOI 10.17487 / RFC8841、2021年1月、<https://www.rfc-editor.org/info/rfc8841>. 

[RFC8842] Holmberg、C. およびR. Shpount、「Datagram Transport Layer Security（DTLS）およびTransport Layer Security（TLS）に関するセッション記述プロトコル（SDP）の提供/回答に関する考慮事項」、RFC 8842、DOI 10.17487 / RFC8842、2021年1月、<https://www.rfc-editor.org/info/rfc8842>. 

[RFC8843] Holmberg、C.、Alvestrand、H. 、およびC. Jennings、「Session Description Protocol（SDP）を使用したメディア多重化のネゴシエーション」、RFC 8843、DOI 10.17487 / RFC8843、2021年1月<https：// www.  rfc-editor.org/info/rfc8843>. 

[RFC8851] Roach、AB、Ed. 、 "RTP Payload Format Limitations"、RFC 8851、DOI 10.17487 / RFC8851、January 2021、<https://www.rfc-editor.org/info/rfc8851>. 

[RFC8852] Roach、AB、Nandakumar、S. 、およびP. Thatcher、「RTP Stream Identifier Source Description（SDES）」、RFC 8852、DOI 10.17487 / RFC8852、2021年1月、<https：//www.rfc-editor.  org / info / rfc8852>. 

[RFC8853] Burman、B.、Westerlund、M.、Nandakumar、S. 、およびM. Zanaty、「セッション記述プロトコル（SDP）およびRTPセッションでのサイマルキャストの使用」、RFC 8853、DOI 10.17487 / RFC8853、2021年1月< https://www.rfc-editor.org/info/rfc8853>. 

[RFC8854] Uberti、J. 、「WebRTC前方誤り訂正要件」、RFC 8854、DOI 10.17487 / RFC8854、2021年1月、<https://www.rfc-editor.org/info/rfc8854>. 

[RFC8858] Holmberg、C. 、 "Indicating Exclusive Support of RTP and RTP Control Protocol（RTCP）Multiplexing Using the Session Description Protocol（SDP）"、RFC 8858、DOI 10.17487 / RFC8858、January 2021、<https：// www.  rfc-editor.org/info/rfc8858>. 

[RFC8859] Nandakumar、S. 、「多重化時のセッション記述プロトコル（SDP）属性のフレームワーク」、RFC 8859、DOI 10.17487 / RFC8859、2021年1月、<https://www.rfc-editor.org/info/rfc8859 >. 

10.2. 有益な参考文献
[RFC3389] Zopf、R. 、「コンフォートノイズ（CN）のリアルタイムトランスポートプロトコル（RTP）ペイロード」、RFC 3389、DOI 10.17487 / RFC3389、2002年9月、<https://www.rfc-editor.org/ info / rfc3389>. 

[RFC3556] Casner、S. 、「RTP制御プロトコル（RTCP）帯域幅のセッション記述プロトコル（SDP）帯域幅修飾子」、RFC 3556、DOI 10.17487 / RFC3556、2003年7月、<https://www.rfc-editor.org / info / rfc3556>. 

[RFC3960] Camarillo、G. and H. Schulzrinne、 "Early Media and Ringing Tone Generation in the Session Initiation Protocol（SIP）"、RFC 3960、DOI 10.17487 / RFC3960、December 2004、<https：//www.rfc-editor .org / info / rfc3960>. 

[RFC4568] Andreasen、F.、Baugher、M. 、およびD. Wing、「Media Streamsのセッション記述プロトコル（SDP）セキュリティ記述」、RFC 4568、DOI 10.17487 / RFC4568、2006年7月、<https：// www.  rfc-editor.org/info/rfc4568>. 

[RFC4588] Rey、J.、Leon、D.、Miyazaki、A.、Varsa、V. 、およびR. Hakenberg、「RTP Retransmission Payload Format」、RFC 4588、DOI 10.17487 / RFC4588、2006年7月、<https：/ /www.rfc-editor.org/info/rfc4588>. 

[RFC4733] Schulzrinne、H. and T. Taylor、 "RTP Payload for DTMF Digits、Telephony Tones、and Telephony Signals"、RFC 4733、DOI 10.17487 / RFC4733、December 2006、<https://www.rfc-editor.org / info / rfc4733>. 

[RFC5245] Rosenberg、J. 、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal for Offer / Answer Protocols」、RFC 5245、DOI 10.17487 / RFC5245、2010年4月、<https：// www .rfc-editor.org / info / rfc5245>. 

[RFC5506] Johansson、I. and M. Westerlund、 "Support for Reduced-Size Real-Time Transport Control Protocol（RTCP）：Opportunities and Consequences"、RFC 5506、DOI 10.17487 / RFC5506、April 2009、<https：// www .rfc-editor.org / info / rfc5506>. 

[RFC5576] Lennox、J.、Ott、J. 、およびT. Schierl、「Session Description Protocol（SDP）のソース固有のメディア属性」、RFC 5576、DOI 10.17487 / RFC5576、2009年6月、<https：// www.rfc-editor.org/info/rfc5576>. 

[RFC5763] Fischl、J.、Tschofenig、H. 、およびE. Rescorla、「Datagram Transport Layer Security（DTLS）を使用してセキュアなReal-time Transport Protocol（SRTP）セキュリティコンテキストを確立するためのフレームワーク」、RFC 5763、DOI 10.17487 / RFC5763、2010年5月、<https://www.rfc-editor.org/info/rfc5763>. 

[RFC5764] McGrew、D. およびE. Rescorla、「Secure Real-time Transport Protocol（SRTP）のキーを確立するためのDatagram Transport Layer Security（DTLS）Extension」、RFC 5764、DOI 10.17487 / RFC5764、2010年5月、<https ：//www.rfc-editor.org/info/rfc5764>. 

[RFC6120] Saint-Andre、P. 、「Extensible Messaging and Presence Protocol（XMPP）：Core」、RFC 6120、DOI 10.17487 / RFC6120、2011年3月、<https://www.rfc-editor.org/info/rfc6120 >. 

[RFC6464] Lennox、J.、Ed. 、Ivov、E.、and E. Marocco、 "A Real-time Transport Protocol（RTP）Header Extension for Client-to-Mixer Audio Level Indication"、RFC 6464、DOI 10.17487 / RFC6464、2011年12月、<https://www.rfc-editor.org/info/rfc6464>. 

[RFC8828] Uberti、J. およびG. Shieh、「WebRTC IPアドレス処理要件」、RFC 8828、DOI 10.17487 / RFC8828、2021年1月、<https://www.rfc-editor.org/info/rfc8828>. 

[SDP4WebRTC] Nandakumar、S. and C. Jennings、 "Annotated Example SDP for WebRTC"、Work in Progress、Internet-Draft、draft-ietf-rtcweb-sdp-14、17 December 2020、<https：//tools.ietf .org / html / draft-ietf-rtcweb-sdp-14>. 

[TS26.114] 3GPP、「第3世代パートナーシッププロジェクト、技術仕様グループのサービスとシステムの側面、IPマルチメディアサブシステム（IMS）、マルチメディアテレフォニー、メディアの処理と相互作用（リリース16）」、3GPP TS 26.114 V16.3.0、2019年9月、<https://www.3gpp.org/DynaReport/26114.htm>. 

[W3C.webrtc] Jennings、C.、Ed. 、Boström、H. 、Ed. 、and J. Bruaroey、Ed. 、 "WebRTC 1.0：Real-time Communication Between Browsers"、World Wide Web Consortium PR PR-webrtc- 20201215、2020年12月、<https://www.w3.org/TR/2020/PR-webrtc-20201215/>. 

付録A.SDPABNF構文
セクション5.8で実行される構文検証では、次のABNF定義のリストが使用されます. 

          + ========================= + ======================= === +
          | 属性| リファレンス|
          + ========================= + ======================= === +
          | ptime | [RFC4566]のセクション6 |
          + -------------------------- + ----------------------- --- +
          | maxptime | [RFC4566]のセクション6 |
          + -------------------------- + ----------------------- --- +
          | rtpmap | [RFC4566]のセクション6 |
          + -------------------------- + ----------------------- --- +
          | recvonly | [RFC4566]のセクション9 |
          + -------------------------- + ----------------------- --- +
          | sendrecv | [RFC4566]のセクション9 |
          + -------------------------- + ----------------------- --- +
          | sendonly | [RFC4566]のセクション9 |
          + -------------------------- + ----------------------- --- +
          | inactive| [RFC4566]のセクション9 |
          + -------------------------- + ----------------------- --- +
          | fmtp | [RFC4566]のセクション9 |
          + -------------------------- + ----------------------- --- +
          | rtcp | [RFC3605]のセクション2.1 |
          + -------------------------- + ----------------------- --- +
          | セットアップ| [RFC4145]のセクション4 |
          + -------------------------- + ----------------------- --- +
          | 指紋| [RFC8122]のセクション5 |
          + -------------------------- + ----------------------- --- +
          | rtcp-fb | [RFC4585]のセクション4.2 |
          + -------------------------- + ----------------------- --- +
          | extmap | [RFC5285]のセクション7 |
          + -------------------------- + ----------------------- --- +
          | ミッド| [RFC5888]のセクション4 |
          + -------------------------- + ----------------------- --- +
          | グループ| [RFC5888]のセクション5 |
          + -------------------------- + ----------------------- --- +
          | imageattr | [RFC6236]のセクション3.1 |
          + -------------------------- + ----------------------- --- +
          | extmap（暗号化オプション）| [RFC6904]のセクション4 |
          + -------------------------- + ----------------------- --- +
          | 候補者| [RFC8839]のセクション5.1 |
          + -------------------------- + ----------------------- --- +
          | リモート候補| [RFC8839]のセクション5.2 |
          + -------------------------- + ----------------------- --- +
          | アイスライト| [RFC8839]のセクション5.3 |
          + -------------------------- + ----------------------- --- +
          | ice-ufrag | [RFC8839]のセクション5.4 |
          + -------------------------- + ----------------------- --- +
          | ice-pwd | [RFC8839]のセクション5.4 |
          + -------------------------- + ----------------------- --- +
          | アイスオプション| [RFC8839]のセクション5.6 |
          + -------------------------- + ----------------------- --- +
          | msid | [RFC8830]のセクション3 |
          + -------------------------- + ----------------------- --- +
          | 取り除く| [RFC8851]のセクション10 |
          + -------------------------- + ----------------------- --- +
          | サイマルキャスト| [RFC8853]のセクション5.1 |
          + -------------------------- + ----------------------- --- +
          | tls-id | [RFC8842]のセクション4 |
          + -------------------------- + ----------------------- --- +
        
表1：SDPABNFリファレンス

謝辞

Harald Alvestrand、Taylor Brandstetter、Suhas Nandakumar、およびPeter Thatcherが、このドキュメントに重要なテキストを提供しました. Bernard Aboba、Adam Bergkvist、Jan-Ivar Bruaroey、Dan Burnett、Ben Campbell、Alissa Cooper、Richard Ejzak、StefanHåkansson、Ted Hardie、Christer Holmberg、Andrew Hutton、Randell Jesup、Matthew Kaufman、Anant Narayanan、Adam Roach、Robert Sparks、 Neil Stratford、Martin Thomson、Sean Turner、およびMagnus Westerlundはすべて、このドキュメントに関する貴重なフィードバックを提供しました. 

著者の住所

Justin Uberti Google 747 6th Street South Kirkland、WA98033アメリカ合衆国

   Eメール：justin@uberti.name
        
カレンジェニングスCisco400 3rd AvenueSWカルガリーABT2P4H2カナダ

   メール：fluffy@iii.ca
        
Eric Rescorla（編集者）Mozilla

   Eメール：ekr@rtfm.com
        