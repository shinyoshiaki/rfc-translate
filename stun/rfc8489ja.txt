RFCトランス
個人情報保護方針
連絡先
イチジク
@ tex2e
8489
RFC 8489-NATのセッショントラバーサルユーティリティ（STUN）
URL：https://tools.ietf.org/html/rfc8489
タイトル：RFC 8489-NATのセッショントラバーサルユーティリティ（STUN）
翻訳編集：自動生成
インターネット技術特別調査委員会（IETF）M. Petit-Huguenin
コメントのリクエスト：8489インピーダンスの不一致
廃止：5389 G.サルゲイロ
カテゴリ：標準はシスコを追跡します
ISSN：2070-1721 J.ローゼンバーグ
                                                                   ファイブ9
                                                                 D.ウィング
                                                                  シトリックス
                                                                 マヒ
                                                            無所属
                                                             P.マシューズ
                                                                   ノキア
                                                           2020年2月
        
NAT用セッショントラバーサルユーティリティ（STUN）

概要

NAT（STUN）のセッショントラバーサルユーティリティは、NATトラバーサルを処理する他のプロトコルのツールとして機能するプロトコルです. エンドポイントは、NATによってエンドポイントに割り当てられたIPアドレスとポートを判別するために使用できます. また、2つのエンドポイント間の接続を確認したり、NATバインディングを維持するためのキープアライブプロトコルとして使用したりすることもできます. STUNは多くの既存のNATで動作し、それらからの特別な動作を必要としません. 

STUN自体は、NATトラバーサルソリューションではありません. むしろ、NATトラバーサルソリューションのコンテキストで使用されるツールです. 

このドキュメントはRFC 5389を廃止します. 

このメモのステータス

これはInternet Standards Trackドキュメントです. 

このドキュメントは、IETF（Internet Engineering Task Force）の製品です. これは、IETFコミュニティのコンセンサスを表しています. これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています. インターネット標準の詳細については、RFC 7841のセクション2を参照してください. 

このドキュメントの現在のステータス、エラッタ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8489で入手できます. 

著作権表示

著作権（c）2020 IETFトラストおよび文書の作成者として識別された人物. 全著作権所有. 

この文書は、BCP 78およびIETF文書に関するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象であり、この文書の発行日に有効です. これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているため、注意深く確認してください. このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseのテキストが含まれている必要があり、Simplified BSD Licenseに記載されているように保証なしで提供されます. 

目次

   1.はじめに............................................... ..... 4
   2.運用の概要........................................... 5
   3.用語..................................................... ......7
   4.定義......................................................... ......7
   5. STUNメッセージ構造.......................................... 9
   6.基本プロトコル手順................................................. 11
      6.1. リクエストまたはインジケーションの作成........................ 11
      6.2. リクエストまたはインジケーションの送信......................... 12
           6.2.1. UDPまたはDTLS-over-UDPを介した送信.................. 13
           6.2.2. TCPまたはTLS-over-TCP経由での送信................... 14
           6.2.3. TLS-over-TCPまたはDTLS-over-UDPを介した送信......... 15
      6.3. STUNメッセージの受信.................................. 16
           6.3.1. リクエストの処理............................... 17
                  6.3.1.1. 成功またはエラー応答の形成....... 17
                  6.3.1.2. 成功またはエラー応答の送信..... 18
           6.3.2. 表示の処理........................... 18
           6.3.3. 成功応答の処理...................... 19
           6.3.4. エラー応答の処理................................. 19
   7. FINGERPRINTメカニズム.......................................................... 20
   8.サーバーのDNS検出................................................ 20
      8.1. STUN URIスキームセマンティクス................................. 21
   9.認証およびメッセージ整合性メカニズム................ 22
      9.1. 短期資格メカニズム........................... 23
           9.1.1. HMACキー........................................... 23
           9.1.2. リクエストまたはインジケーションの形成..................... 23
           9.1.3. リクエストまたはインジケーションを受け取る.................................. 23
           9.1.4. 返答を受け取る............................... 25
           9.1.5. 後続のリクエストの送信........................ 25
      9.2. Long-Term Credentialメカニズム............................ 26
           9.2.1. ビッドダウン攻撃防止......................... 27
           9.2.2. HMACキー........................................... 27
        
           9.2.3. リクエストの作成.................................. 28
                  9.2.3.1. 最初のリクエスト............................. 28
                  9.2.3.2. 後続のリクエスト................................. 29
           9.2.4. リクエストの受け取り................................ 29
           9.2.5. 応答の受け取り............................... 31
   10.代替サーバーメカニズム................................................. 33
   11. RFC 3489との下位互換性......................... 34
   12.サーバーの基本的な動作......................................... 34
   13. STUNの使用法........................................................ ..... 35
   14. STUN属性........................................................ .36
      14.1. マップされたアドレス........................................... 37
      14.2. XOR-MAPPED-ADDRESS ....................................... 38
      14.3. ユーザー名................................................................. 39
      14.4. USERHASH ................................................................. 40
      14.5 メッセージの整合性........................................ 40
      14.6 MESSAGE-INTEGRITY-SHA256 ................................. 41
      14.7. フィンガープリント........................................................ 41
      14.8. エラーコード ............................................... 42
      14.9. REALM ................................................................. ... 44
      14.10. NONCE ................................................................. ..44
      14.11. パスワードアルゴリズム..................................... 44
      14.12. パスワードアルゴリズム................................................ 45
      14.13. 不明な属性................................................ 45
      14.14. ソフトウェア................................................................ 46
      14.15. 代替サーバー.................................................. 46
      14.16. 代替ドメイン........................................ 46
   15.運用上の考慮事項................................................. 47
   16.セキュリティに関する考慮事項................................................. 47
      16.1. プロトコルに対する攻撃............................. 47
           16.1.1. 外部からの攻撃................................... 47
           16.1.2. 内部攻撃................................................. 48
           16.1.3. ビッドダウン攻撃.................................. 48
      16.2. 使用に影響を与える攻撃.............................. 50
           16.2.1. 攻撃I：に対する分散型DoS（DDoS）
                   ターゲット............................................ 51
           16.2.2. 攻撃II：クライアントのサイレンシング..................... 51
           16.2.3. 攻撃III：クライアントのIDを想定する..... 52
           16.2.4. 攻撃IV：盗聴.......................... 52
      16.3. ハッシュアジリティ計画.................................................. 52
   17. IABの考慮事項............................................ 53
   18. IANAの考慮事項........................................... 53
      18.1. STUN Security Features Registry .......................... 53
      18.2. STUNメソッドレジストリ.................................... 54
      18.3. STUN属性レジストリ................................. 54
           18.3.1. 更新された属性................................ 55
           18.3.2. 新しい属性................................................. 55
      18.4. STUNエラーコードレジストリ................................ 56
      18.5. STUNパスワードアルゴリズムレジストリ........................ 56
        
           18.5.1. パスワードアルゴリズム............................... 57
                  18.5.1.1. MD5 ................................................ 57
                  18.5.1.2. SHA-256 .................................. 57
      18.6. STUN UDPおよびTCPポート番号............................ 57
   19. RFC 5389以降の変更点........................................ 57
   20.参考資料......................................................... ..... 58
      20.1. 規範的な参照..................................... 58
      20.2. 有益な参照................................... 61
   付録A. STUNメッセージタイプを決定するCスニペット............ 64
   付録B.テストベクトル......................................... 64
     B.1. を使用した長期認証を使用したサンプルリクエスト
           MESSAGE-INTEGRITY-SHA256およびUSERHASH ..................... 65
   謝辞................................................................ .66
   貢献者................................................. ..... 66
   著者のアドレス............................................... 0.67
        
1.はじめに
この仕様で定義されているプロトコルであるNAT（STUN）のセッショントラバーサルユーティリティは、ネットワークアドレス変換（NAT）を処理するためのツールを提供します. これは、エンドポイントがプライベートIPアドレスとポートに対応するNATによって割り当てられたIPアドレスとポートを決定する手段を提供します. また、エンドポイントがNATバインディングを存続させる方法も提供します. 一部の拡張機能を使用すると、このプロトコルを使用して、2つのエンドポイント間の接続チェックを実行したり（RFC8445）、2つのエンドポイント間でパケットをリレーしたりできます[RFC5766]. 

ツールの性質に合わせて、この仕様は拡張可能なパケット形式を定義し、いくつかのトランスポートプロトコルでの動作を定義し、2つの形式の認証を提供します. 

STUNは、1つ以上のNATトラバーサルソリューションのコンテキストで使用することを目的としています. これらのソリューションは「STUNの使用法」として知られています. それぞれの使用法は、NATトラバーサルソリューションを実現するためにSTUNがどのように利用されるかを説明しています. 通常、使用法は、STUNメッセージが送信されるタイミング、含めるオプションの属性、使用されるサーバー、および使用される認証メカニズムを示します. Interactive Connectivity Establishment（ICE）[RFC8445]は、STUNの1つの使用法です. SIPアウトバウンド[RFC5626]は、STUNのもう1つの使用法です. 場合によっては、STUNの拡張が必要になります. STUN拡張は、新しいメソッド、属性、またはエラー応答コードの形式にすることができます. STUNの使用法の詳細については、セクション13を参照してください. 

2.運用の概要
このセクションは説明のみです. 

                           /-----\
                         // STUN  \\
                        |   Server  |
                         \\       //
                           \-----/




                      +--------------+             Public Internet
      ................|     NAT 2    |.......................
                      +--------------+



                      +--------------+             Private Network 2
      ................|     NAT 1    |.......................
                      +--------------+




                           /-----\
                         // STUN  \\
                        |   Client  |
                         \\       //               Private Network 1
                           \-----/
        
図1：1つの可能なSTUN構成

1つの可能なSTUN構成を図1に示します. この構成には、STUNプロトコルを実装する2つのエンティティ（STUNエージェントと呼ばれる）があります. 図の下のエージェントはクライアントで、プライベートネットワーク1に接続されています. このネットワークはNAT 1を介してプライベートネットワーク2に接続します. プライベートネットワーク2はNAT 2を介してパブリックインターネットに接続します. 図の上のエージェントはサーバーです、公共のインターネット上に存在します. 

STUNはクライアント/サーバープロトコルです. 2つのタイプのトランザクションをサポートします. 1つは、クライアントがサーバーに要求を送信し、サーバーが応答を返す要求/応答トランザクションです. 2つ目は、エージェント（クライアントまたはサーバー）が応答を生成しない指示を送信する指示トランザクションです. どちらのタイプのトランザクションにも、ランダムに選択された96ビット番号であるトランザクションIDが含まれています. 要求/応答トランザクションの場合、このトランザクションIDにより、クライアントは応答を、それを生成した要求に関連付けることができます. 指示の場合、トランザクションIDはデバッグの補助として機能します. 

すべてのSTUNメッセージは、メソッド、クラス、およびトランザクションIDを含む固定ヘッダーで始まります. メソッドは、これがさまざまな要求または指示のどれであるかを示します. この仕様では1つのメソッドBindingのみが定義されていますが、他のメソッドは他のドキュメントで定義されることが期待されています. クラスは、これが要求、成功応答、エラー応答、または指示であるかどうかを示します. 固定ヘッダーの後には0個以上の属性が続きます. これは、特定のメッセージの追加情報を伝えるType-Length-Value拡張です. 

このドキュメントでは、「Binding」と呼ばれる単一のメソッドを定義しています. Bindingメソッドは、要求/応答トランザクションまたは指示トランザクションで使用できます. 要求/応答トランザクションで使用する場合、Bindingメソッドを使用して、NATがSTUNクライアントに割り当てた特定のバインディングを判別できます. 要求/応答または指示トランザクションで使用する場合、Bindingメソッドを使用して、これらのバインディングを存続させることもできます. 

バインディング要求/応答トランザクションでは、バインディング要求がSTUNクライアントからSTUNサーバーに送信されます. バインド要求がSTUNサーバーに到着したとき、STUNクライアントとSTUNサーバーの間の1つ以上のNATを通過している可能性があります（図1では、2つのNATがあります）. バインディング要求メッセージがNATを通過すると、NATはパケットの送信元トランスポートアドレス（つまり、送信元IPアドレスと送信元ポート）を変更します. その結果、サーバーが受信した要求のソーストランスポートアドレスは、サーバーに最も近いNATによって作成されたパブリックIPアドレスとポートになります. これは「reflexive transport address」と呼ばれます. STUNサーバーは、そのソーストランスポートアドレスをSTUNバインディング応答のXOR-MAPPED-ADDRESS属性にコピーし、バインディング応答をSTUNクライアントに送り返します. このパケットがNATを通過すると、NATはIPヘッダーの宛先トランスポートアドレスを変更しますが、STUN応答の本文内のXOR-MAPPED-ADDRESS属性のトランスポートアドレスは変更されません. このようにして、クライアントはSTUNサーバーに関して最も外側のNATによって割り当てられたreflexive transport addressを知ることができます. 

使用法によっては、STUNを他のプロトコル（[RFC8445]や[RFC5626]など）と多重化する必要があります. これらの使用法では、パケットを検査し、それがSTUNパケットであるかどうかを判断する方法が必要です. STUNは、この目的で使用できる固定値を持つSTUNヘッダーに3つのフィールドを提供します. これで十分でない場合、STUNパケットにはFINGERPRINT値も含まれる可能性があり、さらにパケットを区別するために使用できます. 

STUNは、「メカニズム」と呼ばれる、使用法が使用を決定できる一連のオプションのプロシージャを定義します. これらのメカニズムには、DNS検出、代替サーバーへのリダイレクト手法、逆多重化のためのフィンガープリント属性、2つの認証およびメッセージの完全性の交換が含まれます. 認証メカニズムは、ユーザー名、パスワード、およびメッセージの完全性の値の使用を中心に展開します. この仕様では、Long-Term CredentialメカニズムとShort-Term Credentialメカニズムの2つの認証メカニズムが定義されています. 各使用法は、その使用法で許可されるメカニズムを指定します. 

長期的な認証メカニズムでは、クライアントとサーバーは事前にプロビジョニングされたユーザー名とパスワードを共有し、HTTP [RFC7616]で定義されたものから着想を得たダイジェストチャレンジ/レスポンス交換を実行しますが、詳細は異なります. 短期的な資格メカニズムでは、クライアントとサーバーは、STUN交換の前に、帯域外の方法でユーザー名とパスワードを交換します. たとえば、ICEの使用法[RFC8445]では、2つのエンドポイントが帯域外シグナリングを使用してユーザー名とパスワードを交換します. これらは、完全性を保護し、要求と応答を認証するために使用されます. チャレンジやノンスは使用されていません. 

3.用語
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONALこのドキュメントの「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように解釈されます. 

4.定義
STUNエージェント：STUNエージェントは、STUNプロトコルを実装するエンティティです. エンティティは、STUNクライアントまたはSTUNサーバーのいずれかです. 

STUNクライアント：STUNクライアントは、STUN要求を送信し、STUN応答とSTUN通知を受信するエンティティです. STUNクライアントは指標を送信することもできます. この仕様では、「STUNクライアント」と「クライアント」は同義語です. 

STUNサーバー：STUNサーバーは、STUN要求とSTUN通知を受信し、STUN応答を送信するエンティティです. STUNサーバーは指標を送信することもできます. この仕様では、「STUNサーバー」と「サーバー」は同義語です. 

トランスポートアドレス：IPアドレスとポート番号の組み合わせ（UDPまたはTCPポート番号など）. 

reflexive transport address：IPネットワーク上の別のホスト（通常はSTUNサーバー）から見たクライアントを識別するトランスポートアドレス. クライアントと他のホストの間にNATが介在している場合、reflexive transport addressは、NATのパブリック側でクライアントに割り当てられたマッピングアドレスを表します. reflexive transport addressは、STUN応答のマッピングアドレス属性（MAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS）から学習されます. 

Mapped Address：再帰的アドレスと同じ意味. この用語は、歴史的な理由と、MAPPED-ADDRESSおよびXOR-MAPPED-ADDRESS属性の命名のためにのみ保持されます. 

Long-Term Credential：クライアントとサーバー間の共有秘密を表すユーザー名と関連パスワード. サブスクライバーがサービスに登録すると、通常、長期の資格情報がクライアントに付与され、サブスクライバーがサービスを終了するか、資格情報を明示的に変更するまで保持されます. 

Long-Term Password：Long-Term Credentialのパスワード. 

Short-Term Credential：クライアントとサーバー間の共有秘密を表す一時的なユーザー名と関連パスワード. 短期的なクレデンシャルは、STUN交換の前に、クライアントとサーバー間の何らかのプロトコルメカニズムを通じて取得されます. 短期クレデンシャルには、特定の時間（5分など）またはイベント（Session Initiation Protocol（SIP）[RFC3261]ダイアログの終了など）に基づく可能性のある明示的な時間的範囲があります. Short-Term Credentialの具体的な範囲は、アプリケーションの使用法によって定義されます. 

短期パスワード：短期資格のパスワードコンポーネント. 

STUN表示：応答を受信しないSTUNメッセージ. 

属性：STUNメッセージに追加できるType-Length-Value（TLV）オブジェクトのSTUN用語. 属性は、comprehension-requiredとcomprehension-optionalの2つのタイプに分類されます. STUNエージェントは、理解できない理解オプション属性を安全に無視できますが、理解されていない理解必須属性が含まれていると、メッセージを正常に処理できません. 

RTO：Retransmission TimeOut. 要求の送信とその要求の最初の再送信の間の初期期間を定義します. 

5. STUNメッセージ構造 
STUNメッセージは、ネットワーク指向のフォーマットを使用してバイナリでエンコードされます（最初に最上位バイトまたはオクテット、一般にビッグエンディアンとも呼ばれます）. 送信順序は、[RFC0791]の付録Bで詳細に説明されています. 特に明記しない限り、数値定数は10進数（基数10）です. 

すべてのSTUNメッセージは、20バイトのヘッダーとそれに続く0個以上の属性で構成されます. STUNヘッダーには、STUNメッセージタイプ、メッセージ長、マジッククッキー、およびトランザクションIDが含まれています. 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0|     STUN Message Type     |         Message Length        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         Magic Cookie                          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                     Transaction ID (96 bits)                  |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図2：STUNメッセージヘッダーのフォーマット

すべてのSTUNメッセージの最上位2ビットはゼロでなければなりません. これは、同じポートでSTUNが他のプロトコルと多重化されている場合に、STUNパケットを他のプロトコルと区別するために使用できます. 

メッセージタイプは、STUNメッセージのメッセージクラス（要求、成功応答、エラー応答、または表示）とメッセージメソッド（主要機能）を定義します. メッセージクラスは4つありますが、STUNには、要求/応答トランザクション（要求メッセージと応答メッセージで構成される）と指示トランザクション（単一の指示メッセージで構成される）の2種類のトランザクションしかありません. 応答クラスは、STUNメッセージの迅速な処理を支援するために、エラー応答と成功応答に分けられます. 

STUNメッセージタイプフィールドは、さらに次の構造に分解されます.  

                       0                 1
                       2  3  4 5 6 7 8 9 0 1 2 3 4 5
                      +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                      |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
                      |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
                      +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図3：STUNメッセージタイプフィールドのフォーマット

ここで、STUNメッセージタイプフィールドのビットは、最上位（M11）から最下位（M0）として表示されます. M11からM0は、メソッドの12ビットエンコーディングを表します. C1とC0は、クラスの2ビットエンコーディングを表します. クラス0b00は要求、クラス0b01は指示、クラス0b10は成功応答、クラス0b11はエラー応答です. この仕様では、Bindingという単一のメソッドが定義されています. メソッドとクラスは直交しているため、メソッドごとに、そのメソッドに対して要求、成功応答、エラー応答、および指示が可能です. 新しいメソッドを定義する拡張機能は、そのメソッドで許可されているクラスを示す必要があります. 

たとえば、Bindingリクエストにはclass = 0b00（リクエスト）およびmethod = 0b000000000001（Binding）があり、最初の16ビットに0x0001としてエンコードされます. バインディング応答にはclass = 0b10（成功応答）とmethod = 0b000000000001があり、最初の16ビットに0x0101としてエンコードされます. 

注：この不幸なエンコーディングは、ビットフィールドを使用した表示メッセージ、成功応答、およびエラー応答のエンコーディングを考慮していなかった[RFC3489]の値の割り当てによるものです. 

Magic Cookieフィールドには、ネットワークバイトオーダーで固定値0x2112A442を含める必要があります. [RFC3489]では、Magic Cookieフィールドを構成する32ビットはトランザクションIDの一部でした. マジッククッキーをこの場所に配置することで、[RFC5389]によってSTUNに追加された特定の属性をクライアントが理解できるかどうかをサーバーが検出できるようになります. さらに、同じポートでSTUNが他のプロトコルと多重化されている場合に、STUNパケットと他のプロトコルのパケットを区別するのに役立ちます. 

トランザクションIDは、STUNトランザクションを一意に識別するために使用される96ビットの識別子です. 要求/応答トランザクションの場合、トランザクションIDは、要求に対してSTUNクライアントによって選択され、サーバーによって応答でエコーされます. 表示の場合、表示を送信するエージェントによって選択されます. 特定の種類の攻撃を防ぐのに役立ちますが、主に要求と応答を関連付ける役割も果たします. サーバーは、トランザクションIDをキーとして使用して、すべてのクライアント間で各トランザクションを一意に識別します. したがって、トランザクションIDは、間隔0 .. 2 ** 96-1から均一かつランダムに選択する必要があり、暗号的にランダムでなければなりません. 同じリクエストを再送信すると、同じトランザクションIDが再利用されます. ただし、新しい要求が前の要求とビット単位で同一で、同じトランスポートアドレスから同じIPアドレスに送信されない限り、クライアントは新しいトランザクションの新しいトランザクションIDを選択する必要があります. 成功応答とエラー応答は、対応する要求と同じトランザクションIDを伝える必要があります. エージェントがSTUNサーバーとSTUNクライアントとして同じポートで動作している場合、エージェントが送信したリクエストのトランザクションIDは、エージェントが受信したリクエストのトランザクションIDとは関係ありません. 

メッセージ長には、20バイトのSTUNヘッダーを含まない、バイト単位のメッセージのサイズを含める必要があります. すべてのSTUN属性は4バイトの倍数に埋め込まれるため、このフィールドの最後の2ビットは常にゼロです. これは、STUNパケットを他のプロトコルのパケットと区別する別の方法を提供します. 

ヘッダーのSTUN固定部分の後には、0個以上の属性があります. 各属性はTLV（Type-Length-Value）でエンコードされています. エンコーディングと属性自体の詳細については、セクション14を参照してください. 

6.基本プロトコル手順
このセクションでは、STUNプロトコルの基本手順を定義します. メッセージの形成方法、送信方法、および受信時の処理方法について説明します. また、Bindingメソッドの詳細な処理も定義します. このドキュメントの他のセクションでは、特定の状況で使用法が選択できるオプションの手順について説明します. 他のドキュメントでは、新しいメソッド、新しい属性、または新しいエラー応答コードを追加することにより、STUNの他の拡張を定義している場合があります. 

6.1. リクエストまたはインジケーションの形成
リクエストまたはインジケーションメッセージを作成する場合、エージェントはヘッダーを作成するときにセクション5のルールに従う必要があります. さらに、メッセージクラスは「リクエスト」または「表示」（必要に応じて）である必要があり、メソッドはバインディングまたは別のドキュメントで定義されているメソッドである必要があります. 

次に、エージェントはメソッドまたは使用法で指定された属性を追加します. たとえば、一部の使用法では、エージェントが認証方法（セクション9）またはFINGERPRINT属性（セクション7）を使用することを指定できます. 

エージェントがリクエストを送信している場合は、リクエストにSOFTWARE属性を追加する必要があります. 方法に応じて、エージェントはインジケーションにソフトウェア属性を含めることができます. STUNの拡張機能は、ソフトウェアが新しい適応症に役立つかどうかを話し合う必要があります. SOFTWARE属性を含めることは、セキュリティに影響を与える可能性があることに注意してください. 詳細は項16.1.2を参照してください. 

認証のないBindingメソッドの場合、使用法で特に指定されていない限り、属性は必要ありません. 

UDPまたはDTLS-over-UDP [RFC6347]を介して送信されるすべてのSTUNメッセージは、既知の場合、パスMTU未満である必要があります. 

UDPのパスMTUが不明である場合、メッセージは576バイトとIPv4 [RFC1122]の最初のホップMTUおよびIPv6 [RFC8200]の1280バイトの小さい方である必要があります. この値は、IPパケットの全体的なサイズに対応しています. したがって、IPv4の場合、実際のSTUNメッセージは548バイト未満である必要があります（576から20バイトのIPヘッダー、8バイトのUDPヘッダーを差し引いて、IPオプションが使用されないと想定）. 

DTLS-over-UDPのパスMTUが不明な場合は、前の段落で説明したルールを調整して、（13バイト）DTLSレコードヘッダーのサイズ、メッセージ認証コード（MAC）サイズ、そしてパディングサイズ. 

STUNは、要求がMTUよりも小さいが応答がMTUよりも大きい場合を処理する機能を提供しません. この制限がSTUNの問題になることは想定されていません. MTUの制限は、MTU特性[RFC5780]をプローブするためにSTUN自体が使用されている場合を考慮して、必須ではなく、SHOULDです. STUNを使用してPath MTU Discoveryをこのようなメカニズムのないプロトコルに追加するフレームワークについては、[STUN-PMTUD]も参照してください. このアプリケーションまたは同様のアプリケーション以外では、MTU制約に従う必要があります. 

6.2. リクエストまたはインディケーションの送信
次に、エージェントは要求または指示を送信します. このドキュメントでは、UDUN、TCP、TLS-over-TCP、またはDTLS-over-UDPを介してSTUNメッセージを送信する方法を指定します. 他のトランスポートプロトコルは将来追加されるかもしれません. STUNの使用法では、使用するトランスポートプロトコルと、エージェントが受信者のIPアドレスとポートを決定する方法を指定する必要があります. セクション8では、使用法が使用することを選択できるサーバーのIPアドレスとポートを決定するDNSベースの方法について説明します. 

いつでも、クライアントは同じSTUNサーバーで複数の未解決のSTUNリクエスト（つまり、進行中の複数のトランザクションで、異なるトランザクションIDを持つ）を持つことができます（MAY）. 新しいトランザクションのレートに他の制限がない場合（接続チェック用にICEで指定されたものや、STUNがTCPで実行されている場合など）、クライアントは同じサーバーへの未処理のトランザクションを10個に制限する必要があります（SHOULD）. 

6.2.1. UDPまたはDTLS-over-UDPを介した送信
STUN over UDPまたはSTUN over DTLS-over-UDP [RFC7350]を実行している場合、STUNメッセージがネットワークによってドロップされる可能性があります. STUN要求/応答トランザクションの信頼性は、クライアントアプリケーション自体による要求メッセージの再送信を通じて実現されます. STUN通知は再送信されません. したがって、UDPまたはDTLS-over-UDPを介した指示トランザクションは信頼できません. 

クライアントは、RTO（ "Retransmission TimeOut"）の間隔で始まるSTUNリクエストメッセージを再送信する必要があります（再送信ごとに2倍になります）. RTOは往復時間（RTT）の推定値であり、[RFC6298]で説明されているように計算されますが、2つの例外があります. まず、RTOの初期値は500ミリ秒以上である必要があります. この「SHOULD」の例外ケースは、他のメカニズムを使用して輻輳しきい値（ICEで固定レートストリームに対して定義されているしきい値など）を導出する場合、またはネットワーク容量が既知の非インターネット環境でSTUNを使用する場合です. 固定回線アクセスリンクでは、500ミリ秒の値が推奨されます. 次に、RTOの値は最も近い秒に切り上げないでください. むしろ、1 msの精度を維持する必要があります. TCPと同様に、カーンのアルゴリズムの使用は推奨されています[KARN87]. 

RTOの値は、トランザクションの完了後にクライアントによってキャッシュされる必要があり（SHOULD）、同じサーバーへの次のトランザクションのRTOの開始値として使用されます（IPアドレスの同等性に基づく）. 過去10分間に同じサーバーでトランザクションが発生しなかった場合、値は古くなっていると見なして破棄する必要があります（SHOULD）. 

再送信は、応答が受信されるまで、または合計Rc要求が送信されるまで続きます. Rcは構成可能である必要があり、SHOULDのデフォルトは7です. 最後のリクエストの後、RmにRTOを掛けた期間がレスポンスなしで経過した場合（この最後のリクエストのみが実際に成功した場合にレスポンスを取得するための十分な時間を提供します）、クライアントはトランザクションが失敗したと考えるべきです. Rm SHOULDは構成可能であり、SHOULDのデフォルトは16です. ハードICMPエラー[RFC1122]があった場合、UDPまたはDTLS-over-UDP上のSTUNトランザクションも失敗したと見なされます. たとえば、RTOが500ミリ秒の場合、リクエストは0ミリ秒、500ミリ秒、1500ミリ秒、3500ミリ秒、7500ミリ秒、15500ミリ秒、31500ミリ秒の時間に送信されます. 39500ミリ秒後にクライアントが応答を受信しない場合、クライアントはトランザクションがタイムアウトしたと見なします. 

6.2.2. TCPまたはTLS-over-TCPを介した送信
TCPおよびTLS-over-TCP [RFC8446]の場合、クライアントはサーバーへのTCP接続を開きます. 

STUNのいくつかの使用法では、STUNはTCP接続を介した唯一のプロトコルです. この場合、追加のフレーミングや逆多重化を使用せずに送信できます. 他の使用法や他の拡張機能では、TCP接続を介して他のデータと多重化される場合があります. その場合、STUNは、使用法または拡張機能で指定されたある種のフレーミングプロトコルの上で実行する必要があります. これにより、エージェントは完全なSTUNメッセージと完全なアプリケーション層メッセージを抽出できます. セクション8のDNS手順によって検出されたウェルノウンポートで実行されているSTUNサービスは、STUN専用であり、他のデータと多重化されたSTUN用ではありません. したがって、これらのサーバーへの接続ではフレーミングプロトコルは使用されません. 追加のフレーミングが利用される場合、使用法は、クライアントがそれを適用する方法と、接続するポートを指定します. 

STUN over TCPおよびTLS-over-TCPの信頼性はTCP自体によって処理され、STUNプロトコルレベルでの再送信はありません. ただし、要求/応答トランザクションの場合、クライアントが要求メッセージを送信してからTi秒以内に応答を受信しなかった場合、クライアントはトランザクションがタイムアウトしたと見なします. Tiは構成可能である必要があり（SHOULD）、デフォルトは39.5秒です. この値は、デフォルトの初期RTOのTCPタイムアウトとUDPタイムアウトを等しくするために選択されています. 

さらに、クライアントがTCP接続を確立できない場合、または応答を受信する前にTCP接続がリセットまたは失敗した場合、進行中の要求/応答トランザクションは失敗したと見なされます. 

クライアントは、単一のTCP（またはTLS-over-TCP）接続を介して複数のトランザクションを送信してもよく（MAY）、前の要求への応答を受信する前に別の要求を送信してもよい（MAY）. クライアントは、次の状態になるまで接続を開いたままにする必要があります（SHOULD）. 

oその接続を介して送信する追加のSTUN要求または指示はありません. 

oその接続を介して送信されたSTUN要求を通じて学習されたリソース（マップアドレス（MAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS）またはリレーアドレス[RFC5766]など）を使用する予定はありません. 

oそのポートで他のアプリケーションプロトコルを多重化し、それらの他のプロトコルの使用を終了した場合

o学習したポートをリモートピアで使用していて、一部のTCP NATトラバーサルテクニック（[RFC6544]など）で必要なように、そのリモートピアとの通信を確立している場合. 

最終的なキープアライブメカニズムの詳細は、各STUNの使用法に委ねられています. いずれにしても、アイドルTCP接続が機能しなくなったためにトランザクションが失敗した場合、クライアントはRSTを送信して新しいTCP接続を開こうとする必要があります（SHOULD）. 

サーバーが（たとえば、クライアントがネットワークから切断したために）接続がタイムアウトしたと判断しない限り、サーバーは接続を開いたままにし、クライアントが接続を閉じるようにする必要があります（SHOULD）. クライアントが学習したバインディングは、接続が開いたままである間のみ、NATの介入で有効のままです. バインディングがどれだけ必要かを知っているのはクライアントだけです. 応答が送信されなかった接続を介して要求が受信された場合、サーバーは接続を閉じるべきではありません（SHOULD NOT）. サーバーは、応答を送信するために、クライアントへの接続を開かないでください. サーバーは、過負荷の場合の接続管理に関するベストプラクティスに従う必要があります. 

6.2.3. TLS-over-TCPまたはDTLS-over-UDPを介した送信
STUNがTLS-over-TCPまたはDTLS-over-UDPを介して単独で実行される場合、TLS_DHE_RSA_WITH_AES_128_GCM_SHA256およびTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256暗号化スイートを実装する必要があります（このプロトコルの古いバージョンとの互換性のために）. 他の暗号スイートが実装される場合があります. TLSバージョン1.3 [RFC8446]以降のバージョンを実装するSTUNクライアントおよびサーバーは、これらの仕様からの必須の暗号スイートを実装するためにも必要であり、これらの仕様のサポートを検出した場合、非推奨の暗号スイートの使用を無効にする必要があります. Perfect Forward Secrecy（PFS）暗号スイートは、非PFS暗号スイートよりも優先される必要があります. （単一の）DESおよびRC4に基づくものなど、既知の弱点を持つ暗号スイートは使用してはなりません（MUST NOT）. 実装ではTLSレベルの圧縮を無効にする必要があります. 

これらの推奨事項は、TLSまたはDTLSを使用したSTUN Usageの実装と展開が従う必要がある[BCP195]の推奨事項の一部にすぎません. 

TLS証明書メッセージを受信すると、クライアントは証明書を検証し、証明書によって識別されるサイトを検査する必要があります. 証明書が無効または失効している場合、または証明書が適切な当事者を識別していない場合、クライアントはSTUNメッセージを送信してはならず、さもなければSTUNトランザクションを続行してはなりません. クライアントはサーバーのIDを検証する必要があります. これを行うには、[RFC6125]で定義されている識別手順に従います. 証明書には、タイプDNS-IDまたはCN-IDの識別子が含まれ、オプションで左端のラベルにワイルドカード文字が含まれますが、タイプSRV-IDまたはURIは含まれません.  -ID. 

STUNがTLS-over-TCP接続またはDTLS-over-UDPアソシエーションを介して他のプロトコルと多重化して実行される場合、必須の暗号スイートとTLS処理手順は、これらのプロトコルで定義されたとおりに動作します. 

6.3. STUNメッセージの受信
このセクションでは、STUNメッセージの処理を指定します. ここで指定する処理は、この仕様で定義されているSTUNメッセージ用です. 下位互換性に関する追加の規則は、セクション11で定義されています. これらの追加の手順はオプションであり、使用法はそれらを利用することを選択できます. 最初に、クラスに依存しない一連の処理操作が適用されます. これに続いて、以下のサブセクションで説明するクラス固有の処理が行われます. 

STUNエージェントは、STUNメッセージを受信すると、まず、メッセージがセクション5のルールに従っているかどうかを確認します. 最初の2ビットが0であり、Magic Cookieフィールドに正しい値があり、メッセージの長さが適切であることを確認します. メソッドの値がサポートされているメソッドであること. メッセージクラスが特定のメソッドで許可されていることを確認します. メッセージクラスが「成功応答」または「エラー応答」の場合、エージェントは、トランザクションIDがまだ進行中のトランザクションと一致することを確認します. FINGERPRINT拡張が使用されている場合、エージェントはFINGERPRINT属性が存在し、正しい値が含まれていることを確認します. エラーが検出されると、メッセージは通知なく破棄されます. STUNが別のプロトコルと多重化されている場合、エラーはこれが実際にはSTUNメッセージではないことを示す場合があります. 

次に、STUNエージェントは、使用法で指定された認証メカニズムに必要なチェックを行います（セクション9を参照）. 

認証チェックが完了すると、STUNエージェントは、メッセージ内の不明な属性と既知の、ただし予期しない属性をチェックします. 不明なcomprehension-optional属性は、エージェントによって無視される必要があります. 既知であるが予期しない属性は、エージェントによって無視される必要があります（SHOULD）. 不明な理解が必要な属性は、メッセージクラスに依存する処理を引き起こします. これについては以下で説明します. 

この時点で、以降の処理は要求のメッセージクラスによって異なります. 

6.3.1. リクエストの処理
要求に1つ以上の不明な理解が必要な属性が含まれている場合、サーバーはエラー応答でエラーコード420（不明な属性）を返し、不明な理解が必要な属性をリストするUNKNOWN-ATTRIBUTES属性を応答に含めます. 

それ以外の場合、サーバーはメソッドまたは特定の使用法が必要とする追加のチェックを行います. すべてのチェックが成功した場合、サーバーは以下に説明するように成功応答を作成します. 

UDPまたはDTLS-over-UDPを介して実行される場合、サーバーが受信した要求は、トランザクションの最初の要求である場合もあれば、再送信である場合もあります. サーバーは、次のプロパティが保持されるように再送信に応答する必要があります. クライアントが再送信に対する応答を受信し、元の要求に送信された応答を受信しない場合、クライアントとサーバーの全体的な状態は、元の再送信への応答が受信されるか、両方の応答が受信される場合（クライアントは最初の応答を使用します）. この要件を満たす最も簡単な方法は、UDPまたはDTLS-over-UDPを介して受信したすべてのトランザクションIDと、過去40秒間に対応する応答をサーバーが記憶することです. しかしながら、これはサーバーが状態を保持する必要があり、認証されていない要求には不適切です. 別の方法は、要求を再処理して応答を再計算することです. 後者の手法は、べき等の要求にのみ適用する必要があり（システムの全体的な状態に影響を与えずに同じ要求を安全に繰り返すことができる場合、要求はべき等と見なされます）、同じ要求に対して同じ成功応答をもたらします. Bindingメソッドはべき等であると見なされます. reflexive transport address値を変更させ、その結果、異なる成功応答で異なるマッピングアドレスが発生する可能性がある特定のまれなネットワークイベントがあることに注意してください. STUNの拡張機能では、トランザクションの状態を保存しないサーバーでのリクエストの再送信の影響について説明する必要があります. 別の方法は、要求を再処理して応答を再計算することです. 後者の手法は、べき等の要求にのみ適用する必要があり（システムの全体的な状態に影響を与えずに同じ要求を安全に繰り返すことができる場合、要求はべき等と見なされます）、同じ要求に対して同じ成功応答をもたらします. Bindingメソッドはべき等であると見なされます. reflexive transport address値を変更させ、その結果、異なる成功応答で異なるマッピングアドレスが発生する可能性がある特定のまれなネットワークイベントがあることに注意してください. STUNの拡張機能では、トランザクションの状態を保存しないサーバーでのリクエストの再送信の影響について説明する必要があります. 別の方法は、要求を再処理して応答を再計算することです. 後者の手法は、べき等の要求にのみ適用する必要があり（システムの全体的な状態に影響を与えずに同じ要求を安全に繰り返すことができる場合、要求はべき等と見なされます）、同じ要求に対して同じ成功応答をもたらします. Bindingメソッドはべき等であると見なされます. reflexive transport address値を変更させ、その結果、異なる成功応答で異なるマッピングアドレスが発生する可能性がある特定のまれなネットワークイベントがあることに注意してください. STUNの拡張機能では、トランザクションの状態を保存しないサーバーでのリクエストの再送信の影響について説明する必要があります. 後者の手法は、べき等の要求にのみ適用する必要があり（システムの全体的な状態に影響を与えずに同じ要求を安全に繰り返すことができる場合、要求はべき等と見なされます）、同じ要求に対して同じ成功応答をもたらします. Bindingメソッドはべき等であると見なされます. reflexive transport address値を変更させ、その結果、異なる成功応答で異なるマッピングアドレスが発生する可能性がある特定のまれなネットワークイベントがあることに注意してください. STUNの拡張機能では、トランザクションの状態を保存しないサーバーでのリクエストの再送信の影響について説明する必要があります. 後者の手法は、べき等の要求にのみ適用する必要があり（システムの全体的な状態に影響を与えずに同じ要求を安全に繰り返すことができる場合、要求はべき等と見なされます）、同じ要求に対して同じ成功応答をもたらします. Bindingメソッドはべき等であると見なされます. reflexive transport address値を変更させ、その結果、異なる成功応答で異なるマッピングアドレスが発生する可能性がある特定のまれなネットワークイベントがあることに注意してください. STUNの拡張機能では、トランザクションの状態を保存しないサーバーでのリクエストの再送信の影響について説明する必要があります. reflexive transport address値を変更させ、その結果、異なる成功応答で異なるマッピングアドレスが発生する可能性がある特定のまれなネットワークイベントがあることに注意してください. STUNの拡張機能では、トランザクションの状態を保存しないサーバーでのリクエストの再送信の影響について説明する必要があります. reflexive transport address値を変更させ、その結果、異なる成功応答で異なるマッピングアドレスが発生する可能性がある特定のまれなネットワークイベントがあることに注意してください. STUNの拡張機能では、トランザクションの状態を保存しないサーバーでのリクエストの再送信の影響について説明する必要があります. 

6.3.1.1. 成功またはエラー応答の形成
応答（成功またはエラー）を形成する場合、サーバーはセクション6のルールに従います. 応答のメソッドは要求のメソッドと同じであり、メッセージクラスは「成功応答」または「エラー応答」のいずれかです. 

エラー応答の場合、サーバーは上記の処理で指定されたエラーコードを含むERROR-CODE属性を追加する必要があります. 理由句は固定されていませんが、エラーコードに適したものである必要があります. 特定のエラーについては、追加の属性がメッセージに追加されます. これらの属性は、エラーコードが指定されている説明に記載されています. たとえば、エラーコード420（不明な属性）の場合、サーバーにはUNKNOWN-ATTRIBUTES属性を含める必要があります. 特定の認証エラーにより、属性が追加されます（セクション9を参照）. 拡張機能は、他のエラーや追加の属性を定義して、エラーの場合に追加できます. 

サーバーが認証メカニズムを使用して要求を認証した場合、サーバーは適切な認証属性を応答に追加する必要があります（セクション9を参照）. 

サーバーは、特定のメソッドまたは使用法に必要な属性も追加します. さらに、サーバーはメッセージにSOFTWARE属性を追加する必要があります（SHOULD）. 

Bindingメソッドの場合、使用法で特に指定されていない限り、追加のチェックは必要ありません. 成功応答を形成するとき、サーバーはXOR-MAPPED-ADDRESS属性を応答に追加します. この属性には、要求メッセージのソーストランスポートアドレスが含まれます. UDPまたはDTLS-over-UDPの場合、これは要求メッセージのソースIPアドレスとソースUDPポートです. TCPおよびTLS-over-TCPの場合、これはサーバーから見たTCP接続のソースIPアドレスとソースTCPポートです. 

6.3.1.2. 成功またはエラー応答の送信
応答（成功またはエラー）は、要求が受信されたときと同じトランスポートを介して送信されます. 要求がUDPまたはDTLS-over-UDP経由で受信された場合、応答の宛先IPアドレスとポートは、受信した要求メッセージの送信元IPアドレスとポートであり、応答の送信元IPアドレスとポートは、受信した要求メッセージの宛先IPアドレスとポート. 要求がTCPまたはTLS-over-TCPを介して受信された場合、応答は、要求が受信されたのと同じTCP接続で送り返されます. 

サーバーは、要求を受け取った順序とは異なる順序で応答を送信できます. 

6.3.2. 指示の処理
表示に不明な理解が必要な属性が含まれている場合、表示は破棄され、処理が停止します. 

それ以外の場合、エージェントはメソッドまたは特定の使用法が必要とする追加のチェックを行います. すべてのチェックが成功した場合、エージェントは指示を処理します. 指示に対して応答は生成されません. 

Bindingメソッドの場合、使用法で特に指定されていない限り、追加のチェックや処理は必要ありません. エージェントがメッセージを受信するだけで、介在するNATのバインディングが更新されます. 

インジケーションは（リクエストとは異なり）UDPまたはDTLS-over-UDPを介して再送信されないため、送信エージェントでインジケーションの再送信を処理する必要はありません. 

6.3.3. 成功応答の処理
成功の応答に不明な理解が必要な属性が含まれている場合、応答は破棄され、トランザクションは失敗したと見なされます. 

それ以外の場合、クライアントは、メソッドまたは特定の使用法が必要とする追加のチェックを行います. すべてのチェックが成功すると、クライアントは成功応答を処理します. 

Bindingメソッドの場合、クライアントはXOR-MAPPED-ADDRESS属性が応答に存在することを確認します. クライアントは指定されたアドレスファミリをチェックします. サポートされていないアドレスファミリの場合、属性は無視してください. 予期しないがサポートされているアドレスファミリである場合（たとえば、BindingトランザクションがIPv4経由で送信されたが、指定されたアドレスファミリがIPv6である場合）、クライアントは値を受け入れて使用することができます（MAY）. 

6.3.4. エラー応答の処理
エラー応答に不明な理解が必要な属性が含まれている場合、またはエラー応答にERROR-CODE属性が含まれていない場合、トランザクションは単に失敗したと見なされます. 

それ以外の場合、クライアントは認証メカニズムで指定された処理を実行します（セクション9を参照）. これにより、新しいトランザクションが試行される場合があります. 

この時点での処理は、エラーコード、メソッド、および使用方法によって異なります. デフォルトのルールは次のとおりです. 

oエラーコードが300〜399の場合、ALTERNATE-SERVER拡張機能（セクション10）が使用されていない限り、クライアントはトランザクションが失敗したと見なす必要があります（SHOULD）. 

oエラーコードが400〜499の場合、クライアントはトランザクションの失敗を宣言します. 420（不明な属性）の場合、応答には追加情報を提供するUNKNOWN-ATTRIBUTES属性が含まれている必要があります. 

oエラーコードが500〜599の場合、クライアントはリクエストを再送信できます. これを行うクライアントは、これを行う回数を制限する必要があります. 特定のエラーコードが別の値を指定していない限り、再送信の数は4に制限する必要があります. 

その他のエラーコードがあると、クライアントはトランザクションが失敗したと見なします. 

7. FINGERPRINTメカニズム 
このセクションでは、2つのプロトコルが同じトランスポートアドレスで多重化されている場合に、STUNメッセージを他のプロトコルのパケットから区別するのに役立つ、STUNのオプションのメカニズムについて説明します. このメカニズムはオプションであり、STUNの使用法は、それが使用されるかどうか、いつ使用されるかを記述する必要があります. FINGERPRINTメカニズムはRFC 3489との下位互換性がなく、そのような互換性が必要な環境では使用できません. 

一部の使用法では、STUNメッセージは、リアルタイム転送プロトコル（RTP）などの他のプロトコルと同じ転送アドレスで多重化されます. セクション6で説明されている処理を適用するには、まずSTUNメッセージをアプリケーションパケットから分離する必要があります. 

セクション5では、この目的で使用できるSTUNヘッダーの3つの固定フィールドについて説明します. ただし、場合によっては、これらの3つの固定フィールドでは不十分なことがあります. 

FINGERPRINT拡張が使用される場合、エージェントは別のエージェントに送信するメッセージにFINGERPRINT属性を含めます. セクション14.7では、この属性の配置と値について説明します. 

エージェントは、STUNメッセージであると考えるものを受信すると、他の基本的なチェックに加えて、メッセージにFINGERPRINT属性が含まれていること、および属性に正しい値が含まれていることもチェックします. セクション6.3では、STUNメッセージの処理全体でFINGERPRINTチェックが実行されるタイミングについて説明します. この追加のチェックは、エージェントが他のプロトコルのメッセージを検出するのに役立ちます. そうでなければ、STUNメッセージのように見える可能性があります. 

8.サーバーのDNS検出
このセクションでは、クライアントがDNSを使用してサーバーのIPアドレスとポートを判別できるようにするSTUNのオプションの手順について説明します. STUNの使用法では、この拡張機能を使用するかどうか、いつ使用するかを記述する必要があります. この手順を使用するには、クライアントはSTUN URI [RFC7064]を知っている必要があります. 使用方法では、クライアントがこのURIを取得する方法も説明する必要があります. ソフトウェアにSTUN URIをハードコーディングすることは、ドメイン名が失われたり、法的またはその他の理由で変更する必要がある場合に推奨されません. 

クライアントがバインディングリクエスト/レスポンストランザクションを受け入れるパブリックインターネット上にSTUNサーバーを配置したい場合、STUN URIスキームは「stun」です. TLSまたはDTLSセッションを介してバインディング要求/応答トランザクションを受け入れるSTUNサーバーを見つけたい場合、URIスキームは「stuns」です. 

「stun」および「stuns」URIの構文は、[RFC7064]のセクション3.1で定義されています. STUNの使用法は、追加のURIスキームを定義する場合があります. 

8.1. STUN URIスキームのセマンティクス
「stun」URIの<host>部分にIPアドレスが含まれている場合、このIPアドレスはサーバーに直接接続するために使用されます. IPアドレスを含む「スタン」URIは拒否する必要があります. STUNサーバーを認証して中間者攻撃を防ぐ方法が示されていれば、将来のSTUN拡張または使用法によってこの要件が緩和される可能性があります. 

URIにIPアドレスが含まれていない場合、<host>部分に含まれているドメイン名は、[RFC2782]で指定されているSRV手順を使用してトランスポートアドレスに解決されます. DNS SRVサービス名は、<scheme>部分のコンテンツです. SRVルックアップのプロトコルは、クライアントがSTUNを実行するトランスポートプロトコルです. UDPの場合は「udp」、TCPの場合は「tcp」です. 

RFC 2782の手順に従って、接続するサーバーを決定します. RFC 2782は、SRVレコードのセットがどのようにソートされてから試行されるかの詳細を詳しく説明しています. ただし、RFC 2782には、クライアントが「（プロトコル、アドレス、サービス）への接続を試行する」必要があるとのみ記載されており、障害が発生した場合の詳細については説明されていません. これらの手順に従うと、応答を受信せずにSTUNトランザクションがタイムアウトした場合、クライアントはRFC 2782で定義された順序で次のサーバーへの要求を再試行する必要があります（SHOULD）. このような再試行は要求/応答の送信でのみ可能です応答もタイムアウトも生成しません. 

さらに、ドメイン名のAまたはAAAAリソースレコードをクエリする代わりに、デュアルスタックIPv4 / IPv6クライアントは両方にクエリを実行し、[RFC8305]で指定されているように、受信したすべてのIPアドレスでリクエストを試行する必要があります. 

STUN要求のデフォルトポートは、TCPとUDPの両方で3478です. STUN over TLSおよびSTUN over DTLS要求のデフォルトポートは5349です. サーバーソフトウェアが初期メッセージがDTLSまたはSTUNメッセージのどちらであるかを判別できる場合、サーバーはSTUN over UDPと同じポートでSTUN over DTLSを実行できます. サーバーソフトウェアが初期メッセージがTLSメッセージかSTUNメッセージかを判別できる場合、サーバーはSTUN over TCPと同じポートでSTUN over TLSを実行できます. 

STUNサーバーの管理者は、UDPおよびTCPのSRVレコードでこれらのポートを使用する必要があります（SHOULD）. すべての場合において、DNSのポートは、サーバーがリッスンしているポートを反映する必要があります. 

SRVレコードが見つからない場合、[RFC8305]で説明されているように、クライアントはドメイン名のAレコードとAAAAレコードの両方の検索を実行します. その結果、IPアドレスのリストが生成され、STUNの使用方法とは無関係に、UDPまたはTCPを使用して、デフォルトのポートでそれぞれに同時にアクセスできます. TLSを必要とする用途では、クライアントはデフォルトのSTUN over TLSポートを使用してIPアドレスに接続します. DTLSを必要とする用途では、クライアントはデフォルトのSTUN over DTLSポートを使用してIPアドレスに接続します. 

9.認証およびメッセージ整合性メカニズム 
このセクションでは、クライアントとサーバーが認証とメッセージの整合性を提供するために使用できるSTUNの2つのメカニズムを定義します. これら2つのメカニズムは、Short-Term CredentialメカニズムとLong-Term Credentialメカニズムとして知られています. これらの2つのメカニズムはオプションであり、使用方法ごとに、これらのメカニズムを使用するかどうか、および使用するタイミングを指定する必要があります. その結果、クライアントとサーバーはどちらも、適用される使用法の知識に基づいて、どのメカニズム（存在する場合）に従うかを認識します. たとえば、ICEをサポートする公衆インターネット上のSTUNサーバーは認証を持ちませんが、接続性チェックをサポートするエージェントのSTUNサーバー機能は短期的な認証情報を利用します. これら2つのメカニズムの概要については、セクション2で説明します. 

各メカニズムは、そのメカニズムを使用するために必要な追加処理を指定し、セクション6で指定された処理を拡張します. 追加処理は、3つの異なる場所で発生します. メッセージを形成するとき、基本チェックが実行された直後にメッセージを受信するとき、およびエラー応答の詳細な処理. 

エージェントは、MESSAGE-INTEGRITY-SHA256およびFINGERPRINT属性を除いて、MESSAGE-INTEGRITYに続くすべての属性を無視する必要があることに注意してください. 同様に、FINGERPRINT属性を除いて、MESSAGE-INTEGRITY属性が存在しない場合、エージェントはMESSAGE-INTEGRITY-SHA256属性に続くすべての属性を無視する必要があります. 

9.1. Short-Term Credentialメカニズム
短期的な認証メカニズムでは、STUNトランザクションの前に、クライアントとサーバーが他のプロトコルを使用して、ユーザー名とパスワードの形式で認証情報を交換していると想定しています. この資格は期間限定です. 時間制限は使用法によって定義されます. 例として、ICEの使用法[RFC8445]では、2つのエンドポイントが帯域外シグナリングを使用してユーザー名とパスワードを合意し、このユーザー名とパスワードはメディアセッションの期間中適用されます. 

この信任状は、各要求および多くの応答でメッセージ完全性チェックを形成するために使用されます. 長期的なメカニズムのように、課題と対応はありません. その結果、資格情報の時間制限の性質により、再生は制限されます. 

9.1.1. HMACキー
Short-Term Credentialの場合、ハッシュベースのメッセージ認証コード（HMAC）キーは次のように定義されます. 

                       key = OpaqueString（password）
        
ここで、OpaqueStringプロファイルは[RFC8265]で定義されています. 使用されるエンコーディングはUTF-8 [RFC3629]です. 

9.1.2. リクエストまたはインジケーションの形成
リクエストまたはインジケーションメッセージの場合、エージェントは、両方のエージェントでサポートされているメッセージ整合性アルゴリズムを外部メカニズムから知らない限り、メッセージにUSERNAME、MESSAGE-INTEGRITY-SHA256、およびMESSAGE-INTEGRITY属性を含める必要があります. この場合、USERNAMEに加えて、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256を含める必要があります. MESSAGE-INTEGRITY属性のHMACはセクション14.5で説明されているように計算され、MESSAGE-INTEGRITY-SHA256属性のHMACはセクション14.6で説明されているように計算されます. パスワードが要求または表示に含まれることはありません. 

9.1.3. リクエストまたはインジケーションを受け取る
エージェントがメッセージの基本的な処理を行った後、エージェントは以下にリストされているチェックを指定された順序で実行します. 

oメッセージに1）MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性と2）USERNAME属性が含まれていない場合：

*メッセージが要求の場合、サーバーはエラー応答で要求を拒否する必要があります. この応答では、エラーコード400（Bad Request）を使用する必要があります. 

*メッセージが表示である場合、エージェントは表示を静かに破棄しなければなりません（MUST）. 

o USERNAMEにサーバー内で現在有効なユーザー名の値が含まれていない場合：

*メッセージが要求の場合、サーバーはエラー応答で要求を拒否する必要があります. この応答では、エラーコード401（未認証）を使用する必要があります. 

*メッセージが表示である場合、エージェントは表示を静かに破棄しなければなりません（MUST）. 

o MESSAGE-INTEGRITY-SHA256属性が存在する場合、ユーザー名に関連付けられたパスワードを使用して、セクション14.6で説明されているようにメッセージの整合性の値を計算します. MESSAGE-INTEGRITY-SHA256属性が存在しない場合は、同じパスワードを使用して、14.5項で説明されているようにメッセージ整合性の値を計算します. 結果の値が対応する属性（MESSAGE-INTEGRITY-SHA256またはMESSAGE-INTEGRITY）の内容と一致しない場合：

*メッセージが要求の場合、サーバーはエラー応答で要求を拒否する必要があります. この応答では、エラーコード401（未認証）を使用する必要があります. 

*メッセージが表示である場合、エージェントは表示を静かに破棄しなければなりません（MUST）. 

これらのチェックに合格した場合、エージェントはリクエストまたはインジケーションの処理を続行します. MESSAGE-INTEGRITY-SHA256属性を含む要求に対してサーバーが生成する応答には、要求の認証に使用されるパスワードを使用して計算されたMESSAGE-INTEGRITY-SHA256属性を含める必要があります. MESSAGE-INTEGRITY属性のみを含む要求に対してサーバーが生成する応答には、要求の認証に使用されるパスワードを使用して計算されたMESSAGE-INTEGRITY属性を含める必要があります. つまり、これらの属性の1つだけが応答に現れることができます. 応答にUSERNAME属性を含めてはなりません（MUST NOT）. 

チェックのいずれかが失敗した場合、サーバーはMESSAGE-INTEGRITY-SHA256、MESSAGE-INTEGRITY、またはUSERNAME属性をエラー応答に含めてはなりません（MUST NOT）. これは、これらの失敗の場合、サーバーがMESSAGE-INTEGRITY-SHA256またはMESSAGE-INTEGRITY属性の計算に必要な共有シークレットを決定できないためです. 

9.1.4. 応答を受け取る
クライアントは、応答でMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を探します. 存在し、クライアントがリクエストでMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性のいずれか1つのみを送信した場合（セクション9.1.2の外部表示のため、またはセクション9.1.5で定義されている後続のリクエストのため） 、応答のアルゴリズムは一致する必要があります. それ以外の場合は、応答を破棄する必要があります. 

次に、クライアントは、リクエストで使用したのと同じパスワードを使用して、MESSAGE-INTEGRITY属性のセクション14.5またはMESSAGE-INTEGRITY-SHA256属性のセクション14.6で定義されているように、応答のメッセージ整合性を計算します. 結果の値がMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性の内容とそれぞれ一致する場合、応答は認証されたと見なされます. 値が一致しない場合、またはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方が存在しない場合、処理は、要求が信頼できるトランスポートと信頼できないトランスポートのどちらを介して送信されたかによって異なります. 

リクエストが信頼できないトランスポートを介して送信された場合、あたかもそれが受信されたことがないかのように、レスポンスは破棄されなければなりません（MUST）. つまり、該当する場合、再送信が続行されます. 受信したすべての応答が破棄された場合、トランザクションの終了後にタイムアウトを通知する代わりに、レイヤーは整合性保護の違反を通知する必要があります. 

要求が信頼できるトランスポートを介して送信された場合、応答は破棄されなければならず（MUST）、層はトランザクションをただちに終了し、整合性保護に違反したことを通知しなければなりません（MUST）. 

9.1.5. 後続のリクエストの送信
同じサーバーに後続の要求を送信するクライアントは、MESSAGE-INTEGRITY-SHA256または最初の要求への応答で受信された属性と一致するMESSAGE-INTEGRITY属性のみを送信する必要があります. ここで、「同じサーバー」とは、同じURIまたはSRVルックアップ結果だけでなく、同じIPアドレスとポート番号を意味します. 

9.2. Long-Term Credentialメカニズム
Long-Term Credentialメカニズムは、クライアントとサーバー間で共有されるユーザー名とパスワードの形式のLong-Term Credentialに依存します. 資格情報は、ユーザーに対してプロビジョニングされ、ユーザーがシステムのサブスクライバーでなくなるまで、または変更されるまで有効であると想定されているため、長期間と見なされます. これは基本的に、ユーザーに与えられる従来の「ログイン」ユーザー名とパスワードです. 

これらのユーザー名とパスワードは長期間有効であることが期待されるため、再生防止はダイジェストチャレンジの形式で提供されます. このメカニズムでは、クライアントは最初に要求を送信しますが、資格情報や整合性チェックは提供しません. サーバーはこの要求を拒否し、ユーザーにレルム（ユーザーまたはエージェントがユーザー名とパスワードを選択する際に使用される）とナンスを提供します. nonceは限定された再生保護を提供します. これはCookieであり、サーバーによって選択され、有効期間またはクライアントIDが有効であることを示すようにエンコードされます. サーバーだけがCookieの内部構造を知る必要があります. クライアントは、今度はユーザー名とレルムを含めてリクエストを再試行し、サーバーから提供されたナンスをエコーし​​ます. クライアントには、このドキュメントで定義されているメッセージ整合性属性の1つも含まれており、ノンスを含むリクエスト全体にHMACを提供します. サーバーはナンスを検証し、メッセージの整合性をチェックします. それらが一致する場合、要求は認証されます. nonceが有効でなくなった場合、「古い」と見なされ、サーバーは要求を拒否し、新しいnonceを提供します. 

同じサーバーへの後続のリクエストでは、クライアントは以前に使用したナンス、ユーザー名、レルム、パスワードを再利用します. このようにして、サーバーによってナンスが無効になるまで、後続の要求は拒否されません. その場合、拒否によってクライアントに新しいナンスが提供されます. 

兆候にはチャレンジできないため、長期の資格情報メカニズムを使用して兆候を保護することはできません. インジケーションを利用する使用法では、短期的な認証情報を使用するか、認証とメッセージの整合性を省略する必要があります. 

この仕様をサポートしていることを示すために、サーバーは、NONCE属性値の前に、「obMatJos2」で構成される文字列を、セクションで定義されている24ビットSTUNセキュリティ機能の（4文字）base64 [RFC4648]エンコーディングと連結したものを追加する必要があります.  18.1. 24ビットのセキュリティ機能セットは3バイトとしてエンコードされ、最初のバイトの最上位ビットはビット0、3番目のバイトの最下位ビットはビット23です. セキュリティ機能を使用しない場合は、24ビットすべてをゼロに設定したバイト配列を代わりにエンコードする必要があります. このドキュメントの残りの部分では、「ノンスクッキー」という用語は、NONCE属性値の前に付加される完全な13文字の文字列を指します. 

長期的な認証メカニズムはオフラインの辞書攻撃の影響を受けやすいため、展開では推測が難しいパスワードを使用する必要があります. 資格情報がユーザーによって入力されず、デバイスのプロビジョニング中にクライアントデバイスに配置される場合、パスワードには少なくとも128ビットのランダム性が必要です（SHOULD）. ユーザーが資格情報を入力する場合は、パスワード構造に関する現在のベストプラクティスに従う必要があります. 

9.2.1. 入札攻撃の防止
このドキュメントでは、パスワード保護に使用するアルゴリズムを選択する機能と、匿名のユーザー名を使用する機能を提供する2つの新しいセキュリティ機能を紹介します. これらの機能はどちらも、STUNプロトコルの以前のバージョンとの下位互換性を維持するためにオプションです. 

これらの新機能は、メッセージパスの攻撃者がこれらの機能を削除して、より弱いセキュリティプロパティを強制することができる、ビッドダウン攻撃の対象となります. これらの種類の攻撃が検出されないようにするために、ナンスは追加情報で強化されています. 

「nonce cookie」の値は、選択された特定のSTUNセキュリティ機能ビットに基づいて異なります. このドキュメントで、特定のSTUNセキュリティ機能について説明しているセクションの「ノンスクッキー」を参照すると、「ノンスクッキー」の対応するSTUNセキュリティ機能ビットが1に設定されていることがわかります. 

たとえば、PASSWORD-ALGORITHMSセキュリティ機能（セクション9.2.4で定義）を使用すると、対応する「パスワードアルゴリズム」ビット（セクション18.1で定義）が「nonce cookie」で1に設定されます. 

9.2.2. HMACキー
PASSWORD-ALGORITHM属性で指定されている、別のアルゴリズムを使用しないLong-Term Credentialの場合、キーは16バイトです. 

key = MD5（username "：" OpaqueString（realm） "：" OpaqueString（password）） 
        
MD5は[RFC1321]と[RFC6151]で定義されており、OpaqueStringプロファイルは[RFC8265]で定義されています. 使用されるエンコーディングはUTF-8 [RFC3629]です. 

16バイトのキーは、次の5つのフィールドを連結した結果のMD5ハッシュをとることによって形成されます. （1）USERNAME属性から取得された、引用符と末尾のヌルが削除されたユーザー名（この場合、OpaqueStringはすでに適用された）; （2）単一のコロン; （3）レルム. 引用符と末尾のヌルは削除され、OpaqueStringを使用して処理された後. （4）単一のコロン; （5）パスワード、および追跡するヌルが削除され、OpaqueStringを使用して処理された後. たとえば、ユーザー名が「user」、レルムが「realm」、パスワードが「pass」の場合、16バイトのHMACキーは、文字列「user：realm：」でMD5ハッシュを実行した結果です.  pass '、結果のハッシュは0x8493fbc53ba582fb4c044c456bdc40ebです. 

キーの構造をLong-Term Credentialと共に使用すると、SIP [RFC3261]も利用するシステムでの展開が容易になります. 通常、SIPのダイジェスト認証メカニズムを利用するSIPシステムは、実際にはパスワードをデータベースに保存しません. むしろ、それらは「H（A1）」と呼ばれる値を格納します. これは上記で定義されたキーに等しいです. たとえば、このメカニズムは、[RFC5090]で定義されている認証拡張機能で使用できます. 

PASSWORD-ALGORITHMを使用する場合、使用するキーの長さとアルゴリズムについては、セクション18.5.1で説明します. 

9.2.3. リクエストの作成
クライアントからサーバーへの最初の要求（セクション8のDNS手順が使用されている場合はホスト名で識別され、使用されていない場合はIPアドレスで識別される）は、セクション9.2.3.1のルールに従って処理されます. 前の要求/応答トランザクションが正常に完了した後でクライアントが後続の要求を開始すると、クライアントはセクション9.2.3.2のルールに従います. 401（Unauthenticated）または438（Stale Nonce）エラー応答の結果としてリクエストを形成することは、セクション9.2.5で説明されており、「後続のリクエスト」とは見なされないため、セクション9.2.3.2で説明されているルールを利用しません. これらの各タイプのリクエストには、異なる必須属性があります. 

9.2.3.1. 最初のリクエスト
クライアントがサーバーとの正常な要求/応答トランザクションを完了していない場合は、USERNAME、USERHASH、MESSAGE-INTEGRITY、MESSAGE-INTEGRITY-SHA256、REALM、NONCE、PASSWORD-ALGORITHMS、およびPASSWORD-ALGORITHM属性を省略する必要があります. つまり、最初のリクエストは、認証またはメッセージの整合性が適用されていないかのように送信されます. 

9.2.3.2. 後続のリクエスト
要求/応答トランザクションが完了すると、クライアントはサーバーから領域とノンスを提示され、認証に使用するユーザー名とパスワードを選択します. クライアントは、サーバーとのその後の通信のために、ユーザー名、パスワード、レルム、およびナンスをキャッシュする必要があります. クライアントが後続のリクエストを送信するときは、これらのキャッシュされた値を持つUSERNAMEまたはUSERHASH、REALM、NONCE、およびPASSWORD-ALGORITHM属性のいずれかを含める必要があります. キャッシュされたパスワードを使用してセクション14.5および14.6で説明されているように計算されたMESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性を含める必要があります. 2つの属性のどちらを選択するかは、最初の要求への応答で受け取った属性によって異なります. 

9.2.4. リクエストを受け取る
サーバーはリクエストの基本的な処理を行った後、以下にリストされているチェックを指定された順序で実行します. REALM値をSTUNサーバーのプロバイダーのドメイン名にすることをお勧めします. 

oメッセージにMESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性が含まれていない場合、サーバーはエラーコード401（未認証）のエラー応答を生成する必要があります. この応答には、REALM値を含める必要があります. 応答には、サーバーによって選択されたNONCEが含まれている必要があります. 同じ送信元IPアドレスとポートを持たない限り、サーバーは2つの要求に対して同じNONCEを選択してはなりません（MUST NOT）. サーバーは代替パスワードアルゴリズムをサポートしてもよい（MAY）. その場合、PASSWORD-ALGORITHMS属性に優先順位でそれらをリストできます. サーバーがPASSWORD-ALGORITHMS属性を追加する場合、サーバーはSTUNセキュリティ機能の「パスワードアルゴリズム」ビットを1に設定する必要があります. サーバーは匿名ユーザー名をサポートできます. その場合、サーバーはSTUNセキュリティ機能の「ユーザー名匿名」ビットを1に設定する必要があります.  . 応答にはUSERNAMEを含めないでください. 

注：異なるソースIPアドレスまたはポートにNONCEを再利用することは、[RFC5389]で明示的に禁止されていませんでした. 

oメッセージにMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれているが、USERNAMEまたはUSERHASH、REALM、またはNONCE属性が欠落している場合、サーバーはエラーコード400（Bad Request）のエラー応答を生成する必要があります.  . この応答には、USERNAME、USERHASH、NONCE、またはREALM属性を含めないでください. 応答にMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を含めることはできません. これらを生成するために必要な属性が欠落しているためです. 

o NONCE属性がSTUNセキュリティ機能の「パスワードアルゴリズム」ビットが1に設定された「nonce cookie」で始まる場合、サーバーは指定された順序でこれらのチェックを実行します. 

*リクエストにPASSWORD-ALGORITHMSアルゴリズムもPASSWORD-ALGORITHMアルゴリズムも含まれていない場合、リクエストはPASSWORD-ALGORITHMがMD5であるかのように処理されます. 

*それ以外の場合、（1）PASSWORD-ALGORITHMとPASSWORD-ALGORITHMSの両方が存在しない限り、（2）PASSWORD-ALGORITHMSはこのNONCEを送信した応答で送信された値と一致し、（3）PASSWORD-ALGORITHMはPASSWORDのエントリの1つと一致する-ALGORITHMS、サーバーはエラーコード400（Bad Request）のエラー応答を生成する必要があります. 

o USERNAMEまたはUSERHASH属性の値が無効な場合、サーバーはエラーコード401（非認証）のエラー応答を生成する必要があります. この応答には、REALM値を含める必要があります. 応答には、サーバーによって選択されたNONCEが含まれている必要があります. 応答には、PASSWORD-ALGORITHMS属性を含める必要があります. 応答には、USERNAMEまたはUSERHASH属性を含める必要があります（SHOULD NOT）. 応答には、前のキーを使用して計算するMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれる場合があります. 

o MESSAGE-INTEGRITY-SHA256属性が存在する場合、ユーザー名に関連付けられたパスワードを使用して、セクション14.6で説明されているようにメッセージの整合性の値を計算します. それ以外の場合は、同じパスワードを使用して、セクション14.5で説明されているようにMESSAGE-INTEGRITY属性の値を計算します. 結果の値がMESSAGE-INTEGRITY属性またはMESSAGE-INTEGRITY-SHA256属性の内容と一致しない場合、サーバーはエラー応答で要求を拒否する必要があります. この応答では、エラーコード401（未認証）を使用する必要があります. REALMおよびNONCE属性を含める必要があり、USERNAME、USERHASH、MESSAGE-INTEGRITY、またはMESSAGE-INTEGRITY-SHA256属性を含めないでください. 

o NONCEが有効でなくなった場合、サーバーはエラーコード438（Stale Nonce）のエラー応答を生成する必要があります. この応答には、NONCE、REALM、およびPASSWORD-ALGORITHMS属性を含める必要があり、USERNAMEおよびUSERHASH属性を含めないでください. NONCE属性値は有効でなければなりません. 応答には、以前のNONCEを使用して計算するMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれる場合があります. サーバーは、追加のセキュリティを提供するためにナンスを取り消すことができます. ガイドラインについては、[RFC7616]のセクション5.4を参照してください. 

これらのチェックに合格すると、サーバーはリクエストの処理を続行します. サーバーが生成する応答には、リクエストの認証に使用されたユーザー名とパスワードを使用して計算されたMESSAGE-INTEGRITY-SHA256属性を含める必要があります. ただし、PASSWORD-ALGORITHMがMD5であるようにリクエストが処理された場合を除きます（リクエストにPASSWORD-ALGORITHMSもPASSWORD-ALGORITHM）. その場合、MESSAGE-INTEGRITY-SHA256属性の代わりにMESSAGE-INTEGRITY属性を使用する必要があり、REALM、NONCE、USERNAME、およびUSERHASH属性は含めないでください. 

9.2.5. 応答を受け取る
応答がエラーコード401（認証されていない）または438（失効したナンス）のエラー応答である場合、クライアントはNONCE属性値が「ノンスクッキー」で始まるかどうかをテストする必要があります. その場合、「nonce cookie」でSTUNセキュリティ機能の「パスワードアルゴリズム」ビットが1に設定されているが、PASSWORD-ALGORITHMS属性が存在しない場合、クライアントは新しいトランザクションで要求を再試行してはならない（MUST NOT）. 

応答がエラーコード401（非認証）のエラー応答である場合、クライアントは新しいトランザクションで要求を再試行する必要があります（SHOULD）. このリクエストには、エラー応答からのREALMの適切なユーザー名としてクライアントによって決定されたUSERNAMEまたはUSERHASHが含まれている必要があります. 「nonce cookie」が存在し、STUN Security Featureの「Username anonymity」ビットが1に設定されている場合、USERHASH属性を使用する必要があります. それ以外の場合は、USERNAME属性を使用する必要があります. 要求には、エラー応答からコピーされたREALMが含まれている必要があります. リクエストには、エラーレスポンスからコピーされたNONCEが含まれている必要があります. 応答にPASSWORD-ALGORITHMS属性が含まれている場合、リクエストには同じ内容のPASSWORD-ALGORITHMS属性が含まれている必要があります. 応答にPASSWORD-ALGORITHMS属性が含まれている場合、この属性には、クライアントでサポートされているアルゴリズムが少なくとも1つ含まれている場合、リクエストには、リストでサポートされている最初のアルゴリズムを含むPASSWORD-ALGORITHM属性が含まれている必要があります. 応答にPASSWORD-ALGORITHMS属性が含まれていて、この属性にクライアントがサポートするアルゴリズムが含まれていない場合、クライアントは新しいトランザクションで要求を再試行してはなりません（MUST NOT）. クライアントは、前回の試行からUSERNAME、USERHASH、REALM、またはその関連パスワードを変更していない場合、この再試行を実行してはなりません（MUST NOT）. 次に、クライアントは新しいトランザクションで要求を再試行してはなりません（MUST NOT）. クライアントは、前回の試行からUSERNAME、USERHASH、REALM、またはその関連パスワードを変更していない場合、この再試行を実行してはなりません（MUST NOT）. 次に、クライアントは新しいトランザクションで要求を再試行してはなりません（MUST NOT）. クライアントは、前回の試行からUSERNAME、USERHASH、REALM、またはその関連パスワードを変更していない場合、この再試行を実行してはなりません（MUST NOT）. 

応答がエラーコード438（Stale Nonce）のエラー応答である場合、クライアントは438（Stale Nonce）応答で提供される新しいNONCE属性を使用して要求を再試行する必要があります. この再試行には、USERNAMEまたはUSERHASH、REALM、およびMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性のいずれかも含める必要があります. 

他のすべての応答では、NONCE属性がSTUNセキュリティ機能の「パスワードアルゴリズム」ビットが1に設定された「nonce cookie」で始まるが、PASSWORD-ALGORITHMSが存在しない場合、応答は無視する必要があります. 

応答がエラーコード400（Bad Request）のエラー応答であり、MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性のいずれも含まれていない場合は、応答が受信されなかったかのように破棄する必要があります. つまり、該当する場合、再送信が続行されます. 

注：この場合、400応答はアプリケーションに到達しないため、タイムアウトになります. 

クライアントは、応答でMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を探します（成功または失敗）. 存在する場合、クライアントは、セクション14.5または14.6で定義されているように、要求に使用したのと同じパスワードを使用して、応答に対するメッセージの整合性を計算します. 結果の値がMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性の内容と一致する場合、応答は認証されたと見なされます. 値が一致しない場合、またはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方が存在しない場合、処理は、信頼できるトランスポートまたは信頼できないトランスポートを介して送信される要求に依存します. 

リクエストが信頼できないトランスポートを介して送信された場合、あたかもそれが受信されたことがないかのように、レスポンスは破棄されなければなりません（MUST）. つまり、該当する場合、再送信が続行されます. 受信したすべての応答が破棄された場合、トランザクションの終了後にタイムアウトを通知する代わりに、レイヤーは整合性保護の違反を通知する必要があります. 

要求が信頼できるトランスポートを介して送信された場合、応答は破棄されなければならず（MUST）、層はトランザクションをただちに終了し、整合性保護に違反したことを通知しなければなりません（MUST）. 

応答にPASSWORD-ALGORITHMS属性が含まれている場合、後続のすべての要求はMESSAGE-INTEGRITY-SHA256のみを使用して認証される必要があります. 

10. ALTERNATE-SERVERメカニズム 
このセクションでは、サーバーがクライアントを別のサーバーにリダイレクトできるようにするSTUNのメカニズムについて説明します. この拡張機能はオプションであり、使用法では、この拡張機能を使用するかどうか、およびいつ使用するかを定義する必要があります. ALTERNATE-SERVER属性にはIPアドレスが含まれます. 

この拡張機能を使用するサーバーは、エラーコード300のエラー応答メッセージを含む要求メッセージに返信することにより、クライアントを別のサーバーにリダイレクトします（代替を試行）. サーバーは、エラー応答に少なくとも1つのALTERNATE-SERVER属性を含める必要があります. これには、要求メッセージのソースIPアドレスと同じアドレスファミリのIPアドレスを含める必要があります. サーバーは、必須の属性の後に、要求メッセージのソースIPアドレス以外のアドレスファミリのIPアドレスを含む追加のALTERNATE-SERVER属性を含める必要があります（SHOULD）. エラー応答メッセージは認証される場合があります. ただし、応答の認証が不可能または実用的ではないALTERNATE-SERVERの使用例があります. トランザクションがTLSまたはDTLSを使用する場合、トランザクションがMESSAGE-INTEGRITY-SHA256属性によって認証される場合、サーバーが別の証明書を使用するサーバーにリダイレクトする場合は、その証明書のsubjectAltName内に名前を含むALTERNATE-DOMAIN属性を含める必要があります. MESSAGE-INTEGRITY-SHA256属性に関するこの一連の条件は、トランザクションが認証され、クライアントがこの仕様を実装しているため、ALTERNATE-DOMAIN属性を処理できることを示しています. 

この拡張機能を使用するクライアントは、300（代替の試行）エラーコードを次のように処理します. クライアントは、エラー応答でALTERNATE-SERVER属性を探します. 見つかった場合、クライアントは現在のトランザクションが失敗したと見なし、前の要求で使用されたのと同じトランスポートプロトコルを使用して、属性で指定されたサーバーで要求を再試行します. その要求は、認証された場合、クライアントがリダイレクトを実行したサーバーへの要求で使用したのと同じ資格情報を使用する必要があります. トランスポートプロトコルがTLSまたはDTLSを使用する場合、クライアントはALTERNATE-DOMAIN属性を探します. 属性が見つかった場合、[RFC6125]の推奨事項を使用して証明書を検証するためにドメインを使用する必要があります. 証明書には、タイプDNS-IDまたはCN-ID（最終的にはワイルドカードを使用）の識別子が含まれている必要がありますが、タイプSRV-IDまたはURI-IDは含まれていません. 属性が見つからない場合は、元の要求に使用されたのと同じドメインを使用して証明書を検証する必要があります. クライアントが過去5分以内にこの要求を送信したサーバーにリダイレクトされている場合、リダイレクトを無視し、トランザクションが失敗したと見なす必要があります. これにより、リダイレクトループが発生した場合に、サーバー間で無限にピンポンが発生するのを防ぎます. リダイレクトを無視し、トランザクションが失敗したと見なす必要があります. これにより、リダイレクトループが発生した場合に、サーバー間で無限にピンポンが発生するのを防ぎます. リダイレクトを無視し、トランザクションが失敗したと見なす必要があります. これにより、リダイレクトループが発生した場合に、サーバー間で無限にピンポンが発生するのを防ぎます. 

11. RFC 3489との下位互換性
[RFC5389]のセクション12ですでに説明されている下位互換性に加えて、DTLSは[RFC3489]（「クラシックSTUN」と呼ばれる）と共に使用してはならない（MUST NOT）. DTLSを介したマジックCookie（[RFC5389]のセクション6を参照）を使用しないSTUN要求または指示はすべて無効と見なす必要があります. すべての要求は500（サーバーエラー）エラー応答を生成する必要があり、指示は無視する必要があります. 

12.基本的なサーバーの動作 
このセクションでは、基本的なスタンドアロンSTUNサーバーの動作を定義します. 

歴史的に、「クラシックSTUN」[RFC3489]は、STUNバインディング要求を受信して​​応答することにより、クライアントにサーバーreflexive transport addressを提供していたサーバーの動作のみを定義していました. [RFC5389]はプロトコルを拡張可能なフレームワークとして再定義し、サーバー機能はそのドキュメントで定義されている唯一のSTUNの使用法になりました. このSTUNの使用法は、「基本的なSTUNサーバー」とも呼ばれます. 

STUNサーバーは、Bindingメソッドをサポートする必要があります. 短期または長期の資格情報メカニズムを利用しないでください. これは、リクエストの認証に必要な作業が、単にリクエストを処理するだけの作業ではないためです. 同じ理由で、ALTERNATE-SERVERメカニズムを利用すべきではありません. UDPとTCPをサポートする必要があります. STUN over TCP / TLSまたはSTUN over UDP / DTLSをサポートする場合があります. ただし、DTLSとTLSは、この基本的な操作モードで最小限のセキュリティ上の利点を提供します. バインディングトランザクションの終了後にTCPまたはTLS-over-TCP接続が閉じられるため、キープアライブメカニズムは必要ありません. FINGERPRINTメカニズムを利用する場合がありますが、必須ではありません. スタンドアロンサーバーはSTUNのみを実行するため、FINGERPRINTは何のメリットもありません. これを要求すると、RFC 3489との互換性が失われます. このような互換性は、スタンドアロンサーバーでは望ましいものです. スタンドアロンSTUNサーバーは、セクション11で説明されているように、[RFC3489]を使用するクライアントとの下位互換性をサポートする必要があります（SHOULD）. 

STUNサーバーの管理者は、セクション8で説明されているように、これらのサーバーのDNSエントリを提供することをお勧めします. AとAAAAの両方のリソースレコードが返された場合、クライアントはIPv4アドレスとIPv6アドレスにSTUNバインディング要求を同時に送信できます（[ RFC8305]）、Bindingリクエストはべき等であるため. 返されるMAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS属性は、使用されるサーバーアドレスのアドレスファミリーと必ずしも一致しないことに注意してください. 

基本的なSTUNサーバーは、それ自体ではNATトラバーサルのソリューションではありません. ただし、STUN Usagesを通じてソリューションの一部として利用できます. これについては、セクション13で詳しく説明します. 

13. STUNの使用法 
STUN自体は、NATトラバーサル問題の解決策ではありません. むしろ、STUNは、より大きなソリューション内で使用できるツールを定義しています. 「STUNの使用法」という用語は、STUNをコンポーネントとして使用するすべてのソリューションで使用されます. 

STUNの使用法は、STUNが実際にどのように使用されるかを定義します. 要求を送信するタイミング、応答をどう処理するか、およびここで定義する（またはSTUNの拡張で）オプションのプロシージャを使用するかどうかです. 使用法は次のことも定義します. 

o使用されるSTUNメソッド. 

o使用されるトランスポート. DTLS-over-UDPが使用されている場合、[RFC6347]のセクション4.2.1で説明されているサービス拒否対策の実装は必須です. 

o使用されている認証およびメッセージ整合性メカニズム. 

o [RFC4107]で説明されている、整合性メカニズムの手動および自動キー導出に関する考慮事項. 

o STUNメッセージを他のメッセージと区別するために使用されるメカニズム. STUNがTCPまたはTLS-over-TCPで実行される場合、フレーミングメカニズムが必要になる場合があります. 

o STUNクライアントがSTUNサーバーのIPアドレスとポートを決定する方法. 

o IPv4とIPv6アドレスの同時使用（Happy Eyeballs [RFC8305]）は、STUNサーバーの両方のアドレスファミリが見つかった場合に、べき等でないトランザクションでどのように機能するか. 

o RFC 3489への後方互換性が必要かどうか. 

oここで定義されているオプションの属性（FINGERPRINTやALTERNATE-SERVERなど）または他の拡張機能で必要なものは何ですか. 

o MESSAGE-INTEGRITY-SHA256切り捨てが許可されている場合、および切り捨てに許可されている制限. 

o STUNがTCPまたはTLS-over-TCPで実行されている場合のキープアライブメカニズム. 

oサーバーでエニーキャストアドレスを使用できる場合、1）TCPまたはTLS-over-TCPまたは2）認証が使用されます. 

さらに、STUNの使用法では、その使用法でSTUNを使用することのセキュリティへの影響を考慮する必要があります. STUNに対するいくつかの攻撃が知られており（このドキュメントの「セキュリティに関する考慮事項」のセクションを参照）、これらの攻撃をどのように阻止または軽減できるかを考慮する必要があります. 

最後に、使用法は、STUNの使用法がNATトラバーサルへの片側自己アドレス修正アプローチの例であるかどうかを検討し、そうである場合は、RFC 3424 [RFC3424]で提起された質問に対処する必要があります. 

14. STUN属性
STUNヘッダーの後は0個以上の属性です. 各属性は、16ビットタイプ、16ビット長、および値で、TLVエンコードされている必要があります. 各STUN属性は32ビット境界で終了する必要があります. 上記のように、属性のすべてのフィールドは、最上位ビットが最初に送信されます. 

      0 1 2 3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
     | タイプ| 長さ|
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
     | 値（変数）....
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- +-+-+-+-+-+-+-+
        
図4：STUN属性のフォーマット

長さフィールドの値には、バイト単位で測定された、パディング前の属性の値部分の長さが含まれている必要があります. STUNは属性を32ビット境界で整列するため、内容が4バイトの倍数ではない属性は、値に4バイトの倍数が含まれるように、1、2、または3バイトのパディングで埋め込まれます. パディングビットは送信時にゼロに設定する必要があり、受信者は無視する必要があります. 

属性タイプは、STUNメッセージに複数回表示される場合があります. 特に明記されていない限り、出現の順序は重要です. 最初の発生のみがレシーバーによって処理される必要があり、重複はレシーバーによって無視される場合があります. 

この仕様の将来の改訂で必要に応じて新しい属性を追加できるようにするために、属性スペースは2つの範囲に分割されています. タイプ値が0x0000から0x7FFFの間の属性は、理解が必要な属性です. つまり、STUNエージェントは、属性を理解しないとメッセージを正常に処理できません. タイプ値が0x8000と0xFFFFの間の属性は、内包オプション属性です. つまり、これらの属性は、STUNエージェントが理解できない場合、無視することができます. 

STUN属性タイプのセットは、IANAによって維持されます. この仕様で定義されている初期セットは、セクション18.3にあります. 

このセクションの残りの部分では、この仕様で定義されているさまざまな属性の形式について説明します. 

14.1. マップされたアドレス
MAPPED-ADDRESS属性は、クライアントのreflexive transport addressを示します. これは、8ビットのアドレスファミリと16ビットのポートで構成され、その後にIPアドレスを表す固定長の値が続きます. アドレスファミリがIPv4の場合、アドレスは32ビットである必要があります. アドレスファミリがIPv6の場合、アドレスは128ビットである必要があります. すべてのフィールドはネットワークバイトオーダーである必要があります. 

MAPPED-ADDRESS属性の形式は次のとおりです. 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0 0 0 0 0 0 0|    Family     |           Port                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                 Address (32 bits or 128 bits)                 |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図5：MAPPED-ADDRESS属性のフォーマット

アドレスファミリは次の値をとることができます. 

0x01：IPv4 0x02：IPv6

MAPPED-ADDRESSの最初の8ビットは0に設定する必要があり、受信者は無視する必要があります. これらのビットは、自然な32ビット境界にパラメーターを揃えるために存在します. 

この属性は、[RFC3489]クライアントとの下位互換性を実現するためにサーバーでのみ使用されます. 

14.2. XOR-MAPPED-ADDRESS
XOR-MAPPED-ADDRESS属性は、反射トランスポートアドレスがXOR関数によって難読化されることを除いて、MAPPED-ADDRESS属性と同じです. 

XOR-MAPPED-ADDRESSの形式は次のとおりです. 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |0 0 0 0 0 0 0 0|    Family     |         X-Port                |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                X-Address (Variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図6：XOR-MAPPED-ADDRESS属性のフォーマット

FamilyフィールドはIPアドレスファミリーを表し、MAPPED-ADDRESSのFamilyフィールドと同じようにエンコードされます. 

X-Portは、マッピングされたポートをマジッククッキーの最上位16ビットでXORすることによって計算されます. IPアドレスファミリがIPv4の場合、X-Addressは、マップされたIPアドレスをマジッククッキーでXORすることによって計算されます. IPアドレスファミリがIPv6の場合、X-Addressは、マッピングされたIPアドレスとマジッククッキーおよび96ビットトランザクションIDの連結をXORすることによって計算されます. すべての場合において、XOR操作はネットワークバイトオーダー（つまり、メッセージ内でエンコードされる順序）で入力を処理します. 

属性値の最初の8ビットをエンコードして処理する規則、属性の複数のオカレンスを処理する規則、およびアドレスファミリを処理する規則は、MAPPED-ADDRESSと同じです. 

注：XOR-MAPPED-ADDRESSとMAPPED-ADDRESSは、トランスポートアドレスのエンコーディングのみが異なります. 前者は、魔法のcookieでXORすることによってトランスポートアドレスをエンコードします. 後者はバイナリで直接エンコードします. RFC 3489は当初、MAPPED-ADDRESSのみを指定していました. ただし、一部のNATは、STUNのMAPPED-ADDRESS属性など、NATのパブリックIPアドレスを含む32ビットのバイナリペイロードを書き換えて、一般的なアプリケーションレイヤーゲートウェイ（ALG）機能を提供しようとする意味のある見当違いの試みで、展開の経験から判明しました. このような動作は、STUNの操作を妨害し、STUNのメッセージ整合性チェックの失敗の原因にもなります. 

14.3. ユーザー名
USERNAME属性は、メッセージの整合性のために使用されます. メッセージの整合性チェックで使用されるユーザー名とパスワードの組み合わせを識別します. 

USERNAMEの値は、認証ユーザー名を含む可変長の値です. 509バイト未満のUTF-8エンコード[RFC3629]シーケンスが含まれている必要があり、OpaqueStringプロファイル[RFC8265]を使用して処理されている必要があります. 準拠した実装は、763オクテット以下のUTF-8エンコードされたシーケンスを解析できなければなりません[RFC5389]と互換性があります. 

注：[RFC5389]は[RFC2279]のUTF-8の定義を誤って参照していました. [RFC2279]エンコードされる文字ごとに最大6オクテットを想定. [RFC2279]は[RFC3629]に置き換えられました. これにより、Unicode 2.0およびISO / IEC 10646で行われた変更と一致して、エンコードされた文字ごとに4オクテットのみが許可されます. 

注：この仕様では、デプロイされたパスワードストアとの互換性を向上させるために、ユーザー名文字列の処理にUsernameCasePreservedプロファイルの代わりにOpaqueStringプロファイルを使用します. HTTPおよびSIPダイジェスト認証に使用される多くのパスワードデータベースは、プレーンテキストのパスワードではなく、username：realm：passwordのMD5ハッシュを格納します. [RFC3489]では、STUN認証はこれらの既存のデータベースと可能な限り互換性があるように設計されており、SIPやHTTPのように、スペース以外のASCII制御文字を禁止する以外はユーザー名とパスワードの前処理を実行しませんでした. STUN仕様の次の改訂版[RFC5389]では、SASLprep [RFC4013] stringprep [RFC3454]プロファイルを使用して、ユーザー名とパスワードを前処理しました. SASLprepは、Unicode正規化形式KC（互換性分解、後に標準構成が続きます）[UAX15]. さまざまな制御、スペース、非テキスト、非推奨、または不適切なコードポイントを禁止します. PRECISフレームワーク[RFC8264]はstringprepを廃止しました. PRECISによるユーザー名とパスワードの処理[RFC8265]は、Unicode正規化形式C（正規分解とそれに続く正規合成）を使用します. HTTPダイジェストで異なるユーザー名文字列がOpaqueStringで処理された単一のSTUNユーザー名にマッピングされる特定のケースがありますが、これらのケースは非常にありそうになく、検出および修正が簡単です. UsernameCasePreservedプロファイルを使用すると、HTTPダイジェストでの有効なユーザー名が処理済みのフォーム（特に、双方向テキストと互換性フォームを含むユーザー名）と一致しない可能性が高くなります. 

14.4. ユーザーハッシュ
ユーザー名の匿名性がサポートされている場合、USERHASH属性はUSERNAME属性の代わりに使用されます. 

USERHASHの値は32バイトの固定長です. ユーザー名はOpaqueStringプロファイル[RFC8265]を使用して処理されている必要があり、レルムはハッシュの前にOpaqueStringプロファイル[RFC8265]を使用して処理されている必要があります. 

以下は、ユーザー名をハッシュするためにクライアントが実行する操作です. 

   userhash = SHA-256（OpaqueString（username） "：" OpaqueString（realm））
        
14.5 メッセージの整合性
MESSAGE-INTEGRITY属性には、STUNメッセージのHMAC-SHA1 [RFC2104]が含まれています. MESSAGE-INTEGRITY属性は、どのSTUNメッセージタイプにも存在できます. SHA-1ハッシュを使用するため、HMACは20バイトになります. 

HMACのキーは、使用されている資格情報メカニズムによって異なります. セクション9.1.1は短期的な資格メカニズムのキーを定義し、セクション9.2.2は長期的な資格メカニズムのキーを定義します. 他の資格メカニズムは、HMACに使用されるキーを定義しなければなりません（MUST）. 

HMACへの入力として使用されるテキストは、MESSAGE-INTEGRITY属性の前の属性までのSTUNメッセージです. STUNメッセージヘッダーの長さフィールドは、MESSAGE-INTEGRITY属性の末尾を指すように調整されます. MESSAGE-INTEGRITY属性の値は、ダミー値に設定されます. 

計算が実行されると、MESSAGE-INTEGRITY属性の値が入力され、STUNヘッダーの長さの値が正しい値（メッセージ全体の長さ）に設定されます. 同様に、MESSAGE-INTEGRITYを検証するときは、STUNメッセージのHMACを計算する前に、MESSAGE-INTEGRITY属性の最後を指すように、STUNヘッダーのLengthフィールドを調整して、MESSAGE-の前の属性まで含める必要があります.  INTEGRITY属性. このような調整は、FINGERPRINTやMESSAGE-INTEGRITY-SHA256などの属性がMESSAGE-INTEGRITYの後にある場合に必要です. このような計算の例については、[RFC5769]も参照してください. 

14.6 MESSAGE-INTEGRITY-SHA256
MESSAGE-INTEGRITY-SHA256属性には、STUNメッセージのHMAC-SHA256 [RFC2104]が含まれています. MESSAGE-INTEGRITY-SHA256属性は、どのSTUNメッセージタイプにも存在できます. MESSAGE-INTEGRITY-SHA256属性には、STUNメッセージのHMAC-SHA-256 [RFC2104]の最初の部分が含まれています. 値は最大32バイトですが、少なくとも16バイトである必要があり、4バイトの倍数である必要があります. STUNの使用法で切り捨てが許可されていることが明示的に指定されていない限り、値は完全な32バイトでなければなりません. STUNの使用法では、16バイトを超える最小長を指定する場合があります. 

HMACのキーは、使用されている資格情報メカニズムによって異なります. セクション9.1.1は短期的な資格メカニズムのキーを定義し、セクション9.2.2は長期的な資格メカニズムのキーを定義します. 他のクレデンシャルメカニズムは、HMACに使用されるキーを定義する必要があります. 

HMACへの入力として使用されるテキストは、MESSAGE-INTEGRITY-SHA256属性の前の属性までのSTUNメッセージです. STUNメッセージヘッダーの長さフィールドは、MESSAGE-INTEGRITY-SHA256属性の末尾を指すように調整されます. MESSAGE-INTEGRITY-SHA256属性の値は、ダミー値に設定されます. 

計算が実行されると、MESSAGE-INTEGRITY-SHA256属性の値が入力され、STUNヘッダーの長さの値が正しい値（メッセージ全体の長さ）に設定されます. 同様に、MESSAGE-INTEGRITY-SHA256を検証する場合、STUNメッセージのHMACを計算する前に、属性を含めて、MESSAGE-INTEGRITY-SHA256属性の末尾を指すようにSTUNヘッダーの長さフィールドを調整する必要があります.  MESSAGE-INTEGRITY-SHA256属性の前. このような調整は、FINGERPRINTなどの属性がMESSAGE-INTEGRITY-SHA256の後にある場合に必要です. そのような計算の例については、付録B.1も参照してください. 

14.7. 指紋
FINGERPRINT属性は、すべてのSTUNメッセージに存在する場合があります. 

属性の値は、32ビット値0x5354554eでXORされたFINGERPRINT属性自体（を除く）までのSTUNメッセージのCRC-32として計算されます. （XOR操作は、アプリケーションプロトコルによって生成されたCRC-32を含むパケットでFINGERPRINTテストが誤検知を報告しないことを保証します. ）32ビットCRCは、ITU V.42 [ITU.V42.2002で定義されたものです.  ]、それ

x ^ 32 + x ^ 26 + x ^ 23 + x ^ 22 + x ^ 16 + x ^ 12 + x ^ 11 + x ^ 10 + x ^ 8 + x ^ 7 + x ^ 5 + xの生成多項式があります^ 4 + x ^ 2 + x + 1. [RFC1952]のセクション8にあるCRC-32のサンプルコードを参照してください. 

存在する場合、FINGERPRINT属性はメッセージの最後の属性でなければならず、MESSAGE-INTEGRITYおよびMESSAGE-INTEGRITY-SHA256の後に表示されます. 

FINGERPRINT属性は、STUNパケットを他のプロトコルのパケットから区別するのに役立ちます. セクション7を参照してください. 

MESSAGE-INTEGRITYおよびMESSAGE-INTEGRITY-SHA256と同様に、FINGERPRINT属性で使用されるCRCは、STUNメッセージヘッダーのLengthフィールドをカバーします. したがって、CRCを計算する前に、この値が正しく、メッセージ長の一部としてCRC属性が含まれている必要があります. メッセージでFINGERPRINT属性を使用する場合、属性は最初にダミー値とともにメッセージに配置されます. 次に、CRCが計算され、属性の値が更新されます. MESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性も存在する場合、CRCがMESSAGE-INTEGRITYおよびMESSAGE-の値に対して実行されるため、CRCが計算される前に、正しいメッセージ完全性値とともに存在する必要があります.  INTEGRITY-SHA256属性も同様です. 

14.8. エラーコード
ERROR-CODE属性は、エラー応答メッセージで使用されます. 300から699の範囲の数値エラーコード値と、UTF-8 [RFC3629]でエンコードされたテキストの理由フレーズが含まれます. また、SIP [RFC3261]およびHTTP [RFC7231]とのコード割り当ておよびセマンティクスも一貫しています. 理由句は診断を目的としており、エラーコードに適したものであれば何でもかまいません. 定義されたエラーコードの推奨される理由フレーズは、エラーコードのIANAレジストリに含まれています. 理由句は、128文字未満のUTF-8エンコード[RFC3629]シーケンスである必要があります（エンコード時に509バイト、デコード時に763バイトになる場合があります）. 
      
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |           Reserved, should be 0         |Class|     Number    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Reason Phrase (variable)                                ..
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図7：ERROR-CODE属性のフォーマット

図7に示すように、処理を容易にするために、エラーコードのクラス（100桁）は、コードの他の部分とは別にエンコードされます. 

予約済みビットは0である必要があり、32ビット境界でのアライメント用です. 受信機はこれらのビットを無視しなければなりません. クラスは、エラーコードの数百桁を表します. 値は3から6の間である必要があります. 数値は、100を法とするエラーコードのバイナリエンコーディングを表し、その値は0から99の間でなければなりません. 

以下のエラーコードとその推奨される理由フレーズが定義されています. 

300代替試行：クライアントは、このリクエストについて代替サーバーに接続する必要があります. このエラー応答は、リクエストにUSERNAMEまたはUSERHASH属性と有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性が含まれている場合にのみ送信する必要があります. それ以外の場合は送信しないでください. エラーコード400（Bad Request）が提案されます. このエラー応答はMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性で保護する必要があり、受信者は代替サーバーにリダイレクトする前に、この応答のMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256を検証する必要があります. 

注：300応答のメッセージ整合性の生成と検証に失敗すると、パス上の攻撃者が300応答を改ざんできるため、後続のSTUNメッセージが被害者に送信されます. 

400 Bad Request：リクエストは不正な形式でした. クライアントは、前の試行からの変更なしに要求を再試行してはなりません（SHOULD NOT）. サーバーはこのエラーに対して有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256を生成できない場合があるため、クライアントはこの応答で有効なMESSAGE-INTEGRITYまたはMESSAGE-INTEGRITY-SHA256属性を期待してはなりません. 

401 Unauthenticated：要求には、続行するための正しい資格情報が含まれていませんでした. クライアントは適切な資格情報を使用して要求を再試行する必要があります. 

420不明な属性：サーバーは、理解できない必要な属性を含むSTUNパケットを受信しました. サーバーは、この不明な属性をエラー応答のUNKNOWN-ATTRIBUTE属性に入れなければなりません（MUST）. 

438 Stale Nonce：クライアントが使用したNONCEは無効になりました. クライアントは、応答で提供されたNONCEを使用して再試行する必要があります. 

500サーバーエラー：サーバーで一時的なエラーが発生しました. クライアントは再試行する必要があります. 

14.9. レルム
REALM属性は、要求と応答に存在する場合があります. [RFC3261]で説明されている "realm-value"の文法を満たすテキストが含まれていますが、二重引用符とその周囲の空白は含まれていません. つまり、引用符で囲まれていないレルム値です（したがって、qdtextまたは引用符で囲まれたペアのシーケンスです）. これは、128文字未満のUTF-8エンコード[RFC3629]シーケンス（エンコード時に509バイト、デコード時に763バイト）でなければならず、OpaqueStringプロファイルを使用して処理されている必要があります[ RFC8265]. 

リクエストにREALM属性が存在する場合は、認証に長期間の認証情報が使用されていることを示しています. 特定のエラー応答の存在は、サーバーがクライアントに認証のためにそのレルムのLong-Term Credentialを使用することを望んでいることを示します. 

14.10. ノンス
NONCE属性は、要求と応答に存在する場合があります. [RFC3261]で定義されているqdtextまたはquoted-pairのシーケンスが含まれています. これは、NONCE属性には実際の前後の引用文字が含まれないことを意味することに注意してください. NONCE属性は128文字未満にする必要があります（エンコードする場合は509バイト、デコードする場合は763バイト）. サーバーでのナンス値の選択に関するガイダンスについては、[RFC7616]のセクション5.4を参照してください. 

14.11. パスワードアルゴリズム
PASSWORD-ALGORITHMS属性は、要求と応答に存在する場合があります. これには、サーバーがLong-Term Passwordを導出するために使用できるアルゴリズムのリストが含まれています. 

既知のアルゴリズムのセットは、IANAによって維持されています. この仕様で定義されている初期セットは、セクション18.5にあります. 

この属性には、アルゴリズム番号と可変長パラメーターのリストが含まれています. アルゴリズム番号は、セクション18.5で定義されている16ビット値です. パラメーターは、16ビット値としてのパラメーターの長さ（パディングの前）で始まり、その後に各アルゴリズムに固有のパラメーターが続きます. パラメータは、属性と同じ方法で32ビット境界まで埋め込まれます. 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Algorithm 1           | Algorithm 1 Parameters Length |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm 1 Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Algorithm 2           | Algorithm 2 Parameters Length |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm 2 Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                             ...
        
図8：PASSWORD-ALGORITHMS属性のフォーマット

14.12. パスワードアルゴリズム
PASSWORD-ALGORITHM属性は、要求にのみ存在します. これには、サーバーがLong-Term Passwordから鍵を導出するために使用する必要があるアルゴリズムが含まれています. 

既知のアルゴリズムのセットは、IANAによって維持されています. この仕様で定義されている初期セットは、セクション18.5にあります. 

この属性には、アルゴリズム番号と可変長パラメーターが含まれています. アルゴリズム番号は、セクション18.5で定義されている16ビット値です. パラメーターは、16ビット値としてのパラメーターの長さ（パディングの前）で始まり、その後にアルゴリズムに固有のパラメーターが続きます. パラメータは、属性と同じ方法で32ビット境界まで埋め込まれます. 同様に、パディングビットは送信時にゼロに設定されなければならず（MUST）、レシーバーによって無視されなければなりません（MUST）. 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Algorithm           |  Algorithm Parameters Length   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Algorithm Parameters (variable)
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図9：PASSWORD-ALGORITHM属性のフォーマット

14.13. 不明な属性
UNKNOWN-ATTRIBUTES属性は、ERROR-CODE属性の応答コードが420（不明な属性）の場合のエラー応答にのみ存在します. 

この属性には、16ビット値のリストが含まれています. 各値は、サーバーで認識されなかった属性タイプを表します. 

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Attribute 1 Type         |       Attribute 2 Type        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Attribute 3 Type         |       Attribute 4 Type    ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        
図10：UNKNOWN-ATTRIBUTES属性のフォーマット

注：[RFC3489]では、最後の属性を複製することにより、このフィールドは32に埋め込まれました. このバージョンの仕様では、属性の通常のパディングルールが代わりに使用されます. 

14.14. ソフトウェア
SOFTWARE属性には、メッセージを送信するエージェントが使用しているソフトウェアのテキストによる説明が含まれています. クライアントとサーバーによって使用されます. その値には、製造元とバージョン番号を含める必要があります（SHOULD）. この属性はプロトコルの動作に影響を与えず、診断とデバッグの目的でのみツールとして機能します. SOFTWAREの値は可変長です. これは、128文字未満のUTF-8エンコード[RFC3629]シーケンスである必要があります（エンコード時に509、デコード時に763バイトにすることができます）. 

14.15. 代替サーバー
代替サーバーは、STUNクライアントが試行する必要がある別のSTUNサーバーを識別する代替トランスポートアドレスを表します. 

これは、MAPPED-ADDRESSと同じ方法でエンコードされているため、単一のサーバーをIPアドレスで参照します. 

14.16. 代替ドメイン
代替ドメインは、トランスポートプロトコルがTLSまたはDTLSを使用するときに、ALTERNATE-SERVER属性のIPアドレスを確認するために使用されるドメイン名を表します. 

ALTERNATE-DOMAINの値は可変長です. 255文字以下の有効なDNS名[RFC1123]（Aラベル[RFC5890]を含む）でなければなりません. 

15.運用上の考慮事項
STUNはエニーキャストアドレスで使用できますが、認証が使用されないUDPおよびSTUN使用法でのみ使用できます. 

16.セキュリティに関する考慮事項 
TLSまたはDTLSを使用したSTUN Usageの実装と展開は、[BCP195]の推奨事項に従う必要があります. 

長期資格メカニズム（セクション9.2）を使用したSTUN Usageの実装と展開は、[RFC7616]のセクション5の推奨事項に従う必要があります. 

16.1. プロトコルに対する攻撃
16.1.1. 外部攻撃
攻撃者は、STUN操作に失敗を引き起こすために、送信中にSTUNメッセージを変更しようとする可能性があります. これらの攻撃は、短期または長期の資格情報を使用して、メッセージ整合性メカニズムを通じて要求と応答の両方に対して検出されます. もちろん、検出されると、操作されたパケットはドロップされ、STUNトランザクションが事実上失敗します. この攻撃は、パス上の攻撃者によってのみ可能です. 

送信中のSTUNメッセージを監視できるが変更はできない攻撃者（たとえば、Wi-Fiなどの共有アクセスメディアに存在する攻撃者）は、STUNリクエストを確認し、すぐにSTUN応答（通常はエラー）を送信できます.  STUN処理を中断するための応答. この攻撃は、MESSAGE-INTEGRITYを利用するメッセージに対しても防止されます. ただし、一部のエラー応答、特に認証に関連するものは、MESSAGE-INTEGRITYでは保護できません. STUN自体がセキュアなトランスポートプロトコル（TLSなど）で実行される場合、これらの攻撃は完全に軽減されます. 

STUNの使用方法によっては、これらの攻撃の影響が最小限になる可能性があるため、メッセージの整合性を緩和する必要はありません. たとえば、基本的なSTUNサーバーにSTUNを使用してICEで使用するサーバー再帰候補を検出する場合、これらの攻撃は接続性チェックフェーズ中に検出されるため、認証とメッセージの整合性は必要ありません. ただし、接続性のチェック自体は、ICE全体が適切に動作するための保護を必要とします. セクション13で説明したように、STUNの使用法では、認証とメッセージの整合性が必要な場合について説明しています. 

STUNは認証と完全性保護のために共有シークレットのHMACを使用するため、オフライン辞書攻撃の影響を受けます. 認証を利用するときは、オフライン辞書攻撃の影響を受けにくい強力なパスワードを使用する必要があります. TLSまたはDTLSを使用してチャネル自体を保護すると、これらの攻撃が緩和されます. 

STUNはMESSAGE-INTEGRITYとMESSAGE-INTEGRITY-SHA256の両方をサポートします. これにより、STUNはパス上の攻撃者によるビッドダウン攻撃の対象になります. 攻撃者はMESSAGE-INTEGRITY-SHA256属性を取り除き、MESSAGE-INTEGRITY属性のみを残して、潜在的な脆弱性を悪用する可能性があります. TLSまたはDTLSを使用してチャネル自体を保護すると、これらの攻撃が緩和されます. STUNの将来のバージョンでは、MESSAGE-INTEGRITYのサポートをタイムリーに削除する必要があります. 

注：パスワードのハッシュにSHA-256を使用することは、ハッシュを計算するための比較的遅い最小時間を提供することにより、徹底的なパスワード検索の速度を低下させることを目的とした最新の標準を満たしていません. Argon2 [Argon2]などのより優れたアルゴリズムが利用可能ですが、[RFC7616]との整合性のためにSHA-256が選択されました. 

16.1.2. 内部攻撃
不正なクライアントは、サーバーに大量のSTUN要求を送信することにより、サーバーに対してDoS攻撃を仕掛けようとする可能性があります. 幸いにも、STUNリクエストはサーバーによってステートレスに処理できるため、このような攻撃を効果的に開始するのは困難です. 

不正なクライアントはSTUNサーバーをリフレクターとして使用し、偽のソースIPアドレスとポートを使用してリクエストを送信する可能性があります. このような場合、応答はそのソースIPとポートに配信されます. STUNの応答は通常要求よりも大きいため、この攻撃ではパケット数の増幅はありません（STUNサーバーはクライアントが送信したパケットごとに1つのパケットを送信します）. ただし、データ量はわずかに増加します. この攻撃は、入力ソースアドレスフィルタリングによって軽減されます. 

SOFTWARE属性を通じてエージェントの特定のソフトウェアバージョンを明らかにすると、セキュリティホールを含むことがわかっているソフトウェアに対する攻撃に対して、エージェントがより脆弱になる可能性があります. 実装者は、ソフトウェア属性の使用を構成可能なオプションにする必要があります（SHOULD）. 

16.1.3. 入札攻撃
このドキュメントは、[RFC5389]で使用されていたアルゴリズムであるMD5との互換性を確保しながら、長期的な認証メカニズムを使用する場合に、サーバー側に保存されたパスワードの機密性を保護するために異なるアルゴリズムを選択する可能性を追加します. この選択は、PASSWORD-ALGORITHMS属性でサポートされているアルゴリズムのリストをサーバーにクライアントに送信させ、選択されたアルゴリズムを含むPASSWORD-ALGORITHM属性をクライアントに送り返すことによって機能します. 

PASSWORD-ALGORITHMS属性は認証されていない応答で送信される必要があるため、MD5の最終的な脆弱性を悪用しようとするパス上の攻撃者は、PASSWORD-ALGORITHMS属性を保護されていない応答から削除するだけで、サーバーはその後、クライアントは、[RFC5389]で定義されたこのプロトコルのバージョンを実装していました. 

この攻撃や他の同様のビッドダウン攻撃から保護するために、ナンスは、使用されているセキュリティ機能を示す一連のセキュリティビットで強化されています. パスワードアルゴリズムを選択した場合、一致するビットは、PASSWORD-ALGORITHMS属性を含む同じ応答でサーバーから返されるnonceに設定されます. 後続の認証済みトランザクションで使用されるナンスは、サーバーによって最初に送信されたものと同一であることが検証されるため、パス上の攻撃者が変更することはできません. さらに、クライアントは、次の認証済みトランザクションで受信したPASSWORD-ALGORITHMS属性をそのサーバーにコピーすることを要求されます. 

クライアントが次の認証済みトランザクションでそれをサーバーに送り返すことができないため、PASSWORD-ALGORITHMSを削除するオンパス攻撃が検出されます. セキュリティビットは設定されているが、一致する属性がないため、クライアントはその攻撃を検出します. これでセッションが終了します. このプロトコルの古いバージョンを使用しているクライアントはPASSWORD-ALGORITHMSを送り返さず、とにかくMD5しか使用できないため、攻撃は重要ではありません. 

パス上の攻撃では、PASSWORD-ALGORITHMS属性とともにセキュリティビットも削除しようとする場合がありますが、サーバーは、次の認証済みトランザクションに無効なナンスが含まれていることを検出します. 

PASSWORD-ALGORITHMS属性から一部のアルゴリズムを削除するオンパス攻撃は、サーバーが後続の認証済みトランザクションで検証するときに元の属性とは異なるため、同じように無効になります. 

このドキュメントで紹介する入札停止保護メカニズムは、サーバーが401（認証されていない）応答の後に2番目の要求を受信するまで攻撃を検出できないため、本質的に制限されます. 

[RFC7616]との互換性のために、パスワードハッシュの新しいデフォルトとしてSHA-256が選択されましたが、SHA-256（MD5など）は比較的高速なアルゴリズムであるため、ブルートフォース攻撃を阻止することはほとんどありません. 具体的には、これは、ユーザーのパスワードが弱い場合、単一の交換をキャプチャする攻撃者がブルートフォース攻撃を使用してユーザーのパスワードを取得し、同じパスワードがあったサーバーや他のサーバーにユーザーを偽装する可能性があることを意味します中古. このような攻撃者は、ブルートフォース攻撃なしでユーザーをサーバーに偽装できることに注意してください. 

Argon2 [Argon2]のようなより強力な（つまり、より遅い）アルゴリズムは、これらの両方の場合に役立ちます. ただし、最初のケースでは、このユーザーのデータベースエントリが更新されて、より強力なメカニズムのみが使用されるようになった場合にのみ役立ちます. 

このプロトコルのビッドダウン防御は、攻撃者がクライアントとサーバーが共同でサポートするよりも弱いアルゴリズムを使用してハンドシェイクを完了するように強制することを防ぎますが、最も弱い共同アルゴリズムが十分に強力で、ブルートフォース攻撃によって侵害されない場合に限られます. ただし、これはそれらのアルゴリズムに対する多くの攻撃を防御しません. 具体的には、パス上の攻撃者は、パスワードハッシュのためにArgon2 [Argon2]とSHA-256の両方をサポートするクライアントに入札ダウン攻撃を実行し、それを使用してMESSAGE-INTEGRITY-SHA256値を収集してから、オフラインの総当たり攻撃. これは、サーバーが2番目の要求を受信したときに検出されますが、攻撃者がMESSAGE-INTEGRITY-SHA256値を取得することを妨げるものではありません. 

同様に、機能がパス上で破棄されたことをサーバーが検出するため、USERHASHメカニズムに対する攻撃はセッションの確立に成功しませんが、クライアントはUSERNAME属性のクリアでユーザー名を送信することを確信しているため、開示されますそれを攻撃者に. 

最後に、メッセージを保護するために使用されるHMACアルゴリズムの将来のアップグレードに入札ダウン保護メカニズムが採用された場合、現在のHMACアルゴリズムがすでに危険にさらされている場合、限られた保護しか提供されません. 

16.2. 使用に影響を与える攻撃
このセクションでは、STUNの使用に対して起動される可能性のある攻撃を示します. 各STUN使用法は、これらの攻撃がそれに適用可能かどうかを検討し、該当する場合は、対策を検討する必要があります. 

このセクションのほとんどの攻撃は、STUNクライアントがバインディング要求/応答トランザクションを通じて学習した再帰アドレスを変更する攻撃者を中心に展開します. 再帰アドレスの使用は使用法の関数であるため、これらの攻撃の適用性と修復は使用法に固有です. 一般的な状況では、パス上の攻撃者による再帰アドレスの変更は簡単です. たとえば、STUNがUDPを介して直接実行される一般的な状況を考えてみます. この場合、パス上の攻撃者は、バインド要求がSTUNサーバーに到達する前に、そのソースIPアドレスを変更できます. 次に、STUNサーバーはこのIPアドレスをXOR-MAPPED-ADDRESS属性でクライアントに返し、その（改ざんされた）IPアドレスとポートに応答を返します. 攻撃者がこの応答を傍受できる場合、クライアントに向けて戻すことができます. メッセージ整合性の値は送信元IPアドレスをカバーできず、介在するNATがこの値を変更できる必要があるため、メッセージ整合性チェックを使用してこの攻撃から保護することは不可能です. 代わりに、下記の攻撃を防ぐ1つの解決策は、ICE [RFC8445]で行われるように、クライアントが学習した再帰アドレスを確認することです. 

他の使用法では、これらの攻撃を防ぐために他の手段を使用する場合があります. 

16.2.1. 攻撃I：ターゲットに対する分散DoS（DDoS）
この攻撃では、攻撃者は1つ以上のクライアントに、意図されたターゲットを指す同じ偽の再帰アドレスを提供します. これは、STUNクライアントをだまして、再帰アドレスがターゲットのアドレスと等しいと考えさせます. クライアントがその再帰アドレスをその上でトラフィックを受信するために（たとえば、SIPメッセージで）渡す場合、トラフィックは代わりにターゲットに送信されます. この攻撃は、特にマルチメディアアプリケーションを有効にするためにSTUNを使用しているクライアントで使用される場合、大幅な増幅をもたらす可能性があります. ただし、STUNサーバーからターゲットへのパケットが攻撃者を通過するターゲットに対してのみ起動できるため、可能性のあるケースが制限されます. 

16.2.2. 攻撃II：クライアントのサイレンシング
この攻撃では、攻撃者はSTUNクライアントに偽の再帰アドレスを提供します. それが提供する再帰アドレスは、どこにもルーティングされないトランスポートアドレスです. その結果、クライアントは、再帰アドレスを渡すときに受信する予定のパケットを受信しません. この悪用は、攻撃者にとってあまり興味深いものではありません. それは単一のクライアントに影響を与えますが、それはしばしば望ましいターゲットではありません. さらに、攻撃を仕掛けることができる攻撃者は、クライアントがSTUNサーバーまたはDHCPサーバーからの応答を受信できないようにするなど、他の手段によってクライアントへのサービスを拒否することもできます. セクション16.2.1で説明した攻撃と同様に、この攻撃は、攻撃者がSTUNサーバーからこの未使用のIPアドレスに送信されるパケットのパス上にある場合にのみ可能です. 

16.2.3. 攻撃III：クライアントのアイデンティティを想定する
この攻撃は攻撃IIに似ています. ただし、偽の再帰アドレスは攻撃者自身を指しています. これにより、攻撃者はクライアント宛てのトラフィックを受信できます. 

16.2.4. 攻撃IV：盗聴
この攻撃では、攻撃者はクライアントに、自身にルーティングする再帰アドレスを使用するように強制します. 次に、受信したパケットをクライアントに転送します. この攻撃により、攻撃者はクライアントに送信されたすべてのパケットを観察できます. ただし、攻撃を仕掛けるためには、攻撃者がクライアントからSTUNサーバーへのパケットをすでに監視している必要があります. ほとんどの場合（攻撃がアクセスネットワークから起動された場合など）、これは攻撃者がクライアントに送信されたパケットをすでに観察している可能性があることを意味します. 結果として、この攻撃は、攻撃者がクライアントからSTUNサーバーへのパスでトラフィックを監視する場合にのみ役立ちますが、一般に、クライアントにルーティングされるパケットのパスでは役立ちません. 

この攻撃はSTUNサーバー自体によって簡単に起動される可能性があるため、STUNサーバーのユーザーは、通信フローに自分自身を挿入できる他のノードと同じレベルの信頼をSTUNサーバーのユーザーに持つ必要があります. 

16.3. ハッシュアジリティ計画
この仕様では、メッセージの整合性の計算にHMAC-SHA256を使用し、HMAC-SHA1と組み合わせることもあります. 後で、HMAC-SHA256が侵害されていることが判明した場合は、次の対策を適用する必要があります. 

o新しいメッセージ整合性属性と新しいSTUNセキュリティ機能ビットの両方が、Standards Trackドキュメントに割り当てられます. 新しいメッセージ整合性属性の値は、新しいハッシュを使用して計算されます. STUN Security Featureビットは、1）このサーバーがこの新しいハッシュアルゴリズムをサポートするという長期の資格情報メカニズムを使用してSTUNクライアントに同時に信号を送信し、2）新しいメッセージ整合性属性に対するビッドダウン攻撃を防ぐために使用されます. 

o短期の資格情報メカニズムを使用するSTUNクライアントおよびサーバーは、使用しているメッセージ整合性属性を通知するために使用する外部メカニズムを更新する必要があります. 

このドキュメントで説明されているビッドダウン保護メカニズムは新しいため、ハッシュアルゴリズムの強度をHMAC-SHA1に低下させるビッドダウン攻撃から保護することはできません. これが、移行期間の後、これを更新する新しいドキュメントがHMAC-SHA1を非推奨にするために新しいSTUNセキュリティ機能ビットを割り当てる理由です. 使用すると、このビットはHMAC-SHA1が非推奨になり、使用されなくなることを通知します. 

同様に、HMAC-SHA256が危険にさらされていることが判明した場合、新しいuserhash属性と新しいSTUN Security FeatureビットがStandards Trackドキュメントに割り当てられます. 新しいuserhash属性の値は、新しいハッシュを使用して計算されます. STUNセキュリティ機能ビットは、1）このサーバーがuserhash属性のこの新しいハッシュアルゴリズムをサポートするという長期の資格情報メカニズムを使用してSTUNクライアントに同時に信号を送信し、2）新しいuserhash属性へのビッドダウン攻撃を防ぐために使用されます. 

17. IABに関する考慮事項
IABは、クライアントが共同プロトコルリフレクションメカニズム[RFC3424]を介してNATの反対側にある別のレルムでそのアドレスを決定しようとする一般的なプロセスである、ユニラテラルセルフアドレスフィックス（UNSAF）の問題を調査しました. STUNは、一方のエージェントがNATの背後にあり、もう一方のエージェントがNATのパブリック側にある場合に、バインディング要求/応答トランザクションを使用してこの機能を実行するために使用できます. 

IABは、この目的のために開発されたプロトコルが特定の一連の考慮事項を文書化することを提案しています. 一部のSTUN使用法はUNSAF機能（ICE [RFC8445]など）を提供し、他は提供しない（SIPアウトバウンド[RFC5626]など）ので、これらの考慮事項への回答は、使用法自体で対処する必要があります. 

18. IANAに関する考慮事項
18.1. STUN Security Features Registry
STUNセキュリティ機能セットは24ビットをフラグとして定義します. 

IANAは、セクション9.2.1で説明されているビッドダウン攻撃防止メカニズムによって保護されるSTUNセキュリティ機能を含む新しいレジストリを作成しました. 

最初のSTUNセキュリティ機能は次のとおりです. 

ビット0：パスワードアルゴリズムビット1：ユーザー名の匿名性ビット2-23：割り当てられていないビットは、ビットセットの最上位側から割り当てられるため、ビット0が左端のビット、ビット23が右端のビットです. 

新しいセキュリティ機能は、標準アクション[RFC8126]によって割り当てられます. 

18.2. STUNメソッドレジストリ
STUNメソッドは、0x000-0x0FFの範囲の16進数です. STUNメソッドをSTUNメッセージにエンコードする方法については、セクション5で説明します. 

0x000-0x07Fの範囲のSTUNメソッドは、IETFレビュー[RFC8126]によって割り当てられます. 0x080-0x0FFの範囲のSTUNメソッドは、Expert Review [RFC8126]によって割り当てられます. 専門家の責任は、選択されたコードポイントが使用されていないこと、および要求が異常に多数のコードポイントに対するものではないことを確認することです. 拡張自体の技術レビューは、指定された専門家の責任の範囲外です. 

IANAはメソッド0x002の名前を以下のように更新し、次のSTUNメソッドのリファレンスをRFC 5389からRFC 8489に更新しました. 

0x000：予約済み0x001：バインド0x002：予約済み. [RFC5389]以前はSharedSecretでした

18.3. STUN属性レジストリ
STUN属性タイプは、0x0000-0xFFFFの範囲の16進数です. 0x0000-0x7FFFの範囲のSTUN属性タイプは、理解が必要と見なされます. 0x8000-0xFFFFの範囲のSTUN属性タイプは、内包オプションと見なされます. STUNエージェントは、不明な理解が必要な属性と理解がオプションの属性を異なる方法で処理します. 

理解が必要な範囲の前半（0x0000-0x3FFF）と理解が必要な範囲の前半（0x8000-0xBFFF）のSTUN属性タイプは、IETFレビュー[RFC8126]によって割り当てられます. 理解が必要な範囲の後半（0x4000-0x7FFF）と理解が必要な範囲の後半（0xC000-0xFFFF）のSTUN属性タイプは、Expert Review [RFC8126]によって割り当てられます. 専門家の責任は、選択されたコードポイントが使用されていないこと、および要求が異常に多数のコードポイントに対するものではないことを確認することです. 拡張自体の技術レビューは、指定された専門家の責任の範囲外です. 

18.3.1. 更新された属性
IANAは、属性0x0002、0x0004、0x0005、0x0007、および0x000Bの名前を更新し、以下の各STUNメソッドのリファレンスをRFC 5389からRFC 8489に更新しました. 

さらに、[RFC5389]は属性0x0003の名前に誤りを導入しました. [RFC5389]は、以前にCHANGE-REQUESTと呼ばれていたのに、それをCHANGE-ADDRESSと呼びました. したがって、IANAは0x0003の説明を「予約済み、[RFC5389]より前はCHANGE-REQUESTでした」と読むように更新しました. 

   理解が必要な範囲（0x0000-0x7FFF）：
   0x0000：予約済み
   0x0001：Mapped Address
   0x0002：予約済み. [RFC5389]以前はRESPONSE-ADDRESSでした
   0x0003：予約済み. [RFC5389]以前はCHANGE-REQUESTでした
   0x0004：予約済み. [RFC5389]以前はSOURCE-ADDRESSでした
   0x0005：予約済み. [RFC5389]以前はCHANGED-ADDRESSでした
   0x0006：ユーザー名
   0x0007：予約済み. [RFC5389]より前のパスワードでした
   0x0008：メッセージの整合性
   0x0009：エラーコード
   0x000A：不明な属性
   0x000B：予約済み. [RFC5389]より前のREFLECTED-FROMでした
   0x0014：REALM
   0x0015：NONCE
   0x0020：XOR-MAPPED-ADDRESS
        
理解-オプションの範囲（0x8000-0xFFFF）0x8022：ソフトウェア0x8023：ALTERNATE-SERVER 0x8028：FINGERPRINT

18.3.2. 新しい属性
IANAは、「STUN属性」レジストリに次の属性を追加しました. 

理解が必要な範囲（0x0000-0x7FFF）：0x001C：MESSAGE-INTEGRITY-SHA256 0x001D：PASSWORD-ALGORITHM 0x001E：USERHASH

理解度-オプションの範囲（0x8000-0xFFFF）0x8002：PASSWORD-ALGORITHMS 0x8003：ALTERNATE-DOMAIN

18.4. STUNエラーコードレジストリ
STUNエラーコードは、0〜699の範囲の数値です. STUNエラーコードには、UTF-8 [RFC3629]のテキストによる理由フレーズが付随しています. これは、人間が使用することのみを目的としており、適切なものであれば何でも構いません. このドキュメントでは、推奨値のみを提案しています. 

STUNエラーコードは、SIP [RFC3261]およびHTTP [RFC7231]でのコードポイント割り当てとセマンティクスで一貫しています. 

IETFレビュー[RFC8126]に基づいて、新しいSTUNエラーコードが割り当てられます. 仕様では、このエラーコードを理解していないクライアントがリクエストを許可する前にどのように処理するかを慎重に検討する必要があります. セクション6.3.4のルールを参照してください. 

IANAは、セクション14.8で定義されたエラーコードの参照をRFC 5389からRFC 8489に更新しました. 

IANAは、401エラーコードの名前を「無許可」から「非認証」に変更しました. 

18.5. STUNパスワードアルゴリズムレジストリ
IANAは、「STUN Password Algorithms」というタイトルの新しいレジストリを作成しました. 

パスワードアルゴリズムは、0x0000〜0xFFFFの範囲の16進数です. 

「パスワードアルゴリズム」レジストリの初期内容は次のとおりです. 

0x0000：予約済み0x0001：MD5 0x0002：SHA-256 0x0003-0xFFFF：未割り当て

範囲の前半（0x0000-0x7FFF）のパスワードアルゴリズムは、IETFレビュー[RFC8126]によって割り当てられます. 範囲の後半（0x8000-0xFFFF）のパスワードアルゴリズムは、Expert Review [RFC8126]によって割り当てられます. 

18.5.1. パスワードアルゴリズム
18.5.1.1. MD5
このパスワードアルゴリズムは[RFC1321]から取られます. 

キーの長さは16バイトで、パラメーター値は空です. 

注：このアルゴリズムは、レガシーシステムとの互換性のためにのみ使用する必要があります. 

                key = MD5（username "：" OpaqueString（realm）
                  "：" OpaqueString（password））
        
18.5.1.2. SHA-256
このパスワードアルゴリズムは[RFC7616]から取られました. 

キーの長さは32バイトで、パラメーター値は空です. 

              key = SHA-256（username "：" OpaqueString（realm）
                "：" OpaqueString（password））
        
18.6. STUN UDPおよびTCPポート番号
IANAは、「サービス名とトランスポートプロトコルのポート番号レジストリ」の次のポートの参照をRFC 5389からRFC 8489に更新しました. 

   stun 3478 / tcp NAT（STUN）ポート用のセッショントラバーサルユーティリティ
   stun 3478 / udp NAT（STU N）ポートのセッショントラバーサルユーティリティ
   stuns 5349 / tcp NAT（STUN）ポートのセッショントラバーサルユーティリティ
        
19. RFC 5389以降の変更
この仕様は廃止されました[RFC5389]. この仕様は、次の点でRFC 5389と異なります. 

o DTLS-over-UDP [RFC6347]のサポートが追加されました. 

oサーバーとのトランザクションがない場合、RTOは古くなっていると見なされることを明確にしました. 

o RTO計算を[RFC6298]に合わせました. 

o TLSの暗号スイートを更新しました. 

o STUN URI [RFC7064]のサポートを追加しました. 

o SHA256メッセージ整合性のサポートが追加されました. 

o国際化文字列の準備、施行、比較（PRECIS）のサポートを[RFC8265]に更新しました. 

oパスワード暗号化アルゴリズムを選択するためのプロトコルとレジストリを追加しました. 

o匿名ユーザー名のサポートが追加されました. 

oビッドダウン攻撃を防ぐためのプロトコルとレジストリを追加しました. 

o NONCEの共有が許可されなくなったことを明記. 

o代替サーバーメカニズムでドメイン名を使用できるようになりました. 

o Cスニペットを追加しました. 

oテストベクタを追加しました. 

20.リファレンス
20.1. 規範的な参考文献
[ITU.V42.2002]国際電気通信連合、「非同期から同期への変換を使用したDCEのエラー修正手順」、ITU-T勧告V.42、2002年3月. 

[KARN87]カーン、P. およびC.パートリッジ、「信頼性の高いトランスポートプロトコルにおけるラウンドトリップ時間の見積もりの​​向上」、SIGCOMM '87、Proceedings of the ACM Workshop on Frontiers in Computer Communications Technology、Pages 2-7、DOI 10.1145 / 55483.55484 、1987年8月. 

[RFC0791] Postel、J. 、「インターネットプロトコル」、STD 5、RFC 791、DOI 10.17487 / RFC0791、1981年9月、<https://www.rfc-editor.org/info/rfc791>. 

[RFC1122] Braden、R. 、編、「インターネットホストの要件-通信層」、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<https://www.rfc-editor.org/info/ rfc1122>. 

[RFC1123] Braden、R. 、編、「インターネットホストの要件-アプリケーションとサポート」、STD 3、RFC 1123、DOI 10.17487 / RFC1123、1989年10月、<https://www.rfc-editor.org/info / rfc1123>. 

[RFC1321] Rivest、R. 、「The MD5 Message-Digest Algorithm」、RFC 1321、DOI 10.17487 / RFC1321、1992年4月、<https://www.rfc-editor.org/info/rfc1321>. 

[RFC2104] Krawczyk、H.、Bellare、M. 、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<https：//www.rfc-editor .org / info / rfc2104>. 

[RFC2119] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>. 

[RFC2782] Gulbrandsen、A.、Vixie、P. 、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、DOI 10.17487 / RFC2782、2000年2月、<https：// www.rfc-editor.org/info/rfc2782>. 

[RFC3629] Yergeau、F. 、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/ rfc3629>. 

[RFC4648] Josefsson、S. 、「The Base16、Base32、およびBase64データエンコーディング」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https://www.rfc-editor.org/info/rfc4648>. 

[RFC5890] Klensin、J. 、「Internationalized Domain Names for Applications（IDNA）：Definitions and Document Framework」、RFC 5890、DOI 10.17487 / RFC5890、2010年8月、<https://www.rfc-editor.org/info/ rfc5890>. 

[RFC6125] Saint-Andre、P. およびJ. Hodges、「トランスポート層セキュリティ（TLS）のコンテキストでのX.509（PKIX）証明書を使用したインターネット公開鍵インフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<https://www.rfc-editor.org/info/rfc6125>. 

[RFC6151]ターナー、S. およびL.チェン、「MD5メッセージダイジェストおよびHMAC-MD5アルゴリズムの更新されたセキュリティに関する考慮事項」、RFC 6151、DOI 10.17487 / RFC6151、2011年3月、<https：//www.rfc- editor.org/info/rfc6151>. 

[RFC6298] Paxson、V.、Allman、M.、Chu、J. 、およびM. Sargent、「Computing TCP's Retransmission Timer」、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<https：//www.rfc- editor.org/info/rfc6298>. 

[RFC6347] Rescorla、E. およびN. Modadugu、「Datagram Transport Layer Security Version 1.2」、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<https://www.rfc-editor.org/info/rfc6347>. 

[RFC7064] Nandakumar、S.、Salgueiro、G.、Jones、P. 、およびM. Petit-Huguenin、「NAT（STUN）プロトコルのセッショントラバーサルユーティリティのURIスキーム」、RFC 7064、DOI 10.17487 / RFC7064、11月2013、<https://www.rfc-editor.org/info/rfc7064>. 

[RFC7350] Petit-Huguenin、M. およびG. Salgueiro、「NATのセッショントラバーサルユーティリティ（STUN）のトランスポートとしてのデータグラムトランスポート層セキュリティ（DTLS）」、RFC 7350、DOI 10.17487 / RFC7350、2014年8月、<https：/ /www.rfc-editor.org/info/rfc7350>. 

[RFC7616] Shekh-Yusef、R.、Ed. 、Ahrens、D. 、およびS. Bremer、「HTTP Digest Access Authentication」、RFC 7616、DOI 10.17487 / RFC7616、2015年9月、<https：//www.rfc- editor.org/info/rfc7616>. 

[RFC8174] Leiba、B. 、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>. 

[RFC8200] Deering、S. およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、STD 86、RFC 8200、DOI 10.17487 / RFC8200、2017年7月、<https://www.rfc-editor.org / info / rfc8200>. 

[RFC8265] Saint-Andre、P. およびA. Melnikov、「ユーザー名とパスワードを表す国際化された文字列の準備、適用、比較」、RFC 8265、DOI 10.17487 / RFC8265、2017年10月、<https：//www.rfc- editor.org/info/rfc8265>. 

[RFC8305] Schinazi、D. およびT. Pauly、「Happy Eyeballs Version 2：Better Connectivity Using Concurrency」、RFC 8305、DOI 10.17487 / RFC8305、2017年12月、<https://www.rfc-editor.org/info/ rfc8305>. 

20.2. 参考情報
[Argon2] Biryukov、A.、Dinu、D.、Khovratovich、D. 、およびS. Josefsson、「メモリハードArgon2パスワードハッシュおよび作業証明機能」、Work in Progress、draft-irtf-cfrg- argon2-09、2019年11月. 

[BCP195] Sheffer、Y.、Holz、R. 、およびP. Saint-Andre、「Transport Layer Security（TLS）およびDatagram Transport Layer Security（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、2015年5月、<https://www.rfc-editor.org/info/bcp195>. 

[RFC1952] Deutsch、P. 、「GZIPファイル形式仕様バージョン4.3」、RFC 1952、DOI 10.17487 / RFC1952、1996年5月、<https://www.rfc-editor.org/info/rfc1952>. 

[RFC2279] Yergeau、F. 、「UTF-8、ISO 10646の変換フォーマット」、RFC 2279、DOI 10.17487 / RFC2279、1998年1月、<https://www.rfc-editor.org/info/rfc2279>. 

[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M. 、およびE. Schooler、「SIP：Session Initiation Protocol」 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<https://www.rfc-editor.org/info/rfc3261>. 

[RFC3424]ダイグル、L. 、エド. とIAB、「ネットワークアドレス変換を介したUNilateral Self-Address Fixing（UNSAF）AIA考慮事項」、RFC 3424、DOI 10.17487 / RFC3424、2002年11月、<https://www.rfc-editor.org/info/rfc3424>. 

[RFC3454] Hoffman、P.およびM. Blanchet、「Preparation of Internationalized Strings（ "stringprep"）」、RFC 3454、DOI 10.17487 / RFC3454、2002年12月、<https://www.rfc-editor.org/info/ rfc3454>. 

[RFC3489] Rosenberg、J.、Weinberger、J.、Huitema、C. 、およびR. Mahy、「STUN-Simple Data Traversal of User Datagram Protocol（UDP）Through Network Address Translators（NATs）」、RFC 3489、DOI 10.17487 / RFC3489、2003年3月、<https://www.rfc-editor.org/info/rfc3489>. 

[RFC4013] Zeilenga、K. 、「SASLprep：Stringprep Profile for User Names and Passwords」、RFC 4013、DOI 10.17487 / RFC4013、2005年2月、<https://www.rfc-editor.org/info/rfc4013>. 

[RFC4107] Bellovin、S. およびR. Housley、「暗号鍵管理のガイドライン」、BCP 107、RFC 4107、DOI 10.17487 / RFC4107、2005年6月、<https://www.rfc-editor.org/info/rfc4107 >. 

[RFC5090] Sterman、B.、Sadolevsky、D.、Schwartz、D.、Williams、D. 、およびW. Beck、「RADIUS Extension for Digest Authentication」、RFC 5090、DOI 10.17487 / RFC5090、2008年2月、<https： //www.rfc-editor.org/info/rfc5090>. 

[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P. 、およびD. Wing、「NAT用セッショントラバーサルユーティリティ（STUN）」、RFC 5389、DOI 10.17487 / RFC5389、2008年10月、<https：// www.rfc-editor.org/info/rfc5389>. 

[RFC5626] Jennings、C.、Ed. 、Mahy、R.、Ed. 、and F. Audet、Ed. 、 "Managing Client-Initiated Connections in the Session Initiation Protocol（SIP）"、RFC 5626、DOI 10.17487 / RFC5626 、2009年10月、<https://www.rfc-editor.org/info/rfc5626>. 

[RFC5766] Mahy、R.、Matthews、P. 、およびJ. Rosenberg、「NAT周辺のリレーを使用したトラバーサル（TURN）：NATのセッショントラバーサルユーティリティへのリレー拡張（STUN）」、RFC 5766、DOI 10.17487 / RFC5766、4月2010、<https://www.rfc-editor.org/info/rfc5766>. 

[RFC5769] Denis-Courmont、R. 、「NAT（STUN）のセッショントラバーサルユーティリティのテストベクトル」、RFC 5769、DOI 10.17487 / RFC5769、2010年4月、<https://www.rfc-editor.org/info/ rfc5769>. 

[RFC5780] MacDonald、D. およびB. Lowekamp、「NAT（STUN）のセッショントラバーサルユーティリティを使用したNAT動作検出」、RFC 5780、DOI 10.17487 / RFC5780、2010年5月、<https://www.rfc-editor.org / info / rfc5780>. 

[RFC6544] Rosenberg、J.、Kerenen、A.、Lowekamp、B. 、およびA. Roach、「インタラクティブ接続確立（ICE）を使用したTCP候補」、RFC 6544、DOI 10.17487 / RFC6544、2012年3月、<https：/ /www.rfc-editor.org/info/rfc6544>. 

[RFC7231]フィールディング、R. 、エド. およびJ. Reschke編、「Hypertext Transfer Protocol（HTTP / 1.1）：Semantics and Content」、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<https://www.rfc-editor.org/info/rfc7231 >. 

[RFC8126]コットン、M. 、レイバ、B. 、およびT.ナルテン、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>. 

[RFC8264] Saint-Andre、P. およびM. Blanchet、「PRECIS Framework：Preparation、Enforcement、and Comparison of Internationalized Strings in Application Protocols」、RFC 8264、DOI 10.17487 / RFC8264、2017年10月、<https：// www.  rfc-editor.org/info/rfc8264>. 

[RFC8445] Keranen、A.、Holmberg、C. 、およびJ. Rosenberg、「Interactive Connectivity Establishment（ICE）：A Protocol for Network Address Translator（NAT）Traversal」、RFC 8445、DOI 10.17487 / RFC8445、2018年7月、< https://www.rfc-editor.org/info/rfc8445>. 

[RFC8446] Rescorla、E. 、「The Transport Layer Security（TLS）Protocol Version 1.3」、RFC 8446、DOI 10.17487 / RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc8446>. 

[STUN-PMTUD] Petit-Huguenin、M.、Salgueiro、G. 、およびF. Garrido、「NAT用のセッショントラバーサルユーティリティ（STUN）を使用したUDPトランスポートのパケット化レイヤーパスMTU検出（PLMTUD）」、作業中、ドラフト-ietf-tram-stun-pmtud-15、2019年12月. 

[UAX15] Unicode標準付属書＃15、「Unicode正規化フォーム」、Mark DavisおよびKen Whistlerにより編集. Unicode標準の不可欠な部分である<http://unicode.org/reports/tr15/>. 

付録A. STUNメッセージタイプを判別するCスニペット
msg_typeパラメーターにホストバイトオーダーの16ビットSTUNメッセージタイプ値がある場合、STUNメッセージタイプを判別するCマクロを以下に示します. 

   <コード開始>
   #define IS_REQUEST（msg_type）（（（msg_type）＆0x0110）== 0x0000）
   #define IS_INDICATION（msg_type）（（（msg_type）＆0x0110）== 0x0010）
   #define IS_SUCCESS_RESP（msg_type）（（（（msg_type）＆0x0110）== 0x0100）
   #define IS_ERR_RESP（msg_type）（（（（msg_type）＆0x0110）== 0x0110）
   <コード終了>
        
メソッドとクラスをメッセージタイプに変換する関数：

   <コード開始>
   int type（int method、int cls）{
     return（メソッド＆0x1F80）<< 2 | （メソッド＆0x0070）<< 1
       | （メソッド＆0x000F）| （cls＆0x0002）<< 7
       | （cls＆0x0001）<< 4;
     }
   <コード終了>
        
メッセージタイプからメソッドを抽出する関数：

   <コード開始>
   intメソッド（intタイプ）{
     リターン（タイプ＆0x3E00）>> 2 | （タイプ＆0x00E0）>> 1
       | （タイプ＆0x000F）;
     }
   <コード終了>
        
メッセージタイプからクラスを抽出する関数：

   <コード開始>
   int cls（int type）{
     return（type＆0x0100）>> 7 | （タイプ＆0x0010）>> 4;
     }
   <コード終了>
        
付録B.テストベクトル
このセクションは、MESSAGE-INTEGRITY-SHA256で[RFC5769]で定義されたテストベクタのリストを補強します. [RFC5769]のセクション2にリストされているすべてのフォーマットと定義がここに適用されます. 

B.1. MESSAGE-INTEGRITY-SHA256およびUSERHASHを使用した長期認証を使用したサンプルリクエスト

このリクエストは次のパラメーターを使用します. 

   ユーザー名： "<U + 30DE> <U + 30C8> <U + 30EA> <U + 30C3> <U + 30AF> <U + 30B9>"（なし
   引用符）OpaqueString [RFC8265]処理の影響を受けない
        
   パスワード： "The <U + 00AD> M <U + 00AA> tr <U + 2168>"および "TheMatrIX"（なし
   引用符）OpaqueString [RFC8265]の前と後
   処理
        
   Nonce： "obMatJos2AAACf // 499k954d6OL34oL9FSTvy64sA"（引用符なし）
        
レルム： "example.org"（引用符なし）

        00 01 00 9c要求タイプとメッセージ長
        21 12 a4 42マジッククッキー
        78 ad 34 33}
        c6 ad 72 c0}トランザクションID
        29 da 41 2e}
        00 1e 00 20 USERHASH属性ヘッダー
        4a 3c f3 8f}
        ef 69 92 bd}
        a9 52 c6 78}
        04 17 da 0f}ユーザーハッシュ値（32バイト）
        24 81 94 15}
        56 9e 60 b2}
        05 c4 6e 41}
        40 7f 17 04}
        00 15 00 29 NONCE属性ヘッダー
        6f 62 4d 61}
        74 4a 6f 73}
        32 41 41 41}
        43 66 2f 2f}
        34 39 39 6b}ノンス値とパディング（3バイト）
        39 35 34 64}
        36 4f 4c 33}
        34 6f 4c 39}
        46 53 54 76}
        79 36 34 73}
        41 00 00 00} 00 14 00 0b REALM属性ヘッダー
        65 78 61 6d}
        70 6c 65 2e}レルム値（11バイト）およびパディング（1バイト）
        6f 72 67 00}
        00 1c 00 20 MESSAGE-INTEGRITY-SHA256属性ヘッダー
        e4 68 6c 8f}
        0e de b5 90}
        13 e0 70 90}
        01 0a 93 ef} HMAC-SHA256値
        cc bc cc 54}
        4c 0a 45 d9}
        f8 30 aa 6d}
        6f 73 5a 01}
        
謝辞

Michael Tuexen、Tirumaleswar Reddy、Oleg Moskalenko、Simon Perreault、Benjamin Schwartz、Rifaat Shekh-Yusef、Alan Johnston、Jonathan Lennox、Brandon Williams、Olle Johansson、Martin Thomson、Mihaly Meszaros、Tolga Asveren、Noriyuki Doriale、Dr. このドキュメントの改善に役立ったコメント、提案、質問については、Worley、Matthew Miller、Peter Saint-Andre、Julien Elie、Mirja Kuehlewind、Eric Rescorla、Ben Campbell、Adam Roach、Alexey Melnikov、Benjamin Kadukの各氏. 

RFC 5389の謝辞のセクションは次のように表示されました. 

著者は、セドリック・アウン、ピート・コーデル、カレン・ジェニングス、ボブ・ペンフィールド、ザビエル・マルジュ、マグナス・ウェスターランド、ミゲル・ガルシア、ブルース・ローケンプ、クリス・サリバンのコメントに感謝し、初期の実装にはバルーク・スターマンとアラン・ハウリリーシェンに感謝します. この作業に関するIESGおよびIABの入力について、レスリーデイグル、アリソンマンキン、エリックレスコーラ、ヘニングシュルズリンネに感謝します. 

寄稿者

Christian HuitemaとJoel Weinbergerは、RFC 3489の最初の共著者でした. 

著者のアドレス

マルクプティフーゲニンインピーダンスミスマッチ

   メール：marc@petit-huguenin.org
        
Gonzalo Salgueiro Cisco 7200-12 Kit Creek Road Research Triangle Park、NC 27709アメリカ合衆国

   メール：gsalguei@cisco.com
        
ジョナサンローゼンバーグファイブ9エジソン、ニュージャージー州アメリカ合衆国

   メール：jdrosen@jdrosen.net
   URI：http://www.jdrosen.net
        
Dan Wing Citrix Systems、Inc.アメリカ合衆国

   メール：dwing-ietf@fuggles.com
        
Rohan Mahy無関係

   メール：rohan.ietf@gmail.com
        
Philip Matthews Nokia 600 March Roadオタワオンタリオ州K2K 2T6カナダ

電話：613-784-3139メール：philip_matthews@magma.ca